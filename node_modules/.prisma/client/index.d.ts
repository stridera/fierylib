
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model Zone
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model Room
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model RoomExit
 * 
 */
export type RoomExit = $Result.DefaultSelection<Prisma.$RoomExitPayload>
/**
 * Model RoomExtraDescription
 * 
 */
export type RoomExtraDescription = $Result.DefaultSelection<Prisma.$RoomExtraDescriptionPayload>
/**
 * Model Mob
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type Mob = $Result.DefaultSelection<Prisma.$MobPayload>
/**
 * Model MobSkill
 * 
 */
export type MobSkill = $Result.DefaultSelection<Prisma.$MobSkillPayload>
/**
 * Model MobSpell
 * 
 */
export type MobSpell = $Result.DefaultSelection<Prisma.$MobSpellPayload>
/**
 * Model MobReset
 * 
 */
export type MobReset = $Result.DefaultSelection<Prisma.$MobResetPayload>
/**
 * Model MobCarrying
 * 
 */
export type MobCarrying = $Result.DefaultSelection<Prisma.$MobCarryingPayload>
/**
 * Model MobEquipped
 * 
 */
export type MobEquipped = $Result.DefaultSelection<Prisma.$MobEquippedPayload>
/**
 * Model Object
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type Object = $Result.DefaultSelection<Prisma.$ObjectPayload>
/**
 * Model ObjectExtraDescription
 * 
 */
export type ObjectExtraDescription = $Result.DefaultSelection<Prisma.$ObjectExtraDescriptionPayload>
/**
 * Model ObjectAffect
 * 
 */
export type ObjectAffect = $Result.DefaultSelection<Prisma.$ObjectAffectPayload>
/**
 * Model ObjectSpell
 * 
 */
export type ObjectSpell = $Result.DefaultSelection<Prisma.$ObjectSpellPayload>
/**
 * Model Shop
 * 
 */
export type Shop = $Result.DefaultSelection<Prisma.$ShopPayload>
/**
 * Model ShopItem
 * 
 */
export type ShopItem = $Result.DefaultSelection<Prisma.$ShopItemPayload>
/**
 * Model ShopAccept
 * 
 */
export type ShopAccept = $Result.DefaultSelection<Prisma.$ShopAcceptPayload>
/**
 * Model ShopRoom
 * 
 */
export type ShopRoom = $Result.DefaultSelection<Prisma.$ShopRoomPayload>
/**
 * Model ShopHour
 * 
 */
export type ShopHour = $Result.DefaultSelection<Prisma.$ShopHourPayload>
/**
 * Model Trigger
 * 
 */
export type Trigger = $Result.DefaultSelection<Prisma.$TriggerPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model GameClass
 * 
 */
export type GameClass = $Result.DefaultSelection<Prisma.$GameClassPayload>
/**
 * Model Spell
 * 
 */
export type Spell = $Result.DefaultSelection<Prisma.$SpellPayload>
/**
 * Model SpellSchool
 * 
 */
export type SpellSchool = $Result.DefaultSelection<Prisma.$SpellSchoolPayload>
/**
 * Model SpellClassCircle
 * 
 */
export type SpellClassCircle = $Result.DefaultSelection<Prisma.$SpellClassCirclePayload>
/**
 * Model SpellTargeting
 * 
 */
export type SpellTargeting = $Result.DefaultSelection<Prisma.$SpellTargetingPayload>
/**
 * Model SpellSavingThrow
 * 
 */
export type SpellSavingThrow = $Result.DefaultSelection<Prisma.$SpellSavingThrowPayload>
/**
 * Model SpellMessage
 * 
 */
export type SpellMessage = $Result.DefaultSelection<Prisma.$SpellMessagePayload>
/**
 * Model SpellComponent
 * 
 */
export type SpellComponent = $Result.DefaultSelection<Prisma.$SpellComponentPayload>
/**
 * Model SpellRestriction
 * 
 */
export type SpellRestriction = $Result.DefaultSelection<Prisma.$SpellRestrictionPayload>
/**
 * Model SpellEffect
 * 
 */
export type SpellEffect = $Result.DefaultSelection<Prisma.$SpellEffectPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model ClassSkill
 * 
 */
export type ClassSkill = $Result.DefaultSelection<Prisma.$ClassSkillPayload>
/**
 * Model RaceSkill
 * 
 */
export type RaceSkill = $Result.DefaultSelection<Prisma.$RaceSkillPayload>
/**
 * Model CharacterSkill
 * 
 */
export type CharacterSkill = $Result.DefaultSelection<Prisma.$CharacterSkillPayload>
/**
 * Model CharacterSpell
 * 
 */
export type CharacterSpell = $Result.DefaultSelection<Prisma.$CharacterSpellPayload>
/**
 * Model ChangeLog
 * 
 */
export type ChangeLog = $Result.DefaultSelection<Prisma.$ChangeLogPayload>
/**
 * Model BanRecord
 * 
 */
export type BanRecord = $Result.DefaultSelection<Prisma.$BanRecordPayload>
/**
 * Model CharacterItem
 * 
 */
export type CharacterItem = $Result.DefaultSelection<Prisma.$CharacterItemPayload>
/**
 * Model CharacterEffect
 * 
 */
export type CharacterEffect = $Result.DefaultSelection<Prisma.$CharacterEffectPayload>
/**
 * Model EquipmentSetItem
 * 
 */
export type EquipmentSetItem = $Result.DefaultSelection<Prisma.$EquipmentSetItemPayload>
/**
 * Model EquipmentSet
 * 
 */
export type EquipmentSet = $Result.DefaultSelection<Prisma.$EquipmentSetPayload>
/**
 * Model MobEquipmentSet
 * 
 */
export type MobEquipmentSet = $Result.DefaultSelection<Prisma.$MobEquipmentSetPayload>
/**
 * Model ObjectReset
 * 
 */
export type ObjectReset = $Result.DefaultSelection<Prisma.$ObjectResetPayload>
/**
 * Model SpawnCondition
 * 
 */
export type SpawnCondition = $Result.DefaultSelection<Prisma.$SpawnConditionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  PLAYER: 'PLAYER',
  IMMORTAL: 'IMMORTAL',
  BUILDER: 'BUILDER',
  CODER: 'CODER',
  GOD: 'GOD'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Race: {
  HUMAN: 'HUMAN',
  ELF: 'ELF',
  GNOME: 'GNOME',
  DWARF: 'DWARF',
  TROLL: 'TROLL',
  DROW: 'DROW',
  DUERGAR: 'DUERGAR',
  OGRE: 'OGRE',
  ORC: 'ORC',
  HALF_ELF: 'HALF_ELF',
  BARBARIAN: 'BARBARIAN',
  HALFLING: 'HALFLING',
  PLANT: 'PLANT',
  HUMANOID: 'HUMANOID',
  ANIMAL: 'ANIMAL',
  DRAGON_GENERAL: 'DRAGON_GENERAL',
  GIANT: 'GIANT',
  OTHER: 'OTHER',
  GOBLIN: 'GOBLIN',
  DEMON: 'DEMON',
  BROWNIE: 'BROWNIE',
  DRAGON_FIRE: 'DRAGON_FIRE',
  DRAGON_FROST: 'DRAGON_FROST',
  DRAGON_ACID: 'DRAGON_ACID',
  DRAGON_LIGHTNING: 'DRAGON_LIGHTNING',
  DRAGON_GAS: 'DRAGON_GAS',
  DRAGONBORN_FIRE: 'DRAGONBORN_FIRE',
  DRAGONBORN_FROST: 'DRAGONBORN_FROST',
  DRAGONBORN_ACID: 'DRAGONBORN_ACID',
  DRAGONBORN_LIGHTNING: 'DRAGONBORN_LIGHTNING',
  DRAGONBORN_GAS: 'DRAGONBORN_GAS',
  SVERFNEBLIN: 'SVERFNEBLIN',
  FAERIE_SEELIE: 'FAERIE_SEELIE',
  FAERIE_UNSEELIE: 'FAERIE_UNSEELIE',
  NYMPH: 'NYMPH',
  ARBOREAN: 'ARBOREAN'
};

export type Race = (typeof Race)[keyof typeof Race]


export const ResetMode: {
  NEVER: 'NEVER',
  EMPTY: 'EMPTY',
  NORMAL: 'NORMAL'
};

export type ResetMode = (typeof ResetMode)[keyof typeof ResetMode]


export const Hemisphere: {
  NORTHWEST: 'NORTHWEST',
  NORTHEAST: 'NORTHEAST',
  SOUTHWEST: 'SOUTHWEST',
  SOUTHEAST: 'SOUTHEAST'
};

export type Hemisphere = (typeof Hemisphere)[keyof typeof Hemisphere]


export const Climate: {
  NONE: 'NONE',
  SEMIARID: 'SEMIARID',
  ARID: 'ARID',
  OCEANIC: 'OCEANIC',
  TEMPERATE: 'TEMPERATE',
  SUBTROPICAL: 'SUBTROPICAL',
  TROPICAL: 'TROPICAL',
  SUBARCTIC: 'SUBARCTIC',
  ARCTIC: 'ARCTIC',
  ALPINE: 'ALPINE'
};

export type Climate = (typeof Climate)[keyof typeof Climate]


export const Sector: {
  STRUCTURE: 'STRUCTURE',
  CITY: 'CITY',
  FIELD: 'FIELD',
  FOREST: 'FOREST',
  HILLS: 'HILLS',
  MOUNTAIN: 'MOUNTAIN',
  SHALLOWS: 'SHALLOWS',
  WATER: 'WATER',
  UNDERWATER: 'UNDERWATER',
  AIR: 'AIR',
  ROAD: 'ROAD',
  GRASSLANDS: 'GRASSLANDS',
  CAVE: 'CAVE',
  RUINS: 'RUINS',
  SWAMP: 'SWAMP',
  BEACH: 'BEACH',
  UNDERDARK: 'UNDERDARK',
  ASTRALPLANE: 'ASTRALPLANE',
  AIRPLANE: 'AIRPLANE',
  FIREPLANE: 'FIREPLANE',
  EARTHPLANE: 'EARTHPLANE',
  ETHEREALPLANE: 'ETHEREALPLANE',
  AVERNUS: 'AVERNUS'
};

export type Sector = (typeof Sector)[keyof typeof Sector]


export const RoomFlag: {
  DARK: 'DARK',
  DEATH: 'DEATH',
  NO_MOB: 'NO_MOB',
  INDOORS: 'INDOORS',
  PEACEFUL: 'PEACEFUL',
  SOUNDPROOF: 'SOUNDPROOF',
  NO_TRACK: 'NO_TRACK',
  NO_MAGIC: 'NO_MAGIC',
  TUNNEL: 'TUNNEL',
  PRIVATE: 'PRIVATE',
  GODROOM: 'GODROOM',
  HOUSE: 'HOUSE',
  HOUSECRASH: 'HOUSECRASH',
  ATRIUM: 'ATRIUM',
  OLC: 'OLC',
  BFS_MARK: 'BFS_MARK',
  WORLDMAP: 'WORLDMAP',
  FERRY_DEST: 'FERRY_DEST',
  ISOLATED: 'ISOLATED',
  ARENA: 'ARENA',
  LARGE: 'LARGE',
  MEDIUM_LARGE: 'MEDIUM_LARGE',
  MEDIUM: 'MEDIUM',
  MEDIUM_SMALL: 'MEDIUM_SMALL',
  SMALL: 'SMALL',
  VERY_SMALL: 'VERY_SMALL',
  ONE_PERSON: 'ONE_PERSON',
  EFFECTS_NEXT: 'EFFECTS_NEXT',
  ALWAYS_LIT: 'ALWAYS_LIT',
  GUILDHALL: 'GUILDHALL',
  NO_WELL: 'NO_WELL',
  NO_SUMMON: 'NO_SUMMON',
  NO_SCAN: 'NO_SCAN',
  UNDERDARK: 'UNDERDARK',
  NO_SHIFT: 'NO_SHIFT',
  NO_RECALL: 'NO_RECALL',
  ALT_EXIT: 'ALT_EXIT',
  OBSERVATORY: 'OBSERVATORY'
};

export type RoomFlag = (typeof RoomFlag)[keyof typeof RoomFlag]


export const Direction: {
  NORTH: 'NORTH',
  EAST: 'EAST',
  SOUTH: 'SOUTH',
  WEST: 'WEST',
  UP: 'UP',
  DOWN: 'DOWN'
};

export type Direction = (typeof Direction)[keyof typeof Direction]


export const ExitFlag: {
  IS_DOOR: 'IS_DOOR',
  CLOSED: 'CLOSED',
  LOCKED: 'LOCKED',
  PICKPROOF: 'PICKPROOF',
  HIDDEN: 'HIDDEN'
};

export type ExitFlag = (typeof ExitFlag)[keyof typeof ExitFlag]


export const Position: {
  PRONE: 'PRONE',
  SITTING: 'SITTING',
  KNEELING: 'KNEELING',
  STANDING: 'STANDING',
  FLYING: 'FLYING'
};

export type Position = (typeof Position)[keyof typeof Position]


export const Gender: {
  NEUTRAL: 'NEUTRAL',
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  NON_BINARY: 'NON_BINARY'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Size: {
  TINY: 'TINY',
  SMALL: 'SMALL',
  MEDIUM: 'MEDIUM',
  LARGE: 'LARGE',
  HUGE: 'HUGE',
  GIANT: 'GIANT',
  GARGANTUAN: 'GARGANTUAN',
  COLOSSAL: 'COLOSSAL',
  TITANIC: 'TITANIC',
  MOUNTAINOUS: 'MOUNTAINOUS'
};

export type Size = (typeof Size)[keyof typeof Size]


export const LifeForce: {
  LIFE: 'LIFE',
  UNDEAD: 'UNDEAD',
  MAGIC: 'MAGIC',
  CELESTIAL: 'CELESTIAL',
  DEMONIC: 'DEMONIC',
  ELEMENTAL: 'ELEMENTAL'
};

export type LifeForce = (typeof LifeForce)[keyof typeof LifeForce]


export const Composition: {
  FLESH: 'FLESH',
  EARTH: 'EARTH',
  AIR: 'AIR',
  FIRE: 'FIRE',
  WATER: 'WATER',
  ICE: 'ICE',
  MIST: 'MIST',
  ETHER: 'ETHER',
  METAL: 'METAL',
  STONE: 'STONE',
  BONE: 'BONE',
  LAVA: 'LAVA',
  PLANT: 'PLANT'
};

export type Composition = (typeof Composition)[keyof typeof Composition]


export const Stance: {
  DEAD: 'DEAD',
  MORT: 'MORT',
  INCAPACITATED: 'INCAPACITATED',
  STUNNED: 'STUNNED',
  SLEEPING: 'SLEEPING',
  RESTING: 'RESTING',
  ALERT: 'ALERT',
  FIGHTING: 'FIGHTING'
};

export type Stance = (typeof Stance)[keyof typeof Stance]


export const DamageType: {
  HIT: 'HIT',
  STING: 'STING',
  WHIP: 'WHIP',
  SLASH: 'SLASH',
  BITE: 'BITE',
  BLUDGEON: 'BLUDGEON',
  CRUSH: 'CRUSH',
  POUND: 'POUND',
  CLAW: 'CLAW',
  MAUL: 'MAUL',
  THRASH: 'THRASH',
  PIERCE: 'PIERCE',
  BLAST: 'BLAST',
  PUNCH: 'PUNCH',
  STAB: 'STAB',
  FIRE: 'FIRE',
  COLD: 'COLD',
  ACID: 'ACID',
  SHOCK: 'SHOCK',
  POISON: 'POISON',
  ALIGN: 'ALIGN'
};

export type DamageType = (typeof DamageType)[keyof typeof DamageType]


export const MobFlag: {
  SPEC: 'SPEC',
  SENTINEL: 'SENTINEL',
  SCAVENGER: 'SCAVENGER',
  IS_NPC: 'IS_NPC',
  AWARE: 'AWARE',
  AGGRESSIVE: 'AGGRESSIVE',
  STAY_ZONE: 'STAY_ZONE',
  WIMPY: 'WIMPY',
  AGGRO_EVIL: 'AGGRO_EVIL',
  AGGRO_GOOD: 'AGGRO_GOOD',
  AGGRO_NEUTRAL: 'AGGRO_NEUTRAL',
  MEMORY: 'MEMORY',
  HELPER: 'HELPER',
  NO_CHARM: 'NO_CHARM',
  NO_SUMMON: 'NO_SUMMON',
  NO_SLEEP: 'NO_SLEEP',
  NO_BASH: 'NO_BASH',
  NO_BLIND: 'NO_BLIND',
  MOUNT: 'MOUNT',
  STAY_SECT: 'STAY_SECT',
  HATES_SUN: 'HATES_SUN',
  NO_KILL: 'NO_KILL',
  TRACK: 'TRACK',
  ILLUSION: 'ILLUSION',
  POISON_BITE: 'POISON_BITE',
  THIEF: 'THIEF',
  WARRIOR: 'WARRIOR',
  SORCERER: 'SORCERER',
  CLERIC: 'CLERIC',
  PALADIN: 'PALADIN',
  ANTI_PALADIN: 'ANTI_PALADIN',
  RANGER: 'RANGER',
  DRUID: 'DRUID',
  SHAMAN: 'SHAMAN',
  ASSASSIN: 'ASSASSIN',
  MERCENARY: 'MERCENARY',
  NECROMANCER: 'NECROMANCER',
  CONJURER: 'CONJURER',
  MONK: 'MONK',
  BERSERKER: 'BERSERKER',
  DIABOLIST: 'DIABOLIST',
  SLOW_TRACK: 'SLOW_TRACK',
  NO_SILENCE: 'NO_SILENCE',
  PEACEFUL: 'PEACEFUL',
  PROTECTOR: 'PROTECTOR',
  PEACEKEEPER: 'PEACEKEEPER',
  HASTE: 'HASTE',
  BLUR: 'BLUR',
  TEACHER: 'TEACHER',
  MOUNTABLE: 'MOUNTABLE',
  NO_VICIOUS: 'NO_VICIOUS',
  NO_CLASS_AI: 'NO_CLASS_AI',
  FAST_TRACK: 'FAST_TRACK',
  AQUATIC: 'AQUATIC',
  NO_EQ_RESTRICT: 'NO_EQ_RESTRICT',
  SUMMONED_MOUNT: 'SUMMONED_MOUNT',
  NO_POISON: 'NO_POISON'
};

export type MobFlag = (typeof MobFlag)[keyof typeof MobFlag]


export const EffectFlag: {
  BLIND: 'BLIND',
  INVISIBLE: 'INVISIBLE',
  DETECT_ALIGN: 'DETECT_ALIGN',
  DETECT_INVIS: 'DETECT_INVIS',
  DETECT_MAGIC: 'DETECT_MAGIC',
  SENSE_LIFE: 'SENSE_LIFE',
  WATERWALK: 'WATERWALK',
  SANCTUARY: 'SANCTUARY',
  CONFUSION: 'CONFUSION',
  CURSE: 'CURSE',
  INFRAVISION: 'INFRAVISION',
  POISON: 'POISON',
  PROTECT_EVIL: 'PROTECT_EVIL',
  PROTECT_GOOD: 'PROTECT_GOOD',
  SLEEP: 'SLEEP',
  NO_TRACK: 'NO_TRACK',
  TAMED: 'TAMED',
  BERSERK: 'BERSERK',
  SNEAK: 'SNEAK',
  STEALTH: 'STEALTH',
  FLY: 'FLY',
  CHARM: 'CHARM',
  STONE_SKIN: 'STONE_SKIN',
  FARSEE: 'FARSEE',
  HASTE: 'HASTE',
  BLUR: 'BLUR',
  VITALITY: 'VITALITY',
  GLORY: 'GLORY',
  MAJOR_PARALYSIS: 'MAJOR_PARALYSIS',
  FAMILIARITY: 'FAMILIARITY',
  MESMERIZED: 'MESMERIZED',
  IMMOBILIZED: 'IMMOBILIZED',
  LIGHT: 'LIGHT',
  UNUSED: 'UNUSED',
  MINOR_PARALYSIS: 'MINOR_PARALYSIS',
  HURT_THROAT: 'HURT_THROAT',
  FEATHER_FALL: 'FEATHER_FALL',
  WATERBREATH: 'WATERBREATH',
  SOULSHIELD: 'SOULSHIELD',
  SILENCE: 'SILENCE',
  PROTECT_FIRE: 'PROTECT_FIRE',
  PROTECT_COLD: 'PROTECT_COLD',
  PROTECT_AIR: 'PROTECT_AIR',
  PROTECT_EARTH: 'PROTECT_EARTH',
  FIRESHIELD: 'FIRESHIELD',
  COLDSHIELD: 'COLDSHIELD',
  MINOR_GLOBE: 'MINOR_GLOBE',
  MAJOR_GLOBE: 'MAJOR_GLOBE',
  HARNESS: 'HARNESS',
  ON_FIRE: 'ON_FIRE',
  FEAR: 'FEAR',
  TONGUES: 'TONGUES',
  DISEASE: 'DISEASE',
  INSANITY: 'INSANITY',
  ULTRAVISION: 'ULTRAVISION',
  NEGATE_HEAT: 'NEGATE_HEAT',
  NEGATE_COLD: 'NEGATE_COLD',
  NEGATE_AIR: 'NEGATE_AIR',
  NEGATE_EARTH: 'NEGATE_EARTH',
  REMOTE_AGGRO: 'REMOTE_AGGRO',
  AWARE: 'AWARE',
  REDUCE: 'REDUCE',
  ENLARGE: 'ENLARGE',
  VAMPIRIC_TOUCH: 'VAMPIRIC_TOUCH',
  RAY_OF_ENFEEBLEMENT: 'RAY_OF_ENFEEBLEMENT',
  ANIMATED: 'ANIMATED',
  EXPOSED: 'EXPOSED',
  SHADOWING: 'SHADOWING',
  CAMOUFLAGED: 'CAMOUFLAGED',
  SPIRIT_WOLF: 'SPIRIT_WOLF',
  SPIRIT_BEAR: 'SPIRIT_BEAR',
  WRATH: 'WRATH',
  MISDIRECTION: 'MISDIRECTION',
  MISDIRECTING: 'MISDIRECTING',
  BLESS: 'BLESS',
  HEX: 'HEX',
  DETECT_POISON: 'DETECT_POISON',
  SONG_OF_REST: 'SONG_OF_REST',
  DISPLACEMENT: 'DISPLACEMENT',
  GREATER_DISPLACEMENT: 'GREATER_DISPLACEMENT',
  FIRE_WEAPON: 'FIRE_WEAPON',
  ICE_WEAPON: 'ICE_WEAPON',
  POISON_WEAPON: 'POISON_WEAPON',
  ACID_WEAPON: 'ACID_WEAPON',
  SHOCK_WEAPON: 'SHOCK_WEAPON',
  RADIANT_WEAPON: 'RADIANT_WEAPON'
};

export type EffectFlag = (typeof EffectFlag)[keyof typeof EffectFlag]


export const ObjectType: {
  NOTHING: 'NOTHING',
  LIGHT: 'LIGHT',
  SCROLL: 'SCROLL',
  WAND: 'WAND',
  STAFF: 'STAFF',
  WEAPON: 'WEAPON',
  FIREWEAPON: 'FIREWEAPON',
  MISSILE: 'MISSILE',
  TREASURE: 'TREASURE',
  ARMOR: 'ARMOR',
  POTION: 'POTION',
  WORN: 'WORN',
  OTHER: 'OTHER',
  TRASH: 'TRASH',
  TRAP: 'TRAP',
  CONTAINER: 'CONTAINER',
  NOTE: 'NOTE',
  DRINKCONTAINER: 'DRINKCONTAINER',
  KEY: 'KEY',
  FOOD: 'FOOD',
  MONEY: 'MONEY',
  PEN: 'PEN',
  BOAT: 'BOAT',
  FOUNTAIN: 'FOUNTAIN',
  PORTAL: 'PORTAL',
  ROPE: 'ROPE',
  SPELLBOOK: 'SPELLBOOK',
  WALL: 'WALL',
  TOUCHSTONE: 'TOUCHSTONE',
  BOARD: 'BOARD',
  INSTRUMENT: 'INSTRUMENT'
};

export type ObjectType = (typeof ObjectType)[keyof typeof ObjectType]


export const ObjectFlag: {
  GLOW: 'GLOW',
  HUM: 'HUM',
  NO_RENT: 'NO_RENT',
  ANTI_BERSERKER: 'ANTI_BERSERKER',
  NO_INVISIBLE: 'NO_INVISIBLE',
  INVISIBLE: 'INVISIBLE',
  MAGIC: 'MAGIC',
  NO_DROP: 'NO_DROP',
  PERMANENT: 'PERMANENT',
  ANTI_GOOD: 'ANTI_GOOD',
  ANTI_EVIL: 'ANTI_EVIL',
  ANTI_NEUTRAL: 'ANTI_NEUTRAL',
  ANTI_SORCERER: 'ANTI_SORCERER',
  ANTI_CLERIC: 'ANTI_CLERIC',
  ANTI_ROGUE: 'ANTI_ROGUE',
  ANTI_WARRIOR: 'ANTI_WARRIOR',
  NO_SELL: 'NO_SELL',
  ANTI_PALADIN: 'ANTI_PALADIN',
  ANTI_ANTI_PALADIN: 'ANTI_ANTI_PALADIN',
  ANTI_RANGER: 'ANTI_RANGER',
  ANTI_DRUID: 'ANTI_DRUID',
  ANTI_SHAMAN: 'ANTI_SHAMAN',
  ANTI_ASSASSIN: 'ANTI_ASSASSIN',
  ANTI_MERCENARY: 'ANTI_MERCENARY',
  ANTI_NECROMANCER: 'ANTI_NECROMANCER',
  ANTI_CONJURER: 'ANTI_CONJURER',
  NO_BURN: 'NO_BURN',
  NO_LOCATE: 'NO_LOCATE',
  DECOMPOSING: 'DECOMPOSING',
  FLOAT: 'FLOAT',
  NO_FALL: 'NO_FALL',
  WAS_DISARMED: 'WAS_DISARMED',
  ANTI_MONK: 'ANTI_MONK',
  ANTI_BARD: 'ANTI_BARD',
  ELVEN: 'ELVEN',
  DWARVEN: 'DWARVEN',
  ANTI_THIEF: 'ANTI_THIEF',
  ANTI_PYROMANCER: 'ANTI_PYROMANCER',
  ANTI_CRYOMANCER: 'ANTI_CRYOMANCER',
  ANTI_ILLUSIONIST: 'ANTI_ILLUSIONIST',
  ANTI_PRIEST: 'ANTI_PRIEST',
  ANTI_DIABOLIST: 'ANTI_DIABOLIST',
  ANTI_TINY: 'ANTI_TINY',
  ANTI_SMALL: 'ANTI_SMALL',
  ANTI_MEDIUM: 'ANTI_MEDIUM',
  ANTI_LARGE: 'ANTI_LARGE',
  ANTI_HUGE: 'ANTI_HUGE',
  ANTI_GIANT: 'ANTI_GIANT',
  ANTI_GARGANTUAN: 'ANTI_GARGANTUAN',
  ANTI_COLOSSAL: 'ANTI_COLOSSAL',
  ANTI_TITANIC: 'ANTI_TITANIC',
  ANTI_MOUNTAINOUS: 'ANTI_MOUNTAINOUS',
  ANTI_ARBOREAN: 'ANTI_ARBOREAN'
};

export type ObjectFlag = (typeof ObjectFlag)[keyof typeof ObjectFlag]


export const WearFlag: {
  TAKE: 'TAKE',
  FINGER: 'FINGER',
  NECK: 'NECK',
  BODY: 'BODY',
  HEAD: 'HEAD',
  LEGS: 'LEGS',
  FEET: 'FEET',
  HANDS: 'HANDS',
  ARMS: 'ARMS',
  SHIELD: 'SHIELD',
  ABOUT: 'ABOUT',
  WAIST: 'WAIST',
  WRIST: 'WRIST',
  WIELD: 'WIELD',
  HOLD: 'HOLD',
  TWO_HAND_WIELD: 'TWO_HAND_WIELD',
  EYES: 'EYES',
  FACE: 'FACE',
  EAR: 'EAR',
  BADGE: 'BADGE',
  BELT: 'BELT',
  HOVER: 'HOVER'
};

export type WearFlag = (typeof WearFlag)[keyof typeof WearFlag]


export const ShopFlag: {
  WILL_FIGHT: 'WILL_FIGHT',
  USES_BANK: 'USES_BANK',
  WILL_BANK_MONEY: 'WILL_BANK_MONEY',
  WILL_START_FIGHT: 'WILL_START_FIGHT'
};

export type ShopFlag = (typeof ShopFlag)[keyof typeof ShopFlag]


export const ShopTradesWith: {
  ALIGNMENT: 'ALIGNMENT',
  RACE: 'RACE',
  CLASS: 'CLASS',
  TRADE_NOGOOD: 'TRADE_NOGOOD',
  TRADE_NOEVIL: 'TRADE_NOEVIL',
  TRADE_NONEUTRAL: 'TRADE_NONEUTRAL',
  TRADE_NOCLERIC: 'TRADE_NOCLERIC',
  TRADE_NOTHIEF: 'TRADE_NOTHIEF',
  TRADE_NOWARRIOR: 'TRADE_NOWARRIOR'
};

export type ShopTradesWith = (typeof ShopTradesWith)[keyof typeof ShopTradesWith]


export const ScriptType: {
  MOB: 'MOB',
  OBJECT: 'OBJECT',
  WORLD: 'WORLD'
};

export type ScriptType = (typeof ScriptType)[keyof typeof ScriptType]


export const TriggerFlag: {
  GLOBAL: 'GLOBAL',
  RANDOM: 'RANDOM',
  COMMAND: 'COMMAND',
  SPEECH: 'SPEECH',
  ACT: 'ACT',
  DEATH: 'DEATH',
  GREET: 'GREET',
  GREET_ALL: 'GREET_ALL',
  ENTRY: 'ENTRY',
  RECEIVE: 'RECEIVE',
  FIGHT: 'FIGHT',
  HIT_PERCENT: 'HIT_PERCENT',
  BRIBE: 'BRIBE',
  LOAD: 'LOAD',
  MEMORY: 'MEMORY',
  CAST: 'CAST',
  LEAVE: 'LEAVE',
  DOOR: 'DOOR',
  TIME: 'TIME',
  AUTO: 'AUTO',
  SPEECH_TO: 'SPEECH_TO',
  LOOK: 'LOOK'
};

export type TriggerFlag = (typeof TriggerFlag)[keyof typeof TriggerFlag]


export const TargetScope: {
  SINGLE: 'SINGLE',
  ROOM: 'ROOM',
  GROUP: 'GROUP',
  AREA: 'AREA',
  CHAIN: 'CHAIN',
  CONE: 'CONE',
  LINE: 'LINE'
};

export type TargetScope = (typeof TargetScope)[keyof typeof TargetScope]


export const SpellRange: {
  SELF: 'SELF',
  TOUCH: 'TOUCH',
  ROOM: 'ROOM',
  ADJACENT_ROOM: 'ADJACENT_ROOM',
  WORLD: 'WORLD'
};

export type SpellRange = (typeof SpellRange)[keyof typeof SpellRange]


export const SaveType: {
  SPELL: 'SPELL',
  POISON: 'POISON',
  BREATH: 'BREATH',
  PARALYSIS: 'PARALYSIS',
  WAND: 'WAND'
};

export type SaveType = (typeof SaveType)[keyof typeof SaveType]


export const SaveResult: {
  NONE: 'NONE',
  HALF: 'HALF',
  NEGATE: 'NEGATE',
  REDUCE25: 'REDUCE25',
  CUSTOM: 'CUSTOM'
};

export type SaveResult = (typeof SaveResult)[keyof typeof SaveResult]


export const EffectType: {
  DAMAGE: 'DAMAGE',
  HEAL: 'HEAL',
  STAT_MOD: 'STAT_MOD',
  AFFECT_FLAG: 'AFFECT_FLAG',
  DISPEL: 'DISPEL',
  TELEPORT: 'TELEPORT',
  SUMMON: 'SUMMON',
  CREATE_OBJECT: 'CREATE_OBJECT',
  RESOURCE: 'RESOURCE',
  OBJ_AFFECT: 'OBJ_AFFECT',
  ROOM_AFFECT: 'ROOM_AFFECT',
  CLEANSE: 'CLEANSE',
  REMOVE_CURSE: 'REMOVE_CURSE',
  SCRIPT: 'SCRIPT'
};

export type EffectType = (typeof EffectType)[keyof typeof EffectType]


export const EffectTrigger: {
  ON_CAST: 'ON_CAST',
  ON_HIT: 'ON_HIT',
  ON_KILL: 'ON_KILL',
  ON_SAVE: 'ON_SAVE',
  ON_FAIL: 'ON_FAIL'
};

export type EffectTrigger = (typeof EffectTrigger)[keyof typeof EffectTrigger]


export const StackingRule: {
  REFRESH: 'REFRESH',
  STACK: 'STACK',
  IGNORE: 'IGNORE',
  MAX_ONLY: 'MAX_ONLY'
};

export type StackingRule = (typeof StackingRule)[keyof typeof StackingRule]


export const SkillType: {
  WEAPON: 'WEAPON',
  COMBAT: 'COMBAT',
  MAGIC: 'MAGIC',
  STEALTH: 'STEALTH',
  SOCIAL: 'SOCIAL',
  CRAFTING: 'CRAFTING',
  SURVIVAL: 'SURVIVAL',
  KNOWLEDGE: 'KNOWLEDGE',
  UTILITY: 'UTILITY'
};

export type SkillType = (typeof SkillType)[keyof typeof SkillType]


export const SkillCategory: {
  PRIMARY: 'PRIMARY',
  SECONDARY: 'SECONDARY',
  RESTRICTED: 'RESTRICTED',
  FORBIDDEN: 'FORBIDDEN'
};

export type SkillCategory = (typeof SkillCategory)[keyof typeof SkillCategory]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Race = $Enums.Race

export const Race: typeof $Enums.Race

export type ResetMode = $Enums.ResetMode

export const ResetMode: typeof $Enums.ResetMode

export type Hemisphere = $Enums.Hemisphere

export const Hemisphere: typeof $Enums.Hemisphere

export type Climate = $Enums.Climate

export const Climate: typeof $Enums.Climate

export type Sector = $Enums.Sector

export const Sector: typeof $Enums.Sector

export type RoomFlag = $Enums.RoomFlag

export const RoomFlag: typeof $Enums.RoomFlag

export type Direction = $Enums.Direction

export const Direction: typeof $Enums.Direction

export type ExitFlag = $Enums.ExitFlag

export const ExitFlag: typeof $Enums.ExitFlag

export type Position = $Enums.Position

export const Position: typeof $Enums.Position

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type Size = $Enums.Size

export const Size: typeof $Enums.Size

export type LifeForce = $Enums.LifeForce

export const LifeForce: typeof $Enums.LifeForce

export type Composition = $Enums.Composition

export const Composition: typeof $Enums.Composition

export type Stance = $Enums.Stance

export const Stance: typeof $Enums.Stance

export type DamageType = $Enums.DamageType

export const DamageType: typeof $Enums.DamageType

export type MobFlag = $Enums.MobFlag

export const MobFlag: typeof $Enums.MobFlag

export type EffectFlag = $Enums.EffectFlag

export const EffectFlag: typeof $Enums.EffectFlag

export type ObjectType = $Enums.ObjectType

export const ObjectType: typeof $Enums.ObjectType

export type ObjectFlag = $Enums.ObjectFlag

export const ObjectFlag: typeof $Enums.ObjectFlag

export type WearFlag = $Enums.WearFlag

export const WearFlag: typeof $Enums.WearFlag

export type ShopFlag = $Enums.ShopFlag

export const ShopFlag: typeof $Enums.ShopFlag

export type ShopTradesWith = $Enums.ShopTradesWith

export const ShopTradesWith: typeof $Enums.ShopTradesWith

export type ScriptType = $Enums.ScriptType

export const ScriptType: typeof $Enums.ScriptType

export type TriggerFlag = $Enums.TriggerFlag

export const TriggerFlag: typeof $Enums.TriggerFlag

export type TargetScope = $Enums.TargetScope

export const TargetScope: typeof $Enums.TargetScope

export type SpellRange = $Enums.SpellRange

export const SpellRange: typeof $Enums.SpellRange

export type SaveType = $Enums.SaveType

export const SaveType: typeof $Enums.SaveType

export type SaveResult = $Enums.SaveResult

export const SaveResult: typeof $Enums.SaveResult

export type EffectType = $Enums.EffectType

export const EffectType: typeof $Enums.EffectType

export type EffectTrigger = $Enums.EffectTrigger

export const EffectTrigger: typeof $Enums.EffectTrigger

export type StackingRule = $Enums.StackingRule

export const StackingRule: typeof $Enums.StackingRule

export type SkillType = $Enums.SkillType

export const SkillType: typeof $Enums.SkillType

export type SkillCategory = $Enums.SkillCategory

export const SkillCategory: typeof $Enums.SkillCategory

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.roomExit`: Exposes CRUD operations for the **RoomExit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomExits
    * const roomExits = await prisma.roomExit.findMany()
    * ```
    */
  get roomExit(): Prisma.RoomExitDelegate<ExtArgs>;

  /**
   * `prisma.roomExtraDescription`: Exposes CRUD operations for the **RoomExtraDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomExtraDescriptions
    * const roomExtraDescriptions = await prisma.roomExtraDescription.findMany()
    * ```
    */
  get roomExtraDescription(): Prisma.RoomExtraDescriptionDelegate<ExtArgs>;

  /**
   * `prisma.mob`: Exposes CRUD operations for the **Mob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mobs
    * const mobs = await prisma.mob.findMany()
    * ```
    */
  get mob(): Prisma.MobDelegate<ExtArgs>;

  /**
   * `prisma.mobSkill`: Exposes CRUD operations for the **MobSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MobSkills
    * const mobSkills = await prisma.mobSkill.findMany()
    * ```
    */
  get mobSkill(): Prisma.MobSkillDelegate<ExtArgs>;

  /**
   * `prisma.mobSpell`: Exposes CRUD operations for the **MobSpell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MobSpells
    * const mobSpells = await prisma.mobSpell.findMany()
    * ```
    */
  get mobSpell(): Prisma.MobSpellDelegate<ExtArgs>;

  /**
   * `prisma.mobReset`: Exposes CRUD operations for the **MobReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MobResets
    * const mobResets = await prisma.mobReset.findMany()
    * ```
    */
  get mobReset(): Prisma.MobResetDelegate<ExtArgs>;

  /**
   * `prisma.mobCarrying`: Exposes CRUD operations for the **MobCarrying** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MobCarryings
    * const mobCarryings = await prisma.mobCarrying.findMany()
    * ```
    */
  get mobCarrying(): Prisma.MobCarryingDelegate<ExtArgs>;

  /**
   * `prisma.mobEquipped`: Exposes CRUD operations for the **MobEquipped** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MobEquippeds
    * const mobEquippeds = await prisma.mobEquipped.findMany()
    * ```
    */
  get mobEquipped(): Prisma.MobEquippedDelegate<ExtArgs>;

  /**
   * `prisma.object`: Exposes CRUD operations for the **Object** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Objects
    * const objects = await prisma.object.findMany()
    * ```
    */
  get object(): Prisma.ObjectDelegate<ExtArgs>;

  /**
   * `prisma.objectExtraDescription`: Exposes CRUD operations for the **ObjectExtraDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjectExtraDescriptions
    * const objectExtraDescriptions = await prisma.objectExtraDescription.findMany()
    * ```
    */
  get objectExtraDescription(): Prisma.ObjectExtraDescriptionDelegate<ExtArgs>;

  /**
   * `prisma.objectAffect`: Exposes CRUD operations for the **ObjectAffect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjectAffects
    * const objectAffects = await prisma.objectAffect.findMany()
    * ```
    */
  get objectAffect(): Prisma.ObjectAffectDelegate<ExtArgs>;

  /**
   * `prisma.objectSpell`: Exposes CRUD operations for the **ObjectSpell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjectSpells
    * const objectSpells = await prisma.objectSpell.findMany()
    * ```
    */
  get objectSpell(): Prisma.ObjectSpellDelegate<ExtArgs>;

  /**
   * `prisma.shop`: Exposes CRUD operations for the **Shop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shops
    * const shops = await prisma.shop.findMany()
    * ```
    */
  get shop(): Prisma.ShopDelegate<ExtArgs>;

  /**
   * `prisma.shopItem`: Exposes CRUD operations for the **ShopItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopItems
    * const shopItems = await prisma.shopItem.findMany()
    * ```
    */
  get shopItem(): Prisma.ShopItemDelegate<ExtArgs>;

  /**
   * `prisma.shopAccept`: Exposes CRUD operations for the **ShopAccept** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopAccepts
    * const shopAccepts = await prisma.shopAccept.findMany()
    * ```
    */
  get shopAccept(): Prisma.ShopAcceptDelegate<ExtArgs>;

  /**
   * `prisma.shopRoom`: Exposes CRUD operations for the **ShopRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopRooms
    * const shopRooms = await prisma.shopRoom.findMany()
    * ```
    */
  get shopRoom(): Prisma.ShopRoomDelegate<ExtArgs>;

  /**
   * `prisma.shopHour`: Exposes CRUD operations for the **ShopHour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopHours
    * const shopHours = await prisma.shopHour.findMany()
    * ```
    */
  get shopHour(): Prisma.ShopHourDelegate<ExtArgs>;

  /**
   * `prisma.trigger`: Exposes CRUD operations for the **Trigger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Triggers
    * const triggers = await prisma.trigger.findMany()
    * ```
    */
  get trigger(): Prisma.TriggerDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.gameClass`: Exposes CRUD operations for the **GameClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameClasses
    * const gameClasses = await prisma.gameClass.findMany()
    * ```
    */
  get gameClass(): Prisma.GameClassDelegate<ExtArgs>;

  /**
   * `prisma.spell`: Exposes CRUD operations for the **Spell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spells
    * const spells = await prisma.spell.findMany()
    * ```
    */
  get spell(): Prisma.SpellDelegate<ExtArgs>;

  /**
   * `prisma.spellSchool`: Exposes CRUD operations for the **SpellSchool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellSchools
    * const spellSchools = await prisma.spellSchool.findMany()
    * ```
    */
  get spellSchool(): Prisma.SpellSchoolDelegate<ExtArgs>;

  /**
   * `prisma.spellClassCircle`: Exposes CRUD operations for the **SpellClassCircle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellClassCircles
    * const spellClassCircles = await prisma.spellClassCircle.findMany()
    * ```
    */
  get spellClassCircle(): Prisma.SpellClassCircleDelegate<ExtArgs>;

  /**
   * `prisma.spellTargeting`: Exposes CRUD operations for the **SpellTargeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellTargetings
    * const spellTargetings = await prisma.spellTargeting.findMany()
    * ```
    */
  get spellTargeting(): Prisma.SpellTargetingDelegate<ExtArgs>;

  /**
   * `prisma.spellSavingThrow`: Exposes CRUD operations for the **SpellSavingThrow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellSavingThrows
    * const spellSavingThrows = await prisma.spellSavingThrow.findMany()
    * ```
    */
  get spellSavingThrow(): Prisma.SpellSavingThrowDelegate<ExtArgs>;

  /**
   * `prisma.spellMessage`: Exposes CRUD operations for the **SpellMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellMessages
    * const spellMessages = await prisma.spellMessage.findMany()
    * ```
    */
  get spellMessage(): Prisma.SpellMessageDelegate<ExtArgs>;

  /**
   * `prisma.spellComponent`: Exposes CRUD operations for the **SpellComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellComponents
    * const spellComponents = await prisma.spellComponent.findMany()
    * ```
    */
  get spellComponent(): Prisma.SpellComponentDelegate<ExtArgs>;

  /**
   * `prisma.spellRestriction`: Exposes CRUD operations for the **SpellRestriction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellRestrictions
    * const spellRestrictions = await prisma.spellRestriction.findMany()
    * ```
    */
  get spellRestriction(): Prisma.SpellRestrictionDelegate<ExtArgs>;

  /**
   * `prisma.spellEffect`: Exposes CRUD operations for the **SpellEffect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpellEffects
    * const spellEffects = await prisma.spellEffect.findMany()
    * ```
    */
  get spellEffect(): Prisma.SpellEffectDelegate<ExtArgs>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs>;

  /**
   * `prisma.classSkill`: Exposes CRUD operations for the **ClassSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSkills
    * const classSkills = await prisma.classSkill.findMany()
    * ```
    */
  get classSkill(): Prisma.ClassSkillDelegate<ExtArgs>;

  /**
   * `prisma.raceSkill`: Exposes CRUD operations for the **RaceSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceSkills
    * const raceSkills = await prisma.raceSkill.findMany()
    * ```
    */
  get raceSkill(): Prisma.RaceSkillDelegate<ExtArgs>;

  /**
   * `prisma.characterSkill`: Exposes CRUD operations for the **CharacterSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterSkills
    * const characterSkills = await prisma.characterSkill.findMany()
    * ```
    */
  get characterSkill(): Prisma.CharacterSkillDelegate<ExtArgs>;

  /**
   * `prisma.characterSpell`: Exposes CRUD operations for the **CharacterSpell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterSpells
    * const characterSpells = await prisma.characterSpell.findMany()
    * ```
    */
  get characterSpell(): Prisma.CharacterSpellDelegate<ExtArgs>;

  /**
   * `prisma.changeLog`: Exposes CRUD operations for the **ChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangeLogs
    * const changeLogs = await prisma.changeLog.findMany()
    * ```
    */
  get changeLog(): Prisma.ChangeLogDelegate<ExtArgs>;

  /**
   * `prisma.banRecord`: Exposes CRUD operations for the **BanRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BanRecords
    * const banRecords = await prisma.banRecord.findMany()
    * ```
    */
  get banRecord(): Prisma.BanRecordDelegate<ExtArgs>;

  /**
   * `prisma.characterItem`: Exposes CRUD operations for the **CharacterItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterItems
    * const characterItems = await prisma.characterItem.findMany()
    * ```
    */
  get characterItem(): Prisma.CharacterItemDelegate<ExtArgs>;

  /**
   * `prisma.characterEffect`: Exposes CRUD operations for the **CharacterEffect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterEffects
    * const characterEffects = await prisma.characterEffect.findMany()
    * ```
    */
  get characterEffect(): Prisma.CharacterEffectDelegate<ExtArgs>;

  /**
   * `prisma.equipmentSetItem`: Exposes CRUD operations for the **EquipmentSetItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentSetItems
    * const equipmentSetItems = await prisma.equipmentSetItem.findMany()
    * ```
    */
  get equipmentSetItem(): Prisma.EquipmentSetItemDelegate<ExtArgs>;

  /**
   * `prisma.equipmentSet`: Exposes CRUD operations for the **EquipmentSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentSets
    * const equipmentSets = await prisma.equipmentSet.findMany()
    * ```
    */
  get equipmentSet(): Prisma.EquipmentSetDelegate<ExtArgs>;

  /**
   * `prisma.mobEquipmentSet`: Exposes CRUD operations for the **MobEquipmentSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MobEquipmentSets
    * const mobEquipmentSets = await prisma.mobEquipmentSet.findMany()
    * ```
    */
  get mobEquipmentSet(): Prisma.MobEquipmentSetDelegate<ExtArgs>;

  /**
   * `prisma.objectReset`: Exposes CRUD operations for the **ObjectReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjectResets
    * const objectResets = await prisma.objectReset.findMany()
    * ```
    */
  get objectReset(): Prisma.ObjectResetDelegate<ExtArgs>;

  /**
   * `prisma.spawnCondition`: Exposes CRUD operations for the **SpawnCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpawnConditions
    * const spawnConditions = await prisma.spawnCondition.findMany()
    * ```
    */
  get spawnCondition(): Prisma.SpawnConditionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.4.2
   * Query Engine version: ac9d7041ed77bcc8a8dbd2ab6616b39013829574
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Character: 'Character',
    Zone: 'Zone',
    Room: 'Room',
    RoomExit: 'RoomExit',
    RoomExtraDescription: 'RoomExtraDescription',
    Mob: 'Mob',
    MobSkill: 'MobSkill',
    MobSpell: 'MobSpell',
    MobReset: 'MobReset',
    MobCarrying: 'MobCarrying',
    MobEquipped: 'MobEquipped',
    Object: 'Object',
    ObjectExtraDescription: 'ObjectExtraDescription',
    ObjectAffect: 'ObjectAffect',
    ObjectSpell: 'ObjectSpell',
    Shop: 'Shop',
    ShopItem: 'ShopItem',
    ShopAccept: 'ShopAccept',
    ShopRoom: 'ShopRoom',
    ShopHour: 'ShopHour',
    Trigger: 'Trigger',
    AuditLog: 'AuditLog',
    GameClass: 'GameClass',
    Spell: 'Spell',
    SpellSchool: 'SpellSchool',
    SpellClassCircle: 'SpellClassCircle',
    SpellTargeting: 'SpellTargeting',
    SpellSavingThrow: 'SpellSavingThrow',
    SpellMessage: 'SpellMessage',
    SpellComponent: 'SpellComponent',
    SpellRestriction: 'SpellRestriction',
    SpellEffect: 'SpellEffect',
    Skill: 'Skill',
    ClassSkill: 'ClassSkill',
    RaceSkill: 'RaceSkill',
    CharacterSkill: 'CharacterSkill',
    CharacterSpell: 'CharacterSpell',
    ChangeLog: 'ChangeLog',
    BanRecord: 'BanRecord',
    CharacterItem: 'CharacterItem',
    CharacterEffect: 'CharacterEffect',
    EquipmentSetItem: 'EquipmentSetItem',
    EquipmentSet: 'EquipmentSet',
    MobEquipmentSet: 'MobEquipmentSet',
    ObjectReset: 'ObjectReset',
    SpawnCondition: 'SpawnCondition'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'character' | 'zone' | 'room' | 'roomExit' | 'roomExtraDescription' | 'mob' | 'mobSkill' | 'mobSpell' | 'mobReset' | 'mobCarrying' | 'mobEquipped' | 'object' | 'objectExtraDescription' | 'objectAffect' | 'objectSpell' | 'shop' | 'shopItem' | 'shopAccept' | 'shopRoom' | 'shopHour' | 'trigger' | 'auditLog' | 'gameClass' | 'spell' | 'spellSchool' | 'spellClassCircle' | 'spellTargeting' | 'spellSavingThrow' | 'spellMessage' | 'spellComponent' | 'spellRestriction' | 'spellEffect' | 'skill' | 'classSkill' | 'raceSkill' | 'characterSkill' | 'characterSpell' | 'changeLog' | 'banRecord' | 'characterItem' | 'characterEffect' | 'equipmentSetItem' | 'equipmentSet' | 'mobEquipmentSet' | 'objectReset' | 'spawnCondition'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>,
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      RoomExit: {
        payload: Prisma.$RoomExitPayload<ExtArgs>
        fields: Prisma.RoomExitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomExitFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomExitFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExitPayload>
          }
          findFirst: {
            args: Prisma.RoomExitFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomExitFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExitPayload>
          }
          findMany: {
            args: Prisma.RoomExitFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExitPayload>[]
          }
          create: {
            args: Prisma.RoomExitCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExitPayload>
          }
          createMany: {
            args: Prisma.RoomExitCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomExitDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExitPayload>
          }
          update: {
            args: Prisma.RoomExitUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExitPayload>
          }
          deleteMany: {
            args: Prisma.RoomExitDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomExitUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomExitUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExitPayload>
          }
          aggregate: {
            args: Prisma.RoomExitAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomExit>
          }
          groupBy: {
            args: Prisma.RoomExitGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomExitGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomExitCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomExitCountAggregateOutputType> | number
          }
        }
      }
      RoomExtraDescription: {
        payload: Prisma.$RoomExtraDescriptionPayload<ExtArgs>
        fields: Prisma.RoomExtraDescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomExtraDescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExtraDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomExtraDescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExtraDescriptionPayload>
          }
          findFirst: {
            args: Prisma.RoomExtraDescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExtraDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomExtraDescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExtraDescriptionPayload>
          }
          findMany: {
            args: Prisma.RoomExtraDescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExtraDescriptionPayload>[]
          }
          create: {
            args: Prisma.RoomExtraDescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExtraDescriptionPayload>
          }
          createMany: {
            args: Prisma.RoomExtraDescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomExtraDescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExtraDescriptionPayload>
          }
          update: {
            args: Prisma.RoomExtraDescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExtraDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.RoomExtraDescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomExtraDescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomExtraDescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomExtraDescriptionPayload>
          }
          aggregate: {
            args: Prisma.RoomExtraDescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomExtraDescription>
          }
          groupBy: {
            args: Prisma.RoomExtraDescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomExtraDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomExtraDescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomExtraDescriptionCountAggregateOutputType> | number
          }
        }
      }
      Mob: {
        payload: Prisma.$MobPayload<ExtArgs>
        fields: Prisma.MobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          findFirst: {
            args: Prisma.MobFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          findMany: {
            args: Prisma.MobFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>[]
          }
          create: {
            args: Prisma.MobCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          createMany: {
            args: Prisma.MobCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MobDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          update: {
            args: Prisma.MobUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          deleteMany: {
            args: Prisma.MobDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MobUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MobUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobPayload>
          }
          aggregate: {
            args: Prisma.MobAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMob>
          }
          groupBy: {
            args: Prisma.MobGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MobGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobCountArgs<ExtArgs>,
            result: $Utils.Optional<MobCountAggregateOutputType> | number
          }
        }
      }
      MobSkill: {
        payload: Prisma.$MobSkillPayload<ExtArgs>
        fields: Prisma.MobSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobSkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobSkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSkillPayload>
          }
          findFirst: {
            args: Prisma.MobSkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobSkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSkillPayload>
          }
          findMany: {
            args: Prisma.MobSkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSkillPayload>[]
          }
          create: {
            args: Prisma.MobSkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSkillPayload>
          }
          createMany: {
            args: Prisma.MobSkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MobSkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSkillPayload>
          }
          update: {
            args: Prisma.MobSkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSkillPayload>
          }
          deleteMany: {
            args: Prisma.MobSkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MobSkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MobSkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSkillPayload>
          }
          aggregate: {
            args: Prisma.MobSkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMobSkill>
          }
          groupBy: {
            args: Prisma.MobSkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MobSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobSkillCountArgs<ExtArgs>,
            result: $Utils.Optional<MobSkillCountAggregateOutputType> | number
          }
        }
      }
      MobSpell: {
        payload: Prisma.$MobSpellPayload<ExtArgs>
        fields: Prisma.MobSpellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobSpellFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSpellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobSpellFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSpellPayload>
          }
          findFirst: {
            args: Prisma.MobSpellFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSpellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobSpellFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSpellPayload>
          }
          findMany: {
            args: Prisma.MobSpellFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSpellPayload>[]
          }
          create: {
            args: Prisma.MobSpellCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSpellPayload>
          }
          createMany: {
            args: Prisma.MobSpellCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MobSpellDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSpellPayload>
          }
          update: {
            args: Prisma.MobSpellUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSpellPayload>
          }
          deleteMany: {
            args: Prisma.MobSpellDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MobSpellUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MobSpellUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobSpellPayload>
          }
          aggregate: {
            args: Prisma.MobSpellAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMobSpell>
          }
          groupBy: {
            args: Prisma.MobSpellGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MobSpellGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobSpellCountArgs<ExtArgs>,
            result: $Utils.Optional<MobSpellCountAggregateOutputType> | number
          }
        }
      }
      MobReset: {
        payload: Prisma.$MobResetPayload<ExtArgs>
        fields: Prisma.MobResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobResetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobResetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobResetPayload>
          }
          findFirst: {
            args: Prisma.MobResetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobResetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobResetPayload>
          }
          findMany: {
            args: Prisma.MobResetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobResetPayload>[]
          }
          create: {
            args: Prisma.MobResetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobResetPayload>
          }
          createMany: {
            args: Prisma.MobResetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MobResetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobResetPayload>
          }
          update: {
            args: Prisma.MobResetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobResetPayload>
          }
          deleteMany: {
            args: Prisma.MobResetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MobResetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MobResetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobResetPayload>
          }
          aggregate: {
            args: Prisma.MobResetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMobReset>
          }
          groupBy: {
            args: Prisma.MobResetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MobResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobResetCountArgs<ExtArgs>,
            result: $Utils.Optional<MobResetCountAggregateOutputType> | number
          }
        }
      }
      MobCarrying: {
        payload: Prisma.$MobCarryingPayload<ExtArgs>
        fields: Prisma.MobCarryingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobCarryingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobCarryingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobCarryingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobCarryingPayload>
          }
          findFirst: {
            args: Prisma.MobCarryingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobCarryingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobCarryingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobCarryingPayload>
          }
          findMany: {
            args: Prisma.MobCarryingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobCarryingPayload>[]
          }
          create: {
            args: Prisma.MobCarryingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobCarryingPayload>
          }
          createMany: {
            args: Prisma.MobCarryingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MobCarryingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobCarryingPayload>
          }
          update: {
            args: Prisma.MobCarryingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobCarryingPayload>
          }
          deleteMany: {
            args: Prisma.MobCarryingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MobCarryingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MobCarryingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobCarryingPayload>
          }
          aggregate: {
            args: Prisma.MobCarryingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMobCarrying>
          }
          groupBy: {
            args: Prisma.MobCarryingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MobCarryingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobCarryingCountArgs<ExtArgs>,
            result: $Utils.Optional<MobCarryingCountAggregateOutputType> | number
          }
        }
      }
      MobEquipped: {
        payload: Prisma.$MobEquippedPayload<ExtArgs>
        fields: Prisma.MobEquippedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobEquippedFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquippedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobEquippedFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquippedPayload>
          }
          findFirst: {
            args: Prisma.MobEquippedFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquippedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobEquippedFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquippedPayload>
          }
          findMany: {
            args: Prisma.MobEquippedFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquippedPayload>[]
          }
          create: {
            args: Prisma.MobEquippedCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquippedPayload>
          }
          createMany: {
            args: Prisma.MobEquippedCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MobEquippedDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquippedPayload>
          }
          update: {
            args: Prisma.MobEquippedUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquippedPayload>
          }
          deleteMany: {
            args: Prisma.MobEquippedDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MobEquippedUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MobEquippedUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquippedPayload>
          }
          aggregate: {
            args: Prisma.MobEquippedAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMobEquipped>
          }
          groupBy: {
            args: Prisma.MobEquippedGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MobEquippedGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobEquippedCountArgs<ExtArgs>,
            result: $Utils.Optional<MobEquippedCountAggregateOutputType> | number
          }
        }
      }
      Object: {
        payload: Prisma.$ObjectPayload<ExtArgs>
        fields: Prisma.ObjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          findFirst: {
            args: Prisma.ObjectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          findMany: {
            args: Prisma.ObjectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>[]
          }
          create: {
            args: Prisma.ObjectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          createMany: {
            args: Prisma.ObjectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          update: {
            args: Prisma.ObjectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          deleteMany: {
            args: Prisma.ObjectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          aggregate: {
            args: Prisma.ObjectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObject>
          }
          groupBy: {
            args: Prisma.ObjectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectCountAggregateOutputType> | number
          }
        }
      }
      ObjectExtraDescription: {
        payload: Prisma.$ObjectExtraDescriptionPayload<ExtArgs>
        fields: Prisma.ObjectExtraDescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectExtraDescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectExtraDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectExtraDescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectExtraDescriptionPayload>
          }
          findFirst: {
            args: Prisma.ObjectExtraDescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectExtraDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectExtraDescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectExtraDescriptionPayload>
          }
          findMany: {
            args: Prisma.ObjectExtraDescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectExtraDescriptionPayload>[]
          }
          create: {
            args: Prisma.ObjectExtraDescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectExtraDescriptionPayload>
          }
          createMany: {
            args: Prisma.ObjectExtraDescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectExtraDescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectExtraDescriptionPayload>
          }
          update: {
            args: Prisma.ObjectExtraDescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectExtraDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.ObjectExtraDescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectExtraDescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectExtraDescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectExtraDescriptionPayload>
          }
          aggregate: {
            args: Prisma.ObjectExtraDescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObjectExtraDescription>
          }
          groupBy: {
            args: Prisma.ObjectExtraDescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectExtraDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectExtraDescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectExtraDescriptionCountAggregateOutputType> | number
          }
        }
      }
      ObjectAffect: {
        payload: Prisma.$ObjectAffectPayload<ExtArgs>
        fields: Prisma.ObjectAffectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectAffectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectAffectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectAffectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectAffectPayload>
          }
          findFirst: {
            args: Prisma.ObjectAffectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectAffectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectAffectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectAffectPayload>
          }
          findMany: {
            args: Prisma.ObjectAffectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectAffectPayload>[]
          }
          create: {
            args: Prisma.ObjectAffectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectAffectPayload>
          }
          createMany: {
            args: Prisma.ObjectAffectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectAffectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectAffectPayload>
          }
          update: {
            args: Prisma.ObjectAffectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectAffectPayload>
          }
          deleteMany: {
            args: Prisma.ObjectAffectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectAffectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectAffectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectAffectPayload>
          }
          aggregate: {
            args: Prisma.ObjectAffectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObjectAffect>
          }
          groupBy: {
            args: Prisma.ObjectAffectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectAffectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectAffectCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectAffectCountAggregateOutputType> | number
          }
        }
      }
      ObjectSpell: {
        payload: Prisma.$ObjectSpellPayload<ExtArgs>
        fields: Prisma.ObjectSpellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectSpellFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectSpellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectSpellFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectSpellPayload>
          }
          findFirst: {
            args: Prisma.ObjectSpellFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectSpellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectSpellFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectSpellPayload>
          }
          findMany: {
            args: Prisma.ObjectSpellFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectSpellPayload>[]
          }
          create: {
            args: Prisma.ObjectSpellCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectSpellPayload>
          }
          createMany: {
            args: Prisma.ObjectSpellCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectSpellDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectSpellPayload>
          }
          update: {
            args: Prisma.ObjectSpellUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectSpellPayload>
          }
          deleteMany: {
            args: Prisma.ObjectSpellDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectSpellUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectSpellUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectSpellPayload>
          }
          aggregate: {
            args: Prisma.ObjectSpellAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObjectSpell>
          }
          groupBy: {
            args: Prisma.ObjectSpellGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectSpellGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectSpellCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectSpellCountAggregateOutputType> | number
          }
        }
      }
      Shop: {
        payload: Prisma.$ShopPayload<ExtArgs>
        fields: Prisma.ShopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findFirst: {
            args: Prisma.ShopFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findMany: {
            args: Prisma.ShopFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          create: {
            args: Prisma.ShopCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          createMany: {
            args: Prisma.ShopCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShopDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          update: {
            args: Prisma.ShopUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          deleteMany: {
            args: Prisma.ShopDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          aggregate: {
            args: Prisma.ShopAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShop>
          }
          groupBy: {
            args: Prisma.ShopGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopCountAggregateOutputType> | number
          }
        }
      }
      ShopItem: {
        payload: Prisma.$ShopItemPayload<ExtArgs>
        fields: Prisma.ShopItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          findFirst: {
            args: Prisma.ShopItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          findMany: {
            args: Prisma.ShopItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>[]
          }
          create: {
            args: Prisma.ShopItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          createMany: {
            args: Prisma.ShopItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShopItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          update: {
            args: Prisma.ShopItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          deleteMany: {
            args: Prisma.ShopItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          aggregate: {
            args: Prisma.ShopItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShopItem>
          }
          groupBy: {
            args: Prisma.ShopItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopItemCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopItemCountAggregateOutputType> | number
          }
        }
      }
      ShopAccept: {
        payload: Prisma.$ShopAcceptPayload<ExtArgs>
        fields: Prisma.ShopAcceptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopAcceptFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopAcceptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopAcceptFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopAcceptPayload>
          }
          findFirst: {
            args: Prisma.ShopAcceptFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopAcceptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopAcceptFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopAcceptPayload>
          }
          findMany: {
            args: Prisma.ShopAcceptFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopAcceptPayload>[]
          }
          create: {
            args: Prisma.ShopAcceptCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopAcceptPayload>
          }
          createMany: {
            args: Prisma.ShopAcceptCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShopAcceptDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopAcceptPayload>
          }
          update: {
            args: Prisma.ShopAcceptUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopAcceptPayload>
          }
          deleteMany: {
            args: Prisma.ShopAcceptDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopAcceptUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopAcceptUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopAcceptPayload>
          }
          aggregate: {
            args: Prisma.ShopAcceptAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShopAccept>
          }
          groupBy: {
            args: Prisma.ShopAcceptGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopAcceptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopAcceptCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopAcceptCountAggregateOutputType> | number
          }
        }
      }
      ShopRoom: {
        payload: Prisma.$ShopRoomPayload<ExtArgs>
        fields: Prisma.ShopRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopRoomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopRoomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopRoomPayload>
          }
          findFirst: {
            args: Prisma.ShopRoomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopRoomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopRoomPayload>
          }
          findMany: {
            args: Prisma.ShopRoomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopRoomPayload>[]
          }
          create: {
            args: Prisma.ShopRoomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopRoomPayload>
          }
          createMany: {
            args: Prisma.ShopRoomCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShopRoomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopRoomPayload>
          }
          update: {
            args: Prisma.ShopRoomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopRoomPayload>
          }
          deleteMany: {
            args: Prisma.ShopRoomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopRoomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopRoomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopRoomPayload>
          }
          aggregate: {
            args: Prisma.ShopRoomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShopRoom>
          }
          groupBy: {
            args: Prisma.ShopRoomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopRoomCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopRoomCountAggregateOutputType> | number
          }
        }
      }
      ShopHour: {
        payload: Prisma.$ShopHourPayload<ExtArgs>
        fields: Prisma.ShopHourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopHourFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopHourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopHourFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopHourPayload>
          }
          findFirst: {
            args: Prisma.ShopHourFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopHourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopHourFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopHourPayload>
          }
          findMany: {
            args: Prisma.ShopHourFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopHourPayload>[]
          }
          create: {
            args: Prisma.ShopHourCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopHourPayload>
          }
          createMany: {
            args: Prisma.ShopHourCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShopHourDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopHourPayload>
          }
          update: {
            args: Prisma.ShopHourUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopHourPayload>
          }
          deleteMany: {
            args: Prisma.ShopHourDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopHourUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopHourUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopHourPayload>
          }
          aggregate: {
            args: Prisma.ShopHourAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShopHour>
          }
          groupBy: {
            args: Prisma.ShopHourGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopHourGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopHourCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopHourCountAggregateOutputType> | number
          }
        }
      }
      Trigger: {
        payload: Prisma.$TriggerPayload<ExtArgs>
        fields: Prisma.TriggerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TriggerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TriggerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          findFirst: {
            args: Prisma.TriggerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TriggerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          findMany: {
            args: Prisma.TriggerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>[]
          }
          create: {
            args: Prisma.TriggerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          createMany: {
            args: Prisma.TriggerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TriggerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          update: {
            args: Prisma.TriggerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          deleteMany: {
            args: Prisma.TriggerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TriggerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TriggerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          aggregate: {
            args: Prisma.TriggerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrigger>
          }
          groupBy: {
            args: Prisma.TriggerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TriggerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TriggerCountArgs<ExtArgs>,
            result: $Utils.Optional<TriggerCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      GameClass: {
        payload: Prisma.$GameClassPayload<ExtArgs>
        fields: Prisma.GameClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameClassFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameClassFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameClassPayload>
          }
          findFirst: {
            args: Prisma.GameClassFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameClassFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameClassPayload>
          }
          findMany: {
            args: Prisma.GameClassFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameClassPayload>[]
          }
          create: {
            args: Prisma.GameClassCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameClassPayload>
          }
          createMany: {
            args: Prisma.GameClassCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GameClassDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameClassPayload>
          }
          update: {
            args: Prisma.GameClassUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameClassPayload>
          }
          deleteMany: {
            args: Prisma.GameClassDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GameClassUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GameClassUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameClassPayload>
          }
          aggregate: {
            args: Prisma.GameClassAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGameClass>
          }
          groupBy: {
            args: Prisma.GameClassGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GameClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameClassCountArgs<ExtArgs>,
            result: $Utils.Optional<GameClassCountAggregateOutputType> | number
          }
        }
      }
      Spell: {
        payload: Prisma.$SpellPayload<ExtArgs>
        fields: Prisma.SpellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          findFirst: {
            args: Prisma.SpellFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          findMany: {
            args: Prisma.SpellFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>[]
          }
          create: {
            args: Prisma.SpellCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          createMany: {
            args: Prisma.SpellCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpellDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          update: {
            args: Prisma.SpellUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          deleteMany: {
            args: Prisma.SpellDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpellUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpellUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellPayload>
          }
          aggregate: {
            args: Prisma.SpellAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpell>
          }
          groupBy: {
            args: Prisma.SpellGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpellGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellCountArgs<ExtArgs>,
            result: $Utils.Optional<SpellCountAggregateOutputType> | number
          }
        }
      }
      SpellSchool: {
        payload: Prisma.$SpellSchoolPayload<ExtArgs>
        fields: Prisma.SpellSchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellSchoolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellSchoolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolPayload>
          }
          findFirst: {
            args: Prisma.SpellSchoolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellSchoolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolPayload>
          }
          findMany: {
            args: Prisma.SpellSchoolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolPayload>[]
          }
          create: {
            args: Prisma.SpellSchoolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolPayload>
          }
          createMany: {
            args: Prisma.SpellSchoolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpellSchoolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolPayload>
          }
          update: {
            args: Prisma.SpellSchoolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolPayload>
          }
          deleteMany: {
            args: Prisma.SpellSchoolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpellSchoolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpellSchoolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSchoolPayload>
          }
          aggregate: {
            args: Prisma.SpellSchoolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpellSchool>
          }
          groupBy: {
            args: Prisma.SpellSchoolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpellSchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellSchoolCountArgs<ExtArgs>,
            result: $Utils.Optional<SpellSchoolCountAggregateOutputType> | number
          }
        }
      }
      SpellClassCircle: {
        payload: Prisma.$SpellClassCirclePayload<ExtArgs>
        fields: Prisma.SpellClassCircleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellClassCircleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellClassCirclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellClassCircleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellClassCirclePayload>
          }
          findFirst: {
            args: Prisma.SpellClassCircleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellClassCirclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellClassCircleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellClassCirclePayload>
          }
          findMany: {
            args: Prisma.SpellClassCircleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellClassCirclePayload>[]
          }
          create: {
            args: Prisma.SpellClassCircleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellClassCirclePayload>
          }
          createMany: {
            args: Prisma.SpellClassCircleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpellClassCircleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellClassCirclePayload>
          }
          update: {
            args: Prisma.SpellClassCircleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellClassCirclePayload>
          }
          deleteMany: {
            args: Prisma.SpellClassCircleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpellClassCircleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpellClassCircleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellClassCirclePayload>
          }
          aggregate: {
            args: Prisma.SpellClassCircleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpellClassCircle>
          }
          groupBy: {
            args: Prisma.SpellClassCircleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpellClassCircleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellClassCircleCountArgs<ExtArgs>,
            result: $Utils.Optional<SpellClassCircleCountAggregateOutputType> | number
          }
        }
      }
      SpellTargeting: {
        payload: Prisma.$SpellTargetingPayload<ExtArgs>
        fields: Prisma.SpellTargetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellTargetingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellTargetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellTargetingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellTargetingPayload>
          }
          findFirst: {
            args: Prisma.SpellTargetingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellTargetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellTargetingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellTargetingPayload>
          }
          findMany: {
            args: Prisma.SpellTargetingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellTargetingPayload>[]
          }
          create: {
            args: Prisma.SpellTargetingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellTargetingPayload>
          }
          createMany: {
            args: Prisma.SpellTargetingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpellTargetingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellTargetingPayload>
          }
          update: {
            args: Prisma.SpellTargetingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellTargetingPayload>
          }
          deleteMany: {
            args: Prisma.SpellTargetingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpellTargetingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpellTargetingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellTargetingPayload>
          }
          aggregate: {
            args: Prisma.SpellTargetingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpellTargeting>
          }
          groupBy: {
            args: Prisma.SpellTargetingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpellTargetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellTargetingCountArgs<ExtArgs>,
            result: $Utils.Optional<SpellTargetingCountAggregateOutputType> | number
          }
        }
      }
      SpellSavingThrow: {
        payload: Prisma.$SpellSavingThrowPayload<ExtArgs>
        fields: Prisma.SpellSavingThrowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellSavingThrowFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSavingThrowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellSavingThrowFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSavingThrowPayload>
          }
          findFirst: {
            args: Prisma.SpellSavingThrowFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSavingThrowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellSavingThrowFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSavingThrowPayload>
          }
          findMany: {
            args: Prisma.SpellSavingThrowFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSavingThrowPayload>[]
          }
          create: {
            args: Prisma.SpellSavingThrowCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSavingThrowPayload>
          }
          createMany: {
            args: Prisma.SpellSavingThrowCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpellSavingThrowDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSavingThrowPayload>
          }
          update: {
            args: Prisma.SpellSavingThrowUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSavingThrowPayload>
          }
          deleteMany: {
            args: Prisma.SpellSavingThrowDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpellSavingThrowUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpellSavingThrowUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellSavingThrowPayload>
          }
          aggregate: {
            args: Prisma.SpellSavingThrowAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpellSavingThrow>
          }
          groupBy: {
            args: Prisma.SpellSavingThrowGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpellSavingThrowGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellSavingThrowCountArgs<ExtArgs>,
            result: $Utils.Optional<SpellSavingThrowCountAggregateOutputType> | number
          }
        }
      }
      SpellMessage: {
        payload: Prisma.$SpellMessagePayload<ExtArgs>
        fields: Prisma.SpellMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellMessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellMessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellMessagePayload>
          }
          findFirst: {
            args: Prisma.SpellMessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellMessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellMessagePayload>
          }
          findMany: {
            args: Prisma.SpellMessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellMessagePayload>[]
          }
          create: {
            args: Prisma.SpellMessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellMessagePayload>
          }
          createMany: {
            args: Prisma.SpellMessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpellMessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellMessagePayload>
          }
          update: {
            args: Prisma.SpellMessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellMessagePayload>
          }
          deleteMany: {
            args: Prisma.SpellMessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpellMessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpellMessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellMessagePayload>
          }
          aggregate: {
            args: Prisma.SpellMessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpellMessage>
          }
          groupBy: {
            args: Prisma.SpellMessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpellMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellMessageCountArgs<ExtArgs>,
            result: $Utils.Optional<SpellMessageCountAggregateOutputType> | number
          }
        }
      }
      SpellComponent: {
        payload: Prisma.$SpellComponentPayload<ExtArgs>
        fields: Prisma.SpellComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellComponentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellComponentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellComponentPayload>
          }
          findFirst: {
            args: Prisma.SpellComponentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellComponentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellComponentPayload>
          }
          findMany: {
            args: Prisma.SpellComponentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellComponentPayload>[]
          }
          create: {
            args: Prisma.SpellComponentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellComponentPayload>
          }
          createMany: {
            args: Prisma.SpellComponentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpellComponentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellComponentPayload>
          }
          update: {
            args: Prisma.SpellComponentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellComponentPayload>
          }
          deleteMany: {
            args: Prisma.SpellComponentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpellComponentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpellComponentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellComponentPayload>
          }
          aggregate: {
            args: Prisma.SpellComponentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpellComponent>
          }
          groupBy: {
            args: Prisma.SpellComponentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpellComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellComponentCountArgs<ExtArgs>,
            result: $Utils.Optional<SpellComponentCountAggregateOutputType> | number
          }
        }
      }
      SpellRestriction: {
        payload: Prisma.$SpellRestrictionPayload<ExtArgs>
        fields: Prisma.SpellRestrictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellRestrictionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellRestrictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellRestrictionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellRestrictionPayload>
          }
          findFirst: {
            args: Prisma.SpellRestrictionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellRestrictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellRestrictionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellRestrictionPayload>
          }
          findMany: {
            args: Prisma.SpellRestrictionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellRestrictionPayload>[]
          }
          create: {
            args: Prisma.SpellRestrictionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellRestrictionPayload>
          }
          createMany: {
            args: Prisma.SpellRestrictionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpellRestrictionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellRestrictionPayload>
          }
          update: {
            args: Prisma.SpellRestrictionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellRestrictionPayload>
          }
          deleteMany: {
            args: Prisma.SpellRestrictionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpellRestrictionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpellRestrictionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellRestrictionPayload>
          }
          aggregate: {
            args: Prisma.SpellRestrictionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpellRestriction>
          }
          groupBy: {
            args: Prisma.SpellRestrictionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpellRestrictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellRestrictionCountArgs<ExtArgs>,
            result: $Utils.Optional<SpellRestrictionCountAggregateOutputType> | number
          }
        }
      }
      SpellEffect: {
        payload: Prisma.$SpellEffectPayload<ExtArgs>
        fields: Prisma.SpellEffectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpellEffectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellEffectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpellEffectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellEffectPayload>
          }
          findFirst: {
            args: Prisma.SpellEffectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellEffectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpellEffectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellEffectPayload>
          }
          findMany: {
            args: Prisma.SpellEffectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellEffectPayload>[]
          }
          create: {
            args: Prisma.SpellEffectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellEffectPayload>
          }
          createMany: {
            args: Prisma.SpellEffectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpellEffectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellEffectPayload>
          }
          update: {
            args: Prisma.SpellEffectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellEffectPayload>
          }
          deleteMany: {
            args: Prisma.SpellEffectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpellEffectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpellEffectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpellEffectPayload>
          }
          aggregate: {
            args: Prisma.SpellEffectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpellEffect>
          }
          groupBy: {
            args: Prisma.SpellEffectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpellEffectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpellEffectCountArgs<ExtArgs>,
            result: $Utils.Optional<SpellEffectCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>,
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      ClassSkill: {
        payload: Prisma.$ClassSkillPayload<ExtArgs>
        fields: Prisma.ClassSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassSkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassSkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassSkillPayload>
          }
          findFirst: {
            args: Prisma.ClassSkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassSkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassSkillPayload>
          }
          findMany: {
            args: Prisma.ClassSkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassSkillPayload>[]
          }
          create: {
            args: Prisma.ClassSkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassSkillPayload>
          }
          createMany: {
            args: Prisma.ClassSkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClassSkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassSkillPayload>
          }
          update: {
            args: Prisma.ClassSkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassSkillPayload>
          }
          deleteMany: {
            args: Prisma.ClassSkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClassSkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClassSkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClassSkillPayload>
          }
          aggregate: {
            args: Prisma.ClassSkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClassSkill>
          }
          groupBy: {
            args: Prisma.ClassSkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClassSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassSkillCountArgs<ExtArgs>,
            result: $Utils.Optional<ClassSkillCountAggregateOutputType> | number
          }
        }
      }
      RaceSkill: {
        payload: Prisma.$RaceSkillPayload<ExtArgs>
        fields: Prisma.RaceSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceSkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RaceSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceSkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RaceSkillPayload>
          }
          findFirst: {
            args: Prisma.RaceSkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RaceSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceSkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RaceSkillPayload>
          }
          findMany: {
            args: Prisma.RaceSkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RaceSkillPayload>[]
          }
          create: {
            args: Prisma.RaceSkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RaceSkillPayload>
          }
          createMany: {
            args: Prisma.RaceSkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RaceSkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RaceSkillPayload>
          }
          update: {
            args: Prisma.RaceSkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RaceSkillPayload>
          }
          deleteMany: {
            args: Prisma.RaceSkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RaceSkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RaceSkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RaceSkillPayload>
          }
          aggregate: {
            args: Prisma.RaceSkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRaceSkill>
          }
          groupBy: {
            args: Prisma.RaceSkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RaceSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceSkillCountArgs<ExtArgs>,
            result: $Utils.Optional<RaceSkillCountAggregateOutputType> | number
          }
        }
      }
      CharacterSkill: {
        payload: Prisma.$CharacterSkillPayload<ExtArgs>
        fields: Prisma.CharacterSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterSkillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterSkillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          findFirst: {
            args: Prisma.CharacterSkillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterSkillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          findMany: {
            args: Prisma.CharacterSkillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>[]
          }
          create: {
            args: Prisma.CharacterSkillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          createMany: {
            args: Prisma.CharacterSkillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterSkillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          update: {
            args: Prisma.CharacterSkillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          deleteMany: {
            args: Prisma.CharacterSkillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterSkillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterSkillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          aggregate: {
            args: Prisma.CharacterSkillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacterSkill>
          }
          groupBy: {
            args: Prisma.CharacterSkillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterSkillCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterSkillCountAggregateOutputType> | number
          }
        }
      }
      CharacterSpell: {
        payload: Prisma.$CharacterSpellPayload<ExtArgs>
        fields: Prisma.CharacterSpellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterSpellFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterSpellFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellPayload>
          }
          findFirst: {
            args: Prisma.CharacterSpellFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterSpellFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellPayload>
          }
          findMany: {
            args: Prisma.CharacterSpellFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellPayload>[]
          }
          create: {
            args: Prisma.CharacterSpellCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellPayload>
          }
          createMany: {
            args: Prisma.CharacterSpellCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterSpellDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellPayload>
          }
          update: {
            args: Prisma.CharacterSpellUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellPayload>
          }
          deleteMany: {
            args: Prisma.CharacterSpellDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterSpellUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterSpellUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterSpellPayload>
          }
          aggregate: {
            args: Prisma.CharacterSpellAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacterSpell>
          }
          groupBy: {
            args: Prisma.CharacterSpellGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterSpellGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterSpellCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterSpellCountAggregateOutputType> | number
          }
        }
      }
      ChangeLog: {
        payload: Prisma.$ChangeLogPayload<ExtArgs>
        fields: Prisma.ChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          findFirst: {
            args: Prisma.ChangeLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          findMany: {
            args: Prisma.ChangeLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>[]
          }
          create: {
            args: Prisma.ChangeLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          createMany: {
            args: Prisma.ChangeLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ChangeLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          update: {
            args: Prisma.ChangeLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.ChangeLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ChangeLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          aggregate: {
            args: Prisma.ChangeLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChangeLog>
          }
          groupBy: {
            args: Prisma.ChangeLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeLogCountArgs<ExtArgs>,
            result: $Utils.Optional<ChangeLogCountAggregateOutputType> | number
          }
        }
      }
      BanRecord: {
        payload: Prisma.$BanRecordPayload<ExtArgs>
        fields: Prisma.BanRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BanRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BanRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanRecordPayload>
          }
          findFirst: {
            args: Prisma.BanRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BanRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanRecordPayload>
          }
          findMany: {
            args: Prisma.BanRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanRecordPayload>[]
          }
          create: {
            args: Prisma.BanRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanRecordPayload>
          }
          createMany: {
            args: Prisma.BanRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BanRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanRecordPayload>
          }
          update: {
            args: Prisma.BanRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanRecordPayload>
          }
          deleteMany: {
            args: Prisma.BanRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BanRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BanRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanRecordPayload>
          }
          aggregate: {
            args: Prisma.BanRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanRecord>
          }
          groupBy: {
            args: Prisma.BanRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BanRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.BanRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<BanRecordCountAggregateOutputType> | number
          }
        }
      }
      CharacterItem: {
        payload: Prisma.$CharacterItemPayload<ExtArgs>
        fields: Prisma.CharacterItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterItemPayload>
          }
          findFirst: {
            args: Prisma.CharacterItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterItemPayload>
          }
          findMany: {
            args: Prisma.CharacterItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterItemPayload>[]
          }
          create: {
            args: Prisma.CharacterItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterItemPayload>
          }
          createMany: {
            args: Prisma.CharacterItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterItemPayload>
          }
          update: {
            args: Prisma.CharacterItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterItemPayload>
          }
          deleteMany: {
            args: Prisma.CharacterItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterItemPayload>
          }
          aggregate: {
            args: Prisma.CharacterItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacterItem>
          }
          groupBy: {
            args: Prisma.CharacterItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterItemCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterItemCountAggregateOutputType> | number
          }
        }
      }
      CharacterEffect: {
        payload: Prisma.$CharacterEffectPayload<ExtArgs>
        fields: Prisma.CharacterEffectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterEffectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEffectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterEffectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEffectPayload>
          }
          findFirst: {
            args: Prisma.CharacterEffectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEffectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterEffectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEffectPayload>
          }
          findMany: {
            args: Prisma.CharacterEffectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEffectPayload>[]
          }
          create: {
            args: Prisma.CharacterEffectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEffectPayload>
          }
          createMany: {
            args: Prisma.CharacterEffectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterEffectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEffectPayload>
          }
          update: {
            args: Prisma.CharacterEffectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEffectPayload>
          }
          deleteMany: {
            args: Prisma.CharacterEffectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterEffectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterEffectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterEffectPayload>
          }
          aggregate: {
            args: Prisma.CharacterEffectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacterEffect>
          }
          groupBy: {
            args: Prisma.CharacterEffectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterEffectGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterEffectCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterEffectCountAggregateOutputType> | number
          }
        }
      }
      EquipmentSetItem: {
        payload: Prisma.$EquipmentSetItemPayload<ExtArgs>
        fields: Prisma.EquipmentSetItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentSetItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentSetItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetItemPayload>
          }
          findFirst: {
            args: Prisma.EquipmentSetItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentSetItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetItemPayload>
          }
          findMany: {
            args: Prisma.EquipmentSetItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetItemPayload>[]
          }
          create: {
            args: Prisma.EquipmentSetItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetItemPayload>
          }
          createMany: {
            args: Prisma.EquipmentSetItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EquipmentSetItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetItemPayload>
          }
          update: {
            args: Prisma.EquipmentSetItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetItemPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentSetItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentSetItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentSetItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetItemPayload>
          }
          aggregate: {
            args: Prisma.EquipmentSetItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipmentSetItem>
          }
          groupBy: {
            args: Prisma.EquipmentSetItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentSetItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentSetItemCountArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentSetItemCountAggregateOutputType> | number
          }
        }
      }
      EquipmentSet: {
        payload: Prisma.$EquipmentSetPayload<ExtArgs>
        fields: Prisma.EquipmentSetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentSetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentSetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetPayload>
          }
          findFirst: {
            args: Prisma.EquipmentSetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentSetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetPayload>
          }
          findMany: {
            args: Prisma.EquipmentSetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetPayload>[]
          }
          create: {
            args: Prisma.EquipmentSetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetPayload>
          }
          createMany: {
            args: Prisma.EquipmentSetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EquipmentSetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetPayload>
          }
          update: {
            args: Prisma.EquipmentSetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentSetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentSetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentSetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EquipmentSetPayload>
          }
          aggregate: {
            args: Prisma.EquipmentSetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipmentSet>
          }
          groupBy: {
            args: Prisma.EquipmentSetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentSetGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentSetCountArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentSetCountAggregateOutputType> | number
          }
        }
      }
      MobEquipmentSet: {
        payload: Prisma.$MobEquipmentSetPayload<ExtArgs>
        fields: Prisma.MobEquipmentSetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobEquipmentSetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquipmentSetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobEquipmentSetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquipmentSetPayload>
          }
          findFirst: {
            args: Prisma.MobEquipmentSetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquipmentSetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobEquipmentSetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquipmentSetPayload>
          }
          findMany: {
            args: Prisma.MobEquipmentSetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquipmentSetPayload>[]
          }
          create: {
            args: Prisma.MobEquipmentSetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquipmentSetPayload>
          }
          createMany: {
            args: Prisma.MobEquipmentSetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MobEquipmentSetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquipmentSetPayload>
          }
          update: {
            args: Prisma.MobEquipmentSetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquipmentSetPayload>
          }
          deleteMany: {
            args: Prisma.MobEquipmentSetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MobEquipmentSetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MobEquipmentSetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MobEquipmentSetPayload>
          }
          aggregate: {
            args: Prisma.MobEquipmentSetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMobEquipmentSet>
          }
          groupBy: {
            args: Prisma.MobEquipmentSetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MobEquipmentSetGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobEquipmentSetCountArgs<ExtArgs>,
            result: $Utils.Optional<MobEquipmentSetCountAggregateOutputType> | number
          }
        }
      }
      ObjectReset: {
        payload: Prisma.$ObjectResetPayload<ExtArgs>
        fields: Prisma.ObjectResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectResetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectResetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectResetPayload>
          }
          findFirst: {
            args: Prisma.ObjectResetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectResetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectResetPayload>
          }
          findMany: {
            args: Prisma.ObjectResetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectResetPayload>[]
          }
          create: {
            args: Prisma.ObjectResetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectResetPayload>
          }
          createMany: {
            args: Prisma.ObjectResetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectResetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectResetPayload>
          }
          update: {
            args: Prisma.ObjectResetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectResetPayload>
          }
          deleteMany: {
            args: Prisma.ObjectResetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectResetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectResetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectResetPayload>
          }
          aggregate: {
            args: Prisma.ObjectResetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObjectReset>
          }
          groupBy: {
            args: Prisma.ObjectResetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectResetCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectResetCountAggregateOutputType> | number
          }
        }
      }
      SpawnCondition: {
        payload: Prisma.$SpawnConditionPayload<ExtArgs>
        fields: Prisma.SpawnConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpawnConditionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpawnConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpawnConditionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpawnConditionPayload>
          }
          findFirst: {
            args: Prisma.SpawnConditionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpawnConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpawnConditionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpawnConditionPayload>
          }
          findMany: {
            args: Prisma.SpawnConditionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpawnConditionPayload>[]
          }
          create: {
            args: Prisma.SpawnConditionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpawnConditionPayload>
          }
          createMany: {
            args: Prisma.SpawnConditionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpawnConditionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpawnConditionPayload>
          }
          update: {
            args: Prisma.SpawnConditionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpawnConditionPayload>
          }
          deleteMany: {
            args: Prisma.SpawnConditionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpawnConditionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpawnConditionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpawnConditionPayload>
          }
          aggregate: {
            args: Prisma.SpawnConditionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpawnCondition>
          }
          groupBy: {
            args: Prisma.SpawnConditionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpawnConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpawnConditionCountArgs<ExtArgs>,
            result: $Utils.Optional<SpawnConditionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditLogs: number
    issuedBans: number
    banRecords: number
    changeLogs: number
    characters: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    issuedBans?: boolean | UserCountOutputTypeCountIssuedBansArgs
    banRecords?: boolean | UserCountOutputTypeCountBanRecordsArgs
    changeLogs?: boolean | UserCountOutputTypeCountChangeLogsArgs
    characters?: boolean | UserCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIssuedBansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BanRecordWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBanRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BanRecordWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeLogWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }



  /**
   * Count Type CharacterCountOutputType
   */

  export type CharacterCountOutputType = {
    effects: number
    items: number
    skills: number
    spells: number
  }

  export type CharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    effects?: boolean | CharacterCountOutputTypeCountEffectsArgs
    items?: boolean | CharacterCountOutputTypeCountItemsArgs
    skills?: boolean | CharacterCountOutputTypeCountSkillsArgs
    spells?: boolean | CharacterCountOutputTypeCountSpellsArgs
  }

  // Custom InputTypes

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     */
    select?: CharacterCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountEffectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterEffectWhereInput
  }


  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterItemWhereInput
  }


  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSkillWhereInput
  }


  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSpellWhereInput
  }



  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    mobResets: number
    mobs: number
    objectResets: number
    objects: number
    rooms: number
    shops: number
    triggers: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mobResets?: boolean | ZoneCountOutputTypeCountMobResetsArgs
    mobs?: boolean | ZoneCountOutputTypeCountMobsArgs
    objectResets?: boolean | ZoneCountOutputTypeCountObjectResetsArgs
    objects?: boolean | ZoneCountOutputTypeCountObjectsArgs
    rooms?: boolean | ZoneCountOutputTypeCountRoomsArgs
    shops?: boolean | ZoneCountOutputTypeCountShopsArgs
    triggers?: boolean | ZoneCountOutputTypeCountTriggersArgs
  }

  // Custom InputTypes

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountMobResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobResetWhereInput
  }


  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountMobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobWhereInput
  }


  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountObjectResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectResetWhereInput
  }


  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountObjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }


  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }


  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountShopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
  }


  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountTriggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggerWhereInput
  }



  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    mobResets: number
    objectResets: number
    exits: number
    extraDescs: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mobResets?: boolean | RoomCountOutputTypeCountMobResetsArgs
    objectResets?: boolean | RoomCountOutputTypeCountObjectResetsArgs
    exits?: boolean | RoomCountOutputTypeCountExitsArgs
    extraDescs?: boolean | RoomCountOutputTypeCountExtraDescsArgs
  }

  // Custom InputTypes

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountMobResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobResetWhereInput
  }


  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountObjectResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectResetWhereInput
  }


  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountExitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomExitWhereInput
  }


  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountExtraDescsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomExtraDescriptionWhereInput
  }



  /**
   * Count Type MobCountOutputType
   */

  export type MobCountOutputType = {
    resets: number
    skills: number
    spells: number
    shops: number
    triggers: number
  }

  export type MobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resets?: boolean | MobCountOutputTypeCountResetsArgs
    skills?: boolean | MobCountOutputTypeCountSkillsArgs
    spells?: boolean | MobCountOutputTypeCountSpellsArgs
    shops?: boolean | MobCountOutputTypeCountShopsArgs
    triggers?: boolean | MobCountOutputTypeCountTriggersArgs
  }

  // Custom InputTypes

  /**
   * MobCountOutputType without action
   */
  export type MobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCountOutputType
     */
    select?: MobCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MobCountOutputType without action
   */
  export type MobCountOutputTypeCountResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobResetWhereInput
  }


  /**
   * MobCountOutputType without action
   */
  export type MobCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobSkillWhereInput
  }


  /**
   * MobCountOutputType without action
   */
  export type MobCountOutputTypeCountSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobSpellWhereInput
  }


  /**
   * MobCountOutputType without action
   */
  export type MobCountOutputTypeCountShopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
  }


  /**
   * MobCountOutputType without action
   */
  export type MobCountOutputTypeCountTriggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggerWhereInput
  }



  /**
   * Count Type MobResetCountOutputType
   */

  export type MobResetCountOutputType = {
    carrying: number
    equipmentSets: number
    equipped: number
    spawnConditions: number
  }

  export type MobResetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrying?: boolean | MobResetCountOutputTypeCountCarryingArgs
    equipmentSets?: boolean | MobResetCountOutputTypeCountEquipmentSetsArgs
    equipped?: boolean | MobResetCountOutputTypeCountEquippedArgs
    spawnConditions?: boolean | MobResetCountOutputTypeCountSpawnConditionsArgs
  }

  // Custom InputTypes

  /**
   * MobResetCountOutputType without action
   */
  export type MobResetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobResetCountOutputType
     */
    select?: MobResetCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MobResetCountOutputType without action
   */
  export type MobResetCountOutputTypeCountCarryingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobCarryingWhereInput
  }


  /**
   * MobResetCountOutputType without action
   */
  export type MobResetCountOutputTypeCountEquipmentSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobEquipmentSetWhereInput
  }


  /**
   * MobResetCountOutputType without action
   */
  export type MobResetCountOutputTypeCountEquippedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobEquippedWhereInput
  }


  /**
   * MobResetCountOutputType without action
   */
  export type MobResetCountOutputTypeCountSpawnConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpawnConditionWhereInput
  }



  /**
   * Count Type ObjectCountOutputType
   */

  export type ObjectCountOutputType = {
    characterItems: number
    equipmentSetItems: number
    mobCarrying: number
    mobEquipped: number
    affects: number
    extraDescs: number
    resets: number
    spells: number
    shopItems: number
    triggers: number
  }

  export type ObjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterItems?: boolean | ObjectCountOutputTypeCountCharacterItemsArgs
    equipmentSetItems?: boolean | ObjectCountOutputTypeCountEquipmentSetItemsArgs
    mobCarrying?: boolean | ObjectCountOutputTypeCountMobCarryingArgs
    mobEquipped?: boolean | ObjectCountOutputTypeCountMobEquippedArgs
    affects?: boolean | ObjectCountOutputTypeCountAffectsArgs
    extraDescs?: boolean | ObjectCountOutputTypeCountExtraDescsArgs
    resets?: boolean | ObjectCountOutputTypeCountResetsArgs
    spells?: boolean | ObjectCountOutputTypeCountSpellsArgs
    shopItems?: boolean | ObjectCountOutputTypeCountShopItemsArgs
    triggers?: boolean | ObjectCountOutputTypeCountTriggersArgs
  }

  // Custom InputTypes

  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCountOutputType
     */
    select?: ObjectCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountCharacterItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterItemWhereInput
  }


  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountEquipmentSetItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentSetItemWhereInput
  }


  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountMobCarryingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobCarryingWhereInput
  }


  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountMobEquippedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobEquippedWhereInput
  }


  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountAffectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectAffectWhereInput
  }


  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountExtraDescsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectExtraDescriptionWhereInput
  }


  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectResetWhereInput
  }


  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectSpellWhereInput
  }


  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountShopItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemWhereInput
  }


  /**
   * ObjectCountOutputType without action
   */
  export type ObjectCountOutputTypeCountTriggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggerWhereInput
  }



  /**
   * Count Type ShopCountOutputType
   */

  export type ShopCountOutputType = {
    accepts: number
    hours: number
    items: number
    rooms: number
  }

  export type ShopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accepts?: boolean | ShopCountOutputTypeCountAcceptsArgs
    hours?: boolean | ShopCountOutputTypeCountHoursArgs
    items?: boolean | ShopCountOutputTypeCountItemsArgs
    rooms?: boolean | ShopCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCountOutputType
     */
    select?: ShopCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountAcceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopAcceptWhereInput
  }


  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopHourWhereInput
  }


  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemWhereInput
  }


  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopRoomWhereInput
  }



  /**
   * Count Type GameClassCountOutputType
   */

  export type GameClassCountOutputType = {
    characters: number
    skillAccess: number
    mobs: number
    spellCircles: number
  }

  export type GameClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | GameClassCountOutputTypeCountCharactersArgs
    skillAccess?: boolean | GameClassCountOutputTypeCountSkillAccessArgs
    mobs?: boolean | GameClassCountOutputTypeCountMobsArgs
    spellCircles?: boolean | GameClassCountOutputTypeCountSpellCirclesArgs
  }

  // Custom InputTypes

  /**
   * GameClassCountOutputType without action
   */
  export type GameClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClassCountOutputType
     */
    select?: GameClassCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GameClassCountOutputType without action
   */
  export type GameClassCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * GameClassCountOutputType without action
   */
  export type GameClassCountOutputTypeCountSkillAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSkillWhereInput
  }


  /**
   * GameClassCountOutputType without action
   */
  export type GameClassCountOutputTypeCountMobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobWhereInput
  }


  /**
   * GameClassCountOutputType without action
   */
  export type GameClassCountOutputTypeCountSpellCirclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellClassCircleWhereInput
  }



  /**
   * Count Type SpellCountOutputType
   */

  export type SpellCountOutputType = {
    characterSpells: number
    mobSpells: number
    classCircles: number
    components: number
    effects: number
    savingThrows: number
  }

  export type SpellCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterSpells?: boolean | SpellCountOutputTypeCountCharacterSpellsArgs
    mobSpells?: boolean | SpellCountOutputTypeCountMobSpellsArgs
    classCircles?: boolean | SpellCountOutputTypeCountClassCirclesArgs
    components?: boolean | SpellCountOutputTypeCountComponentsArgs
    effects?: boolean | SpellCountOutputTypeCountEffectsArgs
    savingThrows?: boolean | SpellCountOutputTypeCountSavingThrowsArgs
  }

  // Custom InputTypes

  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellCountOutputType
     */
    select?: SpellCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountCharacterSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSpellWhereInput
  }


  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountMobSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobSpellWhereInput
  }


  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountClassCirclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellClassCircleWhereInput
  }


  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellComponentWhereInput
  }


  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountEffectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellEffectWhereInput
  }


  /**
   * SpellCountOutputType without action
   */
  export type SpellCountOutputTypeCountSavingThrowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellSavingThrowWhereInput
  }



  /**
   * Count Type SpellSchoolCountOutputType
   */

  export type SpellSchoolCountOutputType = {
    spells: number
  }

  export type SpellSchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spells?: boolean | SpellSchoolCountOutputTypeCountSpellsArgs
  }

  // Custom InputTypes

  /**
   * SpellSchoolCountOutputType without action
   */
  export type SpellSchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchoolCountOutputType
     */
    select?: SpellSchoolCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SpellSchoolCountOutputType without action
   */
  export type SpellSchoolCountOutputTypeCountSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellWhereInput
  }



  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    characterSkills: number
    classSkills: number
    mobSkills: number
    raceSkills: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterSkills?: boolean | SkillCountOutputTypeCountCharacterSkillsArgs
    classSkills?: boolean | SkillCountOutputTypeCountClassSkillsArgs
    mobSkills?: boolean | SkillCountOutputTypeCountMobSkillsArgs
    raceSkills?: boolean | SkillCountOutputTypeCountRaceSkillsArgs
  }

  // Custom InputTypes

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountCharacterSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSkillWhereInput
  }


  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountClassSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSkillWhereInput
  }


  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountMobSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobSkillWhereInput
  }


  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountRaceSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceSkillWhereInput
  }



  /**
   * Count Type CharacterItemCountOutputType
   */

  export type CharacterItemCountOutputType = {
    containedItems: number
  }

  export type CharacterItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    containedItems?: boolean | CharacterItemCountOutputTypeCountContainedItemsArgs
  }

  // Custom InputTypes

  /**
   * CharacterItemCountOutputType without action
   */
  export type CharacterItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItemCountOutputType
     */
    select?: CharacterItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CharacterItemCountOutputType without action
   */
  export type CharacterItemCountOutputTypeCountContainedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterItemWhereInput
  }



  /**
   * Count Type EquipmentSetCountOutputType
   */

  export type EquipmentSetCountOutputType = {
    items: number
    mobEquipmentSets: number
  }

  export type EquipmentSetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | EquipmentSetCountOutputTypeCountItemsArgs
    mobEquipmentSets?: boolean | EquipmentSetCountOutputTypeCountMobEquipmentSetsArgs
  }

  // Custom InputTypes

  /**
   * EquipmentSetCountOutputType without action
   */
  export type EquipmentSetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetCountOutputType
     */
    select?: EquipmentSetCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EquipmentSetCountOutputType without action
   */
  export type EquipmentSetCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentSetItemWhereInput
  }


  /**
   * EquipmentSetCountOutputType without action
   */
  export type EquipmentSetCountOutputTypeCountMobEquipmentSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobEquipmentSetWhereInput
  }



  /**
   * Count Type ObjectResetCountOutputType
   */

  export type ObjectResetCountOutputType = {
    spawnConditions: number
  }

  export type ObjectResetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spawnConditions?: boolean | ObjectResetCountOutputTypeCountSpawnConditionsArgs
  }

  // Custom InputTypes

  /**
   * ObjectResetCountOutputType without action
   */
  export type ObjectResetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectResetCountOutputType
     */
    select?: ObjectResetCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ObjectResetCountOutputType without action
   */
  export type ObjectResetCountOutputTypeCountSpawnConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpawnConditionWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    lastFailedLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    lastFailedLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    role: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    resetToken: number
    resetTokenExpiry: number
    failedLoginAttempts: number
    lockedUntil: number
    lastFailedLogin: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    resetToken?: true
    resetTokenExpiry?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    lastFailedLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    resetToken?: true
    resetTokenExpiry?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    lastFailedLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    resetToken?: true
    resetTokenExpiry?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    lastFailedLogin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    failedLoginAttempts: number
    lockedUntil: Date | null
    lastFailedLogin: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    lastFailedLogin?: boolean
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    issuedBans?: boolean | User$issuedBansArgs<ExtArgs>
    banRecords?: boolean | User$banRecordsArgs<ExtArgs>
    changeLogs?: boolean | User$changeLogsArgs<ExtArgs>
    characters?: boolean | User$charactersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    lastFailedLogin?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    issuedBans?: boolean | User$issuedBansArgs<ExtArgs>
    banRecords?: boolean | User$banRecordsArgs<ExtArgs>
    changeLogs?: boolean | User$changeLogsArgs<ExtArgs>
    characters?: boolean | User$charactersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      issuedBans: Prisma.$BanRecordPayload<ExtArgs>[]
      banRecords: Prisma.$BanRecordPayload<ExtArgs>[]
      changeLogs: Prisma.$ChangeLogPayload<ExtArgs>[]
      characters: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      failedLoginAttempts: number
      lockedUntil: Date | null
      lastFailedLogin: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    issuedBans<T extends User$issuedBansArgs<ExtArgs> = {}>(args?: Subset<T, User$issuedBansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'findMany'> | Null>;

    banRecords<T extends User$banRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$banRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'findMany'> | Null>;

    changeLogs<T extends User$changeLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$changeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    characters<T extends User$charactersArgs<ExtArgs> = {}>(args?: Subset<T, User$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly failedLoginAttempts: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly lastFailedLogin: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }


  /**
   * User.issuedBans
   */
  export type User$issuedBansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    where?: BanRecordWhereInput
    orderBy?: BanRecordOrderByWithRelationInput | BanRecordOrderByWithRelationInput[]
    cursor?: BanRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BanRecordScalarFieldEnum | BanRecordScalarFieldEnum[]
  }


  /**
   * User.banRecords
   */
  export type User$banRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    where?: BanRecordWhereInput
    orderBy?: BanRecordOrderByWithRelationInput | BanRecordOrderByWithRelationInput[]
    cursor?: BanRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BanRecordScalarFieldEnum | BanRecordScalarFieldEnum[]
  }


  /**
   * User.changeLogs
   */
  export type User$changeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    where?: ChangeLogWhereInput
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    cursor?: ChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }


  /**
   * User.characters
   */
  export type User$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    level: number | null
    alignment: number | null
    strength: number | null
    intelligence: number | null
    wisdom: number | null
    dexterity: number | null
    constitution: number | null
    charisma: number | null
    luck: number | null
    hitPoints: number | null
    movement: number | null
    hitPointsMax: number | null
    movementMax: number | null
    copper: number | null
    silver: number | null
    gold: number | null
    platinum: number | null
    bankCopper: number | null
    bankSilver: number | null
    bankGold: number | null
    bankPlatinum: number | null
    total_wealth: number | null
    average_stats: number | null
    height: number | null
    weight: number | null
    baseSize: number | null
    currentSize: number | null
    hitRoll: number | null
    damageRoll: number | null
    armorClass: number | null
    currentRoom: number | null
    saveRoom: number | null
    homeRoom: number | null
    timePlayed: number | null
    hunger: number | null
    thirst: number | null
    pageLength: number | null
    olcZones: number | null
    invisLevel: number | null
    classId: number | null
    experience: number | null
    skillPoints: number | null
  }

  export type CharacterSumAggregateOutputType = {
    level: number | null
    alignment: number | null
    strength: number | null
    intelligence: number | null
    wisdom: number | null
    dexterity: number | null
    constitution: number | null
    charisma: number | null
    luck: number | null
    hitPoints: number | null
    movement: number | null
    hitPointsMax: number | null
    movementMax: number | null
    copper: number | null
    silver: number | null
    gold: number | null
    platinum: number | null
    bankCopper: number | null
    bankSilver: number | null
    bankGold: number | null
    bankPlatinum: number | null
    total_wealth: number | null
    average_stats: number | null
    height: number | null
    weight: number | null
    baseSize: number | null
    currentSize: number | null
    hitRoll: number | null
    damageRoll: number | null
    armorClass: number | null
    currentRoom: number | null
    saveRoom: number | null
    homeRoom: number | null
    timePlayed: number | null
    hunger: number | null
    thirst: number | null
    pageLength: number | null
    olcZones: number[]
    invisLevel: number | null
    classId: number | null
    experience: number | null
    skillPoints: number | null
  }

  export type CharacterMinAggregateOutputType = {
    id: string | null
    name: string | null
    level: number | null
    alignment: number | null
    strength: number | null
    intelligence: number | null
    wisdom: number | null
    dexterity: number | null
    constitution: number | null
    charisma: number | null
    luck: number | null
    hitPoints: number | null
    movement: number | null
    hitPointsMax: number | null
    movementMax: number | null
    copper: number | null
    silver: number | null
    gold: number | null
    platinum: number | null
    bankCopper: number | null
    bankSilver: number | null
    bankGold: number | null
    bankPlatinum: number | null
    total_wealth: number | null
    average_stats: number | null
    passwordHash: string | null
    raceType: string | null
    race: $Enums.Race | null
    gender: string | null
    playerClass: string | null
    height: number | null
    weight: number | null
    baseSize: number | null
    currentSize: number | null
    hitRoll: number | null
    damageRoll: number | null
    armorClass: number | null
    currentRoom: number | null
    saveRoom: number | null
    homeRoom: number | null
    lastLogin: Date | null
    timePlayed: number | null
    isOnline: boolean | null
    hunger: number | null
    thirst: number | null
    description: string | null
    title: string | null
    prompt: string | null
    pageLength: number | null
    invisLevel: number | null
    birthTime: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    classId: number | null
    experience: number | null
    skillPoints: number | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    level: number | null
    alignment: number | null
    strength: number | null
    intelligence: number | null
    wisdom: number | null
    dexterity: number | null
    constitution: number | null
    charisma: number | null
    luck: number | null
    hitPoints: number | null
    movement: number | null
    hitPointsMax: number | null
    movementMax: number | null
    copper: number | null
    silver: number | null
    gold: number | null
    platinum: number | null
    bankCopper: number | null
    bankSilver: number | null
    bankGold: number | null
    bankPlatinum: number | null
    total_wealth: number | null
    average_stats: number | null
    passwordHash: string | null
    raceType: string | null
    race: $Enums.Race | null
    gender: string | null
    playerClass: string | null
    height: number | null
    weight: number | null
    baseSize: number | null
    currentSize: number | null
    hitRoll: number | null
    damageRoll: number | null
    armorClass: number | null
    currentRoom: number | null
    saveRoom: number | null
    homeRoom: number | null
    lastLogin: Date | null
    timePlayed: number | null
    isOnline: boolean | null
    hunger: number | null
    thirst: number | null
    description: string | null
    title: string | null
    prompt: string | null
    pageLength: number | null
    invisLevel: number | null
    birthTime: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    classId: number | null
    experience: number | null
    skillPoints: number | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    name: number
    level: number
    alignment: number
    strength: number
    intelligence: number
    wisdom: number
    dexterity: number
    constitution: number
    charisma: number
    luck: number
    hitPoints: number
    movement: number
    hitPointsMax: number
    movementMax: number
    copper: number
    silver: number
    gold: number
    platinum: number
    bankCopper: number
    bankSilver: number
    bankGold: number
    bankPlatinum: number
    total_wealth: number
    average_stats: number
    passwordHash: number
    raceType: number
    race: number
    gender: number
    playerClass: number
    height: number
    weight: number
    baseSize: number
    currentSize: number
    hitRoll: number
    damageRoll: number
    armorClass: number
    currentRoom: number
    saveRoom: number
    homeRoom: number
    lastLogin: number
    timePlayed: number
    isOnline: number
    hunger: number
    thirst: number
    description: number
    title: number
    prompt: number
    pageLength: number
    playerFlags: number
    effectFlags: number
    privilegeFlags: number
    olcZones: number
    invisLevel: number
    birthTime: number
    userId: number
    createdAt: number
    updatedAt: number
    classId: number
    experience: number
    skillPoints: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    level?: true
    alignment?: true
    strength?: true
    intelligence?: true
    wisdom?: true
    dexterity?: true
    constitution?: true
    charisma?: true
    luck?: true
    hitPoints?: true
    movement?: true
    hitPointsMax?: true
    movementMax?: true
    copper?: true
    silver?: true
    gold?: true
    platinum?: true
    bankCopper?: true
    bankSilver?: true
    bankGold?: true
    bankPlatinum?: true
    total_wealth?: true
    average_stats?: true
    height?: true
    weight?: true
    baseSize?: true
    currentSize?: true
    hitRoll?: true
    damageRoll?: true
    armorClass?: true
    currentRoom?: true
    saveRoom?: true
    homeRoom?: true
    timePlayed?: true
    hunger?: true
    thirst?: true
    pageLength?: true
    olcZones?: true
    invisLevel?: true
    classId?: true
    experience?: true
    skillPoints?: true
  }

  export type CharacterSumAggregateInputType = {
    level?: true
    alignment?: true
    strength?: true
    intelligence?: true
    wisdom?: true
    dexterity?: true
    constitution?: true
    charisma?: true
    luck?: true
    hitPoints?: true
    movement?: true
    hitPointsMax?: true
    movementMax?: true
    copper?: true
    silver?: true
    gold?: true
    platinum?: true
    bankCopper?: true
    bankSilver?: true
    bankGold?: true
    bankPlatinum?: true
    total_wealth?: true
    average_stats?: true
    height?: true
    weight?: true
    baseSize?: true
    currentSize?: true
    hitRoll?: true
    damageRoll?: true
    armorClass?: true
    currentRoom?: true
    saveRoom?: true
    homeRoom?: true
    timePlayed?: true
    hunger?: true
    thirst?: true
    pageLength?: true
    olcZones?: true
    invisLevel?: true
    classId?: true
    experience?: true
    skillPoints?: true
  }

  export type CharacterMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    alignment?: true
    strength?: true
    intelligence?: true
    wisdom?: true
    dexterity?: true
    constitution?: true
    charisma?: true
    luck?: true
    hitPoints?: true
    movement?: true
    hitPointsMax?: true
    movementMax?: true
    copper?: true
    silver?: true
    gold?: true
    platinum?: true
    bankCopper?: true
    bankSilver?: true
    bankGold?: true
    bankPlatinum?: true
    total_wealth?: true
    average_stats?: true
    passwordHash?: true
    raceType?: true
    race?: true
    gender?: true
    playerClass?: true
    height?: true
    weight?: true
    baseSize?: true
    currentSize?: true
    hitRoll?: true
    damageRoll?: true
    armorClass?: true
    currentRoom?: true
    saveRoom?: true
    homeRoom?: true
    lastLogin?: true
    timePlayed?: true
    isOnline?: true
    hunger?: true
    thirst?: true
    description?: true
    title?: true
    prompt?: true
    pageLength?: true
    invisLevel?: true
    birthTime?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    classId?: true
    experience?: true
    skillPoints?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    alignment?: true
    strength?: true
    intelligence?: true
    wisdom?: true
    dexterity?: true
    constitution?: true
    charisma?: true
    luck?: true
    hitPoints?: true
    movement?: true
    hitPointsMax?: true
    movementMax?: true
    copper?: true
    silver?: true
    gold?: true
    platinum?: true
    bankCopper?: true
    bankSilver?: true
    bankGold?: true
    bankPlatinum?: true
    total_wealth?: true
    average_stats?: true
    passwordHash?: true
    raceType?: true
    race?: true
    gender?: true
    playerClass?: true
    height?: true
    weight?: true
    baseSize?: true
    currentSize?: true
    hitRoll?: true
    damageRoll?: true
    armorClass?: true
    currentRoom?: true
    saveRoom?: true
    homeRoom?: true
    lastLogin?: true
    timePlayed?: true
    isOnline?: true
    hunger?: true
    thirst?: true
    description?: true
    title?: true
    prompt?: true
    pageLength?: true
    invisLevel?: true
    birthTime?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    classId?: true
    experience?: true
    skillPoints?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    alignment?: true
    strength?: true
    intelligence?: true
    wisdom?: true
    dexterity?: true
    constitution?: true
    charisma?: true
    luck?: true
    hitPoints?: true
    movement?: true
    hitPointsMax?: true
    movementMax?: true
    copper?: true
    silver?: true
    gold?: true
    platinum?: true
    bankCopper?: true
    bankSilver?: true
    bankGold?: true
    bankPlatinum?: true
    total_wealth?: true
    average_stats?: true
    passwordHash?: true
    raceType?: true
    race?: true
    gender?: true
    playerClass?: true
    height?: true
    weight?: true
    baseSize?: true
    currentSize?: true
    hitRoll?: true
    damageRoll?: true
    armorClass?: true
    currentRoom?: true
    saveRoom?: true
    homeRoom?: true
    lastLogin?: true
    timePlayed?: true
    isOnline?: true
    hunger?: true
    thirst?: true
    description?: true
    title?: true
    prompt?: true
    pageLength?: true
    playerFlags?: true
    effectFlags?: true
    privilegeFlags?: true
    olcZones?: true
    invisLevel?: true
    birthTime?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    classId?: true
    experience?: true
    skillPoints?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    id: string
    name: string
    level: number
    alignment: number
    strength: number
    intelligence: number
    wisdom: number
    dexterity: number
    constitution: number
    charisma: number
    luck: number
    hitPoints: number
    movement: number
    hitPointsMax: number
    movementMax: number
    copper: number
    silver: number
    gold: number
    platinum: number
    bankCopper: number
    bankSilver: number
    bankGold: number
    bankPlatinum: number
    total_wealth: number
    average_stats: number
    passwordHash: string | null
    raceType: string
    race: $Enums.Race
    gender: string
    playerClass: string | null
    height: number | null
    weight: number | null
    baseSize: number
    currentSize: number
    hitRoll: number
    damageRoll: number
    armorClass: number
    currentRoom: number | null
    saveRoom: number | null
    homeRoom: number | null
    lastLogin: Date | null
    timePlayed: number
    isOnline: boolean
    hunger: number
    thirst: number
    description: string | null
    title: string | null
    prompt: string
    pageLength: number
    playerFlags: string[]
    effectFlags: string[]
    privilegeFlags: string[]
    olcZones: number[]
    invisLevel: number
    birthTime: Date
    userId: string
    createdAt: Date
    updatedAt: Date
    classId: number | null
    experience: number
    skillPoints: number
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    alignment?: boolean
    strength?: boolean
    intelligence?: boolean
    wisdom?: boolean
    dexterity?: boolean
    constitution?: boolean
    charisma?: boolean
    luck?: boolean
    hitPoints?: boolean
    movement?: boolean
    hitPointsMax?: boolean
    movementMax?: boolean
    copper?: boolean
    silver?: boolean
    gold?: boolean
    platinum?: boolean
    bankCopper?: boolean
    bankSilver?: boolean
    bankGold?: boolean
    bankPlatinum?: boolean
    total_wealth?: boolean
    average_stats?: boolean
    passwordHash?: boolean
    raceType?: boolean
    race?: boolean
    gender?: boolean
    playerClass?: boolean
    height?: boolean
    weight?: boolean
    baseSize?: boolean
    currentSize?: boolean
    hitRoll?: boolean
    damageRoll?: boolean
    armorClass?: boolean
    currentRoom?: boolean
    saveRoom?: boolean
    homeRoom?: boolean
    lastLogin?: boolean
    timePlayed?: boolean
    isOnline?: boolean
    hunger?: boolean
    thirst?: boolean
    description?: boolean
    title?: boolean
    prompt?: boolean
    pageLength?: boolean
    playerFlags?: boolean
    effectFlags?: boolean
    privilegeFlags?: boolean
    olcZones?: boolean
    invisLevel?: boolean
    birthTime?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classId?: boolean
    experience?: boolean
    skillPoints?: boolean
    effects?: boolean | Character$effectsArgs<ExtArgs>
    items?: boolean | Character$itemsArgs<ExtArgs>
    skills?: boolean | Character$skillsArgs<ExtArgs>
    spells?: boolean | Character$spellsArgs<ExtArgs>
    gameClass?: boolean | Character$gameClassArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    alignment?: boolean
    strength?: boolean
    intelligence?: boolean
    wisdom?: boolean
    dexterity?: boolean
    constitution?: boolean
    charisma?: boolean
    luck?: boolean
    hitPoints?: boolean
    movement?: boolean
    hitPointsMax?: boolean
    movementMax?: boolean
    copper?: boolean
    silver?: boolean
    gold?: boolean
    platinum?: boolean
    bankCopper?: boolean
    bankSilver?: boolean
    bankGold?: boolean
    bankPlatinum?: boolean
    total_wealth?: boolean
    average_stats?: boolean
    passwordHash?: boolean
    raceType?: boolean
    race?: boolean
    gender?: boolean
    playerClass?: boolean
    height?: boolean
    weight?: boolean
    baseSize?: boolean
    currentSize?: boolean
    hitRoll?: boolean
    damageRoll?: boolean
    armorClass?: boolean
    currentRoom?: boolean
    saveRoom?: boolean
    homeRoom?: boolean
    lastLogin?: boolean
    timePlayed?: boolean
    isOnline?: boolean
    hunger?: boolean
    thirst?: boolean
    description?: boolean
    title?: boolean
    prompt?: boolean
    pageLength?: boolean
    playerFlags?: boolean
    effectFlags?: boolean
    privilegeFlags?: boolean
    olcZones?: boolean
    invisLevel?: boolean
    birthTime?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classId?: boolean
    experience?: boolean
    skillPoints?: boolean
  }

  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    effects?: boolean | Character$effectsArgs<ExtArgs>
    items?: boolean | Character$itemsArgs<ExtArgs>
    skills?: boolean | Character$skillsArgs<ExtArgs>
    spells?: boolean | Character$spellsArgs<ExtArgs>
    gameClass?: boolean | Character$gameClassArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      effects: Prisma.$CharacterEffectPayload<ExtArgs>[]
      items: Prisma.$CharacterItemPayload<ExtArgs>[]
      skills: Prisma.$CharacterSkillPayload<ExtArgs>[]
      spells: Prisma.$CharacterSpellPayload<ExtArgs>[]
      gameClass: Prisma.$GameClassPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      level: number
      alignment: number
      strength: number
      intelligence: number
      wisdom: number
      dexterity: number
      constitution: number
      charisma: number
      luck: number
      hitPoints: number
      movement: number
      hitPointsMax: number
      movementMax: number
      copper: number
      silver: number
      gold: number
      platinum: number
      bankCopper: number
      bankSilver: number
      bankGold: number
      bankPlatinum: number
      total_wealth: number
      average_stats: number
      passwordHash: string | null
      raceType: string
      race: $Enums.Race
      gender: string
      playerClass: string | null
      height: number | null
      weight: number | null
      baseSize: number
      currentSize: number
      hitRoll: number
      damageRoll: number
      armorClass: number
      currentRoom: number | null
      saveRoom: number | null
      homeRoom: number | null
      lastLogin: Date | null
      timePlayed: number
      isOnline: boolean
      hunger: number
      thirst: number
      description: string | null
      title: string | null
      prompt: string
      pageLength: number
      playerFlags: string[]
      effectFlags: string[]
      privilegeFlags: string[]
      olcZones: number[]
      invisLevel: number
      birthTime: Date
      userId: string
      createdAt: Date
      updatedAt: Date
      classId: number | null
      experience: number
      skillPoints: number
    }, ExtArgs["result"]["character"]>
    composites: {}
  }


  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterFindManyArgs, 'select' | 'include'> & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Character that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
    **/
    create<T extends CharacterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Characters.
     *     @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     *     @example
     *     // Create many Characters
     *     const character = await prisma.character.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
    **/
    delete<T extends CharacterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    effects<T extends Character$effectsArgs<ExtArgs> = {}>(args?: Subset<T, Character$effectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterEffectPayload<ExtArgs>, T, 'findMany'> | Null>;

    items<T extends Character$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Character$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    skills<T extends Character$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Character$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    spells<T extends Character$spellsArgs<ExtArgs> = {}>(args?: Subset<T, Character$spellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'findMany'> | Null>;

    gameClass<T extends Character$gameClassArgs<ExtArgs> = {}>(args?: Subset<T, Character$gameClassArgs<ExtArgs>>): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Character model
   */ 
  interface CharacterFieldRefs {
    readonly id: FieldRef<"Character", 'String'>
    readonly name: FieldRef<"Character", 'String'>
    readonly level: FieldRef<"Character", 'Int'>
    readonly alignment: FieldRef<"Character", 'Int'>
    readonly strength: FieldRef<"Character", 'Int'>
    readonly intelligence: FieldRef<"Character", 'Int'>
    readonly wisdom: FieldRef<"Character", 'Int'>
    readonly dexterity: FieldRef<"Character", 'Int'>
    readonly constitution: FieldRef<"Character", 'Int'>
    readonly charisma: FieldRef<"Character", 'Int'>
    readonly luck: FieldRef<"Character", 'Int'>
    readonly hitPoints: FieldRef<"Character", 'Int'>
    readonly movement: FieldRef<"Character", 'Int'>
    readonly hitPointsMax: FieldRef<"Character", 'Int'>
    readonly movementMax: FieldRef<"Character", 'Int'>
    readonly copper: FieldRef<"Character", 'Int'>
    readonly silver: FieldRef<"Character", 'Int'>
    readonly gold: FieldRef<"Character", 'Int'>
    readonly platinum: FieldRef<"Character", 'Int'>
    readonly bankCopper: FieldRef<"Character", 'Int'>
    readonly bankSilver: FieldRef<"Character", 'Int'>
    readonly bankGold: FieldRef<"Character", 'Int'>
    readonly bankPlatinum: FieldRef<"Character", 'Int'>
    readonly total_wealth: FieldRef<"Character", 'Int'>
    readonly average_stats: FieldRef<"Character", 'Int'>
    readonly passwordHash: FieldRef<"Character", 'String'>
    readonly raceType: FieldRef<"Character", 'String'>
    readonly race: FieldRef<"Character", 'Race'>
    readonly gender: FieldRef<"Character", 'String'>
    readonly playerClass: FieldRef<"Character", 'String'>
    readonly height: FieldRef<"Character", 'Int'>
    readonly weight: FieldRef<"Character", 'Int'>
    readonly baseSize: FieldRef<"Character", 'Int'>
    readonly currentSize: FieldRef<"Character", 'Int'>
    readonly hitRoll: FieldRef<"Character", 'Int'>
    readonly damageRoll: FieldRef<"Character", 'Int'>
    readonly armorClass: FieldRef<"Character", 'Int'>
    readonly currentRoom: FieldRef<"Character", 'Int'>
    readonly saveRoom: FieldRef<"Character", 'Int'>
    readonly homeRoom: FieldRef<"Character", 'Int'>
    readonly lastLogin: FieldRef<"Character", 'DateTime'>
    readonly timePlayed: FieldRef<"Character", 'Int'>
    readonly isOnline: FieldRef<"Character", 'Boolean'>
    readonly hunger: FieldRef<"Character", 'Int'>
    readonly thirst: FieldRef<"Character", 'Int'>
    readonly description: FieldRef<"Character", 'String'>
    readonly title: FieldRef<"Character", 'String'>
    readonly prompt: FieldRef<"Character", 'String'>
    readonly pageLength: FieldRef<"Character", 'Int'>
    readonly playerFlags: FieldRef<"Character", 'String[]'>
    readonly effectFlags: FieldRef<"Character", 'String[]'>
    readonly privilegeFlags: FieldRef<"Character", 'String[]'>
    readonly olcZones: FieldRef<"Character", 'Int[]'>
    readonly invisLevel: FieldRef<"Character", 'Int'>
    readonly birthTime: FieldRef<"Character", 'DateTime'>
    readonly userId: FieldRef<"Character", 'String'>
    readonly createdAt: FieldRef<"Character", 'DateTime'>
    readonly updatedAt: FieldRef<"Character", 'DateTime'>
    readonly classId: FieldRef<"Character", 'Int'>
    readonly experience: FieldRef<"Character", 'Int'>
    readonly skillPoints: FieldRef<"Character", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }


  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
  }


  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }


  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
  }


  /**
   * Character.effects
   */
  export type Character$effectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
    where?: CharacterEffectWhereInput
    orderBy?: CharacterEffectOrderByWithRelationInput | CharacterEffectOrderByWithRelationInput[]
    cursor?: CharacterEffectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterEffectScalarFieldEnum | CharacterEffectScalarFieldEnum[]
  }


  /**
   * Character.items
   */
  export type Character$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    where?: CharacterItemWhereInput
    orderBy?: CharacterItemOrderByWithRelationInput | CharacterItemOrderByWithRelationInput[]
    cursor?: CharacterItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterItemScalarFieldEnum | CharacterItemScalarFieldEnum[]
  }


  /**
   * Character.skills
   */
  export type Character$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    where?: CharacterSkillWhereInput
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    cursor?: CharacterSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }


  /**
   * Character.spells
   */
  export type Character$spellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    where?: CharacterSpellWhereInput
    orderBy?: CharacterSpellOrderByWithRelationInput | CharacterSpellOrderByWithRelationInput[]
    cursor?: CharacterSpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterSpellScalarFieldEnum | CharacterSpellScalarFieldEnum[]
  }


  /**
   * Character.gameClass
   */
  export type Character$gameClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    where?: GameClassWhereInput
  }


  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
  }



  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneAvgAggregateOutputType = {
    id: number | null
    lifespan: number | null
  }

  export type ZoneSumAggregateOutputType = {
    id: number | null
    lifespan: number | null
  }

  export type ZoneMinAggregateOutputType = {
    id: number | null
    name: string | null
    lifespan: number | null
    resetMode: $Enums.ResetMode | null
    hemisphere: $Enums.Hemisphere | null
    climate: $Enums.Climate | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: number | null
    name: string | null
    lifespan: number | null
    resetMode: $Enums.ResetMode | null
    hemisphere: $Enums.Hemisphere | null
    climate: $Enums.Climate | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    name: number
    lifespan: number
    resetMode: number
    hemisphere: number
    climate: number
    createdAt: number
    updatedAt: number
    deleted_at: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type ZoneAvgAggregateInputType = {
    id?: true
    lifespan?: true
  }

  export type ZoneSumAggregateInputType = {
    id?: true
    lifespan?: true
  }

  export type ZoneMinAggregateInputType = {
    id?: true
    name?: true
    lifespan?: true
    resetMode?: true
    hemisphere?: true
    climate?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    name?: true
    lifespan?: true
    resetMode?: true
    hemisphere?: true
    climate?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    name?: true
    lifespan?: true
    resetMode?: true
    hemisphere?: true
    climate?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _avg?: ZoneAvgAggregateInputType
    _sum?: ZoneSumAggregateInputType
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: number
    name: string
    lifespan: number
    resetMode: $Enums.ResetMode
    hemisphere: $Enums.Hemisphere
    climate: $Enums.Climate
    createdAt: Date
    updatedAt: Date
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lifespan?: boolean
    resetMode?: boolean
    hemisphere?: boolean
    climate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    mobResets?: boolean | Zone$mobResetsArgs<ExtArgs>
    mobs?: boolean | Zone$mobsArgs<ExtArgs>
    objectResets?: boolean | Zone$objectResetsArgs<ExtArgs>
    objects?: boolean | Zone$objectsArgs<ExtArgs>
    rooms?: boolean | Zone$roomsArgs<ExtArgs>
    shops?: boolean | Zone$shopsArgs<ExtArgs>
    triggers?: boolean | Zone$triggersArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    name?: boolean
    lifespan?: boolean
    resetMode?: boolean
    hemisphere?: boolean
    climate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mobResets?: boolean | Zone$mobResetsArgs<ExtArgs>
    mobs?: boolean | Zone$mobsArgs<ExtArgs>
    objectResets?: boolean | Zone$objectResetsArgs<ExtArgs>
    objects?: boolean | Zone$objectsArgs<ExtArgs>
    rooms?: boolean | Zone$roomsArgs<ExtArgs>
    shops?: boolean | Zone$shopsArgs<ExtArgs>
    triggers?: boolean | Zone$triggersArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      mobResets: Prisma.$MobResetPayload<ExtArgs>[]
      mobs: Prisma.$MobPayload<ExtArgs>[]
      objectResets: Prisma.$ObjectResetPayload<ExtArgs>[]
      objects: Prisma.$ObjectPayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      shops: Prisma.$ShopPayload<ExtArgs>[]
      triggers: Prisma.$TriggerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      lifespan: number
      resetMode: $Enums.ResetMode
      hemisphere: $Enums.Hemisphere
      climate: $Enums.Climate
      createdAt: Date
      updatedAt: Date
      deleted_at: Date | null
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }


  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ZoneFindManyArgs, 'select' | 'include'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ZoneFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>
    ): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Zone that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ZoneFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>
    ): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ZoneFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
    **/
    create<T extends ZoneCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>
    ): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Zones.
     *     @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     *     @example
     *     // Create many Zones
     *     const zone = await prisma.zone.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ZoneCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
    **/
    delete<T extends ZoneDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>
    ): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ZoneUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>
    ): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ZoneDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ZoneUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
    **/
    upsert<T extends ZoneUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>
    ): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mobResets<T extends Zone$mobResetsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$mobResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findMany'> | Null>;

    mobs<T extends Zone$mobsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$mobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findMany'> | Null>;

    objectResets<T extends Zone$objectResetsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$objectResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'findMany'> | Null>;

    objects<T extends Zone$objectsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$objectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    rooms<T extends Zone$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findMany'> | Null>;

    shops<T extends Zone$shopsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$shopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findMany'> | Null>;

    triggers<T extends Zone$triggersArgs<ExtArgs> = {}>(args?: Subset<T, Zone$triggersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Zone model
   */ 
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'Int'>
    readonly name: FieldRef<"Zone", 'String'>
    readonly lifespan: FieldRef<"Zone", 'Int'>
    readonly resetMode: FieldRef<"Zone", 'ResetMode'>
    readonly hemisphere: FieldRef<"Zone", 'Hemisphere'>
    readonly climate: FieldRef<"Zone", 'Climate'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
    readonly updatedAt: FieldRef<"Zone", 'DateTime'>
    readonly deleted_at: FieldRef<"Zone", 'DateTime'>
    readonly createdBy: FieldRef<"Zone", 'String'>
    readonly updatedBy: FieldRef<"Zone", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }


  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }


  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }


  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }


  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }


  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }


  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }


  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
  }


  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }


  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }


  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
  }


  /**
   * Zone.mobResets
   */
  export type Zone$mobResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    where?: MobResetWhereInput
    orderBy?: MobResetOrderByWithRelationInput | MobResetOrderByWithRelationInput[]
    cursor?: MobResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobResetScalarFieldEnum | MobResetScalarFieldEnum[]
  }


  /**
   * Zone.mobs
   */
  export type Zone$mobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    where?: MobWhereInput
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    cursor?: MobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobScalarFieldEnum | MobScalarFieldEnum[]
  }


  /**
   * Zone.objectResets
   */
  export type Zone$objectResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    where?: ObjectResetWhereInput
    orderBy?: ObjectResetOrderByWithRelationInput | ObjectResetOrderByWithRelationInput[]
    cursor?: ObjectResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectResetScalarFieldEnum | ObjectResetScalarFieldEnum[]
  }


  /**
   * Zone.objects
   */
  export type Zone$objectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }


  /**
   * Zone.rooms
   */
  export type Zone$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Zone.shops
   */
  export type Zone$shopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    cursor?: ShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }


  /**
   * Zone.triggers
   */
  export type Zone$triggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    where?: TriggerWhereInput
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    cursor?: TriggerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }


  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
  }



  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    id: number | null
    zoneId: number | null
    layoutX: number | null
    layoutY: number | null
    layoutZ: number | null
  }

  export type RoomSumAggregateOutputType = {
    id: number | null
    zoneId: number | null
    layoutX: number | null
    layoutY: number | null
    layoutZ: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    sector: $Enums.Sector | null
    zoneId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
    layoutX: number | null
    layoutY: number | null
    layoutZ: number | null
  }

  export type RoomMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    sector: $Enums.Sector | null
    zoneId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
    layoutX: number | null
    layoutY: number | null
    layoutZ: number | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    name: number
    description: number
    sector: number
    zoneId: number
    createdAt: number
    updatedAt: number
    deleted_at: number
    createdBy: number
    updatedBy: number
    flags: number
    layoutX: number
    layoutY: number
    layoutZ: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    id?: true
    zoneId?: true
    layoutX?: true
    layoutY?: true
    layoutZ?: true
  }

  export type RoomSumAggregateInputType = {
    id?: true
    zoneId?: true
    layoutX?: true
    layoutY?: true
    layoutZ?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sector?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
    layoutX?: true
    layoutY?: true
    layoutZ?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sector?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
    layoutX?: true
    layoutY?: true
    layoutZ?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sector?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
    flags?: true
    layoutX?: true
    layoutY?: true
    layoutZ?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: number
    name: string
    description: string
    sector: $Enums.Sector
    zoneId: number
    createdAt: Date
    updatedAt: Date
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
    flags: $Enums.RoomFlag[]
    layoutX: number | null
    layoutY: number | null
    layoutZ: number | null
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sector?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    flags?: boolean
    layoutX?: boolean
    layoutY?: boolean
    layoutZ?: boolean
    mobResets?: boolean | Room$mobResetsArgs<ExtArgs>
    objectResets?: boolean | Room$objectResetsArgs<ExtArgs>
    exits?: boolean | Room$exitsArgs<ExtArgs>
    extraDescs?: boolean | Room$extraDescsArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    sector?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    flags?: boolean
    layoutX?: boolean
    layoutY?: boolean
    layoutZ?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mobResets?: boolean | Room$mobResetsArgs<ExtArgs>
    objectResets?: boolean | Room$objectResetsArgs<ExtArgs>
    exits?: boolean | Room$exitsArgs<ExtArgs>
    extraDescs?: boolean | Room$extraDescsArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      mobResets: Prisma.$MobResetPayload<ExtArgs>[]
      objectResets: Prisma.$ObjectResetPayload<ExtArgs>[]
      exits: Prisma.$RoomExitPayload<ExtArgs>[]
      extraDescs: Prisma.$RoomExtraDescriptionPayload<ExtArgs>[]
      zone: Prisma.$ZonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      sector: $Enums.Sector
      zoneId: number
      createdAt: Date
      updatedAt: Date
      deleted_at: Date | null
      createdBy: string | null
      updatedBy: string | null
      flags: $Enums.RoomFlag[]
      layoutX: number | null
      layoutY: number | null
      layoutZ: number | null
    }, ExtArgs["result"]["room"]>
    composites: {}
  }


  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
    **/
    create<T extends RoomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomCreateArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rooms.
     *     @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     *     @example
     *     // Create many Rooms
     *     const room = await prisma.room.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
    **/
    delete<T extends RoomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
    **/
    upsert<T extends RoomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mobResets<T extends Room$mobResetsArgs<ExtArgs> = {}>(args?: Subset<T, Room$mobResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findMany'> | Null>;

    objectResets<T extends Room$objectResetsArgs<ExtArgs> = {}>(args?: Subset<T, Room$objectResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'findMany'> | Null>;

    exits<T extends Room$exitsArgs<ExtArgs> = {}>(args?: Subset<T, Room$exitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomExitPayload<ExtArgs>, T, 'findMany'> | Null>;

    extraDescs<T extends Room$extraDescsArgs<ExtArgs> = {}>(args?: Subset<T, Room$extraDescsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomExtraDescriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'Int'>
    readonly name: FieldRef<"Room", 'String'>
    readonly description: FieldRef<"Room", 'String'>
    readonly sector: FieldRef<"Room", 'Sector'>
    readonly zoneId: FieldRef<"Room", 'Int'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
    readonly deleted_at: FieldRef<"Room", 'DateTime'>
    readonly createdBy: FieldRef<"Room", 'String'>
    readonly updatedBy: FieldRef<"Room", 'String'>
    readonly flags: FieldRef<"Room", 'RoomFlag[]'>
    readonly layoutX: FieldRef<"Room", 'Int'>
    readonly layoutY: FieldRef<"Room", 'Int'>
    readonly layoutZ: FieldRef<"Room", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }


  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }


  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }


  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }


  /**
   * Room.mobResets
   */
  export type Room$mobResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    where?: MobResetWhereInput
    orderBy?: MobResetOrderByWithRelationInput | MobResetOrderByWithRelationInput[]
    cursor?: MobResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobResetScalarFieldEnum | MobResetScalarFieldEnum[]
  }


  /**
   * Room.objectResets
   */
  export type Room$objectResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    where?: ObjectResetWhereInput
    orderBy?: ObjectResetOrderByWithRelationInput | ObjectResetOrderByWithRelationInput[]
    cursor?: ObjectResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectResetScalarFieldEnum | ObjectResetScalarFieldEnum[]
  }


  /**
   * Room.exits
   */
  export type Room$exitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
    where?: RoomExitWhereInput
    orderBy?: RoomExitOrderByWithRelationInput | RoomExitOrderByWithRelationInput[]
    cursor?: RoomExitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomExitScalarFieldEnum | RoomExitScalarFieldEnum[]
  }


  /**
   * Room.extraDescs
   */
  export type Room$extraDescsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
    where?: RoomExtraDescriptionWhereInput
    orderBy?: RoomExtraDescriptionOrderByWithRelationInput | RoomExtraDescriptionOrderByWithRelationInput[]
    cursor?: RoomExtraDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomExtraDescriptionScalarFieldEnum | RoomExtraDescriptionScalarFieldEnum[]
  }


  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
  }



  /**
   * Model RoomExit
   */

  export type AggregateRoomExit = {
    _count: RoomExitCountAggregateOutputType | null
    _avg: RoomExitAvgAggregateOutputType | null
    _sum: RoomExitSumAggregateOutputType | null
    _min: RoomExitMinAggregateOutputType | null
    _max: RoomExitMaxAggregateOutputType | null
  }

  export type RoomExitAvgAggregateOutputType = {
    destination: number | null
    roomZoneId: number | null
    roomId: number | null
  }

  export type RoomExitSumAggregateOutputType = {
    destination: number | null
    roomZoneId: number | null
    roomId: number | null
  }

  export type RoomExitMinAggregateOutputType = {
    id: string | null
    direction: $Enums.Direction | null
    description: string | null
    keyword: string | null
    key: string | null
    destination: number | null
    roomZoneId: number | null
    roomId: number | null
  }

  export type RoomExitMaxAggregateOutputType = {
    id: string | null
    direction: $Enums.Direction | null
    description: string | null
    keyword: string | null
    key: string | null
    destination: number | null
    roomZoneId: number | null
    roomId: number | null
  }

  export type RoomExitCountAggregateOutputType = {
    id: number
    direction: number
    description: number
    keyword: number
    key: number
    destination: number
    roomZoneId: number
    roomId: number
    flags: number
    _all: number
  }


  export type RoomExitAvgAggregateInputType = {
    destination?: true
    roomZoneId?: true
    roomId?: true
  }

  export type RoomExitSumAggregateInputType = {
    destination?: true
    roomZoneId?: true
    roomId?: true
  }

  export type RoomExitMinAggregateInputType = {
    id?: true
    direction?: true
    description?: true
    keyword?: true
    key?: true
    destination?: true
    roomZoneId?: true
    roomId?: true
  }

  export type RoomExitMaxAggregateInputType = {
    id?: true
    direction?: true
    description?: true
    keyword?: true
    key?: true
    destination?: true
    roomZoneId?: true
    roomId?: true
  }

  export type RoomExitCountAggregateInputType = {
    id?: true
    direction?: true
    description?: true
    keyword?: true
    key?: true
    destination?: true
    roomZoneId?: true
    roomId?: true
    flags?: true
    _all?: true
  }

  export type RoomExitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomExit to aggregate.
     */
    where?: RoomExitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomExits to fetch.
     */
    orderBy?: RoomExitOrderByWithRelationInput | RoomExitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomExitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomExits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomExits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomExits
    **/
    _count?: true | RoomExitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomExitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomExitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomExitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomExitMaxAggregateInputType
  }

  export type GetRoomExitAggregateType<T extends RoomExitAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomExit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomExit[P]>
      : GetScalarType<T[P], AggregateRoomExit[P]>
  }




  export type RoomExitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomExitWhereInput
    orderBy?: RoomExitOrderByWithAggregationInput | RoomExitOrderByWithAggregationInput[]
    by: RoomExitScalarFieldEnum[] | RoomExitScalarFieldEnum
    having?: RoomExitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomExitCountAggregateInputType | true
    _avg?: RoomExitAvgAggregateInputType
    _sum?: RoomExitSumAggregateInputType
    _min?: RoomExitMinAggregateInputType
    _max?: RoomExitMaxAggregateInputType
  }

  export type RoomExitGroupByOutputType = {
    id: string
    direction: $Enums.Direction
    description: string | null
    keyword: string | null
    key: string | null
    destination: number | null
    roomZoneId: number
    roomId: number
    flags: $Enums.ExitFlag[]
    _count: RoomExitCountAggregateOutputType | null
    _avg: RoomExitAvgAggregateOutputType | null
    _sum: RoomExitSumAggregateOutputType | null
    _min: RoomExitMinAggregateOutputType | null
    _max: RoomExitMaxAggregateOutputType | null
  }

  type GetRoomExitGroupByPayload<T extends RoomExitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomExitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomExitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomExitGroupByOutputType[P]>
            : GetScalarType<T[P], RoomExitGroupByOutputType[P]>
        }
      >
    >


  export type RoomExitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    direction?: boolean
    description?: boolean
    keyword?: boolean
    key?: boolean
    destination?: boolean
    roomZoneId?: boolean
    roomId?: boolean
    flags?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomExit"]>

  export type RoomExitSelectScalar = {
    id?: boolean
    direction?: boolean
    description?: boolean
    keyword?: boolean
    key?: boolean
    destination?: boolean
    roomZoneId?: boolean
    roomId?: boolean
    flags?: boolean
  }

  export type RoomExitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }


  export type $RoomExitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomExit"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      direction: $Enums.Direction
      description: string | null
      keyword: string | null
      key: string | null
      destination: number | null
      roomZoneId: number
      roomId: number
      flags: $Enums.ExitFlag[]
    }, ExtArgs["result"]["roomExit"]>
    composites: {}
  }


  type RoomExitGetPayload<S extends boolean | null | undefined | RoomExitDefaultArgs> = $Result.GetResult<Prisma.$RoomExitPayload, S>

  type RoomExitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomExitFindManyArgs, 'select' | 'include'> & {
      select?: RoomExitCountAggregateInputType | true
    }

  export interface RoomExitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomExit'], meta: { name: 'RoomExit' } }
    /**
     * Find zero or one RoomExit that matches the filter.
     * @param {RoomExitFindUniqueArgs} args - Arguments to find a RoomExit
     * @example
     * // Get one RoomExit
     * const roomExit = await prisma.roomExit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomExitFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExitFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomExitClient<$Result.GetResult<Prisma.$RoomExitPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomExit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomExitFindUniqueOrThrowArgs} args - Arguments to find a RoomExit
     * @example
     * // Get one RoomExit
     * const roomExit = await prisma.roomExit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomExitFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExitFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomExitClient<$Result.GetResult<Prisma.$RoomExitPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomExit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExitFindFirstArgs} args - Arguments to find a RoomExit
     * @example
     * // Get one RoomExit
     * const roomExit = await prisma.roomExit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomExitFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExitFindFirstArgs<ExtArgs>>
    ): Prisma__RoomExitClient<$Result.GetResult<Prisma.$RoomExitPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomExit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExitFindFirstOrThrowArgs} args - Arguments to find a RoomExit
     * @example
     * // Get one RoomExit
     * const roomExit = await prisma.roomExit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomExitFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExitFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomExitClient<$Result.GetResult<Prisma.$RoomExitPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomExits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomExits
     * const roomExits = await prisma.roomExit.findMany()
     * 
     * // Get first 10 RoomExits
     * const roomExits = await prisma.roomExit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomExitWithIdOnly = await prisma.roomExit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomExitFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExitFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomExitPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomExit.
     * @param {RoomExitCreateArgs} args - Arguments to create a RoomExit.
     * @example
     * // Create one RoomExit
     * const RoomExit = await prisma.roomExit.create({
     *   data: {
     *     // ... data to create a RoomExit
     *   }
     * })
     * 
    **/
    create<T extends RoomExitCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExitCreateArgs<ExtArgs>>
    ): Prisma__RoomExitClient<$Result.GetResult<Prisma.$RoomExitPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomExits.
     *     @param {RoomExitCreateManyArgs} args - Arguments to create many RoomExits.
     *     @example
     *     // Create many RoomExits
     *     const roomExit = await prisma.roomExit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomExitCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExitCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomExit.
     * @param {RoomExitDeleteArgs} args - Arguments to delete one RoomExit.
     * @example
     * // Delete one RoomExit
     * const RoomExit = await prisma.roomExit.delete({
     *   where: {
     *     // ... filter to delete one RoomExit
     *   }
     * })
     * 
    **/
    delete<T extends RoomExitDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExitDeleteArgs<ExtArgs>>
    ): Prisma__RoomExitClient<$Result.GetResult<Prisma.$RoomExitPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomExit.
     * @param {RoomExitUpdateArgs} args - Arguments to update one RoomExit.
     * @example
     * // Update one RoomExit
     * const roomExit = await prisma.roomExit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomExitUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExitUpdateArgs<ExtArgs>>
    ): Prisma__RoomExitClient<$Result.GetResult<Prisma.$RoomExitPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomExits.
     * @param {RoomExitDeleteManyArgs} args - Arguments to filter RoomExits to delete.
     * @example
     * // Delete a few RoomExits
     * const { count } = await prisma.roomExit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomExitDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExitDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomExits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomExits
     * const roomExit = await prisma.roomExit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomExitUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExitUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomExit.
     * @param {RoomExitUpsertArgs} args - Arguments to update or create a RoomExit.
     * @example
     * // Update or create a RoomExit
     * const roomExit = await prisma.roomExit.upsert({
     *   create: {
     *     // ... data to create a RoomExit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomExit we want to update
     *   }
     * })
    **/
    upsert<T extends RoomExitUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExitUpsertArgs<ExtArgs>>
    ): Prisma__RoomExitClient<$Result.GetResult<Prisma.$RoomExitPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomExits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExitCountArgs} args - Arguments to filter RoomExits to count.
     * @example
     * // Count the number of RoomExits
     * const count = await prisma.roomExit.count({
     *   where: {
     *     // ... the filter for the RoomExits we want to count
     *   }
     * })
    **/
    count<T extends RoomExitCountArgs>(
      args?: Subset<T, RoomExitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomExitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomExit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomExitAggregateArgs>(args: Subset<T, RoomExitAggregateArgs>): Prisma.PrismaPromise<GetRoomExitAggregateType<T>>

    /**
     * Group by RoomExit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomExitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomExitGroupByArgs['orderBy'] }
        : { orderBy?: RoomExitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomExitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomExitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomExit model
   */
  readonly fields: RoomExitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomExit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomExitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoomExit model
   */ 
  interface RoomExitFieldRefs {
    readonly id: FieldRef<"RoomExit", 'String'>
    readonly direction: FieldRef<"RoomExit", 'Direction'>
    readonly description: FieldRef<"RoomExit", 'String'>
    readonly keyword: FieldRef<"RoomExit", 'String'>
    readonly key: FieldRef<"RoomExit", 'String'>
    readonly destination: FieldRef<"RoomExit", 'Int'>
    readonly roomZoneId: FieldRef<"RoomExit", 'Int'>
    readonly roomId: FieldRef<"RoomExit", 'Int'>
    readonly flags: FieldRef<"RoomExit", 'ExitFlag[]'>
  }
    

  // Custom InputTypes

  /**
   * RoomExit findUnique
   */
  export type RoomExitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
    /**
     * Filter, which RoomExit to fetch.
     */
    where: RoomExitWhereUniqueInput
  }


  /**
   * RoomExit findUniqueOrThrow
   */
  export type RoomExitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
    /**
     * Filter, which RoomExit to fetch.
     */
    where: RoomExitWhereUniqueInput
  }


  /**
   * RoomExit findFirst
   */
  export type RoomExitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
    /**
     * Filter, which RoomExit to fetch.
     */
    where?: RoomExitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomExits to fetch.
     */
    orderBy?: RoomExitOrderByWithRelationInput | RoomExitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomExits.
     */
    cursor?: RoomExitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomExits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomExits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomExits.
     */
    distinct?: RoomExitScalarFieldEnum | RoomExitScalarFieldEnum[]
  }


  /**
   * RoomExit findFirstOrThrow
   */
  export type RoomExitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
    /**
     * Filter, which RoomExit to fetch.
     */
    where?: RoomExitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomExits to fetch.
     */
    orderBy?: RoomExitOrderByWithRelationInput | RoomExitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomExits.
     */
    cursor?: RoomExitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomExits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomExits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomExits.
     */
    distinct?: RoomExitScalarFieldEnum | RoomExitScalarFieldEnum[]
  }


  /**
   * RoomExit findMany
   */
  export type RoomExitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
    /**
     * Filter, which RoomExits to fetch.
     */
    where?: RoomExitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomExits to fetch.
     */
    orderBy?: RoomExitOrderByWithRelationInput | RoomExitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomExits.
     */
    cursor?: RoomExitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomExits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomExits.
     */
    skip?: number
    distinct?: RoomExitScalarFieldEnum | RoomExitScalarFieldEnum[]
  }


  /**
   * RoomExit create
   */
  export type RoomExitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomExit.
     */
    data: XOR<RoomExitCreateInput, RoomExitUncheckedCreateInput>
  }


  /**
   * RoomExit createMany
   */
  export type RoomExitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomExits.
     */
    data: RoomExitCreateManyInput | RoomExitCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoomExit update
   */
  export type RoomExitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomExit.
     */
    data: XOR<RoomExitUpdateInput, RoomExitUncheckedUpdateInput>
    /**
     * Choose, which RoomExit to update.
     */
    where: RoomExitWhereUniqueInput
  }


  /**
   * RoomExit updateMany
   */
  export type RoomExitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomExits.
     */
    data: XOR<RoomExitUpdateManyMutationInput, RoomExitUncheckedUpdateManyInput>
    /**
     * Filter which RoomExits to update
     */
    where?: RoomExitWhereInput
  }


  /**
   * RoomExit upsert
   */
  export type RoomExitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomExit to update in case it exists.
     */
    where: RoomExitWhereUniqueInput
    /**
     * In case the RoomExit found by the `where` argument doesn't exist, create a new RoomExit with this data.
     */
    create: XOR<RoomExitCreateInput, RoomExitUncheckedCreateInput>
    /**
     * In case the RoomExit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomExitUpdateInput, RoomExitUncheckedUpdateInput>
  }


  /**
   * RoomExit delete
   */
  export type RoomExitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
    /**
     * Filter which RoomExit to delete.
     */
    where: RoomExitWhereUniqueInput
  }


  /**
   * RoomExit deleteMany
   */
  export type RoomExitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomExits to delete
     */
    where?: RoomExitWhereInput
  }


  /**
   * RoomExit without action
   */
  export type RoomExitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExit
     */
    select?: RoomExitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExitInclude<ExtArgs> | null
  }



  /**
   * Model RoomExtraDescription
   */

  export type AggregateRoomExtraDescription = {
    _count: RoomExtraDescriptionCountAggregateOutputType | null
    _avg: RoomExtraDescriptionAvgAggregateOutputType | null
    _sum: RoomExtraDescriptionSumAggregateOutputType | null
    _min: RoomExtraDescriptionMinAggregateOutputType | null
    _max: RoomExtraDescriptionMaxAggregateOutputType | null
  }

  export type RoomExtraDescriptionAvgAggregateOutputType = {
    roomZoneId: number | null
    roomId: number | null
  }

  export type RoomExtraDescriptionSumAggregateOutputType = {
    roomZoneId: number | null
    roomId: number | null
  }

  export type RoomExtraDescriptionMinAggregateOutputType = {
    id: string | null
    keyword: string | null
    description: string | null
    roomZoneId: number | null
    roomId: number | null
  }

  export type RoomExtraDescriptionMaxAggregateOutputType = {
    id: string | null
    keyword: string | null
    description: string | null
    roomZoneId: number | null
    roomId: number | null
  }

  export type RoomExtraDescriptionCountAggregateOutputType = {
    id: number
    keyword: number
    description: number
    roomZoneId: number
    roomId: number
    _all: number
  }


  export type RoomExtraDescriptionAvgAggregateInputType = {
    roomZoneId?: true
    roomId?: true
  }

  export type RoomExtraDescriptionSumAggregateInputType = {
    roomZoneId?: true
    roomId?: true
  }

  export type RoomExtraDescriptionMinAggregateInputType = {
    id?: true
    keyword?: true
    description?: true
    roomZoneId?: true
    roomId?: true
  }

  export type RoomExtraDescriptionMaxAggregateInputType = {
    id?: true
    keyword?: true
    description?: true
    roomZoneId?: true
    roomId?: true
  }

  export type RoomExtraDescriptionCountAggregateInputType = {
    id?: true
    keyword?: true
    description?: true
    roomZoneId?: true
    roomId?: true
    _all?: true
  }

  export type RoomExtraDescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomExtraDescription to aggregate.
     */
    where?: RoomExtraDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomExtraDescriptions to fetch.
     */
    orderBy?: RoomExtraDescriptionOrderByWithRelationInput | RoomExtraDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomExtraDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomExtraDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomExtraDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomExtraDescriptions
    **/
    _count?: true | RoomExtraDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomExtraDescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomExtraDescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomExtraDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomExtraDescriptionMaxAggregateInputType
  }

  export type GetRoomExtraDescriptionAggregateType<T extends RoomExtraDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomExtraDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomExtraDescription[P]>
      : GetScalarType<T[P], AggregateRoomExtraDescription[P]>
  }




  export type RoomExtraDescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomExtraDescriptionWhereInput
    orderBy?: RoomExtraDescriptionOrderByWithAggregationInput | RoomExtraDescriptionOrderByWithAggregationInput[]
    by: RoomExtraDescriptionScalarFieldEnum[] | RoomExtraDescriptionScalarFieldEnum
    having?: RoomExtraDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomExtraDescriptionCountAggregateInputType | true
    _avg?: RoomExtraDescriptionAvgAggregateInputType
    _sum?: RoomExtraDescriptionSumAggregateInputType
    _min?: RoomExtraDescriptionMinAggregateInputType
    _max?: RoomExtraDescriptionMaxAggregateInputType
  }

  export type RoomExtraDescriptionGroupByOutputType = {
    id: string
    keyword: string
    description: string
    roomZoneId: number
    roomId: number
    _count: RoomExtraDescriptionCountAggregateOutputType | null
    _avg: RoomExtraDescriptionAvgAggregateOutputType | null
    _sum: RoomExtraDescriptionSumAggregateOutputType | null
    _min: RoomExtraDescriptionMinAggregateOutputType | null
    _max: RoomExtraDescriptionMaxAggregateOutputType | null
  }

  type GetRoomExtraDescriptionGroupByPayload<T extends RoomExtraDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomExtraDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomExtraDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomExtraDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], RoomExtraDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type RoomExtraDescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    description?: boolean
    roomZoneId?: boolean
    roomId?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomExtraDescription"]>

  export type RoomExtraDescriptionSelectScalar = {
    id?: boolean
    keyword?: boolean
    description?: boolean
    roomZoneId?: boolean
    roomId?: boolean
  }

  export type RoomExtraDescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }


  export type $RoomExtraDescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomExtraDescription"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keyword: string
      description: string
      roomZoneId: number
      roomId: number
    }, ExtArgs["result"]["roomExtraDescription"]>
    composites: {}
  }


  type RoomExtraDescriptionGetPayload<S extends boolean | null | undefined | RoomExtraDescriptionDefaultArgs> = $Result.GetResult<Prisma.$RoomExtraDescriptionPayload, S>

  type RoomExtraDescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomExtraDescriptionFindManyArgs, 'select' | 'include'> & {
      select?: RoomExtraDescriptionCountAggregateInputType | true
    }

  export interface RoomExtraDescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomExtraDescription'], meta: { name: 'RoomExtraDescription' } }
    /**
     * Find zero or one RoomExtraDescription that matches the filter.
     * @param {RoomExtraDescriptionFindUniqueArgs} args - Arguments to find a RoomExtraDescription
     * @example
     * // Get one RoomExtraDescription
     * const roomExtraDescription = await prisma.roomExtraDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomExtraDescriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExtraDescriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomExtraDescriptionClient<$Result.GetResult<Prisma.$RoomExtraDescriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomExtraDescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomExtraDescriptionFindUniqueOrThrowArgs} args - Arguments to find a RoomExtraDescription
     * @example
     * // Get one RoomExtraDescription
     * const roomExtraDescription = await prisma.roomExtraDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomExtraDescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExtraDescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomExtraDescriptionClient<$Result.GetResult<Prisma.$RoomExtraDescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomExtraDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExtraDescriptionFindFirstArgs} args - Arguments to find a RoomExtraDescription
     * @example
     * // Get one RoomExtraDescription
     * const roomExtraDescription = await prisma.roomExtraDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomExtraDescriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExtraDescriptionFindFirstArgs<ExtArgs>>
    ): Prisma__RoomExtraDescriptionClient<$Result.GetResult<Prisma.$RoomExtraDescriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomExtraDescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExtraDescriptionFindFirstOrThrowArgs} args - Arguments to find a RoomExtraDescription
     * @example
     * // Get one RoomExtraDescription
     * const roomExtraDescription = await prisma.roomExtraDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomExtraDescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExtraDescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomExtraDescriptionClient<$Result.GetResult<Prisma.$RoomExtraDescriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomExtraDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExtraDescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomExtraDescriptions
     * const roomExtraDescriptions = await prisma.roomExtraDescription.findMany()
     * 
     * // Get first 10 RoomExtraDescriptions
     * const roomExtraDescriptions = await prisma.roomExtraDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomExtraDescriptionWithIdOnly = await prisma.roomExtraDescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomExtraDescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExtraDescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomExtraDescriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomExtraDescription.
     * @param {RoomExtraDescriptionCreateArgs} args - Arguments to create a RoomExtraDescription.
     * @example
     * // Create one RoomExtraDescription
     * const RoomExtraDescription = await prisma.roomExtraDescription.create({
     *   data: {
     *     // ... data to create a RoomExtraDescription
     *   }
     * })
     * 
    **/
    create<T extends RoomExtraDescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExtraDescriptionCreateArgs<ExtArgs>>
    ): Prisma__RoomExtraDescriptionClient<$Result.GetResult<Prisma.$RoomExtraDescriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomExtraDescriptions.
     *     @param {RoomExtraDescriptionCreateManyArgs} args - Arguments to create many RoomExtraDescriptions.
     *     @example
     *     // Create many RoomExtraDescriptions
     *     const roomExtraDescription = await prisma.roomExtraDescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomExtraDescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExtraDescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomExtraDescription.
     * @param {RoomExtraDescriptionDeleteArgs} args - Arguments to delete one RoomExtraDescription.
     * @example
     * // Delete one RoomExtraDescription
     * const RoomExtraDescription = await prisma.roomExtraDescription.delete({
     *   where: {
     *     // ... filter to delete one RoomExtraDescription
     *   }
     * })
     * 
    **/
    delete<T extends RoomExtraDescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExtraDescriptionDeleteArgs<ExtArgs>>
    ): Prisma__RoomExtraDescriptionClient<$Result.GetResult<Prisma.$RoomExtraDescriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomExtraDescription.
     * @param {RoomExtraDescriptionUpdateArgs} args - Arguments to update one RoomExtraDescription.
     * @example
     * // Update one RoomExtraDescription
     * const roomExtraDescription = await prisma.roomExtraDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomExtraDescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExtraDescriptionUpdateArgs<ExtArgs>>
    ): Prisma__RoomExtraDescriptionClient<$Result.GetResult<Prisma.$RoomExtraDescriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomExtraDescriptions.
     * @param {RoomExtraDescriptionDeleteManyArgs} args - Arguments to filter RoomExtraDescriptions to delete.
     * @example
     * // Delete a few RoomExtraDescriptions
     * const { count } = await prisma.roomExtraDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomExtraDescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomExtraDescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomExtraDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExtraDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomExtraDescriptions
     * const roomExtraDescription = await prisma.roomExtraDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomExtraDescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExtraDescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomExtraDescription.
     * @param {RoomExtraDescriptionUpsertArgs} args - Arguments to update or create a RoomExtraDescription.
     * @example
     * // Update or create a RoomExtraDescription
     * const roomExtraDescription = await prisma.roomExtraDescription.upsert({
     *   create: {
     *     // ... data to create a RoomExtraDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomExtraDescription we want to update
     *   }
     * })
    **/
    upsert<T extends RoomExtraDescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomExtraDescriptionUpsertArgs<ExtArgs>>
    ): Prisma__RoomExtraDescriptionClient<$Result.GetResult<Prisma.$RoomExtraDescriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomExtraDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExtraDescriptionCountArgs} args - Arguments to filter RoomExtraDescriptions to count.
     * @example
     * // Count the number of RoomExtraDescriptions
     * const count = await prisma.roomExtraDescription.count({
     *   where: {
     *     // ... the filter for the RoomExtraDescriptions we want to count
     *   }
     * })
    **/
    count<T extends RoomExtraDescriptionCountArgs>(
      args?: Subset<T, RoomExtraDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomExtraDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomExtraDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExtraDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomExtraDescriptionAggregateArgs>(args: Subset<T, RoomExtraDescriptionAggregateArgs>): Prisma.PrismaPromise<GetRoomExtraDescriptionAggregateType<T>>

    /**
     * Group by RoomExtraDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomExtraDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomExtraDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomExtraDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: RoomExtraDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomExtraDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomExtraDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomExtraDescription model
   */
  readonly fields: RoomExtraDescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomExtraDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomExtraDescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoomExtraDescription model
   */ 
  interface RoomExtraDescriptionFieldRefs {
    readonly id: FieldRef<"RoomExtraDescription", 'String'>
    readonly keyword: FieldRef<"RoomExtraDescription", 'String'>
    readonly description: FieldRef<"RoomExtraDescription", 'String'>
    readonly roomZoneId: FieldRef<"RoomExtraDescription", 'Int'>
    readonly roomId: FieldRef<"RoomExtraDescription", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RoomExtraDescription findUnique
   */
  export type RoomExtraDescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which RoomExtraDescription to fetch.
     */
    where: RoomExtraDescriptionWhereUniqueInput
  }


  /**
   * RoomExtraDescription findUniqueOrThrow
   */
  export type RoomExtraDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which RoomExtraDescription to fetch.
     */
    where: RoomExtraDescriptionWhereUniqueInput
  }


  /**
   * RoomExtraDescription findFirst
   */
  export type RoomExtraDescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which RoomExtraDescription to fetch.
     */
    where?: RoomExtraDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomExtraDescriptions to fetch.
     */
    orderBy?: RoomExtraDescriptionOrderByWithRelationInput | RoomExtraDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomExtraDescriptions.
     */
    cursor?: RoomExtraDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomExtraDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomExtraDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomExtraDescriptions.
     */
    distinct?: RoomExtraDescriptionScalarFieldEnum | RoomExtraDescriptionScalarFieldEnum[]
  }


  /**
   * RoomExtraDescription findFirstOrThrow
   */
  export type RoomExtraDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which RoomExtraDescription to fetch.
     */
    where?: RoomExtraDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomExtraDescriptions to fetch.
     */
    orderBy?: RoomExtraDescriptionOrderByWithRelationInput | RoomExtraDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomExtraDescriptions.
     */
    cursor?: RoomExtraDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomExtraDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomExtraDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomExtraDescriptions.
     */
    distinct?: RoomExtraDescriptionScalarFieldEnum | RoomExtraDescriptionScalarFieldEnum[]
  }


  /**
   * RoomExtraDescription findMany
   */
  export type RoomExtraDescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which RoomExtraDescriptions to fetch.
     */
    where?: RoomExtraDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomExtraDescriptions to fetch.
     */
    orderBy?: RoomExtraDescriptionOrderByWithRelationInput | RoomExtraDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomExtraDescriptions.
     */
    cursor?: RoomExtraDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomExtraDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomExtraDescriptions.
     */
    skip?: number
    distinct?: RoomExtraDescriptionScalarFieldEnum | RoomExtraDescriptionScalarFieldEnum[]
  }


  /**
   * RoomExtraDescription create
   */
  export type RoomExtraDescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomExtraDescription.
     */
    data: XOR<RoomExtraDescriptionCreateInput, RoomExtraDescriptionUncheckedCreateInput>
  }


  /**
   * RoomExtraDescription createMany
   */
  export type RoomExtraDescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomExtraDescriptions.
     */
    data: RoomExtraDescriptionCreateManyInput | RoomExtraDescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoomExtraDescription update
   */
  export type RoomExtraDescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomExtraDescription.
     */
    data: XOR<RoomExtraDescriptionUpdateInput, RoomExtraDescriptionUncheckedUpdateInput>
    /**
     * Choose, which RoomExtraDescription to update.
     */
    where: RoomExtraDescriptionWhereUniqueInput
  }


  /**
   * RoomExtraDescription updateMany
   */
  export type RoomExtraDescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomExtraDescriptions.
     */
    data: XOR<RoomExtraDescriptionUpdateManyMutationInput, RoomExtraDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which RoomExtraDescriptions to update
     */
    where?: RoomExtraDescriptionWhereInput
  }


  /**
   * RoomExtraDescription upsert
   */
  export type RoomExtraDescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomExtraDescription to update in case it exists.
     */
    where: RoomExtraDescriptionWhereUniqueInput
    /**
     * In case the RoomExtraDescription found by the `where` argument doesn't exist, create a new RoomExtraDescription with this data.
     */
    create: XOR<RoomExtraDescriptionCreateInput, RoomExtraDescriptionUncheckedCreateInput>
    /**
     * In case the RoomExtraDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomExtraDescriptionUpdateInput, RoomExtraDescriptionUncheckedUpdateInput>
  }


  /**
   * RoomExtraDescription delete
   */
  export type RoomExtraDescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter which RoomExtraDescription to delete.
     */
    where: RoomExtraDescriptionWhereUniqueInput
  }


  /**
   * RoomExtraDescription deleteMany
   */
  export type RoomExtraDescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomExtraDescriptions to delete
     */
    where?: RoomExtraDescriptionWhereInput
  }


  /**
   * RoomExtraDescription without action
   */
  export type RoomExtraDescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomExtraDescription
     */
    select?: RoomExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomExtraDescriptionInclude<ExtArgs> | null
  }



  /**
   * Model Mob
   */

  export type AggregateMob = {
    _count: MobCountAggregateOutputType | null
    _avg: MobAvgAggregateOutputType | null
    _sum: MobSumAggregateOutputType | null
    _min: MobMinAggregateOutputType | null
    _max: MobMaxAggregateOutputType | null
  }

  export type MobAvgAggregateOutputType = {
    id: number | null
    alignment: number | null
    level: number | null
    armorClass: number | null
    hitRoll: number | null
    move: number | null
    hpDiceNum: number | null
    hpDiceSize: number | null
    hpDiceBonus: number | null
    damageDiceNum: number | null
    damageDiceSize: number | null
    damageDiceBonus: number | null
    copper: number | null
    silver: number | null
    gold: number | null
    platinum: number | null
    raceAlign: number | null
    total_wealth: number | null
    average_stats: number | null
    estimated_hp: number | null
    strength: number | null
    intelligence: number | null
    wisdom: number | null
    dexterity: number | null
    constitution: number | null
    charisma: number | null
    perception: number | null
    concealment: number | null
    zoneId: number | null
    classId: number | null
  }

  export type MobSumAggregateOutputType = {
    id: number | null
    alignment: number | null
    level: number | null
    armorClass: number | null
    hitRoll: number | null
    move: number | null
    hpDiceNum: number | null
    hpDiceSize: number | null
    hpDiceBonus: number | null
    damageDiceNum: number | null
    damageDiceSize: number | null
    damageDiceBonus: number | null
    copper: number | null
    silver: number | null
    gold: number | null
    platinum: number | null
    raceAlign: number | null
    total_wealth: number | null
    average_stats: number | null
    estimated_hp: number | null
    strength: number | null
    intelligence: number | null
    wisdom: number | null
    dexterity: number | null
    constitution: number | null
    charisma: number | null
    perception: number | null
    concealment: number | null
    zoneId: number | null
    classId: number | null
  }

  export type MobMinAggregateOutputType = {
    id: number | null
    mobClass: string | null
    shortDesc: string | null
    longDesc: string | null
    desc: string | null
    alignment: number | null
    level: number | null
    armorClass: number | null
    hitRoll: number | null
    move: number | null
    hpDiceNum: number | null
    hpDiceSize: number | null
    hpDiceBonus: number | null
    damageDiceNum: number | null
    damageDiceSize: number | null
    damageDiceBonus: number | null
    copper: number | null
    silver: number | null
    gold: number | null
    platinum: number | null
    raceAlign: number | null
    total_wealth: number | null
    average_stats: number | null
    estimated_hp: number | null
    strength: number | null
    intelligence: number | null
    wisdom: number | null
    dexterity: number | null
    constitution: number | null
    charisma: number | null
    perception: number | null
    concealment: number | null
    zoneId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
    classId: number | null
    race: $Enums.Race | null
    position: $Enums.Position | null
    defaultPosition: $Enums.Position | null
    gender: $Enums.Gender | null
    size: $Enums.Size | null
    lifeForce: $Enums.LifeForce | null
    composition: $Enums.Composition | null
    stance: $Enums.Stance | null
    damageType: $Enums.DamageType | null
  }

  export type MobMaxAggregateOutputType = {
    id: number | null
    mobClass: string | null
    shortDesc: string | null
    longDesc: string | null
    desc: string | null
    alignment: number | null
    level: number | null
    armorClass: number | null
    hitRoll: number | null
    move: number | null
    hpDiceNum: number | null
    hpDiceSize: number | null
    hpDiceBonus: number | null
    damageDiceNum: number | null
    damageDiceSize: number | null
    damageDiceBonus: number | null
    copper: number | null
    silver: number | null
    gold: number | null
    platinum: number | null
    raceAlign: number | null
    total_wealth: number | null
    average_stats: number | null
    estimated_hp: number | null
    strength: number | null
    intelligence: number | null
    wisdom: number | null
    dexterity: number | null
    constitution: number | null
    charisma: number | null
    perception: number | null
    concealment: number | null
    zoneId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
    classId: number | null
    race: $Enums.Race | null
    position: $Enums.Position | null
    defaultPosition: $Enums.Position | null
    gender: $Enums.Gender | null
    size: $Enums.Size | null
    lifeForce: $Enums.LifeForce | null
    composition: $Enums.Composition | null
    stance: $Enums.Stance | null
    damageType: $Enums.DamageType | null
  }

  export type MobCountAggregateOutputType = {
    id: number
    keywords: number
    mobClass: number
    shortDesc: number
    longDesc: number
    desc: number
    alignment: number
    level: number
    armorClass: number
    hitRoll: number
    move: number
    hpDiceNum: number
    hpDiceSize: number
    hpDiceBonus: number
    damageDiceNum: number
    damageDiceSize: number
    damageDiceBonus: number
    copper: number
    silver: number
    gold: number
    platinum: number
    raceAlign: number
    total_wealth: number
    average_stats: number
    estimated_hp: number
    strength: number
    intelligence: number
    wisdom: number
    dexterity: number
    constitution: number
    charisma: number
    perception: number
    concealment: number
    zoneId: number
    createdAt: number
    updatedAt: number
    deleted_at: number
    createdBy: number
    updatedBy: number
    classId: number
    race: number
    mobFlags: number
    effectFlags: number
    position: number
    defaultPosition: number
    gender: number
    size: number
    lifeForce: number
    composition: number
    stance: number
    damageType: number
    _all: number
  }


  export type MobAvgAggregateInputType = {
    id?: true
    alignment?: true
    level?: true
    armorClass?: true
    hitRoll?: true
    move?: true
    hpDiceNum?: true
    hpDiceSize?: true
    hpDiceBonus?: true
    damageDiceNum?: true
    damageDiceSize?: true
    damageDiceBonus?: true
    copper?: true
    silver?: true
    gold?: true
    platinum?: true
    raceAlign?: true
    total_wealth?: true
    average_stats?: true
    estimated_hp?: true
    strength?: true
    intelligence?: true
    wisdom?: true
    dexterity?: true
    constitution?: true
    charisma?: true
    perception?: true
    concealment?: true
    zoneId?: true
    classId?: true
  }

  export type MobSumAggregateInputType = {
    id?: true
    alignment?: true
    level?: true
    armorClass?: true
    hitRoll?: true
    move?: true
    hpDiceNum?: true
    hpDiceSize?: true
    hpDiceBonus?: true
    damageDiceNum?: true
    damageDiceSize?: true
    damageDiceBonus?: true
    copper?: true
    silver?: true
    gold?: true
    platinum?: true
    raceAlign?: true
    total_wealth?: true
    average_stats?: true
    estimated_hp?: true
    strength?: true
    intelligence?: true
    wisdom?: true
    dexterity?: true
    constitution?: true
    charisma?: true
    perception?: true
    concealment?: true
    zoneId?: true
    classId?: true
  }

  export type MobMinAggregateInputType = {
    id?: true
    mobClass?: true
    shortDesc?: true
    longDesc?: true
    desc?: true
    alignment?: true
    level?: true
    armorClass?: true
    hitRoll?: true
    move?: true
    hpDiceNum?: true
    hpDiceSize?: true
    hpDiceBonus?: true
    damageDiceNum?: true
    damageDiceSize?: true
    damageDiceBonus?: true
    copper?: true
    silver?: true
    gold?: true
    platinum?: true
    raceAlign?: true
    total_wealth?: true
    average_stats?: true
    estimated_hp?: true
    strength?: true
    intelligence?: true
    wisdom?: true
    dexterity?: true
    constitution?: true
    charisma?: true
    perception?: true
    concealment?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
    classId?: true
    race?: true
    position?: true
    defaultPosition?: true
    gender?: true
    size?: true
    lifeForce?: true
    composition?: true
    stance?: true
    damageType?: true
  }

  export type MobMaxAggregateInputType = {
    id?: true
    mobClass?: true
    shortDesc?: true
    longDesc?: true
    desc?: true
    alignment?: true
    level?: true
    armorClass?: true
    hitRoll?: true
    move?: true
    hpDiceNum?: true
    hpDiceSize?: true
    hpDiceBonus?: true
    damageDiceNum?: true
    damageDiceSize?: true
    damageDiceBonus?: true
    copper?: true
    silver?: true
    gold?: true
    platinum?: true
    raceAlign?: true
    total_wealth?: true
    average_stats?: true
    estimated_hp?: true
    strength?: true
    intelligence?: true
    wisdom?: true
    dexterity?: true
    constitution?: true
    charisma?: true
    perception?: true
    concealment?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
    classId?: true
    race?: true
    position?: true
    defaultPosition?: true
    gender?: true
    size?: true
    lifeForce?: true
    composition?: true
    stance?: true
    damageType?: true
  }

  export type MobCountAggregateInputType = {
    id?: true
    keywords?: true
    mobClass?: true
    shortDesc?: true
    longDesc?: true
    desc?: true
    alignment?: true
    level?: true
    armorClass?: true
    hitRoll?: true
    move?: true
    hpDiceNum?: true
    hpDiceSize?: true
    hpDiceBonus?: true
    damageDiceNum?: true
    damageDiceSize?: true
    damageDiceBonus?: true
    copper?: true
    silver?: true
    gold?: true
    platinum?: true
    raceAlign?: true
    total_wealth?: true
    average_stats?: true
    estimated_hp?: true
    strength?: true
    intelligence?: true
    wisdom?: true
    dexterity?: true
    constitution?: true
    charisma?: true
    perception?: true
    concealment?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
    classId?: true
    race?: true
    mobFlags?: true
    effectFlags?: true
    position?: true
    defaultPosition?: true
    gender?: true
    size?: true
    lifeForce?: true
    composition?: true
    stance?: true
    damageType?: true
    _all?: true
  }

  export type MobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mob to aggregate.
     */
    where?: MobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mobs to fetch.
     */
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mobs
    **/
    _count?: true | MobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobMaxAggregateInputType
  }

  export type GetMobAggregateType<T extends MobAggregateArgs> = {
        [P in keyof T & keyof AggregateMob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMob[P]>
      : GetScalarType<T[P], AggregateMob[P]>
  }




  export type MobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobWhereInput
    orderBy?: MobOrderByWithAggregationInput | MobOrderByWithAggregationInput[]
    by: MobScalarFieldEnum[] | MobScalarFieldEnum
    having?: MobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobCountAggregateInputType | true
    _avg?: MobAvgAggregateInputType
    _sum?: MobSumAggregateInputType
    _min?: MobMinAggregateInputType
    _max?: MobMaxAggregateInputType
  }

  export type MobGroupByOutputType = {
    id: number
    keywords: string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment: number
    level: number
    armorClass: number
    hitRoll: number
    move: number
    hpDiceNum: number
    hpDiceSize: number
    hpDiceBonus: number
    damageDiceNum: number
    damageDiceSize: number
    damageDiceBonus: number
    copper: number
    silver: number
    gold: number
    platinum: number
    raceAlign: number
    total_wealth: number
    average_stats: number
    estimated_hp: number
    strength: number
    intelligence: number
    wisdom: number
    dexterity: number
    constitution: number
    charisma: number
    perception: number
    concealment: number
    zoneId: number
    createdAt: Date
    updatedAt: Date
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
    classId: number | null
    race: $Enums.Race
    mobFlags: $Enums.MobFlag[]
    effectFlags: $Enums.EffectFlag[]
    position: $Enums.Position
    defaultPosition: $Enums.Position
    gender: $Enums.Gender
    size: $Enums.Size
    lifeForce: $Enums.LifeForce
    composition: $Enums.Composition
    stance: $Enums.Stance
    damageType: $Enums.DamageType
    _count: MobCountAggregateOutputType | null
    _avg: MobAvgAggregateOutputType | null
    _sum: MobSumAggregateOutputType | null
    _min: MobMinAggregateOutputType | null
    _max: MobMaxAggregateOutputType | null
  }

  type GetMobGroupByPayload<T extends MobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobGroupByOutputType[P]>
            : GetScalarType<T[P], MobGroupByOutputType[P]>
        }
      >
    >


  export type MobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keywords?: boolean
    mobClass?: boolean
    shortDesc?: boolean
    longDesc?: boolean
    desc?: boolean
    alignment?: boolean
    level?: boolean
    armorClass?: boolean
    hitRoll?: boolean
    move?: boolean
    hpDiceNum?: boolean
    hpDiceSize?: boolean
    hpDiceBonus?: boolean
    damageDiceNum?: boolean
    damageDiceSize?: boolean
    damageDiceBonus?: boolean
    copper?: boolean
    silver?: boolean
    gold?: boolean
    platinum?: boolean
    raceAlign?: boolean
    total_wealth?: boolean
    average_stats?: boolean
    estimated_hp?: boolean
    strength?: boolean
    intelligence?: boolean
    wisdom?: boolean
    dexterity?: boolean
    constitution?: boolean
    charisma?: boolean
    perception?: boolean
    concealment?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    classId?: boolean
    race?: boolean
    mobFlags?: boolean
    effectFlags?: boolean
    position?: boolean
    defaultPosition?: boolean
    gender?: boolean
    size?: boolean
    lifeForce?: boolean
    composition?: boolean
    stance?: boolean
    damageType?: boolean
    resets?: boolean | Mob$resetsArgs<ExtArgs>
    skills?: boolean | Mob$skillsArgs<ExtArgs>
    spells?: boolean | Mob$spellsArgs<ExtArgs>
    gameClass?: boolean | Mob$gameClassArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    shops?: boolean | Mob$shopsArgs<ExtArgs>
    triggers?: boolean | Mob$triggersArgs<ExtArgs>
    _count?: boolean | MobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mob"]>

  export type MobSelectScalar = {
    id?: boolean
    keywords?: boolean
    mobClass?: boolean
    shortDesc?: boolean
    longDesc?: boolean
    desc?: boolean
    alignment?: boolean
    level?: boolean
    armorClass?: boolean
    hitRoll?: boolean
    move?: boolean
    hpDiceNum?: boolean
    hpDiceSize?: boolean
    hpDiceBonus?: boolean
    damageDiceNum?: boolean
    damageDiceSize?: boolean
    damageDiceBonus?: boolean
    copper?: boolean
    silver?: boolean
    gold?: boolean
    platinum?: boolean
    raceAlign?: boolean
    total_wealth?: boolean
    average_stats?: boolean
    estimated_hp?: boolean
    strength?: boolean
    intelligence?: boolean
    wisdom?: boolean
    dexterity?: boolean
    constitution?: boolean
    charisma?: boolean
    perception?: boolean
    concealment?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    classId?: boolean
    race?: boolean
    mobFlags?: boolean
    effectFlags?: boolean
    position?: boolean
    defaultPosition?: boolean
    gender?: boolean
    size?: boolean
    lifeForce?: boolean
    composition?: boolean
    stance?: boolean
    damageType?: boolean
  }

  export type MobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resets?: boolean | Mob$resetsArgs<ExtArgs>
    skills?: boolean | Mob$skillsArgs<ExtArgs>
    spells?: boolean | Mob$spellsArgs<ExtArgs>
    gameClass?: boolean | Mob$gameClassArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    shops?: boolean | Mob$shopsArgs<ExtArgs>
    triggers?: boolean | Mob$triggersArgs<ExtArgs>
    _count?: boolean | MobCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mob"
    objects: {
      resets: Prisma.$MobResetPayload<ExtArgs>[]
      skills: Prisma.$MobSkillPayload<ExtArgs>[]
      spells: Prisma.$MobSpellPayload<ExtArgs>[]
      gameClass: Prisma.$GameClassPayload<ExtArgs> | null
      zone: Prisma.$ZonePayload<ExtArgs>
      shops: Prisma.$ShopPayload<ExtArgs>[]
      triggers: Prisma.$TriggerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      keywords: string[]
      mobClass: string
      shortDesc: string
      longDesc: string
      desc: string
      alignment: number
      level: number
      armorClass: number
      hitRoll: number
      move: number
      hpDiceNum: number
      hpDiceSize: number
      hpDiceBonus: number
      damageDiceNum: number
      damageDiceSize: number
      damageDiceBonus: number
      copper: number
      silver: number
      gold: number
      platinum: number
      raceAlign: number
      total_wealth: number
      average_stats: number
      estimated_hp: number
      strength: number
      intelligence: number
      wisdom: number
      dexterity: number
      constitution: number
      charisma: number
      perception: number
      concealment: number
      zoneId: number
      createdAt: Date
      updatedAt: Date
      deleted_at: Date | null
      createdBy: string | null
      updatedBy: string | null
      classId: number | null
      race: $Enums.Race
      mobFlags: $Enums.MobFlag[]
      effectFlags: $Enums.EffectFlag[]
      position: $Enums.Position
      defaultPosition: $Enums.Position
      gender: $Enums.Gender
      size: $Enums.Size
      lifeForce: $Enums.LifeForce
      composition: $Enums.Composition
      stance: $Enums.Stance
      damageType: $Enums.DamageType
    }, ExtArgs["result"]["mob"]>
    composites: {}
  }


  type MobGetPayload<S extends boolean | null | undefined | MobDefaultArgs> = $Result.GetResult<Prisma.$MobPayload, S>

  type MobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MobFindManyArgs, 'select' | 'include'> & {
      select?: MobCountAggregateInputType | true
    }

  export interface MobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mob'], meta: { name: 'Mob' } }
    /**
     * Find zero or one Mob that matches the filter.
     * @param {MobFindUniqueArgs} args - Arguments to find a Mob
     * @example
     * // Get one Mob
     * const mob = await prisma.mob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MobFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MobFindUniqueArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Mob that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MobFindUniqueOrThrowArgs} args - Arguments to find a Mob
     * @example
     * // Get one Mob
     * const mob = await prisma.mob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MobFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Mob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobFindFirstArgs} args - Arguments to find a Mob
     * @example
     * // Get one Mob
     * const mob = await prisma.mob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MobFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MobFindFirstArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Mob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobFindFirstOrThrowArgs} args - Arguments to find a Mob
     * @example
     * // Get one Mob
     * const mob = await prisma.mob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MobFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Mobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mobs
     * const mobs = await prisma.mob.findMany()
     * 
     * // Get first 10 Mobs
     * const mobs = await prisma.mob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mobWithIdOnly = await prisma.mob.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MobFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Mob.
     * @param {MobCreateArgs} args - Arguments to create a Mob.
     * @example
     * // Create one Mob
     * const Mob = await prisma.mob.create({
     *   data: {
     *     // ... data to create a Mob
     *   }
     * })
     * 
    **/
    create<T extends MobCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MobCreateArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Mobs.
     *     @param {MobCreateManyArgs} args - Arguments to create many Mobs.
     *     @example
     *     // Create many Mobs
     *     const mob = await prisma.mob.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MobCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mob.
     * @param {MobDeleteArgs} args - Arguments to delete one Mob.
     * @example
     * // Delete one Mob
     * const Mob = await prisma.mob.delete({
     *   where: {
     *     // ... filter to delete one Mob
     *   }
     * })
     * 
    **/
    delete<T extends MobDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MobDeleteArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Mob.
     * @param {MobUpdateArgs} args - Arguments to update one Mob.
     * @example
     * // Update one Mob
     * const mob = await prisma.mob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MobUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MobUpdateArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Mobs.
     * @param {MobDeleteManyArgs} args - Arguments to filter Mobs to delete.
     * @example
     * // Delete a few Mobs
     * const { count } = await prisma.mob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MobDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mobs
     * const mob = await prisma.mob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MobUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MobUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mob.
     * @param {MobUpsertArgs} args - Arguments to update or create a Mob.
     * @example
     * // Update or create a Mob
     * const mob = await prisma.mob.upsert({
     *   create: {
     *     // ... data to create a Mob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mob we want to update
     *   }
     * })
    **/
    upsert<T extends MobUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MobUpsertArgs<ExtArgs>>
    ): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Mobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobCountArgs} args - Arguments to filter Mobs to count.
     * @example
     * // Count the number of Mobs
     * const count = await prisma.mob.count({
     *   where: {
     *     // ... the filter for the Mobs we want to count
     *   }
     * })
    **/
    count<T extends MobCountArgs>(
      args?: Subset<T, MobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobAggregateArgs>(args: Subset<T, MobAggregateArgs>): Prisma.PrismaPromise<GetMobAggregateType<T>>

    /**
     * Group by Mob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobGroupByArgs['orderBy'] }
        : { orderBy?: MobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mob model
   */
  readonly fields: MobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    resets<T extends Mob$resetsArgs<ExtArgs> = {}>(args?: Subset<T, Mob$resetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findMany'> | Null>;

    skills<T extends Mob$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Mob$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    spells<T extends Mob$spellsArgs<ExtArgs> = {}>(args?: Subset<T, Mob$spellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'findMany'> | Null>;

    gameClass<T extends Mob$gameClassArgs<ExtArgs> = {}>(args?: Subset<T, Mob$gameClassArgs<ExtArgs>>): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    shops<T extends Mob$shopsArgs<ExtArgs> = {}>(args?: Subset<T, Mob$shopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findMany'> | Null>;

    triggers<T extends Mob$triggersArgs<ExtArgs> = {}>(args?: Subset<T, Mob$triggersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Mob model
   */ 
  interface MobFieldRefs {
    readonly id: FieldRef<"Mob", 'Int'>
    readonly keywords: FieldRef<"Mob", 'String[]'>
    readonly mobClass: FieldRef<"Mob", 'String'>
    readonly shortDesc: FieldRef<"Mob", 'String'>
    readonly longDesc: FieldRef<"Mob", 'String'>
    readonly desc: FieldRef<"Mob", 'String'>
    readonly alignment: FieldRef<"Mob", 'Int'>
    readonly level: FieldRef<"Mob", 'Int'>
    readonly armorClass: FieldRef<"Mob", 'Int'>
    readonly hitRoll: FieldRef<"Mob", 'Int'>
    readonly move: FieldRef<"Mob", 'Int'>
    readonly hpDiceNum: FieldRef<"Mob", 'Int'>
    readonly hpDiceSize: FieldRef<"Mob", 'Int'>
    readonly hpDiceBonus: FieldRef<"Mob", 'Int'>
    readonly damageDiceNum: FieldRef<"Mob", 'Int'>
    readonly damageDiceSize: FieldRef<"Mob", 'Int'>
    readonly damageDiceBonus: FieldRef<"Mob", 'Int'>
    readonly copper: FieldRef<"Mob", 'Int'>
    readonly silver: FieldRef<"Mob", 'Int'>
    readonly gold: FieldRef<"Mob", 'Int'>
    readonly platinum: FieldRef<"Mob", 'Int'>
    readonly raceAlign: FieldRef<"Mob", 'Int'>
    readonly total_wealth: FieldRef<"Mob", 'Int'>
    readonly average_stats: FieldRef<"Mob", 'Int'>
    readonly estimated_hp: FieldRef<"Mob", 'Int'>
    readonly strength: FieldRef<"Mob", 'Int'>
    readonly intelligence: FieldRef<"Mob", 'Int'>
    readonly wisdom: FieldRef<"Mob", 'Int'>
    readonly dexterity: FieldRef<"Mob", 'Int'>
    readonly constitution: FieldRef<"Mob", 'Int'>
    readonly charisma: FieldRef<"Mob", 'Int'>
    readonly perception: FieldRef<"Mob", 'Int'>
    readonly concealment: FieldRef<"Mob", 'Int'>
    readonly zoneId: FieldRef<"Mob", 'Int'>
    readonly createdAt: FieldRef<"Mob", 'DateTime'>
    readonly updatedAt: FieldRef<"Mob", 'DateTime'>
    readonly deleted_at: FieldRef<"Mob", 'DateTime'>
    readonly createdBy: FieldRef<"Mob", 'String'>
    readonly updatedBy: FieldRef<"Mob", 'String'>
    readonly classId: FieldRef<"Mob", 'Int'>
    readonly race: FieldRef<"Mob", 'Race'>
    readonly mobFlags: FieldRef<"Mob", 'MobFlag[]'>
    readonly effectFlags: FieldRef<"Mob", 'EffectFlag[]'>
    readonly position: FieldRef<"Mob", 'Position'>
    readonly defaultPosition: FieldRef<"Mob", 'Position'>
    readonly gender: FieldRef<"Mob", 'Gender'>
    readonly size: FieldRef<"Mob", 'Size'>
    readonly lifeForce: FieldRef<"Mob", 'LifeForce'>
    readonly composition: FieldRef<"Mob", 'Composition'>
    readonly stance: FieldRef<"Mob", 'Stance'>
    readonly damageType: FieldRef<"Mob", 'DamageType'>
  }
    

  // Custom InputTypes

  /**
   * Mob findUnique
   */
  export type MobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter, which Mob to fetch.
     */
    where: MobWhereUniqueInput
  }


  /**
   * Mob findUniqueOrThrow
   */
  export type MobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter, which Mob to fetch.
     */
    where: MobWhereUniqueInput
  }


  /**
   * Mob findFirst
   */
  export type MobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter, which Mob to fetch.
     */
    where?: MobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mobs to fetch.
     */
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mobs.
     */
    cursor?: MobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mobs.
     */
    distinct?: MobScalarFieldEnum | MobScalarFieldEnum[]
  }


  /**
   * Mob findFirstOrThrow
   */
  export type MobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter, which Mob to fetch.
     */
    where?: MobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mobs to fetch.
     */
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mobs.
     */
    cursor?: MobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mobs.
     */
    distinct?: MobScalarFieldEnum | MobScalarFieldEnum[]
  }


  /**
   * Mob findMany
   */
  export type MobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter, which Mobs to fetch.
     */
    where?: MobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mobs to fetch.
     */
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mobs.
     */
    cursor?: MobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mobs.
     */
    skip?: number
    distinct?: MobScalarFieldEnum | MobScalarFieldEnum[]
  }


  /**
   * Mob create
   */
  export type MobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * The data needed to create a Mob.
     */
    data: XOR<MobCreateInput, MobUncheckedCreateInput>
  }


  /**
   * Mob createMany
   */
  export type MobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mobs.
     */
    data: MobCreateManyInput | MobCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Mob update
   */
  export type MobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * The data needed to update a Mob.
     */
    data: XOR<MobUpdateInput, MobUncheckedUpdateInput>
    /**
     * Choose, which Mob to update.
     */
    where: MobWhereUniqueInput
  }


  /**
   * Mob updateMany
   */
  export type MobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mobs.
     */
    data: XOR<MobUpdateManyMutationInput, MobUncheckedUpdateManyInput>
    /**
     * Filter which Mobs to update
     */
    where?: MobWhereInput
  }


  /**
   * Mob upsert
   */
  export type MobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * The filter to search for the Mob to update in case it exists.
     */
    where: MobWhereUniqueInput
    /**
     * In case the Mob found by the `where` argument doesn't exist, create a new Mob with this data.
     */
    create: XOR<MobCreateInput, MobUncheckedCreateInput>
    /**
     * In case the Mob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobUpdateInput, MobUncheckedUpdateInput>
  }


  /**
   * Mob delete
   */
  export type MobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    /**
     * Filter which Mob to delete.
     */
    where: MobWhereUniqueInput
  }


  /**
   * Mob deleteMany
   */
  export type MobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mobs to delete
     */
    where?: MobWhereInput
  }


  /**
   * Mob.resets
   */
  export type Mob$resetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    where?: MobResetWhereInput
    orderBy?: MobResetOrderByWithRelationInput | MobResetOrderByWithRelationInput[]
    cursor?: MobResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobResetScalarFieldEnum | MobResetScalarFieldEnum[]
  }


  /**
   * Mob.skills
   */
  export type Mob$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    where?: MobSkillWhereInput
    orderBy?: MobSkillOrderByWithRelationInput | MobSkillOrderByWithRelationInput[]
    cursor?: MobSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobSkillScalarFieldEnum | MobSkillScalarFieldEnum[]
  }


  /**
   * Mob.spells
   */
  export type Mob$spellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    where?: MobSpellWhereInput
    orderBy?: MobSpellOrderByWithRelationInput | MobSpellOrderByWithRelationInput[]
    cursor?: MobSpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobSpellScalarFieldEnum | MobSpellScalarFieldEnum[]
  }


  /**
   * Mob.gameClass
   */
  export type Mob$gameClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    where?: GameClassWhereInput
  }


  /**
   * Mob.shops
   */
  export type Mob$shopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    cursor?: ShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }


  /**
   * Mob.triggers
   */
  export type Mob$triggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    where?: TriggerWhereInput
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    cursor?: TriggerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }


  /**
   * Mob without action
   */
  export type MobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
  }



  /**
   * Model MobSkill
   */

  export type AggregateMobSkill = {
    _count: MobSkillCountAggregateOutputType | null
    _avg: MobSkillAvgAggregateOutputType | null
    _sum: MobSkillSumAggregateOutputType | null
    _min: MobSkillMinAggregateOutputType | null
    _max: MobSkillMaxAggregateOutputType | null
  }

  export type MobSkillAvgAggregateOutputType = {
    id: number | null
    mobZoneId: number | null
    mobId: number | null
    skillId: number | null
    level: number | null
  }

  export type MobSkillSumAggregateOutputType = {
    id: number | null
    mobZoneId: number | null
    mobId: number | null
    skillId: number | null
    level: number | null
  }

  export type MobSkillMinAggregateOutputType = {
    id: number | null
    mobZoneId: number | null
    mobId: number | null
    skillId: number | null
    level: number | null
  }

  export type MobSkillMaxAggregateOutputType = {
    id: number | null
    mobZoneId: number | null
    mobId: number | null
    skillId: number | null
    level: number | null
  }

  export type MobSkillCountAggregateOutputType = {
    id: number
    mobZoneId: number
    mobId: number
    skillId: number
    level: number
    _all: number
  }


  export type MobSkillAvgAggregateInputType = {
    id?: true
    mobZoneId?: true
    mobId?: true
    skillId?: true
    level?: true
  }

  export type MobSkillSumAggregateInputType = {
    id?: true
    mobZoneId?: true
    mobId?: true
    skillId?: true
    level?: true
  }

  export type MobSkillMinAggregateInputType = {
    id?: true
    mobZoneId?: true
    mobId?: true
    skillId?: true
    level?: true
  }

  export type MobSkillMaxAggregateInputType = {
    id?: true
    mobZoneId?: true
    mobId?: true
    skillId?: true
    level?: true
  }

  export type MobSkillCountAggregateInputType = {
    id?: true
    mobZoneId?: true
    mobId?: true
    skillId?: true
    level?: true
    _all?: true
  }

  export type MobSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobSkill to aggregate.
     */
    where?: MobSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobSkills to fetch.
     */
    orderBy?: MobSkillOrderByWithRelationInput | MobSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MobSkills
    **/
    _count?: true | MobSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MobSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MobSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobSkillMaxAggregateInputType
  }

  export type GetMobSkillAggregateType<T extends MobSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateMobSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMobSkill[P]>
      : GetScalarType<T[P], AggregateMobSkill[P]>
  }




  export type MobSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobSkillWhereInput
    orderBy?: MobSkillOrderByWithAggregationInput | MobSkillOrderByWithAggregationInput[]
    by: MobSkillScalarFieldEnum[] | MobSkillScalarFieldEnum
    having?: MobSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobSkillCountAggregateInputType | true
    _avg?: MobSkillAvgAggregateInputType
    _sum?: MobSkillSumAggregateInputType
    _min?: MobSkillMinAggregateInputType
    _max?: MobSkillMaxAggregateInputType
  }

  export type MobSkillGroupByOutputType = {
    id: number
    mobZoneId: number
    mobId: number
    skillId: number
    level: number
    _count: MobSkillCountAggregateOutputType | null
    _avg: MobSkillAvgAggregateOutputType | null
    _sum: MobSkillSumAggregateOutputType | null
    _min: MobSkillMinAggregateOutputType | null
    _max: MobSkillMaxAggregateOutputType | null
  }

  type GetMobSkillGroupByPayload<T extends MobSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobSkillGroupByOutputType[P]>
            : GetScalarType<T[P], MobSkillGroupByOutputType[P]>
        }
      >
    >


  export type MobSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mobZoneId?: boolean
    mobId?: boolean
    skillId?: boolean
    level?: boolean
    mob?: boolean | MobDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobSkill"]>

  export type MobSkillSelectScalar = {
    id?: boolean
    mobZoneId?: boolean
    mobId?: boolean
    skillId?: boolean
    level?: boolean
  }

  export type MobSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mob?: boolean | MobDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }


  export type $MobSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MobSkill"
    objects: {
      mob: Prisma.$MobPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mobZoneId: number
      mobId: number
      skillId: number
      level: number
    }, ExtArgs["result"]["mobSkill"]>
    composites: {}
  }


  type MobSkillGetPayload<S extends boolean | null | undefined | MobSkillDefaultArgs> = $Result.GetResult<Prisma.$MobSkillPayload, S>

  type MobSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MobSkillFindManyArgs, 'select' | 'include'> & {
      select?: MobSkillCountAggregateInputType | true
    }

  export interface MobSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MobSkill'], meta: { name: 'MobSkill' } }
    /**
     * Find zero or one MobSkill that matches the filter.
     * @param {MobSkillFindUniqueArgs} args - Arguments to find a MobSkill
     * @example
     * // Get one MobSkill
     * const mobSkill = await prisma.mobSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MobSkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MobSkillFindUniqueArgs<ExtArgs>>
    ): Prisma__MobSkillClient<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MobSkill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MobSkillFindUniqueOrThrowArgs} args - Arguments to find a MobSkill
     * @example
     * // Get one MobSkill
     * const mobSkill = await prisma.mobSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MobSkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MobSkillClient<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MobSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSkillFindFirstArgs} args - Arguments to find a MobSkill
     * @example
     * // Get one MobSkill
     * const mobSkill = await prisma.mobSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MobSkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSkillFindFirstArgs<ExtArgs>>
    ): Prisma__MobSkillClient<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MobSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSkillFindFirstOrThrowArgs} args - Arguments to find a MobSkill
     * @example
     * // Get one MobSkill
     * const mobSkill = await prisma.mobSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MobSkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MobSkillClient<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MobSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MobSkills
     * const mobSkills = await prisma.mobSkill.findMany()
     * 
     * // Get first 10 MobSkills
     * const mobSkills = await prisma.mobSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mobSkillWithIdOnly = await prisma.mobSkill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MobSkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MobSkill.
     * @param {MobSkillCreateArgs} args - Arguments to create a MobSkill.
     * @example
     * // Create one MobSkill
     * const MobSkill = await prisma.mobSkill.create({
     *   data: {
     *     // ... data to create a MobSkill
     *   }
     * })
     * 
    **/
    create<T extends MobSkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MobSkillCreateArgs<ExtArgs>>
    ): Prisma__MobSkillClient<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MobSkills.
     *     @param {MobSkillCreateManyArgs} args - Arguments to create many MobSkills.
     *     @example
     *     // Create many MobSkills
     *     const mobSkill = await prisma.mobSkill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MobSkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MobSkill.
     * @param {MobSkillDeleteArgs} args - Arguments to delete one MobSkill.
     * @example
     * // Delete one MobSkill
     * const MobSkill = await prisma.mobSkill.delete({
     *   where: {
     *     // ... filter to delete one MobSkill
     *   }
     * })
     * 
    **/
    delete<T extends MobSkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MobSkillDeleteArgs<ExtArgs>>
    ): Prisma__MobSkillClient<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MobSkill.
     * @param {MobSkillUpdateArgs} args - Arguments to update one MobSkill.
     * @example
     * // Update one MobSkill
     * const mobSkill = await prisma.mobSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MobSkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MobSkillUpdateArgs<ExtArgs>>
    ): Prisma__MobSkillClient<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MobSkills.
     * @param {MobSkillDeleteManyArgs} args - Arguments to filter MobSkills to delete.
     * @example
     * // Delete a few MobSkills
     * const { count } = await prisma.mobSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MobSkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MobSkills
     * const mobSkill = await prisma.mobSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MobSkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MobSkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MobSkill.
     * @param {MobSkillUpsertArgs} args - Arguments to update or create a MobSkill.
     * @example
     * // Update or create a MobSkill
     * const mobSkill = await prisma.mobSkill.upsert({
     *   create: {
     *     // ... data to create a MobSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MobSkill we want to update
     *   }
     * })
    **/
    upsert<T extends MobSkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MobSkillUpsertArgs<ExtArgs>>
    ): Prisma__MobSkillClient<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MobSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSkillCountArgs} args - Arguments to filter MobSkills to count.
     * @example
     * // Count the number of MobSkills
     * const count = await prisma.mobSkill.count({
     *   where: {
     *     // ... the filter for the MobSkills we want to count
     *   }
     * })
    **/
    count<T extends MobSkillCountArgs>(
      args?: Subset<T, MobSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MobSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobSkillAggregateArgs>(args: Subset<T, MobSkillAggregateArgs>): Prisma.PrismaPromise<GetMobSkillAggregateType<T>>

    /**
     * Group by MobSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobSkillGroupByArgs['orderBy'] }
        : { orderBy?: MobSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MobSkill model
   */
  readonly fields: MobSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MobSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mob<T extends MobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MobDefaultArgs<ExtArgs>>): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MobSkill model
   */ 
  interface MobSkillFieldRefs {
    readonly id: FieldRef<"MobSkill", 'Int'>
    readonly mobZoneId: FieldRef<"MobSkill", 'Int'>
    readonly mobId: FieldRef<"MobSkill", 'Int'>
    readonly skillId: FieldRef<"MobSkill", 'Int'>
    readonly level: FieldRef<"MobSkill", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MobSkill findUnique
   */
  export type MobSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    /**
     * Filter, which MobSkill to fetch.
     */
    where: MobSkillWhereUniqueInput
  }


  /**
   * MobSkill findUniqueOrThrow
   */
  export type MobSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    /**
     * Filter, which MobSkill to fetch.
     */
    where: MobSkillWhereUniqueInput
  }


  /**
   * MobSkill findFirst
   */
  export type MobSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    /**
     * Filter, which MobSkill to fetch.
     */
    where?: MobSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobSkills to fetch.
     */
    orderBy?: MobSkillOrderByWithRelationInput | MobSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobSkills.
     */
    cursor?: MobSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobSkills.
     */
    distinct?: MobSkillScalarFieldEnum | MobSkillScalarFieldEnum[]
  }


  /**
   * MobSkill findFirstOrThrow
   */
  export type MobSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    /**
     * Filter, which MobSkill to fetch.
     */
    where?: MobSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobSkills to fetch.
     */
    orderBy?: MobSkillOrderByWithRelationInput | MobSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobSkills.
     */
    cursor?: MobSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobSkills.
     */
    distinct?: MobSkillScalarFieldEnum | MobSkillScalarFieldEnum[]
  }


  /**
   * MobSkill findMany
   */
  export type MobSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    /**
     * Filter, which MobSkills to fetch.
     */
    where?: MobSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobSkills to fetch.
     */
    orderBy?: MobSkillOrderByWithRelationInput | MobSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MobSkills.
     */
    cursor?: MobSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobSkills.
     */
    skip?: number
    distinct?: MobSkillScalarFieldEnum | MobSkillScalarFieldEnum[]
  }


  /**
   * MobSkill create
   */
  export type MobSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a MobSkill.
     */
    data: XOR<MobSkillCreateInput, MobSkillUncheckedCreateInput>
  }


  /**
   * MobSkill createMany
   */
  export type MobSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MobSkills.
     */
    data: MobSkillCreateManyInput | MobSkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MobSkill update
   */
  export type MobSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a MobSkill.
     */
    data: XOR<MobSkillUpdateInput, MobSkillUncheckedUpdateInput>
    /**
     * Choose, which MobSkill to update.
     */
    where: MobSkillWhereUniqueInput
  }


  /**
   * MobSkill updateMany
   */
  export type MobSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MobSkills.
     */
    data: XOR<MobSkillUpdateManyMutationInput, MobSkillUncheckedUpdateManyInput>
    /**
     * Filter which MobSkills to update
     */
    where?: MobSkillWhereInput
  }


  /**
   * MobSkill upsert
   */
  export type MobSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the MobSkill to update in case it exists.
     */
    where: MobSkillWhereUniqueInput
    /**
     * In case the MobSkill found by the `where` argument doesn't exist, create a new MobSkill with this data.
     */
    create: XOR<MobSkillCreateInput, MobSkillUncheckedCreateInput>
    /**
     * In case the MobSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobSkillUpdateInput, MobSkillUncheckedUpdateInput>
  }


  /**
   * MobSkill delete
   */
  export type MobSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    /**
     * Filter which MobSkill to delete.
     */
    where: MobSkillWhereUniqueInput
  }


  /**
   * MobSkill deleteMany
   */
  export type MobSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobSkills to delete
     */
    where?: MobSkillWhereInput
  }


  /**
   * MobSkill without action
   */
  export type MobSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
  }



  /**
   * Model MobSpell
   */

  export type AggregateMobSpell = {
    _count: MobSpellCountAggregateOutputType | null
    _avg: MobSpellAvgAggregateOutputType | null
    _sum: MobSpellSumAggregateOutputType | null
    _min: MobSpellMinAggregateOutputType | null
    _max: MobSpellMaxAggregateOutputType | null
  }

  export type MobSpellAvgAggregateOutputType = {
    id: number | null
    mobZoneId: number | null
    mobId: number | null
    spellId: number | null
    circle: number | null
  }

  export type MobSpellSumAggregateOutputType = {
    id: number | null
    mobZoneId: number | null
    mobId: number | null
    spellId: number | null
    circle: number | null
  }

  export type MobSpellMinAggregateOutputType = {
    id: number | null
    mobZoneId: number | null
    mobId: number | null
    spellId: number | null
    circle: number | null
    known: boolean | null
  }

  export type MobSpellMaxAggregateOutputType = {
    id: number | null
    mobZoneId: number | null
    mobId: number | null
    spellId: number | null
    circle: number | null
    known: boolean | null
  }

  export type MobSpellCountAggregateOutputType = {
    id: number
    mobZoneId: number
    mobId: number
    spellId: number
    circle: number
    known: number
    _all: number
  }


  export type MobSpellAvgAggregateInputType = {
    id?: true
    mobZoneId?: true
    mobId?: true
    spellId?: true
    circle?: true
  }

  export type MobSpellSumAggregateInputType = {
    id?: true
    mobZoneId?: true
    mobId?: true
    spellId?: true
    circle?: true
  }

  export type MobSpellMinAggregateInputType = {
    id?: true
    mobZoneId?: true
    mobId?: true
    spellId?: true
    circle?: true
    known?: true
  }

  export type MobSpellMaxAggregateInputType = {
    id?: true
    mobZoneId?: true
    mobId?: true
    spellId?: true
    circle?: true
    known?: true
  }

  export type MobSpellCountAggregateInputType = {
    id?: true
    mobZoneId?: true
    mobId?: true
    spellId?: true
    circle?: true
    known?: true
    _all?: true
  }

  export type MobSpellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobSpell to aggregate.
     */
    where?: MobSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobSpells to fetch.
     */
    orderBy?: MobSpellOrderByWithRelationInput | MobSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MobSpells
    **/
    _count?: true | MobSpellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MobSpellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MobSpellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobSpellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobSpellMaxAggregateInputType
  }

  export type GetMobSpellAggregateType<T extends MobSpellAggregateArgs> = {
        [P in keyof T & keyof AggregateMobSpell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMobSpell[P]>
      : GetScalarType<T[P], AggregateMobSpell[P]>
  }




  export type MobSpellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobSpellWhereInput
    orderBy?: MobSpellOrderByWithAggregationInput | MobSpellOrderByWithAggregationInput[]
    by: MobSpellScalarFieldEnum[] | MobSpellScalarFieldEnum
    having?: MobSpellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobSpellCountAggregateInputType | true
    _avg?: MobSpellAvgAggregateInputType
    _sum?: MobSpellSumAggregateInputType
    _min?: MobSpellMinAggregateInputType
    _max?: MobSpellMaxAggregateInputType
  }

  export type MobSpellGroupByOutputType = {
    id: number
    mobZoneId: number
    mobId: number
    spellId: number
    circle: number
    known: boolean
    _count: MobSpellCountAggregateOutputType | null
    _avg: MobSpellAvgAggregateOutputType | null
    _sum: MobSpellSumAggregateOutputType | null
    _min: MobSpellMinAggregateOutputType | null
    _max: MobSpellMaxAggregateOutputType | null
  }

  type GetMobSpellGroupByPayload<T extends MobSpellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobSpellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobSpellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobSpellGroupByOutputType[P]>
            : GetScalarType<T[P], MobSpellGroupByOutputType[P]>
        }
      >
    >


  export type MobSpellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mobZoneId?: boolean
    mobId?: boolean
    spellId?: boolean
    circle?: boolean
    known?: boolean
    mob?: boolean | MobDefaultArgs<ExtArgs>
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobSpell"]>

  export type MobSpellSelectScalar = {
    id?: boolean
    mobZoneId?: boolean
    mobId?: boolean
    spellId?: boolean
    circle?: boolean
    known?: boolean
  }

  export type MobSpellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mob?: boolean | MobDefaultArgs<ExtArgs>
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }


  export type $MobSpellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MobSpell"
    objects: {
      mob: Prisma.$MobPayload<ExtArgs>
      spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mobZoneId: number
      mobId: number
      spellId: number
      circle: number
      known: boolean
    }, ExtArgs["result"]["mobSpell"]>
    composites: {}
  }


  type MobSpellGetPayload<S extends boolean | null | undefined | MobSpellDefaultArgs> = $Result.GetResult<Prisma.$MobSpellPayload, S>

  type MobSpellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MobSpellFindManyArgs, 'select' | 'include'> & {
      select?: MobSpellCountAggregateInputType | true
    }

  export interface MobSpellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MobSpell'], meta: { name: 'MobSpell' } }
    /**
     * Find zero or one MobSpell that matches the filter.
     * @param {MobSpellFindUniqueArgs} args - Arguments to find a MobSpell
     * @example
     * // Get one MobSpell
     * const mobSpell = await prisma.mobSpell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MobSpellFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MobSpellFindUniqueArgs<ExtArgs>>
    ): Prisma__MobSpellClient<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MobSpell that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MobSpellFindUniqueOrThrowArgs} args - Arguments to find a MobSpell
     * @example
     * // Get one MobSpell
     * const mobSpell = await prisma.mobSpell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MobSpellFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSpellFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MobSpellClient<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MobSpell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSpellFindFirstArgs} args - Arguments to find a MobSpell
     * @example
     * // Get one MobSpell
     * const mobSpell = await prisma.mobSpell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MobSpellFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSpellFindFirstArgs<ExtArgs>>
    ): Prisma__MobSpellClient<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MobSpell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSpellFindFirstOrThrowArgs} args - Arguments to find a MobSpell
     * @example
     * // Get one MobSpell
     * const mobSpell = await prisma.mobSpell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MobSpellFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSpellFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MobSpellClient<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MobSpells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSpellFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MobSpells
     * const mobSpells = await prisma.mobSpell.findMany()
     * 
     * // Get first 10 MobSpells
     * const mobSpells = await prisma.mobSpell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mobSpellWithIdOnly = await prisma.mobSpell.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MobSpellFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSpellFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MobSpell.
     * @param {MobSpellCreateArgs} args - Arguments to create a MobSpell.
     * @example
     * // Create one MobSpell
     * const MobSpell = await prisma.mobSpell.create({
     *   data: {
     *     // ... data to create a MobSpell
     *   }
     * })
     * 
    **/
    create<T extends MobSpellCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MobSpellCreateArgs<ExtArgs>>
    ): Prisma__MobSpellClient<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MobSpells.
     *     @param {MobSpellCreateManyArgs} args - Arguments to create many MobSpells.
     *     @example
     *     // Create many MobSpells
     *     const mobSpell = await prisma.mobSpell.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MobSpellCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSpellCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MobSpell.
     * @param {MobSpellDeleteArgs} args - Arguments to delete one MobSpell.
     * @example
     * // Delete one MobSpell
     * const MobSpell = await prisma.mobSpell.delete({
     *   where: {
     *     // ... filter to delete one MobSpell
     *   }
     * })
     * 
    **/
    delete<T extends MobSpellDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MobSpellDeleteArgs<ExtArgs>>
    ): Prisma__MobSpellClient<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MobSpell.
     * @param {MobSpellUpdateArgs} args - Arguments to update one MobSpell.
     * @example
     * // Update one MobSpell
     * const mobSpell = await prisma.mobSpell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MobSpellUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MobSpellUpdateArgs<ExtArgs>>
    ): Prisma__MobSpellClient<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MobSpells.
     * @param {MobSpellDeleteManyArgs} args - Arguments to filter MobSpells to delete.
     * @example
     * // Delete a few MobSpells
     * const { count } = await prisma.mobSpell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MobSpellDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobSpellDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSpellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MobSpells
     * const mobSpell = await prisma.mobSpell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MobSpellUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MobSpellUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MobSpell.
     * @param {MobSpellUpsertArgs} args - Arguments to update or create a MobSpell.
     * @example
     * // Update or create a MobSpell
     * const mobSpell = await prisma.mobSpell.upsert({
     *   create: {
     *     // ... data to create a MobSpell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MobSpell we want to update
     *   }
     * })
    **/
    upsert<T extends MobSpellUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MobSpellUpsertArgs<ExtArgs>>
    ): Prisma__MobSpellClient<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MobSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSpellCountArgs} args - Arguments to filter MobSpells to count.
     * @example
     * // Count the number of MobSpells
     * const count = await prisma.mobSpell.count({
     *   where: {
     *     // ... the filter for the MobSpells we want to count
     *   }
     * })
    **/
    count<T extends MobSpellCountArgs>(
      args?: Subset<T, MobSpellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobSpellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MobSpell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSpellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobSpellAggregateArgs>(args: Subset<T, MobSpellAggregateArgs>): Prisma.PrismaPromise<GetMobSpellAggregateType<T>>

    /**
     * Group by MobSpell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobSpellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobSpellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobSpellGroupByArgs['orderBy'] }
        : { orderBy?: MobSpellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobSpellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobSpellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MobSpell model
   */
  readonly fields: MobSpellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MobSpell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobSpellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mob<T extends MobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MobDefaultArgs<ExtArgs>>): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MobSpell model
   */ 
  interface MobSpellFieldRefs {
    readonly id: FieldRef<"MobSpell", 'Int'>
    readonly mobZoneId: FieldRef<"MobSpell", 'Int'>
    readonly mobId: FieldRef<"MobSpell", 'Int'>
    readonly spellId: FieldRef<"MobSpell", 'Int'>
    readonly circle: FieldRef<"MobSpell", 'Int'>
    readonly known: FieldRef<"MobSpell", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * MobSpell findUnique
   */
  export type MobSpellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    /**
     * Filter, which MobSpell to fetch.
     */
    where: MobSpellWhereUniqueInput
  }


  /**
   * MobSpell findUniqueOrThrow
   */
  export type MobSpellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    /**
     * Filter, which MobSpell to fetch.
     */
    where: MobSpellWhereUniqueInput
  }


  /**
   * MobSpell findFirst
   */
  export type MobSpellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    /**
     * Filter, which MobSpell to fetch.
     */
    where?: MobSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobSpells to fetch.
     */
    orderBy?: MobSpellOrderByWithRelationInput | MobSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobSpells.
     */
    cursor?: MobSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobSpells.
     */
    distinct?: MobSpellScalarFieldEnum | MobSpellScalarFieldEnum[]
  }


  /**
   * MobSpell findFirstOrThrow
   */
  export type MobSpellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    /**
     * Filter, which MobSpell to fetch.
     */
    where?: MobSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobSpells to fetch.
     */
    orderBy?: MobSpellOrderByWithRelationInput | MobSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobSpells.
     */
    cursor?: MobSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobSpells.
     */
    distinct?: MobSpellScalarFieldEnum | MobSpellScalarFieldEnum[]
  }


  /**
   * MobSpell findMany
   */
  export type MobSpellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    /**
     * Filter, which MobSpells to fetch.
     */
    where?: MobSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobSpells to fetch.
     */
    orderBy?: MobSpellOrderByWithRelationInput | MobSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MobSpells.
     */
    cursor?: MobSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobSpells.
     */
    skip?: number
    distinct?: MobSpellScalarFieldEnum | MobSpellScalarFieldEnum[]
  }


  /**
   * MobSpell create
   */
  export type MobSpellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    /**
     * The data needed to create a MobSpell.
     */
    data: XOR<MobSpellCreateInput, MobSpellUncheckedCreateInput>
  }


  /**
   * MobSpell createMany
   */
  export type MobSpellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MobSpells.
     */
    data: MobSpellCreateManyInput | MobSpellCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MobSpell update
   */
  export type MobSpellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    /**
     * The data needed to update a MobSpell.
     */
    data: XOR<MobSpellUpdateInput, MobSpellUncheckedUpdateInput>
    /**
     * Choose, which MobSpell to update.
     */
    where: MobSpellWhereUniqueInput
  }


  /**
   * MobSpell updateMany
   */
  export type MobSpellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MobSpells.
     */
    data: XOR<MobSpellUpdateManyMutationInput, MobSpellUncheckedUpdateManyInput>
    /**
     * Filter which MobSpells to update
     */
    where?: MobSpellWhereInput
  }


  /**
   * MobSpell upsert
   */
  export type MobSpellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    /**
     * The filter to search for the MobSpell to update in case it exists.
     */
    where: MobSpellWhereUniqueInput
    /**
     * In case the MobSpell found by the `where` argument doesn't exist, create a new MobSpell with this data.
     */
    create: XOR<MobSpellCreateInput, MobSpellUncheckedCreateInput>
    /**
     * In case the MobSpell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobSpellUpdateInput, MobSpellUncheckedUpdateInput>
  }


  /**
   * MobSpell delete
   */
  export type MobSpellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    /**
     * Filter which MobSpell to delete.
     */
    where: MobSpellWhereUniqueInput
  }


  /**
   * MobSpell deleteMany
   */
  export type MobSpellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobSpells to delete
     */
    where?: MobSpellWhereInput
  }


  /**
   * MobSpell without action
   */
  export type MobSpellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
  }



  /**
   * Model MobReset
   */

  export type AggregateMobReset = {
    _count: MobResetCountAggregateOutputType | null
    _avg: MobResetAvgAggregateOutputType | null
    _sum: MobResetSumAggregateOutputType | null
    _min: MobResetMinAggregateOutputType | null
    _max: MobResetMaxAggregateOutputType | null
  }

  export type MobResetAvgAggregateOutputType = {
    max: number | null
    mobZoneId: number | null
    mobId: number | null
    roomZoneId: number | null
    roomId: number | null
    zoneId: number | null
    probability: number | null
  }

  export type MobResetSumAggregateOutputType = {
    max: number | null
    mobZoneId: number | null
    mobId: number | null
    roomZoneId: number | null
    roomId: number | null
    zoneId: number | null
    probability: number | null
  }

  export type MobResetMinAggregateOutputType = {
    id: string | null
    max: number | null
    name: string | null
    mobZoneId: number | null
    mobId: number | null
    roomZoneId: number | null
    roomId: number | null
    zoneId: number | null
    probability: number | null
  }

  export type MobResetMaxAggregateOutputType = {
    id: string | null
    max: number | null
    name: string | null
    mobZoneId: number | null
    mobId: number | null
    roomZoneId: number | null
    roomId: number | null
    zoneId: number | null
    probability: number | null
  }

  export type MobResetCountAggregateOutputType = {
    id: number
    max: number
    name: number
    mobZoneId: number
    mobId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability: number
    _all: number
  }


  export type MobResetAvgAggregateInputType = {
    max?: true
    mobZoneId?: true
    mobId?: true
    roomZoneId?: true
    roomId?: true
    zoneId?: true
    probability?: true
  }

  export type MobResetSumAggregateInputType = {
    max?: true
    mobZoneId?: true
    mobId?: true
    roomZoneId?: true
    roomId?: true
    zoneId?: true
    probability?: true
  }

  export type MobResetMinAggregateInputType = {
    id?: true
    max?: true
    name?: true
    mobZoneId?: true
    mobId?: true
    roomZoneId?: true
    roomId?: true
    zoneId?: true
    probability?: true
  }

  export type MobResetMaxAggregateInputType = {
    id?: true
    max?: true
    name?: true
    mobZoneId?: true
    mobId?: true
    roomZoneId?: true
    roomId?: true
    zoneId?: true
    probability?: true
  }

  export type MobResetCountAggregateInputType = {
    id?: true
    max?: true
    name?: true
    mobZoneId?: true
    mobId?: true
    roomZoneId?: true
    roomId?: true
    zoneId?: true
    probability?: true
    _all?: true
  }

  export type MobResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobReset to aggregate.
     */
    where?: MobResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobResets to fetch.
     */
    orderBy?: MobResetOrderByWithRelationInput | MobResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MobResets
    **/
    _count?: true | MobResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MobResetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MobResetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobResetMaxAggregateInputType
  }

  export type GetMobResetAggregateType<T extends MobResetAggregateArgs> = {
        [P in keyof T & keyof AggregateMobReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMobReset[P]>
      : GetScalarType<T[P], AggregateMobReset[P]>
  }




  export type MobResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobResetWhereInput
    orderBy?: MobResetOrderByWithAggregationInput | MobResetOrderByWithAggregationInput[]
    by: MobResetScalarFieldEnum[] | MobResetScalarFieldEnum
    having?: MobResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobResetCountAggregateInputType | true
    _avg?: MobResetAvgAggregateInputType
    _sum?: MobResetSumAggregateInputType
    _min?: MobResetMinAggregateInputType
    _max?: MobResetMaxAggregateInputType
  }

  export type MobResetGroupByOutputType = {
    id: string
    max: number
    name: string | null
    mobZoneId: number
    mobId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability: number
    _count: MobResetCountAggregateOutputType | null
    _avg: MobResetAvgAggregateOutputType | null
    _sum: MobResetSumAggregateOutputType | null
    _min: MobResetMinAggregateOutputType | null
    _max: MobResetMaxAggregateOutputType | null
  }

  type GetMobResetGroupByPayload<T extends MobResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobResetGroupByOutputType[P]>
            : GetScalarType<T[P], MobResetGroupByOutputType[P]>
        }
      >
    >


  export type MobResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    name?: boolean
    mobZoneId?: boolean
    mobId?: boolean
    roomZoneId?: boolean
    roomId?: boolean
    zoneId?: boolean
    probability?: boolean
    carrying?: boolean | MobReset$carryingArgs<ExtArgs>
    equipmentSets?: boolean | MobReset$equipmentSetsArgs<ExtArgs>
    equipped?: boolean | MobReset$equippedArgs<ExtArgs>
    mob?: boolean | MobDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    spawnConditions?: boolean | MobReset$spawnConditionsArgs<ExtArgs>
    _count?: boolean | MobResetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobReset"]>

  export type MobResetSelectScalar = {
    id?: boolean
    max?: boolean
    name?: boolean
    mobZoneId?: boolean
    mobId?: boolean
    roomZoneId?: boolean
    roomId?: boolean
    zoneId?: boolean
    probability?: boolean
  }

  export type MobResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrying?: boolean | MobReset$carryingArgs<ExtArgs>
    equipmentSets?: boolean | MobReset$equipmentSetsArgs<ExtArgs>
    equipped?: boolean | MobReset$equippedArgs<ExtArgs>
    mob?: boolean | MobDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    spawnConditions?: boolean | MobReset$spawnConditionsArgs<ExtArgs>
    _count?: boolean | MobResetCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MobResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MobReset"
    objects: {
      carrying: Prisma.$MobCarryingPayload<ExtArgs>[]
      equipmentSets: Prisma.$MobEquipmentSetPayload<ExtArgs>[]
      equipped: Prisma.$MobEquippedPayload<ExtArgs>[]
      mob: Prisma.$MobPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs>
      spawnConditions: Prisma.$SpawnConditionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      max: number
      name: string | null
      mobZoneId: number
      mobId: number
      roomZoneId: number
      roomId: number
      zoneId: number
      probability: number
    }, ExtArgs["result"]["mobReset"]>
    composites: {}
  }


  type MobResetGetPayload<S extends boolean | null | undefined | MobResetDefaultArgs> = $Result.GetResult<Prisma.$MobResetPayload, S>

  type MobResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MobResetFindManyArgs, 'select' | 'include'> & {
      select?: MobResetCountAggregateInputType | true
    }

  export interface MobResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MobReset'], meta: { name: 'MobReset' } }
    /**
     * Find zero or one MobReset that matches the filter.
     * @param {MobResetFindUniqueArgs} args - Arguments to find a MobReset
     * @example
     * // Get one MobReset
     * const mobReset = await prisma.mobReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MobResetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MobResetFindUniqueArgs<ExtArgs>>
    ): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MobReset that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MobResetFindUniqueOrThrowArgs} args - Arguments to find a MobReset
     * @example
     * // Get one MobReset
     * const mobReset = await prisma.mobReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MobResetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobResetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MobReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobResetFindFirstArgs} args - Arguments to find a MobReset
     * @example
     * // Get one MobReset
     * const mobReset = await prisma.mobReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MobResetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MobResetFindFirstArgs<ExtArgs>>
    ): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MobReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobResetFindFirstOrThrowArgs} args - Arguments to find a MobReset
     * @example
     * // Get one MobReset
     * const mobReset = await prisma.mobReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MobResetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobResetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MobResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobResetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MobResets
     * const mobResets = await prisma.mobReset.findMany()
     * 
     * // Get first 10 MobResets
     * const mobResets = await prisma.mobReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mobResetWithIdOnly = await prisma.mobReset.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MobResetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobResetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MobReset.
     * @param {MobResetCreateArgs} args - Arguments to create a MobReset.
     * @example
     * // Create one MobReset
     * const MobReset = await prisma.mobReset.create({
     *   data: {
     *     // ... data to create a MobReset
     *   }
     * })
     * 
    **/
    create<T extends MobResetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MobResetCreateArgs<ExtArgs>>
    ): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MobResets.
     *     @param {MobResetCreateManyArgs} args - Arguments to create many MobResets.
     *     @example
     *     // Create many MobResets
     *     const mobReset = await prisma.mobReset.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MobResetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobResetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MobReset.
     * @param {MobResetDeleteArgs} args - Arguments to delete one MobReset.
     * @example
     * // Delete one MobReset
     * const MobReset = await prisma.mobReset.delete({
     *   where: {
     *     // ... filter to delete one MobReset
     *   }
     * })
     * 
    **/
    delete<T extends MobResetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MobResetDeleteArgs<ExtArgs>>
    ): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MobReset.
     * @param {MobResetUpdateArgs} args - Arguments to update one MobReset.
     * @example
     * // Update one MobReset
     * const mobReset = await prisma.mobReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MobResetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MobResetUpdateArgs<ExtArgs>>
    ): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MobResets.
     * @param {MobResetDeleteManyArgs} args - Arguments to filter MobResets to delete.
     * @example
     * // Delete a few MobResets
     * const { count } = await prisma.mobReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MobResetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobResetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MobResets
     * const mobReset = await prisma.mobReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MobResetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MobResetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MobReset.
     * @param {MobResetUpsertArgs} args - Arguments to update or create a MobReset.
     * @example
     * // Update or create a MobReset
     * const mobReset = await prisma.mobReset.upsert({
     *   create: {
     *     // ... data to create a MobReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MobReset we want to update
     *   }
     * })
    **/
    upsert<T extends MobResetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MobResetUpsertArgs<ExtArgs>>
    ): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MobResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobResetCountArgs} args - Arguments to filter MobResets to count.
     * @example
     * // Count the number of MobResets
     * const count = await prisma.mobReset.count({
     *   where: {
     *     // ... the filter for the MobResets we want to count
     *   }
     * })
    **/
    count<T extends MobResetCountArgs>(
      args?: Subset<T, MobResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MobReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobResetAggregateArgs>(args: Subset<T, MobResetAggregateArgs>): Prisma.PrismaPromise<GetMobResetAggregateType<T>>

    /**
     * Group by MobReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobResetGroupByArgs['orderBy'] }
        : { orderBy?: MobResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MobReset model
   */
  readonly fields: MobResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MobReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    carrying<T extends MobReset$carryingArgs<ExtArgs> = {}>(args?: Subset<T, MobReset$carryingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'findMany'> | Null>;

    equipmentSets<T extends MobReset$equipmentSetsArgs<ExtArgs> = {}>(args?: Subset<T, MobReset$equipmentSetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'findMany'> | Null>;

    equipped<T extends MobReset$equippedArgs<ExtArgs> = {}>(args?: Subset<T, MobReset$equippedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'findMany'> | Null>;

    mob<T extends MobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MobDefaultArgs<ExtArgs>>): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    spawnConditions<T extends MobReset$spawnConditionsArgs<ExtArgs> = {}>(args?: Subset<T, MobReset$spawnConditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MobReset model
   */ 
  interface MobResetFieldRefs {
    readonly id: FieldRef<"MobReset", 'String'>
    readonly max: FieldRef<"MobReset", 'Int'>
    readonly name: FieldRef<"MobReset", 'String'>
    readonly mobZoneId: FieldRef<"MobReset", 'Int'>
    readonly mobId: FieldRef<"MobReset", 'Int'>
    readonly roomZoneId: FieldRef<"MobReset", 'Int'>
    readonly roomId: FieldRef<"MobReset", 'Int'>
    readonly zoneId: FieldRef<"MobReset", 'Int'>
    readonly probability: FieldRef<"MobReset", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * MobReset findUnique
   */
  export type MobResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    /**
     * Filter, which MobReset to fetch.
     */
    where: MobResetWhereUniqueInput
  }


  /**
   * MobReset findUniqueOrThrow
   */
  export type MobResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    /**
     * Filter, which MobReset to fetch.
     */
    where: MobResetWhereUniqueInput
  }


  /**
   * MobReset findFirst
   */
  export type MobResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    /**
     * Filter, which MobReset to fetch.
     */
    where?: MobResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobResets to fetch.
     */
    orderBy?: MobResetOrderByWithRelationInput | MobResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobResets.
     */
    cursor?: MobResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobResets.
     */
    distinct?: MobResetScalarFieldEnum | MobResetScalarFieldEnum[]
  }


  /**
   * MobReset findFirstOrThrow
   */
  export type MobResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    /**
     * Filter, which MobReset to fetch.
     */
    where?: MobResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobResets to fetch.
     */
    orderBy?: MobResetOrderByWithRelationInput | MobResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobResets.
     */
    cursor?: MobResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobResets.
     */
    distinct?: MobResetScalarFieldEnum | MobResetScalarFieldEnum[]
  }


  /**
   * MobReset findMany
   */
  export type MobResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    /**
     * Filter, which MobResets to fetch.
     */
    where?: MobResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobResets to fetch.
     */
    orderBy?: MobResetOrderByWithRelationInput | MobResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MobResets.
     */
    cursor?: MobResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobResets.
     */
    skip?: number
    distinct?: MobResetScalarFieldEnum | MobResetScalarFieldEnum[]
  }


  /**
   * MobReset create
   */
  export type MobResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    /**
     * The data needed to create a MobReset.
     */
    data: XOR<MobResetCreateInput, MobResetUncheckedCreateInput>
  }


  /**
   * MobReset createMany
   */
  export type MobResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MobResets.
     */
    data: MobResetCreateManyInput | MobResetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MobReset update
   */
  export type MobResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    /**
     * The data needed to update a MobReset.
     */
    data: XOR<MobResetUpdateInput, MobResetUncheckedUpdateInput>
    /**
     * Choose, which MobReset to update.
     */
    where: MobResetWhereUniqueInput
  }


  /**
   * MobReset updateMany
   */
  export type MobResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MobResets.
     */
    data: XOR<MobResetUpdateManyMutationInput, MobResetUncheckedUpdateManyInput>
    /**
     * Filter which MobResets to update
     */
    where?: MobResetWhereInput
  }


  /**
   * MobReset upsert
   */
  export type MobResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    /**
     * The filter to search for the MobReset to update in case it exists.
     */
    where: MobResetWhereUniqueInput
    /**
     * In case the MobReset found by the `where` argument doesn't exist, create a new MobReset with this data.
     */
    create: XOR<MobResetCreateInput, MobResetUncheckedCreateInput>
    /**
     * In case the MobReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobResetUpdateInput, MobResetUncheckedUpdateInput>
  }


  /**
   * MobReset delete
   */
  export type MobResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    /**
     * Filter which MobReset to delete.
     */
    where: MobResetWhereUniqueInput
  }


  /**
   * MobReset deleteMany
   */
  export type MobResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobResets to delete
     */
    where?: MobResetWhereInput
  }


  /**
   * MobReset.carrying
   */
  export type MobReset$carryingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    where?: MobCarryingWhereInput
    orderBy?: MobCarryingOrderByWithRelationInput | MobCarryingOrderByWithRelationInput[]
    cursor?: MobCarryingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobCarryingScalarFieldEnum | MobCarryingScalarFieldEnum[]
  }


  /**
   * MobReset.equipmentSets
   */
  export type MobReset$equipmentSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    where?: MobEquipmentSetWhereInput
    orderBy?: MobEquipmentSetOrderByWithRelationInput | MobEquipmentSetOrderByWithRelationInput[]
    cursor?: MobEquipmentSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobEquipmentSetScalarFieldEnum | MobEquipmentSetScalarFieldEnum[]
  }


  /**
   * MobReset.equipped
   */
  export type MobReset$equippedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    where?: MobEquippedWhereInput
    orderBy?: MobEquippedOrderByWithRelationInput | MobEquippedOrderByWithRelationInput[]
    cursor?: MobEquippedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobEquippedScalarFieldEnum | MobEquippedScalarFieldEnum[]
  }


  /**
   * MobReset.spawnConditions
   */
  export type MobReset$spawnConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    where?: SpawnConditionWhereInput
    orderBy?: SpawnConditionOrderByWithRelationInput | SpawnConditionOrderByWithRelationInput[]
    cursor?: SpawnConditionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpawnConditionScalarFieldEnum | SpawnConditionScalarFieldEnum[]
  }


  /**
   * MobReset without action
   */
  export type MobResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
  }



  /**
   * Model MobCarrying
   */

  export type AggregateMobCarrying = {
    _count: MobCarryingCountAggregateOutputType | null
    _avg: MobCarryingAvgAggregateOutputType | null
    _sum: MobCarryingSumAggregateOutputType | null
    _min: MobCarryingMinAggregateOutputType | null
    _max: MobCarryingMaxAggregateOutputType | null
  }

  export type MobCarryingAvgAggregateOutputType = {
    max: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type MobCarryingSumAggregateOutputType = {
    max: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type MobCarryingMinAggregateOutputType = {
    id: string | null
    max: number | null
    name: string | null
    objectZoneId: number | null
    objectId: number | null
    resetId: string | null
  }

  export type MobCarryingMaxAggregateOutputType = {
    id: string | null
    max: number | null
    name: string | null
    objectZoneId: number | null
    objectId: number | null
    resetId: string | null
  }

  export type MobCarryingCountAggregateOutputType = {
    id: number
    max: number
    name: number
    objectZoneId: number
    objectId: number
    resetId: number
    _all: number
  }


  export type MobCarryingAvgAggregateInputType = {
    max?: true
    objectZoneId?: true
    objectId?: true
  }

  export type MobCarryingSumAggregateInputType = {
    max?: true
    objectZoneId?: true
    objectId?: true
  }

  export type MobCarryingMinAggregateInputType = {
    id?: true
    max?: true
    name?: true
    objectZoneId?: true
    objectId?: true
    resetId?: true
  }

  export type MobCarryingMaxAggregateInputType = {
    id?: true
    max?: true
    name?: true
    objectZoneId?: true
    objectId?: true
    resetId?: true
  }

  export type MobCarryingCountAggregateInputType = {
    id?: true
    max?: true
    name?: true
    objectZoneId?: true
    objectId?: true
    resetId?: true
    _all?: true
  }

  export type MobCarryingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobCarrying to aggregate.
     */
    where?: MobCarryingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobCarryings to fetch.
     */
    orderBy?: MobCarryingOrderByWithRelationInput | MobCarryingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobCarryingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobCarryings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobCarryings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MobCarryings
    **/
    _count?: true | MobCarryingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MobCarryingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MobCarryingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobCarryingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobCarryingMaxAggregateInputType
  }

  export type GetMobCarryingAggregateType<T extends MobCarryingAggregateArgs> = {
        [P in keyof T & keyof AggregateMobCarrying]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMobCarrying[P]>
      : GetScalarType<T[P], AggregateMobCarrying[P]>
  }




  export type MobCarryingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobCarryingWhereInput
    orderBy?: MobCarryingOrderByWithAggregationInput | MobCarryingOrderByWithAggregationInput[]
    by: MobCarryingScalarFieldEnum[] | MobCarryingScalarFieldEnum
    having?: MobCarryingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobCarryingCountAggregateInputType | true
    _avg?: MobCarryingAvgAggregateInputType
    _sum?: MobCarryingSumAggregateInputType
    _min?: MobCarryingMinAggregateInputType
    _max?: MobCarryingMaxAggregateInputType
  }

  export type MobCarryingGroupByOutputType = {
    id: string
    max: number
    name: string | null
    objectZoneId: number
    objectId: number
    resetId: string
    _count: MobCarryingCountAggregateOutputType | null
    _avg: MobCarryingAvgAggregateOutputType | null
    _sum: MobCarryingSumAggregateOutputType | null
    _min: MobCarryingMinAggregateOutputType | null
    _max: MobCarryingMaxAggregateOutputType | null
  }

  type GetMobCarryingGroupByPayload<T extends MobCarryingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobCarryingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobCarryingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobCarryingGroupByOutputType[P]>
            : GetScalarType<T[P], MobCarryingGroupByOutputType[P]>
        }
      >
    >


  export type MobCarryingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    name?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    resetId?: boolean
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    reset?: boolean | MobResetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobCarrying"]>

  export type MobCarryingSelectScalar = {
    id?: boolean
    max?: boolean
    name?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    resetId?: boolean
  }

  export type MobCarryingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    reset?: boolean | MobResetDefaultArgs<ExtArgs>
  }


  export type $MobCarryingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MobCarrying"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>
      reset: Prisma.$MobResetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      max: number
      name: string | null
      objectZoneId: number
      objectId: number
      resetId: string
    }, ExtArgs["result"]["mobCarrying"]>
    composites: {}
  }


  type MobCarryingGetPayload<S extends boolean | null | undefined | MobCarryingDefaultArgs> = $Result.GetResult<Prisma.$MobCarryingPayload, S>

  type MobCarryingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MobCarryingFindManyArgs, 'select' | 'include'> & {
      select?: MobCarryingCountAggregateInputType | true
    }

  export interface MobCarryingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MobCarrying'], meta: { name: 'MobCarrying' } }
    /**
     * Find zero or one MobCarrying that matches the filter.
     * @param {MobCarryingFindUniqueArgs} args - Arguments to find a MobCarrying
     * @example
     * // Get one MobCarrying
     * const mobCarrying = await prisma.mobCarrying.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MobCarryingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MobCarryingFindUniqueArgs<ExtArgs>>
    ): Prisma__MobCarryingClient<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MobCarrying that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MobCarryingFindUniqueOrThrowArgs} args - Arguments to find a MobCarrying
     * @example
     * // Get one MobCarrying
     * const mobCarrying = await prisma.mobCarrying.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MobCarryingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobCarryingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MobCarryingClient<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MobCarrying that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobCarryingFindFirstArgs} args - Arguments to find a MobCarrying
     * @example
     * // Get one MobCarrying
     * const mobCarrying = await prisma.mobCarrying.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MobCarryingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MobCarryingFindFirstArgs<ExtArgs>>
    ): Prisma__MobCarryingClient<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MobCarrying that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobCarryingFindFirstOrThrowArgs} args - Arguments to find a MobCarrying
     * @example
     * // Get one MobCarrying
     * const mobCarrying = await prisma.mobCarrying.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MobCarryingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobCarryingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MobCarryingClient<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MobCarryings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobCarryingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MobCarryings
     * const mobCarryings = await prisma.mobCarrying.findMany()
     * 
     * // Get first 10 MobCarryings
     * const mobCarryings = await prisma.mobCarrying.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mobCarryingWithIdOnly = await prisma.mobCarrying.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MobCarryingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobCarryingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MobCarrying.
     * @param {MobCarryingCreateArgs} args - Arguments to create a MobCarrying.
     * @example
     * // Create one MobCarrying
     * const MobCarrying = await prisma.mobCarrying.create({
     *   data: {
     *     // ... data to create a MobCarrying
     *   }
     * })
     * 
    **/
    create<T extends MobCarryingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MobCarryingCreateArgs<ExtArgs>>
    ): Prisma__MobCarryingClient<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MobCarryings.
     *     @param {MobCarryingCreateManyArgs} args - Arguments to create many MobCarryings.
     *     @example
     *     // Create many MobCarryings
     *     const mobCarrying = await prisma.mobCarrying.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MobCarryingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobCarryingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MobCarrying.
     * @param {MobCarryingDeleteArgs} args - Arguments to delete one MobCarrying.
     * @example
     * // Delete one MobCarrying
     * const MobCarrying = await prisma.mobCarrying.delete({
     *   where: {
     *     // ... filter to delete one MobCarrying
     *   }
     * })
     * 
    **/
    delete<T extends MobCarryingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MobCarryingDeleteArgs<ExtArgs>>
    ): Prisma__MobCarryingClient<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MobCarrying.
     * @param {MobCarryingUpdateArgs} args - Arguments to update one MobCarrying.
     * @example
     * // Update one MobCarrying
     * const mobCarrying = await prisma.mobCarrying.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MobCarryingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MobCarryingUpdateArgs<ExtArgs>>
    ): Prisma__MobCarryingClient<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MobCarryings.
     * @param {MobCarryingDeleteManyArgs} args - Arguments to filter MobCarryings to delete.
     * @example
     * // Delete a few MobCarryings
     * const { count } = await prisma.mobCarrying.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MobCarryingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobCarryingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobCarryings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobCarryingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MobCarryings
     * const mobCarrying = await prisma.mobCarrying.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MobCarryingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MobCarryingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MobCarrying.
     * @param {MobCarryingUpsertArgs} args - Arguments to update or create a MobCarrying.
     * @example
     * // Update or create a MobCarrying
     * const mobCarrying = await prisma.mobCarrying.upsert({
     *   create: {
     *     // ... data to create a MobCarrying
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MobCarrying we want to update
     *   }
     * })
    **/
    upsert<T extends MobCarryingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MobCarryingUpsertArgs<ExtArgs>>
    ): Prisma__MobCarryingClient<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MobCarryings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobCarryingCountArgs} args - Arguments to filter MobCarryings to count.
     * @example
     * // Count the number of MobCarryings
     * const count = await prisma.mobCarrying.count({
     *   where: {
     *     // ... the filter for the MobCarryings we want to count
     *   }
     * })
    **/
    count<T extends MobCarryingCountArgs>(
      args?: Subset<T, MobCarryingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobCarryingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MobCarrying.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobCarryingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobCarryingAggregateArgs>(args: Subset<T, MobCarryingAggregateArgs>): Prisma.PrismaPromise<GetMobCarryingAggregateType<T>>

    /**
     * Group by MobCarrying.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobCarryingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobCarryingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobCarryingGroupByArgs['orderBy'] }
        : { orderBy?: MobCarryingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobCarryingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobCarryingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MobCarrying model
   */
  readonly fields: MobCarryingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MobCarrying.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobCarryingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    reset<T extends MobResetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MobResetDefaultArgs<ExtArgs>>): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MobCarrying model
   */ 
  interface MobCarryingFieldRefs {
    readonly id: FieldRef<"MobCarrying", 'String'>
    readonly max: FieldRef<"MobCarrying", 'Int'>
    readonly name: FieldRef<"MobCarrying", 'String'>
    readonly objectZoneId: FieldRef<"MobCarrying", 'Int'>
    readonly objectId: FieldRef<"MobCarrying", 'Int'>
    readonly resetId: FieldRef<"MobCarrying", 'String'>
  }
    

  // Custom InputTypes

  /**
   * MobCarrying findUnique
   */
  export type MobCarryingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    /**
     * Filter, which MobCarrying to fetch.
     */
    where: MobCarryingWhereUniqueInput
  }


  /**
   * MobCarrying findUniqueOrThrow
   */
  export type MobCarryingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    /**
     * Filter, which MobCarrying to fetch.
     */
    where: MobCarryingWhereUniqueInput
  }


  /**
   * MobCarrying findFirst
   */
  export type MobCarryingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    /**
     * Filter, which MobCarrying to fetch.
     */
    where?: MobCarryingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobCarryings to fetch.
     */
    orderBy?: MobCarryingOrderByWithRelationInput | MobCarryingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobCarryings.
     */
    cursor?: MobCarryingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobCarryings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobCarryings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobCarryings.
     */
    distinct?: MobCarryingScalarFieldEnum | MobCarryingScalarFieldEnum[]
  }


  /**
   * MobCarrying findFirstOrThrow
   */
  export type MobCarryingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    /**
     * Filter, which MobCarrying to fetch.
     */
    where?: MobCarryingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobCarryings to fetch.
     */
    orderBy?: MobCarryingOrderByWithRelationInput | MobCarryingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobCarryings.
     */
    cursor?: MobCarryingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobCarryings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobCarryings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobCarryings.
     */
    distinct?: MobCarryingScalarFieldEnum | MobCarryingScalarFieldEnum[]
  }


  /**
   * MobCarrying findMany
   */
  export type MobCarryingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    /**
     * Filter, which MobCarryings to fetch.
     */
    where?: MobCarryingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobCarryings to fetch.
     */
    orderBy?: MobCarryingOrderByWithRelationInput | MobCarryingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MobCarryings.
     */
    cursor?: MobCarryingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobCarryings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobCarryings.
     */
    skip?: number
    distinct?: MobCarryingScalarFieldEnum | MobCarryingScalarFieldEnum[]
  }


  /**
   * MobCarrying create
   */
  export type MobCarryingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    /**
     * The data needed to create a MobCarrying.
     */
    data: XOR<MobCarryingCreateInput, MobCarryingUncheckedCreateInput>
  }


  /**
   * MobCarrying createMany
   */
  export type MobCarryingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MobCarryings.
     */
    data: MobCarryingCreateManyInput | MobCarryingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MobCarrying update
   */
  export type MobCarryingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    /**
     * The data needed to update a MobCarrying.
     */
    data: XOR<MobCarryingUpdateInput, MobCarryingUncheckedUpdateInput>
    /**
     * Choose, which MobCarrying to update.
     */
    where: MobCarryingWhereUniqueInput
  }


  /**
   * MobCarrying updateMany
   */
  export type MobCarryingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MobCarryings.
     */
    data: XOR<MobCarryingUpdateManyMutationInput, MobCarryingUncheckedUpdateManyInput>
    /**
     * Filter which MobCarryings to update
     */
    where?: MobCarryingWhereInput
  }


  /**
   * MobCarrying upsert
   */
  export type MobCarryingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    /**
     * The filter to search for the MobCarrying to update in case it exists.
     */
    where: MobCarryingWhereUniqueInput
    /**
     * In case the MobCarrying found by the `where` argument doesn't exist, create a new MobCarrying with this data.
     */
    create: XOR<MobCarryingCreateInput, MobCarryingUncheckedCreateInput>
    /**
     * In case the MobCarrying was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobCarryingUpdateInput, MobCarryingUncheckedUpdateInput>
  }


  /**
   * MobCarrying delete
   */
  export type MobCarryingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    /**
     * Filter which MobCarrying to delete.
     */
    where: MobCarryingWhereUniqueInput
  }


  /**
   * MobCarrying deleteMany
   */
  export type MobCarryingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobCarryings to delete
     */
    where?: MobCarryingWhereInput
  }


  /**
   * MobCarrying without action
   */
  export type MobCarryingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
  }



  /**
   * Model MobEquipped
   */

  export type AggregateMobEquipped = {
    _count: MobEquippedCountAggregateOutputType | null
    _avg: MobEquippedAvgAggregateOutputType | null
    _sum: MobEquippedSumAggregateOutputType | null
    _min: MobEquippedMinAggregateOutputType | null
    _max: MobEquippedMaxAggregateOutputType | null
  }

  export type MobEquippedAvgAggregateOutputType = {
    max: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type MobEquippedSumAggregateOutputType = {
    max: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type MobEquippedMinAggregateOutputType = {
    id: string | null
    max: number | null
    location: string | null
    name: string | null
    objectZoneId: number | null
    objectId: number | null
    resetId: string | null
  }

  export type MobEquippedMaxAggregateOutputType = {
    id: string | null
    max: number | null
    location: string | null
    name: string | null
    objectZoneId: number | null
    objectId: number | null
    resetId: string | null
  }

  export type MobEquippedCountAggregateOutputType = {
    id: number
    max: number
    location: number
    name: number
    objectZoneId: number
    objectId: number
    resetId: number
    _all: number
  }


  export type MobEquippedAvgAggregateInputType = {
    max?: true
    objectZoneId?: true
    objectId?: true
  }

  export type MobEquippedSumAggregateInputType = {
    max?: true
    objectZoneId?: true
    objectId?: true
  }

  export type MobEquippedMinAggregateInputType = {
    id?: true
    max?: true
    location?: true
    name?: true
    objectZoneId?: true
    objectId?: true
    resetId?: true
  }

  export type MobEquippedMaxAggregateInputType = {
    id?: true
    max?: true
    location?: true
    name?: true
    objectZoneId?: true
    objectId?: true
    resetId?: true
  }

  export type MobEquippedCountAggregateInputType = {
    id?: true
    max?: true
    location?: true
    name?: true
    objectZoneId?: true
    objectId?: true
    resetId?: true
    _all?: true
  }

  export type MobEquippedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobEquipped to aggregate.
     */
    where?: MobEquippedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobEquippeds to fetch.
     */
    orderBy?: MobEquippedOrderByWithRelationInput | MobEquippedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobEquippedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobEquippeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobEquippeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MobEquippeds
    **/
    _count?: true | MobEquippedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MobEquippedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MobEquippedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobEquippedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobEquippedMaxAggregateInputType
  }

  export type GetMobEquippedAggregateType<T extends MobEquippedAggregateArgs> = {
        [P in keyof T & keyof AggregateMobEquipped]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMobEquipped[P]>
      : GetScalarType<T[P], AggregateMobEquipped[P]>
  }




  export type MobEquippedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobEquippedWhereInput
    orderBy?: MobEquippedOrderByWithAggregationInput | MobEquippedOrderByWithAggregationInput[]
    by: MobEquippedScalarFieldEnum[] | MobEquippedScalarFieldEnum
    having?: MobEquippedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobEquippedCountAggregateInputType | true
    _avg?: MobEquippedAvgAggregateInputType
    _sum?: MobEquippedSumAggregateInputType
    _min?: MobEquippedMinAggregateInputType
    _max?: MobEquippedMaxAggregateInputType
  }

  export type MobEquippedGroupByOutputType = {
    id: string
    max: number
    location: string
    name: string | null
    objectZoneId: number
    objectId: number
    resetId: string
    _count: MobEquippedCountAggregateOutputType | null
    _avg: MobEquippedAvgAggregateOutputType | null
    _sum: MobEquippedSumAggregateOutputType | null
    _min: MobEquippedMinAggregateOutputType | null
    _max: MobEquippedMaxAggregateOutputType | null
  }

  type GetMobEquippedGroupByPayload<T extends MobEquippedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobEquippedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobEquippedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobEquippedGroupByOutputType[P]>
            : GetScalarType<T[P], MobEquippedGroupByOutputType[P]>
        }
      >
    >


  export type MobEquippedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    location?: boolean
    name?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    resetId?: boolean
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    reset?: boolean | MobResetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobEquipped"]>

  export type MobEquippedSelectScalar = {
    id?: boolean
    max?: boolean
    location?: boolean
    name?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    resetId?: boolean
  }

  export type MobEquippedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    reset?: boolean | MobResetDefaultArgs<ExtArgs>
  }


  export type $MobEquippedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MobEquipped"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>
      reset: Prisma.$MobResetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      max: number
      location: string
      name: string | null
      objectZoneId: number
      objectId: number
      resetId: string
    }, ExtArgs["result"]["mobEquipped"]>
    composites: {}
  }


  type MobEquippedGetPayload<S extends boolean | null | undefined | MobEquippedDefaultArgs> = $Result.GetResult<Prisma.$MobEquippedPayload, S>

  type MobEquippedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MobEquippedFindManyArgs, 'select' | 'include'> & {
      select?: MobEquippedCountAggregateInputType | true
    }

  export interface MobEquippedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MobEquipped'], meta: { name: 'MobEquipped' } }
    /**
     * Find zero or one MobEquipped that matches the filter.
     * @param {MobEquippedFindUniqueArgs} args - Arguments to find a MobEquipped
     * @example
     * // Get one MobEquipped
     * const mobEquipped = await prisma.mobEquipped.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MobEquippedFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquippedFindUniqueArgs<ExtArgs>>
    ): Prisma__MobEquippedClient<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MobEquipped that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MobEquippedFindUniqueOrThrowArgs} args - Arguments to find a MobEquipped
     * @example
     * // Get one MobEquipped
     * const mobEquipped = await prisma.mobEquipped.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MobEquippedFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquippedFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MobEquippedClient<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MobEquipped that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquippedFindFirstArgs} args - Arguments to find a MobEquipped
     * @example
     * // Get one MobEquipped
     * const mobEquipped = await prisma.mobEquipped.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MobEquippedFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquippedFindFirstArgs<ExtArgs>>
    ): Prisma__MobEquippedClient<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MobEquipped that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquippedFindFirstOrThrowArgs} args - Arguments to find a MobEquipped
     * @example
     * // Get one MobEquipped
     * const mobEquipped = await prisma.mobEquipped.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MobEquippedFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquippedFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MobEquippedClient<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MobEquippeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquippedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MobEquippeds
     * const mobEquippeds = await prisma.mobEquipped.findMany()
     * 
     * // Get first 10 MobEquippeds
     * const mobEquippeds = await prisma.mobEquipped.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mobEquippedWithIdOnly = await prisma.mobEquipped.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MobEquippedFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquippedFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MobEquipped.
     * @param {MobEquippedCreateArgs} args - Arguments to create a MobEquipped.
     * @example
     * // Create one MobEquipped
     * const MobEquipped = await prisma.mobEquipped.create({
     *   data: {
     *     // ... data to create a MobEquipped
     *   }
     * })
     * 
    **/
    create<T extends MobEquippedCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquippedCreateArgs<ExtArgs>>
    ): Prisma__MobEquippedClient<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MobEquippeds.
     *     @param {MobEquippedCreateManyArgs} args - Arguments to create many MobEquippeds.
     *     @example
     *     // Create many MobEquippeds
     *     const mobEquipped = await prisma.mobEquipped.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MobEquippedCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquippedCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MobEquipped.
     * @param {MobEquippedDeleteArgs} args - Arguments to delete one MobEquipped.
     * @example
     * // Delete one MobEquipped
     * const MobEquipped = await prisma.mobEquipped.delete({
     *   where: {
     *     // ... filter to delete one MobEquipped
     *   }
     * })
     * 
    **/
    delete<T extends MobEquippedDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquippedDeleteArgs<ExtArgs>>
    ): Prisma__MobEquippedClient<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MobEquipped.
     * @param {MobEquippedUpdateArgs} args - Arguments to update one MobEquipped.
     * @example
     * // Update one MobEquipped
     * const mobEquipped = await prisma.mobEquipped.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MobEquippedUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquippedUpdateArgs<ExtArgs>>
    ): Prisma__MobEquippedClient<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MobEquippeds.
     * @param {MobEquippedDeleteManyArgs} args - Arguments to filter MobEquippeds to delete.
     * @example
     * // Delete a few MobEquippeds
     * const { count } = await prisma.mobEquipped.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MobEquippedDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquippedDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobEquippeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquippedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MobEquippeds
     * const mobEquipped = await prisma.mobEquipped.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MobEquippedUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquippedUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MobEquipped.
     * @param {MobEquippedUpsertArgs} args - Arguments to update or create a MobEquipped.
     * @example
     * // Update or create a MobEquipped
     * const mobEquipped = await prisma.mobEquipped.upsert({
     *   create: {
     *     // ... data to create a MobEquipped
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MobEquipped we want to update
     *   }
     * })
    **/
    upsert<T extends MobEquippedUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquippedUpsertArgs<ExtArgs>>
    ): Prisma__MobEquippedClient<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MobEquippeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquippedCountArgs} args - Arguments to filter MobEquippeds to count.
     * @example
     * // Count the number of MobEquippeds
     * const count = await prisma.mobEquipped.count({
     *   where: {
     *     // ... the filter for the MobEquippeds we want to count
     *   }
     * })
    **/
    count<T extends MobEquippedCountArgs>(
      args?: Subset<T, MobEquippedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobEquippedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MobEquipped.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquippedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobEquippedAggregateArgs>(args: Subset<T, MobEquippedAggregateArgs>): Prisma.PrismaPromise<GetMobEquippedAggregateType<T>>

    /**
     * Group by MobEquipped.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquippedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobEquippedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobEquippedGroupByArgs['orderBy'] }
        : { orderBy?: MobEquippedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobEquippedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobEquippedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MobEquipped model
   */
  readonly fields: MobEquippedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MobEquipped.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobEquippedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    reset<T extends MobResetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MobResetDefaultArgs<ExtArgs>>): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MobEquipped model
   */ 
  interface MobEquippedFieldRefs {
    readonly id: FieldRef<"MobEquipped", 'String'>
    readonly max: FieldRef<"MobEquipped", 'Int'>
    readonly location: FieldRef<"MobEquipped", 'String'>
    readonly name: FieldRef<"MobEquipped", 'String'>
    readonly objectZoneId: FieldRef<"MobEquipped", 'Int'>
    readonly objectId: FieldRef<"MobEquipped", 'Int'>
    readonly resetId: FieldRef<"MobEquipped", 'String'>
  }
    

  // Custom InputTypes

  /**
   * MobEquipped findUnique
   */
  export type MobEquippedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    /**
     * Filter, which MobEquipped to fetch.
     */
    where: MobEquippedWhereUniqueInput
  }


  /**
   * MobEquipped findUniqueOrThrow
   */
  export type MobEquippedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    /**
     * Filter, which MobEquipped to fetch.
     */
    where: MobEquippedWhereUniqueInput
  }


  /**
   * MobEquipped findFirst
   */
  export type MobEquippedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    /**
     * Filter, which MobEquipped to fetch.
     */
    where?: MobEquippedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobEquippeds to fetch.
     */
    orderBy?: MobEquippedOrderByWithRelationInput | MobEquippedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobEquippeds.
     */
    cursor?: MobEquippedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobEquippeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobEquippeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobEquippeds.
     */
    distinct?: MobEquippedScalarFieldEnum | MobEquippedScalarFieldEnum[]
  }


  /**
   * MobEquipped findFirstOrThrow
   */
  export type MobEquippedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    /**
     * Filter, which MobEquipped to fetch.
     */
    where?: MobEquippedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobEquippeds to fetch.
     */
    orderBy?: MobEquippedOrderByWithRelationInput | MobEquippedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobEquippeds.
     */
    cursor?: MobEquippedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobEquippeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobEquippeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobEquippeds.
     */
    distinct?: MobEquippedScalarFieldEnum | MobEquippedScalarFieldEnum[]
  }


  /**
   * MobEquipped findMany
   */
  export type MobEquippedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    /**
     * Filter, which MobEquippeds to fetch.
     */
    where?: MobEquippedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobEquippeds to fetch.
     */
    orderBy?: MobEquippedOrderByWithRelationInput | MobEquippedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MobEquippeds.
     */
    cursor?: MobEquippedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobEquippeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobEquippeds.
     */
    skip?: number
    distinct?: MobEquippedScalarFieldEnum | MobEquippedScalarFieldEnum[]
  }


  /**
   * MobEquipped create
   */
  export type MobEquippedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    /**
     * The data needed to create a MobEquipped.
     */
    data: XOR<MobEquippedCreateInput, MobEquippedUncheckedCreateInput>
  }


  /**
   * MobEquipped createMany
   */
  export type MobEquippedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MobEquippeds.
     */
    data: MobEquippedCreateManyInput | MobEquippedCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MobEquipped update
   */
  export type MobEquippedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    /**
     * The data needed to update a MobEquipped.
     */
    data: XOR<MobEquippedUpdateInput, MobEquippedUncheckedUpdateInput>
    /**
     * Choose, which MobEquipped to update.
     */
    where: MobEquippedWhereUniqueInput
  }


  /**
   * MobEquipped updateMany
   */
  export type MobEquippedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MobEquippeds.
     */
    data: XOR<MobEquippedUpdateManyMutationInput, MobEquippedUncheckedUpdateManyInput>
    /**
     * Filter which MobEquippeds to update
     */
    where?: MobEquippedWhereInput
  }


  /**
   * MobEquipped upsert
   */
  export type MobEquippedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    /**
     * The filter to search for the MobEquipped to update in case it exists.
     */
    where: MobEquippedWhereUniqueInput
    /**
     * In case the MobEquipped found by the `where` argument doesn't exist, create a new MobEquipped with this data.
     */
    create: XOR<MobEquippedCreateInput, MobEquippedUncheckedCreateInput>
    /**
     * In case the MobEquipped was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobEquippedUpdateInput, MobEquippedUncheckedUpdateInput>
  }


  /**
   * MobEquipped delete
   */
  export type MobEquippedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    /**
     * Filter which MobEquipped to delete.
     */
    where: MobEquippedWhereUniqueInput
  }


  /**
   * MobEquipped deleteMany
   */
  export type MobEquippedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobEquippeds to delete
     */
    where?: MobEquippedWhereInput
  }


  /**
   * MobEquipped without action
   */
  export type MobEquippedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
  }



  /**
   * Model Object
   */

  export type AggregateObject = {
    _count: ObjectCountAggregateOutputType | null
    _avg: ObjectAvgAggregateOutputType | null
    _sum: ObjectSumAggregateOutputType | null
    _min: ObjectMinAggregateOutputType | null
    _max: ObjectMaxAggregateOutputType | null
  }

  export type ObjectAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    cost: number | null
    timer: number | null
    decomposeTimer: number | null
    level: number | null
    concealment: number | null
    zoneId: number | null
  }

  export type ObjectSumAggregateOutputType = {
    id: number | null
    weight: number | null
    cost: number | null
    timer: number | null
    decomposeTimer: number | null
    level: number | null
    concealment: number | null
    zoneId: number | null
  }

  export type ObjectMinAggregateOutputType = {
    id: number | null
    type: $Enums.ObjectType | null
    shortDesc: string | null
    description: string | null
    actionDesc: string | null
    weight: number | null
    cost: number | null
    timer: number | null
    decomposeTimer: number | null
    level: number | null
    concealment: number | null
    zoneId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ObjectMaxAggregateOutputType = {
    id: number | null
    type: $Enums.ObjectType | null
    shortDesc: string | null
    description: string | null
    actionDesc: string | null
    weight: number | null
    cost: number | null
    timer: number | null
    decomposeTimer: number | null
    level: number | null
    concealment: number | null
    zoneId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ObjectCountAggregateOutputType = {
    id: number
    type: number
    keywords: number
    shortDesc: number
    description: number
    actionDesc: number
    weight: number
    cost: number
    timer: number
    decomposeTimer: number
    level: number
    concealment: number
    values: number
    zoneId: number
    createdAt: number
    updatedAt: number
    deleted_at: number
    createdBy: number
    updatedBy: number
    flags: number
    effectFlags: number
    wearFlags: number
    _all: number
  }


  export type ObjectAvgAggregateInputType = {
    id?: true
    weight?: true
    cost?: true
    timer?: true
    decomposeTimer?: true
    level?: true
    concealment?: true
    zoneId?: true
  }

  export type ObjectSumAggregateInputType = {
    id?: true
    weight?: true
    cost?: true
    timer?: true
    decomposeTimer?: true
    level?: true
    concealment?: true
    zoneId?: true
  }

  export type ObjectMinAggregateInputType = {
    id?: true
    type?: true
    shortDesc?: true
    description?: true
    actionDesc?: true
    weight?: true
    cost?: true
    timer?: true
    decomposeTimer?: true
    level?: true
    concealment?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ObjectMaxAggregateInputType = {
    id?: true
    type?: true
    shortDesc?: true
    description?: true
    actionDesc?: true
    weight?: true
    cost?: true
    timer?: true
    decomposeTimer?: true
    level?: true
    concealment?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ObjectCountAggregateInputType = {
    id?: true
    type?: true
    keywords?: true
    shortDesc?: true
    description?: true
    actionDesc?: true
    weight?: true
    cost?: true
    timer?: true
    decomposeTimer?: true
    level?: true
    concealment?: true
    values?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    createdBy?: true
    updatedBy?: true
    flags?: true
    effectFlags?: true
    wearFlags?: true
    _all?: true
  }

  export type ObjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Object to aggregate.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Objects
    **/
    _count?: true | ObjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectMaxAggregateInputType
  }

  export type GetObjectAggregateType<T extends ObjectAggregateArgs> = {
        [P in keyof T & keyof AggregateObject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObject[P]>
      : GetScalarType<T[P], AggregateObject[P]>
  }




  export type ObjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithAggregationInput | ObjectOrderByWithAggregationInput[]
    by: ObjectScalarFieldEnum[] | ObjectScalarFieldEnum
    having?: ObjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectCountAggregateInputType | true
    _avg?: ObjectAvgAggregateInputType
    _sum?: ObjectSumAggregateInputType
    _min?: ObjectMinAggregateInputType
    _max?: ObjectMaxAggregateInputType
  }

  export type ObjectGroupByOutputType = {
    id: number
    type: $Enums.ObjectType
    keywords: string[]
    shortDesc: string
    description: string
    actionDesc: string | null
    weight: number
    cost: number
    timer: number
    decomposeTimer: number
    level: number
    concealment: number
    values: JsonValue
    zoneId: number
    createdAt: Date
    updatedAt: Date
    deleted_at: Date | null
    createdBy: string | null
    updatedBy: string | null
    flags: $Enums.ObjectFlag[]
    effectFlags: $Enums.EffectFlag[]
    wearFlags: $Enums.WearFlag[]
    _count: ObjectCountAggregateOutputType | null
    _avg: ObjectAvgAggregateOutputType | null
    _sum: ObjectSumAggregateOutputType | null
    _min: ObjectMinAggregateOutputType | null
    _max: ObjectMaxAggregateOutputType | null
  }

  type GetObjectGroupByPayload<T extends ObjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectGroupByOutputType[P]>
        }
      >
    >


  export type ObjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    keywords?: boolean
    shortDesc?: boolean
    description?: boolean
    actionDesc?: boolean
    weight?: boolean
    cost?: boolean
    timer?: boolean
    decomposeTimer?: boolean
    level?: boolean
    concealment?: boolean
    values?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    flags?: boolean
    effectFlags?: boolean
    wearFlags?: boolean
    characterItems?: boolean | Object$characterItemsArgs<ExtArgs>
    equipmentSetItems?: boolean | Object$equipmentSetItemsArgs<ExtArgs>
    mobCarrying?: boolean | Object$mobCarryingArgs<ExtArgs>
    mobEquipped?: boolean | Object$mobEquippedArgs<ExtArgs>
    affects?: boolean | Object$affectsArgs<ExtArgs>
    extraDescs?: boolean | Object$extraDescsArgs<ExtArgs>
    resets?: boolean | Object$resetsArgs<ExtArgs>
    spells?: boolean | Object$spellsArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    shopItems?: boolean | Object$shopItemsArgs<ExtArgs>
    triggers?: boolean | Object$triggersArgs<ExtArgs>
    _count?: boolean | ObjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["object"]>

  export type ObjectSelectScalar = {
    id?: boolean
    type?: boolean
    keywords?: boolean
    shortDesc?: boolean
    description?: boolean
    actionDesc?: boolean
    weight?: boolean
    cost?: boolean
    timer?: boolean
    decomposeTimer?: boolean
    level?: boolean
    concealment?: boolean
    values?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    flags?: boolean
    effectFlags?: boolean
    wearFlags?: boolean
  }

  export type ObjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterItems?: boolean | Object$characterItemsArgs<ExtArgs>
    equipmentSetItems?: boolean | Object$equipmentSetItemsArgs<ExtArgs>
    mobCarrying?: boolean | Object$mobCarryingArgs<ExtArgs>
    mobEquipped?: boolean | Object$mobEquippedArgs<ExtArgs>
    affects?: boolean | Object$affectsArgs<ExtArgs>
    extraDescs?: boolean | Object$extraDescsArgs<ExtArgs>
    resets?: boolean | Object$resetsArgs<ExtArgs>
    spells?: boolean | Object$spellsArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    shopItems?: boolean | Object$shopItemsArgs<ExtArgs>
    triggers?: boolean | Object$triggersArgs<ExtArgs>
    _count?: boolean | ObjectCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ObjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Object"
    objects: {
      characterItems: Prisma.$CharacterItemPayload<ExtArgs>[]
      equipmentSetItems: Prisma.$EquipmentSetItemPayload<ExtArgs>[]
      mobCarrying: Prisma.$MobCarryingPayload<ExtArgs>[]
      mobEquipped: Prisma.$MobEquippedPayload<ExtArgs>[]
      affects: Prisma.$ObjectAffectPayload<ExtArgs>[]
      extraDescs: Prisma.$ObjectExtraDescriptionPayload<ExtArgs>[]
      resets: Prisma.$ObjectResetPayload<ExtArgs>[]
      spells: Prisma.$ObjectSpellPayload<ExtArgs>[]
      zone: Prisma.$ZonePayload<ExtArgs>
      shopItems: Prisma.$ShopItemPayload<ExtArgs>[]
      triggers: Prisma.$TriggerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.ObjectType
      keywords: string[]
      shortDesc: string
      description: string
      actionDesc: string | null
      weight: number
      cost: number
      timer: number
      decomposeTimer: number
      level: number
      concealment: number
      values: Prisma.JsonValue
      zoneId: number
      createdAt: Date
      updatedAt: Date
      deleted_at: Date | null
      createdBy: string | null
      updatedBy: string | null
      flags: $Enums.ObjectFlag[]
      effectFlags: $Enums.EffectFlag[]
      wearFlags: $Enums.WearFlag[]
    }, ExtArgs["result"]["object"]>
    composites: {}
  }


  type ObjectGetPayload<S extends boolean | null | undefined | ObjectDefaultArgs> = $Result.GetResult<Prisma.$ObjectPayload, S>

  type ObjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectFindManyArgs, 'select' | 'include'> & {
      select?: ObjectCountAggregateInputType | true
    }

  export interface ObjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Object'], meta: { name: 'Object' } }
    /**
     * Find zero or one Object that matches the filter.
     * @param {ObjectFindUniqueArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Object that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObjectFindUniqueOrThrowArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Object that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindFirstArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Object that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindFirstOrThrowArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Objects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Objects
     * const objects = await prisma.object.findMany()
     * 
     * // Get first 10 Objects
     * const objects = await prisma.object.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectWithIdOnly = await prisma.object.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Object.
     * @param {ObjectCreateArgs} args - Arguments to create a Object.
     * @example
     * // Create one Object
     * const Object = await prisma.object.create({
     *   data: {
     *     // ... data to create a Object
     *   }
     * })
     * 
    **/
    create<T extends ObjectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectCreateArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Objects.
     *     @param {ObjectCreateManyArgs} args - Arguments to create many Objects.
     *     @example
     *     // Create many Objects
     *     const object = await prisma.object.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Object.
     * @param {ObjectDeleteArgs} args - Arguments to delete one Object.
     * @example
     * // Delete one Object
     * const Object = await prisma.object.delete({
     *   where: {
     *     // ... filter to delete one Object
     *   }
     * })
     * 
    **/
    delete<T extends ObjectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectDeleteArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Object.
     * @param {ObjectUpdateArgs} args - Arguments to update one Object.
     * @example
     * // Update one Object
     * const object = await prisma.object.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpdateArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Objects.
     * @param {ObjectDeleteManyArgs} args - Arguments to filter Objects to delete.
     * @example
     * // Delete a few Objects
     * const { count } = await prisma.object.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Objects
     * const object = await prisma.object.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Object.
     * @param {ObjectUpsertArgs} args - Arguments to update or create a Object.
     * @example
     * // Update or create a Object
     * const object = await prisma.object.upsert({
     *   create: {
     *     // ... data to create a Object
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Object we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpsertArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCountArgs} args - Arguments to filter Objects to count.
     * @example
     * // Count the number of Objects
     * const count = await prisma.object.count({
     *   where: {
     *     // ... the filter for the Objects we want to count
     *   }
     * })
    **/
    count<T extends ObjectCountArgs>(
      args?: Subset<T, ObjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Object.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectAggregateArgs>(args: Subset<T, ObjectAggregateArgs>): Prisma.PrismaPromise<GetObjectAggregateType<T>>

    /**
     * Group by Object.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectGroupByArgs['orderBy'] }
        : { orderBy?: ObjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Object model
   */
  readonly fields: ObjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Object.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    characterItems<T extends Object$characterItemsArgs<ExtArgs> = {}>(args?: Subset<T, Object$characterItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    equipmentSetItems<T extends Object$equipmentSetItemsArgs<ExtArgs> = {}>(args?: Subset<T, Object$equipmentSetItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    mobCarrying<T extends Object$mobCarryingArgs<ExtArgs> = {}>(args?: Subset<T, Object$mobCarryingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobCarryingPayload<ExtArgs>, T, 'findMany'> | Null>;

    mobEquipped<T extends Object$mobEquippedArgs<ExtArgs> = {}>(args?: Subset<T, Object$mobEquippedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobEquippedPayload<ExtArgs>, T, 'findMany'> | Null>;

    affects<T extends Object$affectsArgs<ExtArgs> = {}>(args?: Subset<T, Object$affectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectAffectPayload<ExtArgs>, T, 'findMany'> | Null>;

    extraDescs<T extends Object$extraDescsArgs<ExtArgs> = {}>(args?: Subset<T, Object$extraDescsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectExtraDescriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    resets<T extends Object$resetsArgs<ExtArgs> = {}>(args?: Subset<T, Object$resetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'findMany'> | Null>;

    spells<T extends Object$spellsArgs<ExtArgs> = {}>(args?: Subset<T, Object$spellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectSpellPayload<ExtArgs>, T, 'findMany'> | Null>;

    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    shopItems<T extends Object$shopItemsArgs<ExtArgs> = {}>(args?: Subset<T, Object$shopItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    triggers<T extends Object$triggersArgs<ExtArgs> = {}>(args?: Subset<T, Object$triggersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Object model
   */ 
  interface ObjectFieldRefs {
    readonly id: FieldRef<"Object", 'Int'>
    readonly type: FieldRef<"Object", 'ObjectType'>
    readonly keywords: FieldRef<"Object", 'String[]'>
    readonly shortDesc: FieldRef<"Object", 'String'>
    readonly description: FieldRef<"Object", 'String'>
    readonly actionDesc: FieldRef<"Object", 'String'>
    readonly weight: FieldRef<"Object", 'Float'>
    readonly cost: FieldRef<"Object", 'Int'>
    readonly timer: FieldRef<"Object", 'Int'>
    readonly decomposeTimer: FieldRef<"Object", 'Int'>
    readonly level: FieldRef<"Object", 'Int'>
    readonly concealment: FieldRef<"Object", 'Int'>
    readonly values: FieldRef<"Object", 'Json'>
    readonly zoneId: FieldRef<"Object", 'Int'>
    readonly createdAt: FieldRef<"Object", 'DateTime'>
    readonly updatedAt: FieldRef<"Object", 'DateTime'>
    readonly deleted_at: FieldRef<"Object", 'DateTime'>
    readonly createdBy: FieldRef<"Object", 'String'>
    readonly updatedBy: FieldRef<"Object", 'String'>
    readonly flags: FieldRef<"Object", 'ObjectFlag[]'>
    readonly effectFlags: FieldRef<"Object", 'EffectFlag[]'>
    readonly wearFlags: FieldRef<"Object", 'WearFlag[]'>
  }
    

  // Custom InputTypes

  /**
   * Object findUnique
   */
  export type ObjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where: ObjectWhereUniqueInput
  }


  /**
   * Object findUniqueOrThrow
   */
  export type ObjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where: ObjectWhereUniqueInput
  }


  /**
   * Object findFirst
   */
  export type ObjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objects.
     */
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }


  /**
   * Object findFirstOrThrow
   */
  export type ObjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objects.
     */
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }


  /**
   * Object findMany
   */
  export type ObjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Objects to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }


  /**
   * Object create
   */
  export type ObjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Object.
     */
    data: XOR<ObjectCreateInput, ObjectUncheckedCreateInput>
  }


  /**
   * Object createMany
   */
  export type ObjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Objects.
     */
    data: ObjectCreateManyInput | ObjectCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Object update
   */
  export type ObjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Object.
     */
    data: XOR<ObjectUpdateInput, ObjectUncheckedUpdateInput>
    /**
     * Choose, which Object to update.
     */
    where: ObjectWhereUniqueInput
  }


  /**
   * Object updateMany
   */
  export type ObjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Objects.
     */
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyInput>
    /**
     * Filter which Objects to update
     */
    where?: ObjectWhereInput
  }


  /**
   * Object upsert
   */
  export type ObjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Object to update in case it exists.
     */
    where: ObjectWhereUniqueInput
    /**
     * In case the Object found by the `where` argument doesn't exist, create a new Object with this data.
     */
    create: XOR<ObjectCreateInput, ObjectUncheckedCreateInput>
    /**
     * In case the Object was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectUpdateInput, ObjectUncheckedUpdateInput>
  }


  /**
   * Object delete
   */
  export type ObjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter which Object to delete.
     */
    where: ObjectWhereUniqueInput
  }


  /**
   * Object deleteMany
   */
  export type ObjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Objects to delete
     */
    where?: ObjectWhereInput
  }


  /**
   * Object.characterItems
   */
  export type Object$characterItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    where?: CharacterItemWhereInput
    orderBy?: CharacterItemOrderByWithRelationInput | CharacterItemOrderByWithRelationInput[]
    cursor?: CharacterItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterItemScalarFieldEnum | CharacterItemScalarFieldEnum[]
  }


  /**
   * Object.equipmentSetItems
   */
  export type Object$equipmentSetItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    where?: EquipmentSetItemWhereInput
    orderBy?: EquipmentSetItemOrderByWithRelationInput | EquipmentSetItemOrderByWithRelationInput[]
    cursor?: EquipmentSetItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentSetItemScalarFieldEnum | EquipmentSetItemScalarFieldEnum[]
  }


  /**
   * Object.mobCarrying
   */
  export type Object$mobCarryingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobCarrying
     */
    select?: MobCarryingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobCarryingInclude<ExtArgs> | null
    where?: MobCarryingWhereInput
    orderBy?: MobCarryingOrderByWithRelationInput | MobCarryingOrderByWithRelationInput[]
    cursor?: MobCarryingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobCarryingScalarFieldEnum | MobCarryingScalarFieldEnum[]
  }


  /**
   * Object.mobEquipped
   */
  export type Object$mobEquippedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipped
     */
    select?: MobEquippedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquippedInclude<ExtArgs> | null
    where?: MobEquippedWhereInput
    orderBy?: MobEquippedOrderByWithRelationInput | MobEquippedOrderByWithRelationInput[]
    cursor?: MobEquippedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobEquippedScalarFieldEnum | MobEquippedScalarFieldEnum[]
  }


  /**
   * Object.affects
   */
  export type Object$affectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
    where?: ObjectAffectWhereInput
    orderBy?: ObjectAffectOrderByWithRelationInput | ObjectAffectOrderByWithRelationInput[]
    cursor?: ObjectAffectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectAffectScalarFieldEnum | ObjectAffectScalarFieldEnum[]
  }


  /**
   * Object.extraDescs
   */
  export type Object$extraDescsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
    where?: ObjectExtraDescriptionWhereInput
    orderBy?: ObjectExtraDescriptionOrderByWithRelationInput | ObjectExtraDescriptionOrderByWithRelationInput[]
    cursor?: ObjectExtraDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectExtraDescriptionScalarFieldEnum | ObjectExtraDescriptionScalarFieldEnum[]
  }


  /**
   * Object.resets
   */
  export type Object$resetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    where?: ObjectResetWhereInput
    orderBy?: ObjectResetOrderByWithRelationInput | ObjectResetOrderByWithRelationInput[]
    cursor?: ObjectResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectResetScalarFieldEnum | ObjectResetScalarFieldEnum[]
  }


  /**
   * Object.spells
   */
  export type Object$spellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
    where?: ObjectSpellWhereInput
    orderBy?: ObjectSpellOrderByWithRelationInput | ObjectSpellOrderByWithRelationInput[]
    cursor?: ObjectSpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectSpellScalarFieldEnum | ObjectSpellScalarFieldEnum[]
  }


  /**
   * Object.shopItems
   */
  export type Object$shopItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    where?: ShopItemWhereInput
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    cursor?: ShopItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }


  /**
   * Object.triggers
   */
  export type Object$triggersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    where?: TriggerWhereInput
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    cursor?: TriggerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }


  /**
   * Object without action
   */
  export type ObjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
  }



  /**
   * Model ObjectExtraDescription
   */

  export type AggregateObjectExtraDescription = {
    _count: ObjectExtraDescriptionCountAggregateOutputType | null
    _avg: ObjectExtraDescriptionAvgAggregateOutputType | null
    _sum: ObjectExtraDescriptionSumAggregateOutputType | null
    _min: ObjectExtraDescriptionMinAggregateOutputType | null
    _max: ObjectExtraDescriptionMaxAggregateOutputType | null
  }

  export type ObjectExtraDescriptionAvgAggregateOutputType = {
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectExtraDescriptionSumAggregateOutputType = {
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectExtraDescriptionMinAggregateOutputType = {
    id: string | null
    keyword: string | null
    description: string | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectExtraDescriptionMaxAggregateOutputType = {
    id: string | null
    keyword: string | null
    description: string | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectExtraDescriptionCountAggregateOutputType = {
    id: number
    keyword: number
    description: number
    objectZoneId: number
    objectId: number
    _all: number
  }


  export type ObjectExtraDescriptionAvgAggregateInputType = {
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectExtraDescriptionSumAggregateInputType = {
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectExtraDescriptionMinAggregateInputType = {
    id?: true
    keyword?: true
    description?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectExtraDescriptionMaxAggregateInputType = {
    id?: true
    keyword?: true
    description?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectExtraDescriptionCountAggregateInputType = {
    id?: true
    keyword?: true
    description?: true
    objectZoneId?: true
    objectId?: true
    _all?: true
  }

  export type ObjectExtraDescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectExtraDescription to aggregate.
     */
    where?: ObjectExtraDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectExtraDescriptions to fetch.
     */
    orderBy?: ObjectExtraDescriptionOrderByWithRelationInput | ObjectExtraDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectExtraDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectExtraDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectExtraDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObjectExtraDescriptions
    **/
    _count?: true | ObjectExtraDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectExtraDescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectExtraDescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectExtraDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectExtraDescriptionMaxAggregateInputType
  }

  export type GetObjectExtraDescriptionAggregateType<T extends ObjectExtraDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateObjectExtraDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjectExtraDescription[P]>
      : GetScalarType<T[P], AggregateObjectExtraDescription[P]>
  }




  export type ObjectExtraDescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectExtraDescriptionWhereInput
    orderBy?: ObjectExtraDescriptionOrderByWithAggregationInput | ObjectExtraDescriptionOrderByWithAggregationInput[]
    by: ObjectExtraDescriptionScalarFieldEnum[] | ObjectExtraDescriptionScalarFieldEnum
    having?: ObjectExtraDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectExtraDescriptionCountAggregateInputType | true
    _avg?: ObjectExtraDescriptionAvgAggregateInputType
    _sum?: ObjectExtraDescriptionSumAggregateInputType
    _min?: ObjectExtraDescriptionMinAggregateInputType
    _max?: ObjectExtraDescriptionMaxAggregateInputType
  }

  export type ObjectExtraDescriptionGroupByOutputType = {
    id: string
    keyword: string
    description: string
    objectZoneId: number
    objectId: number
    _count: ObjectExtraDescriptionCountAggregateOutputType | null
    _avg: ObjectExtraDescriptionAvgAggregateOutputType | null
    _sum: ObjectExtraDescriptionSumAggregateOutputType | null
    _min: ObjectExtraDescriptionMinAggregateOutputType | null
    _max: ObjectExtraDescriptionMaxAggregateOutputType | null
  }

  type GetObjectExtraDescriptionGroupByPayload<T extends ObjectExtraDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectExtraDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectExtraDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectExtraDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectExtraDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type ObjectExtraDescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    description?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objectExtraDescription"]>

  export type ObjectExtraDescriptionSelectScalar = {
    id?: boolean
    keyword?: boolean
    description?: boolean
    objectZoneId?: boolean
    objectId?: boolean
  }

  export type ObjectExtraDescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }


  export type $ObjectExtraDescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObjectExtraDescription"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keyword: string
      description: string
      objectZoneId: number
      objectId: number
    }, ExtArgs["result"]["objectExtraDescription"]>
    composites: {}
  }


  type ObjectExtraDescriptionGetPayload<S extends boolean | null | undefined | ObjectExtraDescriptionDefaultArgs> = $Result.GetResult<Prisma.$ObjectExtraDescriptionPayload, S>

  type ObjectExtraDescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectExtraDescriptionFindManyArgs, 'select' | 'include'> & {
      select?: ObjectExtraDescriptionCountAggregateInputType | true
    }

  export interface ObjectExtraDescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObjectExtraDescription'], meta: { name: 'ObjectExtraDescription' } }
    /**
     * Find zero or one ObjectExtraDescription that matches the filter.
     * @param {ObjectExtraDescriptionFindUniqueArgs} args - Arguments to find a ObjectExtraDescription
     * @example
     * // Get one ObjectExtraDescription
     * const objectExtraDescription = await prisma.objectExtraDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectExtraDescriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectExtraDescriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectExtraDescriptionClient<$Result.GetResult<Prisma.$ObjectExtraDescriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ObjectExtraDescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObjectExtraDescriptionFindUniqueOrThrowArgs} args - Arguments to find a ObjectExtraDescription
     * @example
     * // Get one ObjectExtraDescription
     * const objectExtraDescription = await prisma.objectExtraDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectExtraDescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectExtraDescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectExtraDescriptionClient<$Result.GetResult<Prisma.$ObjectExtraDescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ObjectExtraDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectExtraDescriptionFindFirstArgs} args - Arguments to find a ObjectExtraDescription
     * @example
     * // Get one ObjectExtraDescription
     * const objectExtraDescription = await prisma.objectExtraDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectExtraDescriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectExtraDescriptionFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectExtraDescriptionClient<$Result.GetResult<Prisma.$ObjectExtraDescriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ObjectExtraDescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectExtraDescriptionFindFirstOrThrowArgs} args - Arguments to find a ObjectExtraDescription
     * @example
     * // Get one ObjectExtraDescription
     * const objectExtraDescription = await prisma.objectExtraDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectExtraDescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectExtraDescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectExtraDescriptionClient<$Result.GetResult<Prisma.$ObjectExtraDescriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ObjectExtraDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectExtraDescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjectExtraDescriptions
     * const objectExtraDescriptions = await prisma.objectExtraDescription.findMany()
     * 
     * // Get first 10 ObjectExtraDescriptions
     * const objectExtraDescriptions = await prisma.objectExtraDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectExtraDescriptionWithIdOnly = await prisma.objectExtraDescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectExtraDescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectExtraDescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectExtraDescriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ObjectExtraDescription.
     * @param {ObjectExtraDescriptionCreateArgs} args - Arguments to create a ObjectExtraDescription.
     * @example
     * // Create one ObjectExtraDescription
     * const ObjectExtraDescription = await prisma.objectExtraDescription.create({
     *   data: {
     *     // ... data to create a ObjectExtraDescription
     *   }
     * })
     * 
    **/
    create<T extends ObjectExtraDescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectExtraDescriptionCreateArgs<ExtArgs>>
    ): Prisma__ObjectExtraDescriptionClient<$Result.GetResult<Prisma.$ObjectExtraDescriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ObjectExtraDescriptions.
     *     @param {ObjectExtraDescriptionCreateManyArgs} args - Arguments to create many ObjectExtraDescriptions.
     *     @example
     *     // Create many ObjectExtraDescriptions
     *     const objectExtraDescription = await prisma.objectExtraDescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectExtraDescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectExtraDescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ObjectExtraDescription.
     * @param {ObjectExtraDescriptionDeleteArgs} args - Arguments to delete one ObjectExtraDescription.
     * @example
     * // Delete one ObjectExtraDescription
     * const ObjectExtraDescription = await prisma.objectExtraDescription.delete({
     *   where: {
     *     // ... filter to delete one ObjectExtraDescription
     *   }
     * })
     * 
    **/
    delete<T extends ObjectExtraDescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectExtraDescriptionDeleteArgs<ExtArgs>>
    ): Prisma__ObjectExtraDescriptionClient<$Result.GetResult<Prisma.$ObjectExtraDescriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ObjectExtraDescription.
     * @param {ObjectExtraDescriptionUpdateArgs} args - Arguments to update one ObjectExtraDescription.
     * @example
     * // Update one ObjectExtraDescription
     * const objectExtraDescription = await prisma.objectExtraDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectExtraDescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectExtraDescriptionUpdateArgs<ExtArgs>>
    ): Prisma__ObjectExtraDescriptionClient<$Result.GetResult<Prisma.$ObjectExtraDescriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ObjectExtraDescriptions.
     * @param {ObjectExtraDescriptionDeleteManyArgs} args - Arguments to filter ObjectExtraDescriptions to delete.
     * @example
     * // Delete a few ObjectExtraDescriptions
     * const { count } = await prisma.objectExtraDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectExtraDescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectExtraDescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjectExtraDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectExtraDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjectExtraDescriptions
     * const objectExtraDescription = await prisma.objectExtraDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectExtraDescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectExtraDescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObjectExtraDescription.
     * @param {ObjectExtraDescriptionUpsertArgs} args - Arguments to update or create a ObjectExtraDescription.
     * @example
     * // Update or create a ObjectExtraDescription
     * const objectExtraDescription = await prisma.objectExtraDescription.upsert({
     *   create: {
     *     // ... data to create a ObjectExtraDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjectExtraDescription we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectExtraDescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectExtraDescriptionUpsertArgs<ExtArgs>>
    ): Prisma__ObjectExtraDescriptionClient<$Result.GetResult<Prisma.$ObjectExtraDescriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ObjectExtraDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectExtraDescriptionCountArgs} args - Arguments to filter ObjectExtraDescriptions to count.
     * @example
     * // Count the number of ObjectExtraDescriptions
     * const count = await prisma.objectExtraDescription.count({
     *   where: {
     *     // ... the filter for the ObjectExtraDescriptions we want to count
     *   }
     * })
    **/
    count<T extends ObjectExtraDescriptionCountArgs>(
      args?: Subset<T, ObjectExtraDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectExtraDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjectExtraDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectExtraDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectExtraDescriptionAggregateArgs>(args: Subset<T, ObjectExtraDescriptionAggregateArgs>): Prisma.PrismaPromise<GetObjectExtraDescriptionAggregateType<T>>

    /**
     * Group by ObjectExtraDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectExtraDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectExtraDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectExtraDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: ObjectExtraDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectExtraDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectExtraDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObjectExtraDescription model
   */
  readonly fields: ObjectExtraDescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObjectExtraDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectExtraDescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ObjectExtraDescription model
   */ 
  interface ObjectExtraDescriptionFieldRefs {
    readonly id: FieldRef<"ObjectExtraDescription", 'String'>
    readonly keyword: FieldRef<"ObjectExtraDescription", 'String'>
    readonly description: FieldRef<"ObjectExtraDescription", 'String'>
    readonly objectZoneId: FieldRef<"ObjectExtraDescription", 'Int'>
    readonly objectId: FieldRef<"ObjectExtraDescription", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ObjectExtraDescription findUnique
   */
  export type ObjectExtraDescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ObjectExtraDescription to fetch.
     */
    where: ObjectExtraDescriptionWhereUniqueInput
  }


  /**
   * ObjectExtraDescription findUniqueOrThrow
   */
  export type ObjectExtraDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ObjectExtraDescription to fetch.
     */
    where: ObjectExtraDescriptionWhereUniqueInput
  }


  /**
   * ObjectExtraDescription findFirst
   */
  export type ObjectExtraDescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ObjectExtraDescription to fetch.
     */
    where?: ObjectExtraDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectExtraDescriptions to fetch.
     */
    orderBy?: ObjectExtraDescriptionOrderByWithRelationInput | ObjectExtraDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectExtraDescriptions.
     */
    cursor?: ObjectExtraDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectExtraDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectExtraDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectExtraDescriptions.
     */
    distinct?: ObjectExtraDescriptionScalarFieldEnum | ObjectExtraDescriptionScalarFieldEnum[]
  }


  /**
   * ObjectExtraDescription findFirstOrThrow
   */
  export type ObjectExtraDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ObjectExtraDescription to fetch.
     */
    where?: ObjectExtraDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectExtraDescriptions to fetch.
     */
    orderBy?: ObjectExtraDescriptionOrderByWithRelationInput | ObjectExtraDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectExtraDescriptions.
     */
    cursor?: ObjectExtraDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectExtraDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectExtraDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectExtraDescriptions.
     */
    distinct?: ObjectExtraDescriptionScalarFieldEnum | ObjectExtraDescriptionScalarFieldEnum[]
  }


  /**
   * ObjectExtraDescription findMany
   */
  export type ObjectExtraDescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ObjectExtraDescriptions to fetch.
     */
    where?: ObjectExtraDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectExtraDescriptions to fetch.
     */
    orderBy?: ObjectExtraDescriptionOrderByWithRelationInput | ObjectExtraDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObjectExtraDescriptions.
     */
    cursor?: ObjectExtraDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectExtraDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectExtraDescriptions.
     */
    skip?: number
    distinct?: ObjectExtraDescriptionScalarFieldEnum | ObjectExtraDescriptionScalarFieldEnum[]
  }


  /**
   * ObjectExtraDescription create
   */
  export type ObjectExtraDescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ObjectExtraDescription.
     */
    data: XOR<ObjectExtraDescriptionCreateInput, ObjectExtraDescriptionUncheckedCreateInput>
  }


  /**
   * ObjectExtraDescription createMany
   */
  export type ObjectExtraDescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObjectExtraDescriptions.
     */
    data: ObjectExtraDescriptionCreateManyInput | ObjectExtraDescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ObjectExtraDescription update
   */
  export type ObjectExtraDescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ObjectExtraDescription.
     */
    data: XOR<ObjectExtraDescriptionUpdateInput, ObjectExtraDescriptionUncheckedUpdateInput>
    /**
     * Choose, which ObjectExtraDescription to update.
     */
    where: ObjectExtraDescriptionWhereUniqueInput
  }


  /**
   * ObjectExtraDescription updateMany
   */
  export type ObjectExtraDescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObjectExtraDescriptions.
     */
    data: XOR<ObjectExtraDescriptionUpdateManyMutationInput, ObjectExtraDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which ObjectExtraDescriptions to update
     */
    where?: ObjectExtraDescriptionWhereInput
  }


  /**
   * ObjectExtraDescription upsert
   */
  export type ObjectExtraDescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ObjectExtraDescription to update in case it exists.
     */
    where: ObjectExtraDescriptionWhereUniqueInput
    /**
     * In case the ObjectExtraDescription found by the `where` argument doesn't exist, create a new ObjectExtraDescription with this data.
     */
    create: XOR<ObjectExtraDescriptionCreateInput, ObjectExtraDescriptionUncheckedCreateInput>
    /**
     * In case the ObjectExtraDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectExtraDescriptionUpdateInput, ObjectExtraDescriptionUncheckedUpdateInput>
  }


  /**
   * ObjectExtraDescription delete
   */
  export type ObjectExtraDescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
    /**
     * Filter which ObjectExtraDescription to delete.
     */
    where: ObjectExtraDescriptionWhereUniqueInput
  }


  /**
   * ObjectExtraDescription deleteMany
   */
  export type ObjectExtraDescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectExtraDescriptions to delete
     */
    where?: ObjectExtraDescriptionWhereInput
  }


  /**
   * ObjectExtraDescription without action
   */
  export type ObjectExtraDescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectExtraDescription
     */
    select?: ObjectExtraDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectExtraDescriptionInclude<ExtArgs> | null
  }



  /**
   * Model ObjectAffect
   */

  export type AggregateObjectAffect = {
    _count: ObjectAffectCountAggregateOutputType | null
    _avg: ObjectAffectAvgAggregateOutputType | null
    _sum: ObjectAffectSumAggregateOutputType | null
    _min: ObjectAffectMinAggregateOutputType | null
    _max: ObjectAffectMaxAggregateOutputType | null
  }

  export type ObjectAffectAvgAggregateOutputType = {
    modifier: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectAffectSumAggregateOutputType = {
    modifier: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectAffectMinAggregateOutputType = {
    id: string | null
    location: string | null
    modifier: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectAffectMaxAggregateOutputType = {
    id: string | null
    location: string | null
    modifier: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectAffectCountAggregateOutputType = {
    id: number
    location: number
    modifier: number
    objectZoneId: number
    objectId: number
    _all: number
  }


  export type ObjectAffectAvgAggregateInputType = {
    modifier?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectAffectSumAggregateInputType = {
    modifier?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectAffectMinAggregateInputType = {
    id?: true
    location?: true
    modifier?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectAffectMaxAggregateInputType = {
    id?: true
    location?: true
    modifier?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectAffectCountAggregateInputType = {
    id?: true
    location?: true
    modifier?: true
    objectZoneId?: true
    objectId?: true
    _all?: true
  }

  export type ObjectAffectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectAffect to aggregate.
     */
    where?: ObjectAffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectAffects to fetch.
     */
    orderBy?: ObjectAffectOrderByWithRelationInput | ObjectAffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectAffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectAffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectAffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObjectAffects
    **/
    _count?: true | ObjectAffectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectAffectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectAffectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectAffectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectAffectMaxAggregateInputType
  }

  export type GetObjectAffectAggregateType<T extends ObjectAffectAggregateArgs> = {
        [P in keyof T & keyof AggregateObjectAffect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjectAffect[P]>
      : GetScalarType<T[P], AggregateObjectAffect[P]>
  }




  export type ObjectAffectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectAffectWhereInput
    orderBy?: ObjectAffectOrderByWithAggregationInput | ObjectAffectOrderByWithAggregationInput[]
    by: ObjectAffectScalarFieldEnum[] | ObjectAffectScalarFieldEnum
    having?: ObjectAffectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectAffectCountAggregateInputType | true
    _avg?: ObjectAffectAvgAggregateInputType
    _sum?: ObjectAffectSumAggregateInputType
    _min?: ObjectAffectMinAggregateInputType
    _max?: ObjectAffectMaxAggregateInputType
  }

  export type ObjectAffectGroupByOutputType = {
    id: string
    location: string
    modifier: number
    objectZoneId: number
    objectId: number
    _count: ObjectAffectCountAggregateOutputType | null
    _avg: ObjectAffectAvgAggregateOutputType | null
    _sum: ObjectAffectSumAggregateOutputType | null
    _min: ObjectAffectMinAggregateOutputType | null
    _max: ObjectAffectMaxAggregateOutputType | null
  }

  type GetObjectAffectGroupByPayload<T extends ObjectAffectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectAffectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectAffectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectAffectGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectAffectGroupByOutputType[P]>
        }
      >
    >


  export type ObjectAffectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    modifier?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objectAffect"]>

  export type ObjectAffectSelectScalar = {
    id?: boolean
    location?: boolean
    modifier?: boolean
    objectZoneId?: boolean
    objectId?: boolean
  }

  export type ObjectAffectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }


  export type $ObjectAffectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObjectAffect"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      location: string
      modifier: number
      objectZoneId: number
      objectId: number
    }, ExtArgs["result"]["objectAffect"]>
    composites: {}
  }


  type ObjectAffectGetPayload<S extends boolean | null | undefined | ObjectAffectDefaultArgs> = $Result.GetResult<Prisma.$ObjectAffectPayload, S>

  type ObjectAffectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectAffectFindManyArgs, 'select' | 'include'> & {
      select?: ObjectAffectCountAggregateInputType | true
    }

  export interface ObjectAffectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObjectAffect'], meta: { name: 'ObjectAffect' } }
    /**
     * Find zero or one ObjectAffect that matches the filter.
     * @param {ObjectAffectFindUniqueArgs} args - Arguments to find a ObjectAffect
     * @example
     * // Get one ObjectAffect
     * const objectAffect = await prisma.objectAffect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectAffectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectAffectFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectAffectClient<$Result.GetResult<Prisma.$ObjectAffectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ObjectAffect that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObjectAffectFindUniqueOrThrowArgs} args - Arguments to find a ObjectAffect
     * @example
     * // Get one ObjectAffect
     * const objectAffect = await prisma.objectAffect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectAffectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectAffectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectAffectClient<$Result.GetResult<Prisma.$ObjectAffectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ObjectAffect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAffectFindFirstArgs} args - Arguments to find a ObjectAffect
     * @example
     * // Get one ObjectAffect
     * const objectAffect = await prisma.objectAffect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectAffectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectAffectFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectAffectClient<$Result.GetResult<Prisma.$ObjectAffectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ObjectAffect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAffectFindFirstOrThrowArgs} args - Arguments to find a ObjectAffect
     * @example
     * // Get one ObjectAffect
     * const objectAffect = await prisma.objectAffect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectAffectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectAffectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectAffectClient<$Result.GetResult<Prisma.$ObjectAffectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ObjectAffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAffectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjectAffects
     * const objectAffects = await prisma.objectAffect.findMany()
     * 
     * // Get first 10 ObjectAffects
     * const objectAffects = await prisma.objectAffect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectAffectWithIdOnly = await prisma.objectAffect.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectAffectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectAffectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectAffectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ObjectAffect.
     * @param {ObjectAffectCreateArgs} args - Arguments to create a ObjectAffect.
     * @example
     * // Create one ObjectAffect
     * const ObjectAffect = await prisma.objectAffect.create({
     *   data: {
     *     // ... data to create a ObjectAffect
     *   }
     * })
     * 
    **/
    create<T extends ObjectAffectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectAffectCreateArgs<ExtArgs>>
    ): Prisma__ObjectAffectClient<$Result.GetResult<Prisma.$ObjectAffectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ObjectAffects.
     *     @param {ObjectAffectCreateManyArgs} args - Arguments to create many ObjectAffects.
     *     @example
     *     // Create many ObjectAffects
     *     const objectAffect = await prisma.objectAffect.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectAffectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectAffectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ObjectAffect.
     * @param {ObjectAffectDeleteArgs} args - Arguments to delete one ObjectAffect.
     * @example
     * // Delete one ObjectAffect
     * const ObjectAffect = await prisma.objectAffect.delete({
     *   where: {
     *     // ... filter to delete one ObjectAffect
     *   }
     * })
     * 
    **/
    delete<T extends ObjectAffectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectAffectDeleteArgs<ExtArgs>>
    ): Prisma__ObjectAffectClient<$Result.GetResult<Prisma.$ObjectAffectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ObjectAffect.
     * @param {ObjectAffectUpdateArgs} args - Arguments to update one ObjectAffect.
     * @example
     * // Update one ObjectAffect
     * const objectAffect = await prisma.objectAffect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectAffectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectAffectUpdateArgs<ExtArgs>>
    ): Prisma__ObjectAffectClient<$Result.GetResult<Prisma.$ObjectAffectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ObjectAffects.
     * @param {ObjectAffectDeleteManyArgs} args - Arguments to filter ObjectAffects to delete.
     * @example
     * // Delete a few ObjectAffects
     * const { count } = await prisma.objectAffect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectAffectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectAffectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjectAffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAffectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjectAffects
     * const objectAffect = await prisma.objectAffect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectAffectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectAffectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObjectAffect.
     * @param {ObjectAffectUpsertArgs} args - Arguments to update or create a ObjectAffect.
     * @example
     * // Update or create a ObjectAffect
     * const objectAffect = await prisma.objectAffect.upsert({
     *   create: {
     *     // ... data to create a ObjectAffect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjectAffect we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectAffectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectAffectUpsertArgs<ExtArgs>>
    ): Prisma__ObjectAffectClient<$Result.GetResult<Prisma.$ObjectAffectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ObjectAffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAffectCountArgs} args - Arguments to filter ObjectAffects to count.
     * @example
     * // Count the number of ObjectAffects
     * const count = await prisma.objectAffect.count({
     *   where: {
     *     // ... the filter for the ObjectAffects we want to count
     *   }
     * })
    **/
    count<T extends ObjectAffectCountArgs>(
      args?: Subset<T, ObjectAffectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectAffectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjectAffect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAffectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectAffectAggregateArgs>(args: Subset<T, ObjectAffectAggregateArgs>): Prisma.PrismaPromise<GetObjectAffectAggregateType<T>>

    /**
     * Group by ObjectAffect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAffectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectAffectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectAffectGroupByArgs['orderBy'] }
        : { orderBy?: ObjectAffectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectAffectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectAffectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObjectAffect model
   */
  readonly fields: ObjectAffectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObjectAffect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectAffectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ObjectAffect model
   */ 
  interface ObjectAffectFieldRefs {
    readonly id: FieldRef<"ObjectAffect", 'String'>
    readonly location: FieldRef<"ObjectAffect", 'String'>
    readonly modifier: FieldRef<"ObjectAffect", 'Int'>
    readonly objectZoneId: FieldRef<"ObjectAffect", 'Int'>
    readonly objectId: FieldRef<"ObjectAffect", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ObjectAffect findUnique
   */
  export type ObjectAffectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
    /**
     * Filter, which ObjectAffect to fetch.
     */
    where: ObjectAffectWhereUniqueInput
  }


  /**
   * ObjectAffect findUniqueOrThrow
   */
  export type ObjectAffectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
    /**
     * Filter, which ObjectAffect to fetch.
     */
    where: ObjectAffectWhereUniqueInput
  }


  /**
   * ObjectAffect findFirst
   */
  export type ObjectAffectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
    /**
     * Filter, which ObjectAffect to fetch.
     */
    where?: ObjectAffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectAffects to fetch.
     */
    orderBy?: ObjectAffectOrderByWithRelationInput | ObjectAffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectAffects.
     */
    cursor?: ObjectAffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectAffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectAffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectAffects.
     */
    distinct?: ObjectAffectScalarFieldEnum | ObjectAffectScalarFieldEnum[]
  }


  /**
   * ObjectAffect findFirstOrThrow
   */
  export type ObjectAffectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
    /**
     * Filter, which ObjectAffect to fetch.
     */
    where?: ObjectAffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectAffects to fetch.
     */
    orderBy?: ObjectAffectOrderByWithRelationInput | ObjectAffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectAffects.
     */
    cursor?: ObjectAffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectAffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectAffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectAffects.
     */
    distinct?: ObjectAffectScalarFieldEnum | ObjectAffectScalarFieldEnum[]
  }


  /**
   * ObjectAffect findMany
   */
  export type ObjectAffectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
    /**
     * Filter, which ObjectAffects to fetch.
     */
    where?: ObjectAffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectAffects to fetch.
     */
    orderBy?: ObjectAffectOrderByWithRelationInput | ObjectAffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObjectAffects.
     */
    cursor?: ObjectAffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectAffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectAffects.
     */
    skip?: number
    distinct?: ObjectAffectScalarFieldEnum | ObjectAffectScalarFieldEnum[]
  }


  /**
   * ObjectAffect create
   */
  export type ObjectAffectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
    /**
     * The data needed to create a ObjectAffect.
     */
    data: XOR<ObjectAffectCreateInput, ObjectAffectUncheckedCreateInput>
  }


  /**
   * ObjectAffect createMany
   */
  export type ObjectAffectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObjectAffects.
     */
    data: ObjectAffectCreateManyInput | ObjectAffectCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ObjectAffect update
   */
  export type ObjectAffectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
    /**
     * The data needed to update a ObjectAffect.
     */
    data: XOR<ObjectAffectUpdateInput, ObjectAffectUncheckedUpdateInput>
    /**
     * Choose, which ObjectAffect to update.
     */
    where: ObjectAffectWhereUniqueInput
  }


  /**
   * ObjectAffect updateMany
   */
  export type ObjectAffectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObjectAffects.
     */
    data: XOR<ObjectAffectUpdateManyMutationInput, ObjectAffectUncheckedUpdateManyInput>
    /**
     * Filter which ObjectAffects to update
     */
    where?: ObjectAffectWhereInput
  }


  /**
   * ObjectAffect upsert
   */
  export type ObjectAffectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
    /**
     * The filter to search for the ObjectAffect to update in case it exists.
     */
    where: ObjectAffectWhereUniqueInput
    /**
     * In case the ObjectAffect found by the `where` argument doesn't exist, create a new ObjectAffect with this data.
     */
    create: XOR<ObjectAffectCreateInput, ObjectAffectUncheckedCreateInput>
    /**
     * In case the ObjectAffect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectAffectUpdateInput, ObjectAffectUncheckedUpdateInput>
  }


  /**
   * ObjectAffect delete
   */
  export type ObjectAffectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
    /**
     * Filter which ObjectAffect to delete.
     */
    where: ObjectAffectWhereUniqueInput
  }


  /**
   * ObjectAffect deleteMany
   */
  export type ObjectAffectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectAffects to delete
     */
    where?: ObjectAffectWhereInput
  }


  /**
   * ObjectAffect without action
   */
  export type ObjectAffectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectAffect
     */
    select?: ObjectAffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectAffectInclude<ExtArgs> | null
  }



  /**
   * Model ObjectSpell
   */

  export type AggregateObjectSpell = {
    _count: ObjectSpellCountAggregateOutputType | null
    _avg: ObjectSpellAvgAggregateOutputType | null
    _sum: ObjectSpellSumAggregateOutputType | null
    _min: ObjectSpellMinAggregateOutputType | null
    _max: ObjectSpellMaxAggregateOutputType | null
  }

  export type ObjectSpellAvgAggregateOutputType = {
    level: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectSpellSumAggregateOutputType = {
    level: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectSpellMinAggregateOutputType = {
    id: string | null
    spell: string | null
    level: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectSpellMaxAggregateOutputType = {
    id: string | null
    spell: string | null
    level: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ObjectSpellCountAggregateOutputType = {
    id: number
    spell: number
    level: number
    objectZoneId: number
    objectId: number
    _all: number
  }


  export type ObjectSpellAvgAggregateInputType = {
    level?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectSpellSumAggregateInputType = {
    level?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectSpellMinAggregateInputType = {
    id?: true
    spell?: true
    level?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectSpellMaxAggregateInputType = {
    id?: true
    spell?: true
    level?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ObjectSpellCountAggregateInputType = {
    id?: true
    spell?: true
    level?: true
    objectZoneId?: true
    objectId?: true
    _all?: true
  }

  export type ObjectSpellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectSpell to aggregate.
     */
    where?: ObjectSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectSpells to fetch.
     */
    orderBy?: ObjectSpellOrderByWithRelationInput | ObjectSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObjectSpells
    **/
    _count?: true | ObjectSpellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectSpellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectSpellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectSpellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectSpellMaxAggregateInputType
  }

  export type GetObjectSpellAggregateType<T extends ObjectSpellAggregateArgs> = {
        [P in keyof T & keyof AggregateObjectSpell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjectSpell[P]>
      : GetScalarType<T[P], AggregateObjectSpell[P]>
  }




  export type ObjectSpellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectSpellWhereInput
    orderBy?: ObjectSpellOrderByWithAggregationInput | ObjectSpellOrderByWithAggregationInput[]
    by: ObjectSpellScalarFieldEnum[] | ObjectSpellScalarFieldEnum
    having?: ObjectSpellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectSpellCountAggregateInputType | true
    _avg?: ObjectSpellAvgAggregateInputType
    _sum?: ObjectSpellSumAggregateInputType
    _min?: ObjectSpellMinAggregateInputType
    _max?: ObjectSpellMaxAggregateInputType
  }

  export type ObjectSpellGroupByOutputType = {
    id: string
    spell: string
    level: number
    objectZoneId: number
    objectId: number
    _count: ObjectSpellCountAggregateOutputType | null
    _avg: ObjectSpellAvgAggregateOutputType | null
    _sum: ObjectSpellSumAggregateOutputType | null
    _min: ObjectSpellMinAggregateOutputType | null
    _max: ObjectSpellMaxAggregateOutputType | null
  }

  type GetObjectSpellGroupByPayload<T extends ObjectSpellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectSpellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectSpellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectSpellGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectSpellGroupByOutputType[P]>
        }
      >
    >


  export type ObjectSpellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spell?: boolean
    level?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objectSpell"]>

  export type ObjectSpellSelectScalar = {
    id?: boolean
    spell?: boolean
    level?: boolean
    objectZoneId?: boolean
    objectId?: boolean
  }

  export type ObjectSpellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }


  export type $ObjectSpellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObjectSpell"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      spell: string
      level: number
      objectZoneId: number
      objectId: number
    }, ExtArgs["result"]["objectSpell"]>
    composites: {}
  }


  type ObjectSpellGetPayload<S extends boolean | null | undefined | ObjectSpellDefaultArgs> = $Result.GetResult<Prisma.$ObjectSpellPayload, S>

  type ObjectSpellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectSpellFindManyArgs, 'select' | 'include'> & {
      select?: ObjectSpellCountAggregateInputType | true
    }

  export interface ObjectSpellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObjectSpell'], meta: { name: 'ObjectSpell' } }
    /**
     * Find zero or one ObjectSpell that matches the filter.
     * @param {ObjectSpellFindUniqueArgs} args - Arguments to find a ObjectSpell
     * @example
     * // Get one ObjectSpell
     * const objectSpell = await prisma.objectSpell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectSpellFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectSpellFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectSpellClient<$Result.GetResult<Prisma.$ObjectSpellPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ObjectSpell that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObjectSpellFindUniqueOrThrowArgs} args - Arguments to find a ObjectSpell
     * @example
     * // Get one ObjectSpell
     * const objectSpell = await prisma.objectSpell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectSpellFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectSpellFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectSpellClient<$Result.GetResult<Prisma.$ObjectSpellPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ObjectSpell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectSpellFindFirstArgs} args - Arguments to find a ObjectSpell
     * @example
     * // Get one ObjectSpell
     * const objectSpell = await prisma.objectSpell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectSpellFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectSpellFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectSpellClient<$Result.GetResult<Prisma.$ObjectSpellPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ObjectSpell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectSpellFindFirstOrThrowArgs} args - Arguments to find a ObjectSpell
     * @example
     * // Get one ObjectSpell
     * const objectSpell = await prisma.objectSpell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectSpellFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectSpellFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectSpellClient<$Result.GetResult<Prisma.$ObjectSpellPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ObjectSpells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectSpellFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjectSpells
     * const objectSpells = await prisma.objectSpell.findMany()
     * 
     * // Get first 10 ObjectSpells
     * const objectSpells = await prisma.objectSpell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectSpellWithIdOnly = await prisma.objectSpell.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectSpellFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectSpellFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectSpellPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ObjectSpell.
     * @param {ObjectSpellCreateArgs} args - Arguments to create a ObjectSpell.
     * @example
     * // Create one ObjectSpell
     * const ObjectSpell = await prisma.objectSpell.create({
     *   data: {
     *     // ... data to create a ObjectSpell
     *   }
     * })
     * 
    **/
    create<T extends ObjectSpellCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectSpellCreateArgs<ExtArgs>>
    ): Prisma__ObjectSpellClient<$Result.GetResult<Prisma.$ObjectSpellPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ObjectSpells.
     *     @param {ObjectSpellCreateManyArgs} args - Arguments to create many ObjectSpells.
     *     @example
     *     // Create many ObjectSpells
     *     const objectSpell = await prisma.objectSpell.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectSpellCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectSpellCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ObjectSpell.
     * @param {ObjectSpellDeleteArgs} args - Arguments to delete one ObjectSpell.
     * @example
     * // Delete one ObjectSpell
     * const ObjectSpell = await prisma.objectSpell.delete({
     *   where: {
     *     // ... filter to delete one ObjectSpell
     *   }
     * })
     * 
    **/
    delete<T extends ObjectSpellDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectSpellDeleteArgs<ExtArgs>>
    ): Prisma__ObjectSpellClient<$Result.GetResult<Prisma.$ObjectSpellPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ObjectSpell.
     * @param {ObjectSpellUpdateArgs} args - Arguments to update one ObjectSpell.
     * @example
     * // Update one ObjectSpell
     * const objectSpell = await prisma.objectSpell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectSpellUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectSpellUpdateArgs<ExtArgs>>
    ): Prisma__ObjectSpellClient<$Result.GetResult<Prisma.$ObjectSpellPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ObjectSpells.
     * @param {ObjectSpellDeleteManyArgs} args - Arguments to filter ObjectSpells to delete.
     * @example
     * // Delete a few ObjectSpells
     * const { count } = await prisma.objectSpell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectSpellDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectSpellDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjectSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectSpellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjectSpells
     * const objectSpell = await prisma.objectSpell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectSpellUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectSpellUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObjectSpell.
     * @param {ObjectSpellUpsertArgs} args - Arguments to update or create a ObjectSpell.
     * @example
     * // Update or create a ObjectSpell
     * const objectSpell = await prisma.objectSpell.upsert({
     *   create: {
     *     // ... data to create a ObjectSpell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjectSpell we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectSpellUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectSpellUpsertArgs<ExtArgs>>
    ): Prisma__ObjectSpellClient<$Result.GetResult<Prisma.$ObjectSpellPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ObjectSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectSpellCountArgs} args - Arguments to filter ObjectSpells to count.
     * @example
     * // Count the number of ObjectSpells
     * const count = await prisma.objectSpell.count({
     *   where: {
     *     // ... the filter for the ObjectSpells we want to count
     *   }
     * })
    **/
    count<T extends ObjectSpellCountArgs>(
      args?: Subset<T, ObjectSpellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectSpellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjectSpell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectSpellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectSpellAggregateArgs>(args: Subset<T, ObjectSpellAggregateArgs>): Prisma.PrismaPromise<GetObjectSpellAggregateType<T>>

    /**
     * Group by ObjectSpell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectSpellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectSpellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectSpellGroupByArgs['orderBy'] }
        : { orderBy?: ObjectSpellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectSpellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectSpellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObjectSpell model
   */
  readonly fields: ObjectSpellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObjectSpell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectSpellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ObjectSpell model
   */ 
  interface ObjectSpellFieldRefs {
    readonly id: FieldRef<"ObjectSpell", 'String'>
    readonly spell: FieldRef<"ObjectSpell", 'String'>
    readonly level: FieldRef<"ObjectSpell", 'Int'>
    readonly objectZoneId: FieldRef<"ObjectSpell", 'Int'>
    readonly objectId: FieldRef<"ObjectSpell", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ObjectSpell findUnique
   */
  export type ObjectSpellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
    /**
     * Filter, which ObjectSpell to fetch.
     */
    where: ObjectSpellWhereUniqueInput
  }


  /**
   * ObjectSpell findUniqueOrThrow
   */
  export type ObjectSpellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
    /**
     * Filter, which ObjectSpell to fetch.
     */
    where: ObjectSpellWhereUniqueInput
  }


  /**
   * ObjectSpell findFirst
   */
  export type ObjectSpellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
    /**
     * Filter, which ObjectSpell to fetch.
     */
    where?: ObjectSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectSpells to fetch.
     */
    orderBy?: ObjectSpellOrderByWithRelationInput | ObjectSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectSpells.
     */
    cursor?: ObjectSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectSpells.
     */
    distinct?: ObjectSpellScalarFieldEnum | ObjectSpellScalarFieldEnum[]
  }


  /**
   * ObjectSpell findFirstOrThrow
   */
  export type ObjectSpellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
    /**
     * Filter, which ObjectSpell to fetch.
     */
    where?: ObjectSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectSpells to fetch.
     */
    orderBy?: ObjectSpellOrderByWithRelationInput | ObjectSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectSpells.
     */
    cursor?: ObjectSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectSpells.
     */
    distinct?: ObjectSpellScalarFieldEnum | ObjectSpellScalarFieldEnum[]
  }


  /**
   * ObjectSpell findMany
   */
  export type ObjectSpellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
    /**
     * Filter, which ObjectSpells to fetch.
     */
    where?: ObjectSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectSpells to fetch.
     */
    orderBy?: ObjectSpellOrderByWithRelationInput | ObjectSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObjectSpells.
     */
    cursor?: ObjectSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectSpells.
     */
    skip?: number
    distinct?: ObjectSpellScalarFieldEnum | ObjectSpellScalarFieldEnum[]
  }


  /**
   * ObjectSpell create
   */
  export type ObjectSpellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
    /**
     * The data needed to create a ObjectSpell.
     */
    data: XOR<ObjectSpellCreateInput, ObjectSpellUncheckedCreateInput>
  }


  /**
   * ObjectSpell createMany
   */
  export type ObjectSpellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObjectSpells.
     */
    data: ObjectSpellCreateManyInput | ObjectSpellCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ObjectSpell update
   */
  export type ObjectSpellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
    /**
     * The data needed to update a ObjectSpell.
     */
    data: XOR<ObjectSpellUpdateInput, ObjectSpellUncheckedUpdateInput>
    /**
     * Choose, which ObjectSpell to update.
     */
    where: ObjectSpellWhereUniqueInput
  }


  /**
   * ObjectSpell updateMany
   */
  export type ObjectSpellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObjectSpells.
     */
    data: XOR<ObjectSpellUpdateManyMutationInput, ObjectSpellUncheckedUpdateManyInput>
    /**
     * Filter which ObjectSpells to update
     */
    where?: ObjectSpellWhereInput
  }


  /**
   * ObjectSpell upsert
   */
  export type ObjectSpellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
    /**
     * The filter to search for the ObjectSpell to update in case it exists.
     */
    where: ObjectSpellWhereUniqueInput
    /**
     * In case the ObjectSpell found by the `where` argument doesn't exist, create a new ObjectSpell with this data.
     */
    create: XOR<ObjectSpellCreateInput, ObjectSpellUncheckedCreateInput>
    /**
     * In case the ObjectSpell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectSpellUpdateInput, ObjectSpellUncheckedUpdateInput>
  }


  /**
   * ObjectSpell delete
   */
  export type ObjectSpellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
    /**
     * Filter which ObjectSpell to delete.
     */
    where: ObjectSpellWhereUniqueInput
  }


  /**
   * ObjectSpell deleteMany
   */
  export type ObjectSpellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectSpells to delete
     */
    where?: ObjectSpellWhereInput
  }


  /**
   * ObjectSpell without action
   */
  export type ObjectSpellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectSpell
     */
    select?: ObjectSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectSpellInclude<ExtArgs> | null
  }



  /**
   * Model Shop
   */

  export type AggregateShop = {
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  export type ShopAvgAggregateOutputType = {
    id: number | null
    buyProfit: number | null
    sellProfit: number | null
    temper1: number | null
    keeperZoneId: number | null
    keeperId: number | null
    zoneId: number | null
  }

  export type ShopSumAggregateOutputType = {
    id: number | null
    buyProfit: number | null
    sellProfit: number | null
    temper1: number | null
    keeperZoneId: number | null
    keeperId: number | null
    zoneId: number | null
  }

  export type ShopMinAggregateOutputType = {
    id: number | null
    buyProfit: number | null
    sellProfit: number | null
    temper1: number | null
    noSuchItem1: string | null
    noSuchItem2: string | null
    doNotBuy: string | null
    missingCash1: string | null
    missingCash2: string | null
    messageBuy: string | null
    messageSell: string | null
    keeperZoneId: number | null
    keeperId: number | null
    zoneId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ShopMaxAggregateOutputType = {
    id: number | null
    buyProfit: number | null
    sellProfit: number | null
    temper1: number | null
    noSuchItem1: string | null
    noSuchItem2: string | null
    doNotBuy: string | null
    missingCash1: string | null
    missingCash2: string | null
    messageBuy: string | null
    messageSell: string | null
    keeperZoneId: number | null
    keeperId: number | null
    zoneId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type ShopCountAggregateOutputType = {
    id: number
    buyProfit: number
    sellProfit: number
    temper1: number
    noSuchItem1: number
    noSuchItem2: number
    doNotBuy: number
    missingCash1: number
    missingCash2: number
    messageBuy: number
    messageSell: number
    keeperZoneId: number
    keeperId: number
    zoneId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    flags: number
    tradesWithFlags: number
    _all: number
  }


  export type ShopAvgAggregateInputType = {
    id?: true
    buyProfit?: true
    sellProfit?: true
    temper1?: true
    keeperZoneId?: true
    keeperId?: true
    zoneId?: true
  }

  export type ShopSumAggregateInputType = {
    id?: true
    buyProfit?: true
    sellProfit?: true
    temper1?: true
    keeperZoneId?: true
    keeperId?: true
    zoneId?: true
  }

  export type ShopMinAggregateInputType = {
    id?: true
    buyProfit?: true
    sellProfit?: true
    temper1?: true
    noSuchItem1?: true
    noSuchItem2?: true
    doNotBuy?: true
    missingCash1?: true
    missingCash2?: true
    messageBuy?: true
    messageSell?: true
    keeperZoneId?: true
    keeperId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ShopMaxAggregateInputType = {
    id?: true
    buyProfit?: true
    sellProfit?: true
    temper1?: true
    noSuchItem1?: true
    noSuchItem2?: true
    doNotBuy?: true
    missingCash1?: true
    missingCash2?: true
    messageBuy?: true
    messageSell?: true
    keeperZoneId?: true
    keeperId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type ShopCountAggregateInputType = {
    id?: true
    buyProfit?: true
    sellProfit?: true
    temper1?: true
    noSuchItem1?: true
    noSuchItem2?: true
    doNotBuy?: true
    missingCash1?: true
    missingCash2?: true
    messageBuy?: true
    messageSell?: true
    keeperZoneId?: true
    keeperId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    flags?: true
    tradesWithFlags?: true
    _all?: true
  }

  export type ShopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shop to aggregate.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shops
    **/
    _count?: true | ShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopMaxAggregateInputType
  }

  export type GetShopAggregateType<T extends ShopAggregateArgs> = {
        [P in keyof T & keyof AggregateShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShop[P]>
      : GetScalarType<T[P], AggregateShop[P]>
  }




  export type ShopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithAggregationInput | ShopOrderByWithAggregationInput[]
    by: ShopScalarFieldEnum[] | ShopScalarFieldEnum
    having?: ShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopCountAggregateInputType | true
    _avg?: ShopAvgAggregateInputType
    _sum?: ShopSumAggregateInputType
    _min?: ShopMinAggregateInputType
    _max?: ShopMaxAggregateInputType
  }

  export type ShopGroupByOutputType = {
    id: number
    buyProfit: number
    sellProfit: number
    temper1: number
    noSuchItem1: string | null
    noSuchItem2: string | null
    doNotBuy: string | null
    missingCash1: string | null
    missingCash2: string | null
    messageBuy: string | null
    messageSell: string | null
    keeperZoneId: number | null
    keeperId: number | null
    zoneId: number
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    flags: $Enums.ShopFlag[]
    tradesWithFlags: $Enums.ShopTradesWith[]
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  type GetShopGroupByPayload<T extends ShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopGroupByOutputType[P]>
            : GetScalarType<T[P], ShopGroupByOutputType[P]>
        }
      >
    >


  export type ShopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buyProfit?: boolean
    sellProfit?: boolean
    temper1?: boolean
    noSuchItem1?: boolean
    noSuchItem2?: boolean
    doNotBuy?: boolean
    missingCash1?: boolean
    missingCash2?: boolean
    messageBuy?: boolean
    messageSell?: boolean
    keeperZoneId?: boolean
    keeperId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    flags?: boolean
    tradesWithFlags?: boolean
    accepts?: boolean | Shop$acceptsArgs<ExtArgs>
    hours?: boolean | Shop$hoursArgs<ExtArgs>
    items?: boolean | Shop$itemsArgs<ExtArgs>
    rooms?: boolean | Shop$roomsArgs<ExtArgs>
    keeper?: boolean | Shop$keeperArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectScalar = {
    id?: boolean
    buyProfit?: boolean
    sellProfit?: boolean
    temper1?: boolean
    noSuchItem1?: boolean
    noSuchItem2?: boolean
    doNotBuy?: boolean
    missingCash1?: boolean
    missingCash2?: boolean
    messageBuy?: boolean
    messageSell?: boolean
    keeperZoneId?: boolean
    keeperId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    flags?: boolean
    tradesWithFlags?: boolean
  }

  export type ShopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accepts?: boolean | Shop$acceptsArgs<ExtArgs>
    hours?: boolean | Shop$hoursArgs<ExtArgs>
    items?: boolean | Shop$itemsArgs<ExtArgs>
    rooms?: boolean | Shop$roomsArgs<ExtArgs>
    keeper?: boolean | Shop$keeperArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ShopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shop"
    objects: {
      accepts: Prisma.$ShopAcceptPayload<ExtArgs>[]
      hours: Prisma.$ShopHourPayload<ExtArgs>[]
      items: Prisma.$ShopItemPayload<ExtArgs>[]
      rooms: Prisma.$ShopRoomPayload<ExtArgs>[]
      keeper: Prisma.$MobPayload<ExtArgs> | null
      zone: Prisma.$ZonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      buyProfit: number
      sellProfit: number
      temper1: number
      noSuchItem1: string | null
      noSuchItem2: string | null
      doNotBuy: string | null
      missingCash1: string | null
      missingCash2: string | null
      messageBuy: string | null
      messageSell: string | null
      keeperZoneId: number | null
      keeperId: number | null
      zoneId: number
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      flags: $Enums.ShopFlag[]
      tradesWithFlags: $Enums.ShopTradesWith[]
    }, ExtArgs["result"]["shop"]>
    composites: {}
  }


  type ShopGetPayload<S extends boolean | null | undefined | ShopDefaultArgs> = $Result.GetResult<Prisma.$ShopPayload, S>

  type ShopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopFindManyArgs, 'select' | 'include'> & {
      select?: ShopCountAggregateInputType | true
    }

  export interface ShopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shop'], meta: { name: 'Shop' } }
    /**
     * Find zero or one Shop that matches the filter.
     * @param {ShopFindUniqueArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Shop that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShopFindUniqueOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Shop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopFindFirstArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Shop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shops
     * const shops = await prisma.shop.findMany()
     * 
     * // Get first 10 Shops
     * const shops = await prisma.shop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopWithIdOnly = await prisma.shop.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShopFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Shop.
     * @param {ShopCreateArgs} args - Arguments to create a Shop.
     * @example
     * // Create one Shop
     * const Shop = await prisma.shop.create({
     *   data: {
     *     // ... data to create a Shop
     *   }
     * })
     * 
    **/
    create<T extends ShopCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopCreateArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Shops.
     *     @param {ShopCreateManyArgs} args - Arguments to create many Shops.
     *     @example
     *     // Create many Shops
     *     const shop = await prisma.shop.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shop.
     * @param {ShopDeleteArgs} args - Arguments to delete one Shop.
     * @example
     * // Delete one Shop
     * const Shop = await prisma.shop.delete({
     *   where: {
     *     // ... filter to delete one Shop
     *   }
     * })
     * 
    **/
    delete<T extends ShopDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopDeleteArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Shop.
     * @param {ShopUpdateArgs} args - Arguments to update one Shop.
     * @example
     * // Update one Shop
     * const shop = await prisma.shop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopUpdateArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Shops.
     * @param {ShopDeleteManyArgs} args - Arguments to filter Shops to delete.
     * @example
     * // Delete a few Shops
     * const { count } = await prisma.shop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shop.
     * @param {ShopUpsertArgs} args - Arguments to update or create a Shop.
     * @example
     * // Update or create a Shop
     * const shop = await prisma.shop.upsert({
     *   create: {
     *     // ... data to create a Shop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shop we want to update
     *   }
     * })
    **/
    upsert<T extends ShopUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopUpsertArgs<ExtArgs>>
    ): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCountArgs} args - Arguments to filter Shops to count.
     * @example
     * // Count the number of Shops
     * const count = await prisma.shop.count({
     *   where: {
     *     // ... the filter for the Shops we want to count
     *   }
     * })
    **/
    count<T extends ShopCountArgs>(
      args?: Subset<T, ShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopAggregateArgs>(args: Subset<T, ShopAggregateArgs>): Prisma.PrismaPromise<GetShopAggregateType<T>>

    /**
     * Group by Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopGroupByArgs['orderBy'] }
        : { orderBy?: ShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shop model
   */
  readonly fields: ShopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    accepts<T extends Shop$acceptsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$acceptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopAcceptPayload<ExtArgs>, T, 'findMany'> | Null>;

    hours<T extends Shop$hoursArgs<ExtArgs> = {}>(args?: Subset<T, Shop$hoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopHourPayload<ExtArgs>, T, 'findMany'> | Null>;

    items<T extends Shop$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    rooms<T extends Shop$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopRoomPayload<ExtArgs>, T, 'findMany'> | Null>;

    keeper<T extends Shop$keeperArgs<ExtArgs> = {}>(args?: Subset<T, Shop$keeperArgs<ExtArgs>>): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Shop model
   */ 
  interface ShopFieldRefs {
    readonly id: FieldRef<"Shop", 'Int'>
    readonly buyProfit: FieldRef<"Shop", 'Float'>
    readonly sellProfit: FieldRef<"Shop", 'Float'>
    readonly temper1: FieldRef<"Shop", 'Int'>
    readonly noSuchItem1: FieldRef<"Shop", 'String'>
    readonly noSuchItem2: FieldRef<"Shop", 'String'>
    readonly doNotBuy: FieldRef<"Shop", 'String'>
    readonly missingCash1: FieldRef<"Shop", 'String'>
    readonly missingCash2: FieldRef<"Shop", 'String'>
    readonly messageBuy: FieldRef<"Shop", 'String'>
    readonly messageSell: FieldRef<"Shop", 'String'>
    readonly keeperZoneId: FieldRef<"Shop", 'Int'>
    readonly keeperId: FieldRef<"Shop", 'Int'>
    readonly zoneId: FieldRef<"Shop", 'Int'>
    readonly createdAt: FieldRef<"Shop", 'DateTime'>
    readonly updatedAt: FieldRef<"Shop", 'DateTime'>
    readonly createdBy: FieldRef<"Shop", 'String'>
    readonly updatedBy: FieldRef<"Shop", 'String'>
    readonly flags: FieldRef<"Shop", 'ShopFlag[]'>
    readonly tradesWithFlags: FieldRef<"Shop", 'ShopTradesWith[]'>
  }
    

  // Custom InputTypes

  /**
   * Shop findUnique
   */
  export type ShopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }


  /**
   * Shop findUniqueOrThrow
   */
  export type ShopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }


  /**
   * Shop findFirst
   */
  export type ShopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }


  /**
   * Shop findFirstOrThrow
   */
  export type ShopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }


  /**
   * Shop findMany
   */
  export type ShopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }


  /**
   * Shop create
   */
  export type ShopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to create a Shop.
     */
    data: XOR<ShopCreateInput, ShopUncheckedCreateInput>
  }


  /**
   * Shop createMany
   */
  export type ShopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Shop update
   */
  export type ShopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to update a Shop.
     */
    data: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
    /**
     * Choose, which Shop to update.
     */
    where: ShopWhereUniqueInput
  }


  /**
   * Shop updateMany
   */
  export type ShopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
  }


  /**
   * Shop upsert
   */
  export type ShopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The filter to search for the Shop to update in case it exists.
     */
    where: ShopWhereUniqueInput
    /**
     * In case the Shop found by the `where` argument doesn't exist, create a new Shop with this data.
     */
    create: XOR<ShopCreateInput, ShopUncheckedCreateInput>
    /**
     * In case the Shop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
  }


  /**
   * Shop delete
   */
  export type ShopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter which Shop to delete.
     */
    where: ShopWhereUniqueInput
  }


  /**
   * Shop deleteMany
   */
  export type ShopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shops to delete
     */
    where?: ShopWhereInput
  }


  /**
   * Shop.accepts
   */
  export type Shop$acceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
    where?: ShopAcceptWhereInput
    orderBy?: ShopAcceptOrderByWithRelationInput | ShopAcceptOrderByWithRelationInput[]
    cursor?: ShopAcceptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopAcceptScalarFieldEnum | ShopAcceptScalarFieldEnum[]
  }


  /**
   * Shop.hours
   */
  export type Shop$hoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
    where?: ShopHourWhereInput
    orderBy?: ShopHourOrderByWithRelationInput | ShopHourOrderByWithRelationInput[]
    cursor?: ShopHourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopHourScalarFieldEnum | ShopHourScalarFieldEnum[]
  }


  /**
   * Shop.items
   */
  export type Shop$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    where?: ShopItemWhereInput
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    cursor?: ShopItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }


  /**
   * Shop.rooms
   */
  export type Shop$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
    where?: ShopRoomWhereInput
    orderBy?: ShopRoomOrderByWithRelationInput | ShopRoomOrderByWithRelationInput[]
    cursor?: ShopRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopRoomScalarFieldEnum | ShopRoomScalarFieldEnum[]
  }


  /**
   * Shop.keeper
   */
  export type Shop$keeperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    where?: MobWhereInput
  }


  /**
   * Shop without action
   */
  export type ShopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopInclude<ExtArgs> | null
  }



  /**
   * Model ShopItem
   */

  export type AggregateShopItem = {
    _count: ShopItemCountAggregateOutputType | null
    _avg: ShopItemAvgAggregateOutputType | null
    _sum: ShopItemSumAggregateOutputType | null
    _min: ShopItemMinAggregateOutputType | null
    _max: ShopItemMaxAggregateOutputType | null
  }

  export type ShopItemAvgAggregateOutputType = {
    amount: number | null
    shopZoneId: number | null
    shopId: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ShopItemSumAggregateOutputType = {
    amount: number | null
    shopZoneId: number | null
    shopId: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ShopItemMinAggregateOutputType = {
    id: string | null
    amount: number | null
    shopZoneId: number | null
    shopId: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ShopItemMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    shopZoneId: number | null
    shopId: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type ShopItemCountAggregateOutputType = {
    id: number
    amount: number
    shopZoneId: number
    shopId: number
    objectZoneId: number
    objectId: number
    _all: number
  }


  export type ShopItemAvgAggregateInputType = {
    amount?: true
    shopZoneId?: true
    shopId?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ShopItemSumAggregateInputType = {
    amount?: true
    shopZoneId?: true
    shopId?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ShopItemMinAggregateInputType = {
    id?: true
    amount?: true
    shopZoneId?: true
    shopId?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ShopItemMaxAggregateInputType = {
    id?: true
    amount?: true
    shopZoneId?: true
    shopId?: true
    objectZoneId?: true
    objectId?: true
  }

  export type ShopItemCountAggregateInputType = {
    id?: true
    amount?: true
    shopZoneId?: true
    shopId?: true
    objectZoneId?: true
    objectId?: true
    _all?: true
  }

  export type ShopItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItem to aggregate.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopItems
    **/
    _count?: true | ShopItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopItemMaxAggregateInputType
  }

  export type GetShopItemAggregateType<T extends ShopItemAggregateArgs> = {
        [P in keyof T & keyof AggregateShopItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopItem[P]>
      : GetScalarType<T[P], AggregateShopItem[P]>
  }




  export type ShopItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemWhereInput
    orderBy?: ShopItemOrderByWithAggregationInput | ShopItemOrderByWithAggregationInput[]
    by: ShopItemScalarFieldEnum[] | ShopItemScalarFieldEnum
    having?: ShopItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopItemCountAggregateInputType | true
    _avg?: ShopItemAvgAggregateInputType
    _sum?: ShopItemSumAggregateInputType
    _min?: ShopItemMinAggregateInputType
    _max?: ShopItemMaxAggregateInputType
  }

  export type ShopItemGroupByOutputType = {
    id: string
    amount: number
    shopZoneId: number
    shopId: number
    objectZoneId: number
    objectId: number
    _count: ShopItemCountAggregateOutputType | null
    _avg: ShopItemAvgAggregateOutputType | null
    _sum: ShopItemSumAggregateOutputType | null
    _min: ShopItemMinAggregateOutputType | null
    _max: ShopItemMaxAggregateOutputType | null
  }

  type GetShopItemGroupByPayload<T extends ShopItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopItemGroupByOutputType[P]>
            : GetScalarType<T[P], ShopItemGroupByOutputType[P]>
        }
      >
    >


  export type ShopItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    shopZoneId?: boolean
    shopId?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopItem"]>

  export type ShopItemSelectScalar = {
    id?: boolean
    amount?: boolean
    shopZoneId?: boolean
    shopId?: boolean
    objectZoneId?: boolean
    objectId?: boolean
  }

  export type ShopItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }


  export type $ShopItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopItem"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      shopZoneId: number
      shopId: number
      objectZoneId: number
      objectId: number
    }, ExtArgs["result"]["shopItem"]>
    composites: {}
  }


  type ShopItemGetPayload<S extends boolean | null | undefined | ShopItemDefaultArgs> = $Result.GetResult<Prisma.$ShopItemPayload, S>

  type ShopItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopItemFindManyArgs, 'select' | 'include'> & {
      select?: ShopItemCountAggregateInputType | true
    }

  export interface ShopItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopItem'], meta: { name: 'ShopItem' } }
    /**
     * Find zero or one ShopItem that matches the filter.
     * @param {ShopItemFindUniqueArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopItemFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShopItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShopItemFindUniqueOrThrowArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShopItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindFirstArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopItemFindFirstArgs<ExtArgs>>
    ): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShopItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindFirstOrThrowArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShopItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopItems
     * const shopItems = await prisma.shopItem.findMany()
     * 
     * // Get first 10 ShopItems
     * const shopItems = await prisma.shopItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopItemWithIdOnly = await prisma.shopItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShopItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShopItem.
     * @param {ShopItemCreateArgs} args - Arguments to create a ShopItem.
     * @example
     * // Create one ShopItem
     * const ShopItem = await prisma.shopItem.create({
     *   data: {
     *     // ... data to create a ShopItem
     *   }
     * })
     * 
    **/
    create<T extends ShopItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopItemCreateArgs<ExtArgs>>
    ): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShopItems.
     *     @param {ShopItemCreateManyArgs} args - Arguments to create many ShopItems.
     *     @example
     *     // Create many ShopItems
     *     const shopItem = await prisma.shopItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopItem.
     * @param {ShopItemDeleteArgs} args - Arguments to delete one ShopItem.
     * @example
     * // Delete one ShopItem
     * const ShopItem = await prisma.shopItem.delete({
     *   where: {
     *     // ... filter to delete one ShopItem
     *   }
     * })
     * 
    **/
    delete<T extends ShopItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopItemDeleteArgs<ExtArgs>>
    ): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShopItem.
     * @param {ShopItemUpdateArgs} args - Arguments to update one ShopItem.
     * @example
     * // Update one ShopItem
     * const shopItem = await prisma.shopItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopItemUpdateArgs<ExtArgs>>
    ): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShopItems.
     * @param {ShopItemDeleteManyArgs} args - Arguments to filter ShopItems to delete.
     * @example
     * // Delete a few ShopItems
     * const { count } = await prisma.shopItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopItems
     * const shopItem = await prisma.shopItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopItem.
     * @param {ShopItemUpsertArgs} args - Arguments to update or create a ShopItem.
     * @example
     * // Update or create a ShopItem
     * const shopItem = await prisma.shopItem.upsert({
     *   create: {
     *     // ... data to create a ShopItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopItem we want to update
     *   }
     * })
    **/
    upsert<T extends ShopItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopItemUpsertArgs<ExtArgs>>
    ): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShopItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemCountArgs} args - Arguments to filter ShopItems to count.
     * @example
     * // Count the number of ShopItems
     * const count = await prisma.shopItem.count({
     *   where: {
     *     // ... the filter for the ShopItems we want to count
     *   }
     * })
    **/
    count<T extends ShopItemCountArgs>(
      args?: Subset<T, ShopItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopItemAggregateArgs>(args: Subset<T, ShopItemAggregateArgs>): Prisma.PrismaPromise<GetShopItemAggregateType<T>>

    /**
     * Group by ShopItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopItemGroupByArgs['orderBy'] }
        : { orderBy?: ShopItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopItem model
   */
  readonly fields: ShopItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShopItem model
   */ 
  interface ShopItemFieldRefs {
    readonly id: FieldRef<"ShopItem", 'String'>
    readonly amount: FieldRef<"ShopItem", 'Int'>
    readonly shopZoneId: FieldRef<"ShopItem", 'Int'>
    readonly shopId: FieldRef<"ShopItem", 'Int'>
    readonly objectZoneId: FieldRef<"ShopItem", 'Int'>
    readonly objectId: FieldRef<"ShopItem", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ShopItem findUnique
   */
  export type ShopItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where: ShopItemWhereUniqueInput
  }


  /**
   * ShopItem findUniqueOrThrow
   */
  export type ShopItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where: ShopItemWhereUniqueInput
  }


  /**
   * ShopItem findFirst
   */
  export type ShopItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItems.
     */
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }


  /**
   * ShopItem findFirstOrThrow
   */
  export type ShopItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItems.
     */
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }


  /**
   * ShopItem findMany
   */
  export type ShopItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItems to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }


  /**
   * ShopItem create
   */
  export type ShopItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopItem.
     */
    data: XOR<ShopItemCreateInput, ShopItemUncheckedCreateInput>
  }


  /**
   * ShopItem createMany
   */
  export type ShopItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopItems.
     */
    data: ShopItemCreateManyInput | ShopItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ShopItem update
   */
  export type ShopItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopItem.
     */
    data: XOR<ShopItemUpdateInput, ShopItemUncheckedUpdateInput>
    /**
     * Choose, which ShopItem to update.
     */
    where: ShopItemWhereUniqueInput
  }


  /**
   * ShopItem updateMany
   */
  export type ShopItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopItems.
     */
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyInput>
    /**
     * Filter which ShopItems to update
     */
    where?: ShopItemWhereInput
  }


  /**
   * ShopItem upsert
   */
  export type ShopItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopItem to update in case it exists.
     */
    where: ShopItemWhereUniqueInput
    /**
     * In case the ShopItem found by the `where` argument doesn't exist, create a new ShopItem with this data.
     */
    create: XOR<ShopItemCreateInput, ShopItemUncheckedCreateInput>
    /**
     * In case the ShopItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopItemUpdateInput, ShopItemUncheckedUpdateInput>
  }


  /**
   * ShopItem delete
   */
  export type ShopItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter which ShopItem to delete.
     */
    where: ShopItemWhereUniqueInput
  }


  /**
   * ShopItem deleteMany
   */
  export type ShopItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItems to delete
     */
    where?: ShopItemWhereInput
  }


  /**
   * ShopItem without action
   */
  export type ShopItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopItemInclude<ExtArgs> | null
  }



  /**
   * Model ShopAccept
   */

  export type AggregateShopAccept = {
    _count: ShopAcceptCountAggregateOutputType | null
    _avg: ShopAcceptAvgAggregateOutputType | null
    _sum: ShopAcceptSumAggregateOutputType | null
    _min: ShopAcceptMinAggregateOutputType | null
    _max: ShopAcceptMaxAggregateOutputType | null
  }

  export type ShopAcceptAvgAggregateOutputType = {
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopAcceptSumAggregateOutputType = {
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopAcceptMinAggregateOutputType = {
    id: string | null
    type: string | null
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopAcceptMaxAggregateOutputType = {
    id: string | null
    type: string | null
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopAcceptCountAggregateOutputType = {
    id: number
    type: number
    keywords: number
    shopZoneId: number
    shopId: number
    _all: number
  }


  export type ShopAcceptAvgAggregateInputType = {
    shopZoneId?: true
    shopId?: true
  }

  export type ShopAcceptSumAggregateInputType = {
    shopZoneId?: true
    shopId?: true
  }

  export type ShopAcceptMinAggregateInputType = {
    id?: true
    type?: true
    shopZoneId?: true
    shopId?: true
  }

  export type ShopAcceptMaxAggregateInputType = {
    id?: true
    type?: true
    shopZoneId?: true
    shopId?: true
  }

  export type ShopAcceptCountAggregateInputType = {
    id?: true
    type?: true
    keywords?: true
    shopZoneId?: true
    shopId?: true
    _all?: true
  }

  export type ShopAcceptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopAccept to aggregate.
     */
    where?: ShopAcceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopAccepts to fetch.
     */
    orderBy?: ShopAcceptOrderByWithRelationInput | ShopAcceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopAcceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopAccepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopAccepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopAccepts
    **/
    _count?: true | ShopAcceptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopAcceptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopAcceptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopAcceptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopAcceptMaxAggregateInputType
  }

  export type GetShopAcceptAggregateType<T extends ShopAcceptAggregateArgs> = {
        [P in keyof T & keyof AggregateShopAccept]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopAccept[P]>
      : GetScalarType<T[P], AggregateShopAccept[P]>
  }




  export type ShopAcceptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopAcceptWhereInput
    orderBy?: ShopAcceptOrderByWithAggregationInput | ShopAcceptOrderByWithAggregationInput[]
    by: ShopAcceptScalarFieldEnum[] | ShopAcceptScalarFieldEnum
    having?: ShopAcceptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopAcceptCountAggregateInputType | true
    _avg?: ShopAcceptAvgAggregateInputType
    _sum?: ShopAcceptSumAggregateInputType
    _min?: ShopAcceptMinAggregateInputType
    _max?: ShopAcceptMaxAggregateInputType
  }

  export type ShopAcceptGroupByOutputType = {
    id: string
    type: string
    keywords: string[]
    shopZoneId: number
    shopId: number
    _count: ShopAcceptCountAggregateOutputType | null
    _avg: ShopAcceptAvgAggregateOutputType | null
    _sum: ShopAcceptSumAggregateOutputType | null
    _min: ShopAcceptMinAggregateOutputType | null
    _max: ShopAcceptMaxAggregateOutputType | null
  }

  type GetShopAcceptGroupByPayload<T extends ShopAcceptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopAcceptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopAcceptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopAcceptGroupByOutputType[P]>
            : GetScalarType<T[P], ShopAcceptGroupByOutputType[P]>
        }
      >
    >


  export type ShopAcceptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    keywords?: boolean
    shopZoneId?: boolean
    shopId?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopAccept"]>

  export type ShopAcceptSelectScalar = {
    id?: boolean
    type?: boolean
    keywords?: boolean
    shopZoneId?: boolean
    shopId?: boolean
  }

  export type ShopAcceptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }


  export type $ShopAcceptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopAccept"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      keywords: string[]
      shopZoneId: number
      shopId: number
    }, ExtArgs["result"]["shopAccept"]>
    composites: {}
  }


  type ShopAcceptGetPayload<S extends boolean | null | undefined | ShopAcceptDefaultArgs> = $Result.GetResult<Prisma.$ShopAcceptPayload, S>

  type ShopAcceptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopAcceptFindManyArgs, 'select' | 'include'> & {
      select?: ShopAcceptCountAggregateInputType | true
    }

  export interface ShopAcceptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopAccept'], meta: { name: 'ShopAccept' } }
    /**
     * Find zero or one ShopAccept that matches the filter.
     * @param {ShopAcceptFindUniqueArgs} args - Arguments to find a ShopAccept
     * @example
     * // Get one ShopAccept
     * const shopAccept = await prisma.shopAccept.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopAcceptFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopAcceptFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopAcceptClient<$Result.GetResult<Prisma.$ShopAcceptPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShopAccept that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShopAcceptFindUniqueOrThrowArgs} args - Arguments to find a ShopAccept
     * @example
     * // Get one ShopAccept
     * const shopAccept = await prisma.shopAccept.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopAcceptFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopAcceptFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopAcceptClient<$Result.GetResult<Prisma.$ShopAcceptPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShopAccept that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAcceptFindFirstArgs} args - Arguments to find a ShopAccept
     * @example
     * // Get one ShopAccept
     * const shopAccept = await prisma.shopAccept.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopAcceptFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopAcceptFindFirstArgs<ExtArgs>>
    ): Prisma__ShopAcceptClient<$Result.GetResult<Prisma.$ShopAcceptPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShopAccept that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAcceptFindFirstOrThrowArgs} args - Arguments to find a ShopAccept
     * @example
     * // Get one ShopAccept
     * const shopAccept = await prisma.shopAccept.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopAcceptFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopAcceptFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopAcceptClient<$Result.GetResult<Prisma.$ShopAcceptPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShopAccepts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAcceptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopAccepts
     * const shopAccepts = await prisma.shopAccept.findMany()
     * 
     * // Get first 10 ShopAccepts
     * const shopAccepts = await prisma.shopAccept.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopAcceptWithIdOnly = await prisma.shopAccept.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShopAcceptFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopAcceptFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopAcceptPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShopAccept.
     * @param {ShopAcceptCreateArgs} args - Arguments to create a ShopAccept.
     * @example
     * // Create one ShopAccept
     * const ShopAccept = await prisma.shopAccept.create({
     *   data: {
     *     // ... data to create a ShopAccept
     *   }
     * })
     * 
    **/
    create<T extends ShopAcceptCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopAcceptCreateArgs<ExtArgs>>
    ): Prisma__ShopAcceptClient<$Result.GetResult<Prisma.$ShopAcceptPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShopAccepts.
     *     @param {ShopAcceptCreateManyArgs} args - Arguments to create many ShopAccepts.
     *     @example
     *     // Create many ShopAccepts
     *     const shopAccept = await prisma.shopAccept.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopAcceptCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopAcceptCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopAccept.
     * @param {ShopAcceptDeleteArgs} args - Arguments to delete one ShopAccept.
     * @example
     * // Delete one ShopAccept
     * const ShopAccept = await prisma.shopAccept.delete({
     *   where: {
     *     // ... filter to delete one ShopAccept
     *   }
     * })
     * 
    **/
    delete<T extends ShopAcceptDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopAcceptDeleteArgs<ExtArgs>>
    ): Prisma__ShopAcceptClient<$Result.GetResult<Prisma.$ShopAcceptPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShopAccept.
     * @param {ShopAcceptUpdateArgs} args - Arguments to update one ShopAccept.
     * @example
     * // Update one ShopAccept
     * const shopAccept = await prisma.shopAccept.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopAcceptUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopAcceptUpdateArgs<ExtArgs>>
    ): Prisma__ShopAcceptClient<$Result.GetResult<Prisma.$ShopAcceptPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShopAccepts.
     * @param {ShopAcceptDeleteManyArgs} args - Arguments to filter ShopAccepts to delete.
     * @example
     * // Delete a few ShopAccepts
     * const { count } = await prisma.shopAccept.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopAcceptDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopAcceptDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopAccepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAcceptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopAccepts
     * const shopAccept = await prisma.shopAccept.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopAcceptUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopAcceptUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopAccept.
     * @param {ShopAcceptUpsertArgs} args - Arguments to update or create a ShopAccept.
     * @example
     * // Update or create a ShopAccept
     * const shopAccept = await prisma.shopAccept.upsert({
     *   create: {
     *     // ... data to create a ShopAccept
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopAccept we want to update
     *   }
     * })
    **/
    upsert<T extends ShopAcceptUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopAcceptUpsertArgs<ExtArgs>>
    ): Prisma__ShopAcceptClient<$Result.GetResult<Prisma.$ShopAcceptPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShopAccepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAcceptCountArgs} args - Arguments to filter ShopAccepts to count.
     * @example
     * // Count the number of ShopAccepts
     * const count = await prisma.shopAccept.count({
     *   where: {
     *     // ... the filter for the ShopAccepts we want to count
     *   }
     * })
    **/
    count<T extends ShopAcceptCountArgs>(
      args?: Subset<T, ShopAcceptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopAcceptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopAccept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAcceptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopAcceptAggregateArgs>(args: Subset<T, ShopAcceptAggregateArgs>): Prisma.PrismaPromise<GetShopAcceptAggregateType<T>>

    /**
     * Group by ShopAccept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAcceptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopAcceptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopAcceptGroupByArgs['orderBy'] }
        : { orderBy?: ShopAcceptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopAcceptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopAcceptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopAccept model
   */
  readonly fields: ShopAcceptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopAccept.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopAcceptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShopAccept model
   */ 
  interface ShopAcceptFieldRefs {
    readonly id: FieldRef<"ShopAccept", 'String'>
    readonly type: FieldRef<"ShopAccept", 'String'>
    readonly keywords: FieldRef<"ShopAccept", 'String[]'>
    readonly shopZoneId: FieldRef<"ShopAccept", 'Int'>
    readonly shopId: FieldRef<"ShopAccept", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ShopAccept findUnique
   */
  export type ShopAcceptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
    /**
     * Filter, which ShopAccept to fetch.
     */
    where: ShopAcceptWhereUniqueInput
  }


  /**
   * ShopAccept findUniqueOrThrow
   */
  export type ShopAcceptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
    /**
     * Filter, which ShopAccept to fetch.
     */
    where: ShopAcceptWhereUniqueInput
  }


  /**
   * ShopAccept findFirst
   */
  export type ShopAcceptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
    /**
     * Filter, which ShopAccept to fetch.
     */
    where?: ShopAcceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopAccepts to fetch.
     */
    orderBy?: ShopAcceptOrderByWithRelationInput | ShopAcceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopAccepts.
     */
    cursor?: ShopAcceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopAccepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopAccepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopAccepts.
     */
    distinct?: ShopAcceptScalarFieldEnum | ShopAcceptScalarFieldEnum[]
  }


  /**
   * ShopAccept findFirstOrThrow
   */
  export type ShopAcceptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
    /**
     * Filter, which ShopAccept to fetch.
     */
    where?: ShopAcceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopAccepts to fetch.
     */
    orderBy?: ShopAcceptOrderByWithRelationInput | ShopAcceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopAccepts.
     */
    cursor?: ShopAcceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopAccepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopAccepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopAccepts.
     */
    distinct?: ShopAcceptScalarFieldEnum | ShopAcceptScalarFieldEnum[]
  }


  /**
   * ShopAccept findMany
   */
  export type ShopAcceptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
    /**
     * Filter, which ShopAccepts to fetch.
     */
    where?: ShopAcceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopAccepts to fetch.
     */
    orderBy?: ShopAcceptOrderByWithRelationInput | ShopAcceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopAccepts.
     */
    cursor?: ShopAcceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopAccepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopAccepts.
     */
    skip?: number
    distinct?: ShopAcceptScalarFieldEnum | ShopAcceptScalarFieldEnum[]
  }


  /**
   * ShopAccept create
   */
  export type ShopAcceptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopAccept.
     */
    data: XOR<ShopAcceptCreateInput, ShopAcceptUncheckedCreateInput>
  }


  /**
   * ShopAccept createMany
   */
  export type ShopAcceptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopAccepts.
     */
    data: ShopAcceptCreateManyInput | ShopAcceptCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ShopAccept update
   */
  export type ShopAcceptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopAccept.
     */
    data: XOR<ShopAcceptUpdateInput, ShopAcceptUncheckedUpdateInput>
    /**
     * Choose, which ShopAccept to update.
     */
    where: ShopAcceptWhereUniqueInput
  }


  /**
   * ShopAccept updateMany
   */
  export type ShopAcceptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopAccepts.
     */
    data: XOR<ShopAcceptUpdateManyMutationInput, ShopAcceptUncheckedUpdateManyInput>
    /**
     * Filter which ShopAccepts to update
     */
    where?: ShopAcceptWhereInput
  }


  /**
   * ShopAccept upsert
   */
  export type ShopAcceptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopAccept to update in case it exists.
     */
    where: ShopAcceptWhereUniqueInput
    /**
     * In case the ShopAccept found by the `where` argument doesn't exist, create a new ShopAccept with this data.
     */
    create: XOR<ShopAcceptCreateInput, ShopAcceptUncheckedCreateInput>
    /**
     * In case the ShopAccept was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopAcceptUpdateInput, ShopAcceptUncheckedUpdateInput>
  }


  /**
   * ShopAccept delete
   */
  export type ShopAcceptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
    /**
     * Filter which ShopAccept to delete.
     */
    where: ShopAcceptWhereUniqueInput
  }


  /**
   * ShopAccept deleteMany
   */
  export type ShopAcceptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopAccepts to delete
     */
    where?: ShopAcceptWhereInput
  }


  /**
   * ShopAccept without action
   */
  export type ShopAcceptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopAccept
     */
    select?: ShopAcceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopAcceptInclude<ExtArgs> | null
  }



  /**
   * Model ShopRoom
   */

  export type AggregateShopRoom = {
    _count: ShopRoomCountAggregateOutputType | null
    _avg: ShopRoomAvgAggregateOutputType | null
    _sum: ShopRoomSumAggregateOutputType | null
    _min: ShopRoomMinAggregateOutputType | null
    _max: ShopRoomMaxAggregateOutputType | null
  }

  export type ShopRoomAvgAggregateOutputType = {
    roomId: number | null
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopRoomSumAggregateOutputType = {
    roomId: number | null
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopRoomMinAggregateOutputType = {
    id: string | null
    roomId: number | null
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopRoomMaxAggregateOutputType = {
    id: string | null
    roomId: number | null
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopRoomCountAggregateOutputType = {
    id: number
    roomId: number
    shopZoneId: number
    shopId: number
    _all: number
  }


  export type ShopRoomAvgAggregateInputType = {
    roomId?: true
    shopZoneId?: true
    shopId?: true
  }

  export type ShopRoomSumAggregateInputType = {
    roomId?: true
    shopZoneId?: true
    shopId?: true
  }

  export type ShopRoomMinAggregateInputType = {
    id?: true
    roomId?: true
    shopZoneId?: true
    shopId?: true
  }

  export type ShopRoomMaxAggregateInputType = {
    id?: true
    roomId?: true
    shopZoneId?: true
    shopId?: true
  }

  export type ShopRoomCountAggregateInputType = {
    id?: true
    roomId?: true
    shopZoneId?: true
    shopId?: true
    _all?: true
  }

  export type ShopRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopRoom to aggregate.
     */
    where?: ShopRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopRooms to fetch.
     */
    orderBy?: ShopRoomOrderByWithRelationInput | ShopRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopRooms
    **/
    _count?: true | ShopRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopRoomMaxAggregateInputType
  }

  export type GetShopRoomAggregateType<T extends ShopRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateShopRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopRoom[P]>
      : GetScalarType<T[P], AggregateShopRoom[P]>
  }




  export type ShopRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopRoomWhereInput
    orderBy?: ShopRoomOrderByWithAggregationInput | ShopRoomOrderByWithAggregationInput[]
    by: ShopRoomScalarFieldEnum[] | ShopRoomScalarFieldEnum
    having?: ShopRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopRoomCountAggregateInputType | true
    _avg?: ShopRoomAvgAggregateInputType
    _sum?: ShopRoomSumAggregateInputType
    _min?: ShopRoomMinAggregateInputType
    _max?: ShopRoomMaxAggregateInputType
  }

  export type ShopRoomGroupByOutputType = {
    id: string
    roomId: number
    shopZoneId: number
    shopId: number
    _count: ShopRoomCountAggregateOutputType | null
    _avg: ShopRoomAvgAggregateOutputType | null
    _sum: ShopRoomSumAggregateOutputType | null
    _min: ShopRoomMinAggregateOutputType | null
    _max: ShopRoomMaxAggregateOutputType | null
  }

  type GetShopRoomGroupByPayload<T extends ShopRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopRoomGroupByOutputType[P]>
            : GetScalarType<T[P], ShopRoomGroupByOutputType[P]>
        }
      >
    >


  export type ShopRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    shopZoneId?: boolean
    shopId?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopRoom"]>

  export type ShopRoomSelectScalar = {
    id?: boolean
    roomId?: boolean
    shopZoneId?: boolean
    shopId?: boolean
  }

  export type ShopRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }


  export type $ShopRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopRoom"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: number
      shopZoneId: number
      shopId: number
    }, ExtArgs["result"]["shopRoom"]>
    composites: {}
  }


  type ShopRoomGetPayload<S extends boolean | null | undefined | ShopRoomDefaultArgs> = $Result.GetResult<Prisma.$ShopRoomPayload, S>

  type ShopRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopRoomFindManyArgs, 'select' | 'include'> & {
      select?: ShopRoomCountAggregateInputType | true
    }

  export interface ShopRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopRoom'], meta: { name: 'ShopRoom' } }
    /**
     * Find zero or one ShopRoom that matches the filter.
     * @param {ShopRoomFindUniqueArgs} args - Arguments to find a ShopRoom
     * @example
     * // Get one ShopRoom
     * const shopRoom = await prisma.shopRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopRoomFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopRoomFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopRoomClient<$Result.GetResult<Prisma.$ShopRoomPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShopRoom that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShopRoomFindUniqueOrThrowArgs} args - Arguments to find a ShopRoom
     * @example
     * // Get one ShopRoom
     * const shopRoom = await prisma.shopRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopRoomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopRoomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopRoomClient<$Result.GetResult<Prisma.$ShopRoomPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShopRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopRoomFindFirstArgs} args - Arguments to find a ShopRoom
     * @example
     * // Get one ShopRoom
     * const shopRoom = await prisma.shopRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopRoomFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopRoomFindFirstArgs<ExtArgs>>
    ): Prisma__ShopRoomClient<$Result.GetResult<Prisma.$ShopRoomPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShopRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopRoomFindFirstOrThrowArgs} args - Arguments to find a ShopRoom
     * @example
     * // Get one ShopRoom
     * const shopRoom = await prisma.shopRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopRoomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopRoomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopRoomClient<$Result.GetResult<Prisma.$ShopRoomPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShopRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopRoomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopRooms
     * const shopRooms = await prisma.shopRoom.findMany()
     * 
     * // Get first 10 ShopRooms
     * const shopRooms = await prisma.shopRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopRoomWithIdOnly = await prisma.shopRoom.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShopRoomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopRoomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopRoomPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShopRoom.
     * @param {ShopRoomCreateArgs} args - Arguments to create a ShopRoom.
     * @example
     * // Create one ShopRoom
     * const ShopRoom = await prisma.shopRoom.create({
     *   data: {
     *     // ... data to create a ShopRoom
     *   }
     * })
     * 
    **/
    create<T extends ShopRoomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopRoomCreateArgs<ExtArgs>>
    ): Prisma__ShopRoomClient<$Result.GetResult<Prisma.$ShopRoomPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShopRooms.
     *     @param {ShopRoomCreateManyArgs} args - Arguments to create many ShopRooms.
     *     @example
     *     // Create many ShopRooms
     *     const shopRoom = await prisma.shopRoom.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopRoomCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopRoomCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopRoom.
     * @param {ShopRoomDeleteArgs} args - Arguments to delete one ShopRoom.
     * @example
     * // Delete one ShopRoom
     * const ShopRoom = await prisma.shopRoom.delete({
     *   where: {
     *     // ... filter to delete one ShopRoom
     *   }
     * })
     * 
    **/
    delete<T extends ShopRoomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopRoomDeleteArgs<ExtArgs>>
    ): Prisma__ShopRoomClient<$Result.GetResult<Prisma.$ShopRoomPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShopRoom.
     * @param {ShopRoomUpdateArgs} args - Arguments to update one ShopRoom.
     * @example
     * // Update one ShopRoom
     * const shopRoom = await prisma.shopRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopRoomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopRoomUpdateArgs<ExtArgs>>
    ): Prisma__ShopRoomClient<$Result.GetResult<Prisma.$ShopRoomPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShopRooms.
     * @param {ShopRoomDeleteManyArgs} args - Arguments to filter ShopRooms to delete.
     * @example
     * // Delete a few ShopRooms
     * const { count } = await prisma.shopRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopRoomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopRoomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopRooms
     * const shopRoom = await prisma.shopRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopRoomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopRoomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopRoom.
     * @param {ShopRoomUpsertArgs} args - Arguments to update or create a ShopRoom.
     * @example
     * // Update or create a ShopRoom
     * const shopRoom = await prisma.shopRoom.upsert({
     *   create: {
     *     // ... data to create a ShopRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopRoom we want to update
     *   }
     * })
    **/
    upsert<T extends ShopRoomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopRoomUpsertArgs<ExtArgs>>
    ): Prisma__ShopRoomClient<$Result.GetResult<Prisma.$ShopRoomPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShopRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopRoomCountArgs} args - Arguments to filter ShopRooms to count.
     * @example
     * // Count the number of ShopRooms
     * const count = await prisma.shopRoom.count({
     *   where: {
     *     // ... the filter for the ShopRooms we want to count
     *   }
     * })
    **/
    count<T extends ShopRoomCountArgs>(
      args?: Subset<T, ShopRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopRoomAggregateArgs>(args: Subset<T, ShopRoomAggregateArgs>): Prisma.PrismaPromise<GetShopRoomAggregateType<T>>

    /**
     * Group by ShopRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopRoomGroupByArgs['orderBy'] }
        : { orderBy?: ShopRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopRoom model
   */
  readonly fields: ShopRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShopRoom model
   */ 
  interface ShopRoomFieldRefs {
    readonly id: FieldRef<"ShopRoom", 'String'>
    readonly roomId: FieldRef<"ShopRoom", 'Int'>
    readonly shopZoneId: FieldRef<"ShopRoom", 'Int'>
    readonly shopId: FieldRef<"ShopRoom", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ShopRoom findUnique
   */
  export type ShopRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
    /**
     * Filter, which ShopRoom to fetch.
     */
    where: ShopRoomWhereUniqueInput
  }


  /**
   * ShopRoom findUniqueOrThrow
   */
  export type ShopRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
    /**
     * Filter, which ShopRoom to fetch.
     */
    where: ShopRoomWhereUniqueInput
  }


  /**
   * ShopRoom findFirst
   */
  export type ShopRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
    /**
     * Filter, which ShopRoom to fetch.
     */
    where?: ShopRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopRooms to fetch.
     */
    orderBy?: ShopRoomOrderByWithRelationInput | ShopRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopRooms.
     */
    cursor?: ShopRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopRooms.
     */
    distinct?: ShopRoomScalarFieldEnum | ShopRoomScalarFieldEnum[]
  }


  /**
   * ShopRoom findFirstOrThrow
   */
  export type ShopRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
    /**
     * Filter, which ShopRoom to fetch.
     */
    where?: ShopRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopRooms to fetch.
     */
    orderBy?: ShopRoomOrderByWithRelationInput | ShopRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopRooms.
     */
    cursor?: ShopRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopRooms.
     */
    distinct?: ShopRoomScalarFieldEnum | ShopRoomScalarFieldEnum[]
  }


  /**
   * ShopRoom findMany
   */
  export type ShopRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
    /**
     * Filter, which ShopRooms to fetch.
     */
    where?: ShopRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopRooms to fetch.
     */
    orderBy?: ShopRoomOrderByWithRelationInput | ShopRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopRooms.
     */
    cursor?: ShopRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopRooms.
     */
    skip?: number
    distinct?: ShopRoomScalarFieldEnum | ShopRoomScalarFieldEnum[]
  }


  /**
   * ShopRoom create
   */
  export type ShopRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopRoom.
     */
    data: XOR<ShopRoomCreateInput, ShopRoomUncheckedCreateInput>
  }


  /**
   * ShopRoom createMany
   */
  export type ShopRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopRooms.
     */
    data: ShopRoomCreateManyInput | ShopRoomCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ShopRoom update
   */
  export type ShopRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopRoom.
     */
    data: XOR<ShopRoomUpdateInput, ShopRoomUncheckedUpdateInput>
    /**
     * Choose, which ShopRoom to update.
     */
    where: ShopRoomWhereUniqueInput
  }


  /**
   * ShopRoom updateMany
   */
  export type ShopRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopRooms.
     */
    data: XOR<ShopRoomUpdateManyMutationInput, ShopRoomUncheckedUpdateManyInput>
    /**
     * Filter which ShopRooms to update
     */
    where?: ShopRoomWhereInput
  }


  /**
   * ShopRoom upsert
   */
  export type ShopRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopRoom to update in case it exists.
     */
    where: ShopRoomWhereUniqueInput
    /**
     * In case the ShopRoom found by the `where` argument doesn't exist, create a new ShopRoom with this data.
     */
    create: XOR<ShopRoomCreateInput, ShopRoomUncheckedCreateInput>
    /**
     * In case the ShopRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopRoomUpdateInput, ShopRoomUncheckedUpdateInput>
  }


  /**
   * ShopRoom delete
   */
  export type ShopRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
    /**
     * Filter which ShopRoom to delete.
     */
    where: ShopRoomWhereUniqueInput
  }


  /**
   * ShopRoom deleteMany
   */
  export type ShopRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopRooms to delete
     */
    where?: ShopRoomWhereInput
  }


  /**
   * ShopRoom without action
   */
  export type ShopRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopRoom
     */
    select?: ShopRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopRoomInclude<ExtArgs> | null
  }



  /**
   * Model ShopHour
   */

  export type AggregateShopHour = {
    _count: ShopHourCountAggregateOutputType | null
    _avg: ShopHourAvgAggregateOutputType | null
    _sum: ShopHourSumAggregateOutputType | null
    _min: ShopHourMinAggregateOutputType | null
    _max: ShopHourMaxAggregateOutputType | null
  }

  export type ShopHourAvgAggregateOutputType = {
    open: number | null
    close: number | null
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopHourSumAggregateOutputType = {
    open: number | null
    close: number | null
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopHourMinAggregateOutputType = {
    id: string | null
    open: number | null
    close: number | null
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopHourMaxAggregateOutputType = {
    id: string | null
    open: number | null
    close: number | null
    shopZoneId: number | null
    shopId: number | null
  }

  export type ShopHourCountAggregateOutputType = {
    id: number
    open: number
    close: number
    shopZoneId: number
    shopId: number
    _all: number
  }


  export type ShopHourAvgAggregateInputType = {
    open?: true
    close?: true
    shopZoneId?: true
    shopId?: true
  }

  export type ShopHourSumAggregateInputType = {
    open?: true
    close?: true
    shopZoneId?: true
    shopId?: true
  }

  export type ShopHourMinAggregateInputType = {
    id?: true
    open?: true
    close?: true
    shopZoneId?: true
    shopId?: true
  }

  export type ShopHourMaxAggregateInputType = {
    id?: true
    open?: true
    close?: true
    shopZoneId?: true
    shopId?: true
  }

  export type ShopHourCountAggregateInputType = {
    id?: true
    open?: true
    close?: true
    shopZoneId?: true
    shopId?: true
    _all?: true
  }

  export type ShopHourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopHour to aggregate.
     */
    where?: ShopHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopHours to fetch.
     */
    orderBy?: ShopHourOrderByWithRelationInput | ShopHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopHours
    **/
    _count?: true | ShopHourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopHourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopHourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopHourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopHourMaxAggregateInputType
  }

  export type GetShopHourAggregateType<T extends ShopHourAggregateArgs> = {
        [P in keyof T & keyof AggregateShopHour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopHour[P]>
      : GetScalarType<T[P], AggregateShopHour[P]>
  }




  export type ShopHourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopHourWhereInput
    orderBy?: ShopHourOrderByWithAggregationInput | ShopHourOrderByWithAggregationInput[]
    by: ShopHourScalarFieldEnum[] | ShopHourScalarFieldEnum
    having?: ShopHourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopHourCountAggregateInputType | true
    _avg?: ShopHourAvgAggregateInputType
    _sum?: ShopHourSumAggregateInputType
    _min?: ShopHourMinAggregateInputType
    _max?: ShopHourMaxAggregateInputType
  }

  export type ShopHourGroupByOutputType = {
    id: string
    open: number
    close: number
    shopZoneId: number
    shopId: number
    _count: ShopHourCountAggregateOutputType | null
    _avg: ShopHourAvgAggregateOutputType | null
    _sum: ShopHourSumAggregateOutputType | null
    _min: ShopHourMinAggregateOutputType | null
    _max: ShopHourMaxAggregateOutputType | null
  }

  type GetShopHourGroupByPayload<T extends ShopHourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopHourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopHourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopHourGroupByOutputType[P]>
            : GetScalarType<T[P], ShopHourGroupByOutputType[P]>
        }
      >
    >


  export type ShopHourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    open?: boolean
    close?: boolean
    shopZoneId?: boolean
    shopId?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopHour"]>

  export type ShopHourSelectScalar = {
    id?: boolean
    open?: boolean
    close?: boolean
    shopZoneId?: boolean
    shopId?: boolean
  }

  export type ShopHourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }


  export type $ShopHourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopHour"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      open: number
      close: number
      shopZoneId: number
      shopId: number
    }, ExtArgs["result"]["shopHour"]>
    composites: {}
  }


  type ShopHourGetPayload<S extends boolean | null | undefined | ShopHourDefaultArgs> = $Result.GetResult<Prisma.$ShopHourPayload, S>

  type ShopHourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopHourFindManyArgs, 'select' | 'include'> & {
      select?: ShopHourCountAggregateInputType | true
    }

  export interface ShopHourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopHour'], meta: { name: 'ShopHour' } }
    /**
     * Find zero or one ShopHour that matches the filter.
     * @param {ShopHourFindUniqueArgs} args - Arguments to find a ShopHour
     * @example
     * // Get one ShopHour
     * const shopHour = await prisma.shopHour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopHourFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopHourFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopHourClient<$Result.GetResult<Prisma.$ShopHourPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShopHour that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShopHourFindUniqueOrThrowArgs} args - Arguments to find a ShopHour
     * @example
     * // Get one ShopHour
     * const shopHour = await prisma.shopHour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopHourFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopHourFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopHourClient<$Result.GetResult<Prisma.$ShopHourPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShopHour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopHourFindFirstArgs} args - Arguments to find a ShopHour
     * @example
     * // Get one ShopHour
     * const shopHour = await prisma.shopHour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopHourFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopHourFindFirstArgs<ExtArgs>>
    ): Prisma__ShopHourClient<$Result.GetResult<Prisma.$ShopHourPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShopHour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopHourFindFirstOrThrowArgs} args - Arguments to find a ShopHour
     * @example
     * // Get one ShopHour
     * const shopHour = await prisma.shopHour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopHourFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopHourFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopHourClient<$Result.GetResult<Prisma.$ShopHourPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShopHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopHourFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopHours
     * const shopHours = await prisma.shopHour.findMany()
     * 
     * // Get first 10 ShopHours
     * const shopHours = await prisma.shopHour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopHourWithIdOnly = await prisma.shopHour.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShopHourFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopHourFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopHourPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShopHour.
     * @param {ShopHourCreateArgs} args - Arguments to create a ShopHour.
     * @example
     * // Create one ShopHour
     * const ShopHour = await prisma.shopHour.create({
     *   data: {
     *     // ... data to create a ShopHour
     *   }
     * })
     * 
    **/
    create<T extends ShopHourCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopHourCreateArgs<ExtArgs>>
    ): Prisma__ShopHourClient<$Result.GetResult<Prisma.$ShopHourPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShopHours.
     *     @param {ShopHourCreateManyArgs} args - Arguments to create many ShopHours.
     *     @example
     *     // Create many ShopHours
     *     const shopHour = await prisma.shopHour.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopHourCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopHourCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopHour.
     * @param {ShopHourDeleteArgs} args - Arguments to delete one ShopHour.
     * @example
     * // Delete one ShopHour
     * const ShopHour = await prisma.shopHour.delete({
     *   where: {
     *     // ... filter to delete one ShopHour
     *   }
     * })
     * 
    **/
    delete<T extends ShopHourDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopHourDeleteArgs<ExtArgs>>
    ): Prisma__ShopHourClient<$Result.GetResult<Prisma.$ShopHourPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShopHour.
     * @param {ShopHourUpdateArgs} args - Arguments to update one ShopHour.
     * @example
     * // Update one ShopHour
     * const shopHour = await prisma.shopHour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopHourUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopHourUpdateArgs<ExtArgs>>
    ): Prisma__ShopHourClient<$Result.GetResult<Prisma.$ShopHourPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShopHours.
     * @param {ShopHourDeleteManyArgs} args - Arguments to filter ShopHours to delete.
     * @example
     * // Delete a few ShopHours
     * const { count } = await prisma.shopHour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopHourDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopHourDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopHourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopHours
     * const shopHour = await prisma.shopHour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopHourUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopHourUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopHour.
     * @param {ShopHourUpsertArgs} args - Arguments to update or create a ShopHour.
     * @example
     * // Update or create a ShopHour
     * const shopHour = await prisma.shopHour.upsert({
     *   create: {
     *     // ... data to create a ShopHour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopHour we want to update
     *   }
     * })
    **/
    upsert<T extends ShopHourUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopHourUpsertArgs<ExtArgs>>
    ): Prisma__ShopHourClient<$Result.GetResult<Prisma.$ShopHourPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShopHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopHourCountArgs} args - Arguments to filter ShopHours to count.
     * @example
     * // Count the number of ShopHours
     * const count = await prisma.shopHour.count({
     *   where: {
     *     // ... the filter for the ShopHours we want to count
     *   }
     * })
    **/
    count<T extends ShopHourCountArgs>(
      args?: Subset<T, ShopHourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopHourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopHourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopHourAggregateArgs>(args: Subset<T, ShopHourAggregateArgs>): Prisma.PrismaPromise<GetShopHourAggregateType<T>>

    /**
     * Group by ShopHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopHourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopHourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopHourGroupByArgs['orderBy'] }
        : { orderBy?: ShopHourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopHourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopHourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopHour model
   */
  readonly fields: ShopHourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopHour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopHourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShopHour model
   */ 
  interface ShopHourFieldRefs {
    readonly id: FieldRef<"ShopHour", 'String'>
    readonly open: FieldRef<"ShopHour", 'Int'>
    readonly close: FieldRef<"ShopHour", 'Int'>
    readonly shopZoneId: FieldRef<"ShopHour", 'Int'>
    readonly shopId: FieldRef<"ShopHour", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ShopHour findUnique
   */
  export type ShopHourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
    /**
     * Filter, which ShopHour to fetch.
     */
    where: ShopHourWhereUniqueInput
  }


  /**
   * ShopHour findUniqueOrThrow
   */
  export type ShopHourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
    /**
     * Filter, which ShopHour to fetch.
     */
    where: ShopHourWhereUniqueInput
  }


  /**
   * ShopHour findFirst
   */
  export type ShopHourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
    /**
     * Filter, which ShopHour to fetch.
     */
    where?: ShopHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopHours to fetch.
     */
    orderBy?: ShopHourOrderByWithRelationInput | ShopHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopHours.
     */
    cursor?: ShopHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopHours.
     */
    distinct?: ShopHourScalarFieldEnum | ShopHourScalarFieldEnum[]
  }


  /**
   * ShopHour findFirstOrThrow
   */
  export type ShopHourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
    /**
     * Filter, which ShopHour to fetch.
     */
    where?: ShopHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopHours to fetch.
     */
    orderBy?: ShopHourOrderByWithRelationInput | ShopHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopHours.
     */
    cursor?: ShopHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopHours.
     */
    distinct?: ShopHourScalarFieldEnum | ShopHourScalarFieldEnum[]
  }


  /**
   * ShopHour findMany
   */
  export type ShopHourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
    /**
     * Filter, which ShopHours to fetch.
     */
    where?: ShopHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopHours to fetch.
     */
    orderBy?: ShopHourOrderByWithRelationInput | ShopHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopHours.
     */
    cursor?: ShopHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopHours.
     */
    skip?: number
    distinct?: ShopHourScalarFieldEnum | ShopHourScalarFieldEnum[]
  }


  /**
   * ShopHour create
   */
  export type ShopHourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopHour.
     */
    data: XOR<ShopHourCreateInput, ShopHourUncheckedCreateInput>
  }


  /**
   * ShopHour createMany
   */
  export type ShopHourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopHours.
     */
    data: ShopHourCreateManyInput | ShopHourCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ShopHour update
   */
  export type ShopHourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopHour.
     */
    data: XOR<ShopHourUpdateInput, ShopHourUncheckedUpdateInput>
    /**
     * Choose, which ShopHour to update.
     */
    where: ShopHourWhereUniqueInput
  }


  /**
   * ShopHour updateMany
   */
  export type ShopHourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopHours.
     */
    data: XOR<ShopHourUpdateManyMutationInput, ShopHourUncheckedUpdateManyInput>
    /**
     * Filter which ShopHours to update
     */
    where?: ShopHourWhereInput
  }


  /**
   * ShopHour upsert
   */
  export type ShopHourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopHour to update in case it exists.
     */
    where: ShopHourWhereUniqueInput
    /**
     * In case the ShopHour found by the `where` argument doesn't exist, create a new ShopHour with this data.
     */
    create: XOR<ShopHourCreateInput, ShopHourUncheckedCreateInput>
    /**
     * In case the ShopHour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopHourUpdateInput, ShopHourUncheckedUpdateInput>
  }


  /**
   * ShopHour delete
   */
  export type ShopHourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
    /**
     * Filter which ShopHour to delete.
     */
    where: ShopHourWhereUniqueInput
  }


  /**
   * ShopHour deleteMany
   */
  export type ShopHourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopHours to delete
     */
    where?: ShopHourWhereInput
  }


  /**
   * ShopHour without action
   */
  export type ShopHourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopHour
     */
    select?: ShopHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopHourInclude<ExtArgs> | null
  }



  /**
   * Model Trigger
   */

  export type AggregateTrigger = {
    _count: TriggerCountAggregateOutputType | null
    _avg: TriggerAvgAggregateOutputType | null
    _sum: TriggerSumAggregateOutputType | null
    _min: TriggerMinAggregateOutputType | null
    _max: TriggerMaxAggregateOutputType | null
  }

  export type TriggerAvgAggregateOutputType = {
    numArgs: number | null
    zoneId: number | null
    mobZoneId: number | null
    mobId: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type TriggerSumAggregateOutputType = {
    numArgs: number | null
    zoneId: number | null
    mobZoneId: number | null
    mobId: number | null
    objectZoneId: number | null
    objectId: number | null
  }

  export type TriggerMinAggregateOutputType = {
    id: string | null
    name: string | null
    attachType: $Enums.ScriptType | null
    numArgs: number | null
    argList: string | null
    commands: string | null
    zoneId: number | null
    mobZoneId: number | null
    mobId: number | null
    objectZoneId: number | null
    objectId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type TriggerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    attachType: $Enums.ScriptType | null
    numArgs: number | null
    argList: string | null
    commands: string | null
    zoneId: number | null
    mobZoneId: number | null
    mobId: number | null
    objectZoneId: number | null
    objectId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type TriggerCountAggregateOutputType = {
    id: number
    name: number
    attachType: number
    numArgs: number
    argList: number
    commands: number
    zoneId: number
    mobZoneId: number
    mobId: number
    objectZoneId: number
    objectId: number
    variables: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    flags: number
    _all: number
  }


  export type TriggerAvgAggregateInputType = {
    numArgs?: true
    zoneId?: true
    mobZoneId?: true
    mobId?: true
    objectZoneId?: true
    objectId?: true
  }

  export type TriggerSumAggregateInputType = {
    numArgs?: true
    zoneId?: true
    mobZoneId?: true
    mobId?: true
    objectZoneId?: true
    objectId?: true
  }

  export type TriggerMinAggregateInputType = {
    id?: true
    name?: true
    attachType?: true
    numArgs?: true
    argList?: true
    commands?: true
    zoneId?: true
    mobZoneId?: true
    mobId?: true
    objectZoneId?: true
    objectId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type TriggerMaxAggregateInputType = {
    id?: true
    name?: true
    attachType?: true
    numArgs?: true
    argList?: true
    commands?: true
    zoneId?: true
    mobZoneId?: true
    mobId?: true
    objectZoneId?: true
    objectId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type TriggerCountAggregateInputType = {
    id?: true
    name?: true
    attachType?: true
    numArgs?: true
    argList?: true
    commands?: true
    zoneId?: true
    mobZoneId?: true
    mobId?: true
    objectZoneId?: true
    objectId?: true
    variables?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    flags?: true
    _all?: true
  }

  export type TriggerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trigger to aggregate.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Triggers
    **/
    _count?: true | TriggerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TriggerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TriggerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriggerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriggerMaxAggregateInputType
  }

  export type GetTriggerAggregateType<T extends TriggerAggregateArgs> = {
        [P in keyof T & keyof AggregateTrigger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrigger[P]>
      : GetScalarType<T[P], AggregateTrigger[P]>
  }




  export type TriggerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggerWhereInput
    orderBy?: TriggerOrderByWithAggregationInput | TriggerOrderByWithAggregationInput[]
    by: TriggerScalarFieldEnum[] | TriggerScalarFieldEnum
    having?: TriggerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriggerCountAggregateInputType | true
    _avg?: TriggerAvgAggregateInputType
    _sum?: TriggerSumAggregateInputType
    _min?: TriggerMinAggregateInputType
    _max?: TriggerMaxAggregateInputType
  }

  export type TriggerGroupByOutputType = {
    id: string
    name: string
    attachType: $Enums.ScriptType
    numArgs: number
    argList: string | null
    commands: string
    zoneId: number | null
    mobZoneId: number | null
    mobId: number | null
    objectZoneId: number | null
    objectId: number | null
    variables: JsonValue
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    flags: $Enums.TriggerFlag[]
    _count: TriggerCountAggregateOutputType | null
    _avg: TriggerAvgAggregateOutputType | null
    _sum: TriggerSumAggregateOutputType | null
    _min: TriggerMinAggregateOutputType | null
    _max: TriggerMaxAggregateOutputType | null
  }

  type GetTriggerGroupByPayload<T extends TriggerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TriggerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriggerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriggerGroupByOutputType[P]>
            : GetScalarType<T[P], TriggerGroupByOutputType[P]>
        }
      >
    >


  export type TriggerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    attachType?: boolean
    numArgs?: boolean
    argList?: boolean
    commands?: boolean
    zoneId?: boolean
    mobZoneId?: boolean
    mobId?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    variables?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    flags?: boolean
    mob?: boolean | Trigger$mobArgs<ExtArgs>
    object?: boolean | Trigger$objectArgs<ExtArgs>
    zone?: boolean | Trigger$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["trigger"]>

  export type TriggerSelectScalar = {
    id?: boolean
    name?: boolean
    attachType?: boolean
    numArgs?: boolean
    argList?: boolean
    commands?: boolean
    zoneId?: boolean
    mobZoneId?: boolean
    mobId?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    variables?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    flags?: boolean
  }

  export type TriggerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mob?: boolean | Trigger$mobArgs<ExtArgs>
    object?: boolean | Trigger$objectArgs<ExtArgs>
    zone?: boolean | Trigger$zoneArgs<ExtArgs>
  }


  export type $TriggerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trigger"
    objects: {
      mob: Prisma.$MobPayload<ExtArgs> | null
      object: Prisma.$ObjectPayload<ExtArgs> | null
      zone: Prisma.$ZonePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      attachType: $Enums.ScriptType
      numArgs: number
      argList: string | null
      commands: string
      zoneId: number | null
      mobZoneId: number | null
      mobId: number | null
      objectZoneId: number | null
      objectId: number | null
      variables: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      flags: $Enums.TriggerFlag[]
    }, ExtArgs["result"]["trigger"]>
    composites: {}
  }


  type TriggerGetPayload<S extends boolean | null | undefined | TriggerDefaultArgs> = $Result.GetResult<Prisma.$TriggerPayload, S>

  type TriggerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TriggerFindManyArgs, 'select' | 'include'> & {
      select?: TriggerCountAggregateInputType | true
    }

  export interface TriggerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trigger'], meta: { name: 'Trigger' } }
    /**
     * Find zero or one Trigger that matches the filter.
     * @param {TriggerFindUniqueArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TriggerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TriggerFindUniqueArgs<ExtArgs>>
    ): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Trigger that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TriggerFindUniqueOrThrowArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TriggerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TriggerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Trigger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerFindFirstArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TriggerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TriggerFindFirstArgs<ExtArgs>>
    ): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Trigger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerFindFirstOrThrowArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TriggerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TriggerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Triggers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Triggers
     * const triggers = await prisma.trigger.findMany()
     * 
     * // Get first 10 Triggers
     * const triggers = await prisma.trigger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triggerWithIdOnly = await prisma.trigger.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TriggerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TriggerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Trigger.
     * @param {TriggerCreateArgs} args - Arguments to create a Trigger.
     * @example
     * // Create one Trigger
     * const Trigger = await prisma.trigger.create({
     *   data: {
     *     // ... data to create a Trigger
     *   }
     * })
     * 
    **/
    create<T extends TriggerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TriggerCreateArgs<ExtArgs>>
    ): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Triggers.
     *     @param {TriggerCreateManyArgs} args - Arguments to create many Triggers.
     *     @example
     *     // Create many Triggers
     *     const trigger = await prisma.trigger.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TriggerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TriggerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trigger.
     * @param {TriggerDeleteArgs} args - Arguments to delete one Trigger.
     * @example
     * // Delete one Trigger
     * const Trigger = await prisma.trigger.delete({
     *   where: {
     *     // ... filter to delete one Trigger
     *   }
     * })
     * 
    **/
    delete<T extends TriggerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TriggerDeleteArgs<ExtArgs>>
    ): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Trigger.
     * @param {TriggerUpdateArgs} args - Arguments to update one Trigger.
     * @example
     * // Update one Trigger
     * const trigger = await prisma.trigger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TriggerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TriggerUpdateArgs<ExtArgs>>
    ): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Triggers.
     * @param {TriggerDeleteManyArgs} args - Arguments to filter Triggers to delete.
     * @example
     * // Delete a few Triggers
     * const { count } = await prisma.trigger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TriggerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TriggerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Triggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Triggers
     * const trigger = await prisma.trigger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TriggerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TriggerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trigger.
     * @param {TriggerUpsertArgs} args - Arguments to update or create a Trigger.
     * @example
     * // Update or create a Trigger
     * const trigger = await prisma.trigger.upsert({
     *   create: {
     *     // ... data to create a Trigger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trigger we want to update
     *   }
     * })
    **/
    upsert<T extends TriggerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TriggerUpsertArgs<ExtArgs>>
    ): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Triggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerCountArgs} args - Arguments to filter Triggers to count.
     * @example
     * // Count the number of Triggers
     * const count = await prisma.trigger.count({
     *   where: {
     *     // ... the filter for the Triggers we want to count
     *   }
     * })
    **/
    count<T extends TriggerCountArgs>(
      args?: Subset<T, TriggerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriggerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trigger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriggerAggregateArgs>(args: Subset<T, TriggerAggregateArgs>): Prisma.PrismaPromise<GetTriggerAggregateType<T>>

    /**
     * Group by Trigger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriggerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriggerGroupByArgs['orderBy'] }
        : { orderBy?: TriggerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriggerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriggerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trigger model
   */
  readonly fields: TriggerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trigger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TriggerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mob<T extends Trigger$mobArgs<ExtArgs> = {}>(args?: Subset<T, Trigger$mobArgs<ExtArgs>>): Prisma__MobClient<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    object<T extends Trigger$objectArgs<ExtArgs> = {}>(args?: Subset<T, Trigger$objectArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    zone<T extends Trigger$zoneArgs<ExtArgs> = {}>(args?: Subset<T, Trigger$zoneArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Trigger model
   */ 
  interface TriggerFieldRefs {
    readonly id: FieldRef<"Trigger", 'String'>
    readonly name: FieldRef<"Trigger", 'String'>
    readonly attachType: FieldRef<"Trigger", 'ScriptType'>
    readonly numArgs: FieldRef<"Trigger", 'Int'>
    readonly argList: FieldRef<"Trigger", 'String'>
    readonly commands: FieldRef<"Trigger", 'String'>
    readonly zoneId: FieldRef<"Trigger", 'Int'>
    readonly mobZoneId: FieldRef<"Trigger", 'Int'>
    readonly mobId: FieldRef<"Trigger", 'Int'>
    readonly objectZoneId: FieldRef<"Trigger", 'Int'>
    readonly objectId: FieldRef<"Trigger", 'Int'>
    readonly variables: FieldRef<"Trigger", 'Json'>
    readonly createdAt: FieldRef<"Trigger", 'DateTime'>
    readonly updatedAt: FieldRef<"Trigger", 'DateTime'>
    readonly createdBy: FieldRef<"Trigger", 'String'>
    readonly updatedBy: FieldRef<"Trigger", 'String'>
    readonly flags: FieldRef<"Trigger", 'TriggerFlag[]'>
  }
    

  // Custom InputTypes

  /**
   * Trigger findUnique
   */
  export type TriggerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where: TriggerWhereUniqueInput
  }


  /**
   * Trigger findUniqueOrThrow
   */
  export type TriggerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where: TriggerWhereUniqueInput
  }


  /**
   * Trigger findFirst
   */
  export type TriggerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Triggers.
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Triggers.
     */
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }


  /**
   * Trigger findFirstOrThrow
   */
  export type TriggerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Triggers.
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Triggers.
     */
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }


  /**
   * Trigger findMany
   */
  export type TriggerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Triggers to fetch.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Triggers.
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }


  /**
   * Trigger create
   */
  export type TriggerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * The data needed to create a Trigger.
     */
    data: XOR<TriggerCreateInput, TriggerUncheckedCreateInput>
  }


  /**
   * Trigger createMany
   */
  export type TriggerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Triggers.
     */
    data: TriggerCreateManyInput | TriggerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Trigger update
   */
  export type TriggerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * The data needed to update a Trigger.
     */
    data: XOR<TriggerUpdateInput, TriggerUncheckedUpdateInput>
    /**
     * Choose, which Trigger to update.
     */
    where: TriggerWhereUniqueInput
  }


  /**
   * Trigger updateMany
   */
  export type TriggerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Triggers.
     */
    data: XOR<TriggerUpdateManyMutationInput, TriggerUncheckedUpdateManyInput>
    /**
     * Filter which Triggers to update
     */
    where?: TriggerWhereInput
  }


  /**
   * Trigger upsert
   */
  export type TriggerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * The filter to search for the Trigger to update in case it exists.
     */
    where: TriggerWhereUniqueInput
    /**
     * In case the Trigger found by the `where` argument doesn't exist, create a new Trigger with this data.
     */
    create: XOR<TriggerCreateInput, TriggerUncheckedCreateInput>
    /**
     * In case the Trigger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriggerUpdateInput, TriggerUncheckedUpdateInput>
  }


  /**
   * Trigger delete
   */
  export type TriggerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter which Trigger to delete.
     */
    where: TriggerWhereUniqueInput
  }


  /**
   * Trigger deleteMany
   */
  export type TriggerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Triggers to delete
     */
    where?: TriggerWhereInput
  }


  /**
   * Trigger.mob
   */
  export type Trigger$mobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    where?: MobWhereInput
  }


  /**
   * Trigger.object
   */
  export type Trigger$objectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
  }


  /**
   * Trigger.zone
   */
  export type Trigger$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }


  /**
   * Trigger without action
   */
  export type TriggerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriggerInclude<ExtArgs> | null
  }



  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    oldValues: number
    newValues: number
    userId: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValues?: true
    newValues?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    entityType: string
    entityId: string
    oldValues: JsonValue | null
    newValues: JsonValue | null
    userId: string
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entityType: string
      entityId: string
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }


  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuditLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuditLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuditLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
    **/
    create<T extends AuditLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AuditLogs.
     *     @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     *     @example
     *     // Create many AuditLogs
     *     const auditLog = await prisma.auditLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuditLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
    **/
    delete<T extends AuditLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuditLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuditLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuditLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
    **/
    upsert<T extends AuditLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }


  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }


  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }


  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }


  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }


  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }


  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }


  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
  }



  /**
   * Model GameClass
   */

  export type AggregateGameClass = {
    _count: GameClassCountAggregateOutputType | null
    _avg: GameClassAvgAggregateOutputType | null
    _sum: GameClassSumAggregateOutputType | null
    _min: GameClassMinAggregateOutputType | null
    _max: GameClassMaxAggregateOutputType | null
  }

  export type GameClassAvgAggregateOutputType = {
    id: number | null
  }

  export type GameClassSumAggregateOutputType = {
    id: number | null
  }

  export type GameClassMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    hitDice: string | null
    primaryStat: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameClassMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    hitDice: string | null
    primaryStat: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameClassCountAggregateOutputType = {
    id: number
    name: number
    description: number
    hitDice: number
    primaryStat: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameClassAvgAggregateInputType = {
    id?: true
  }

  export type GameClassSumAggregateInputType = {
    id?: true
  }

  export type GameClassMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    hitDice?: true
    primaryStat?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameClassMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    hitDice?: true
    primaryStat?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameClassCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    hitDice?: true
    primaryStat?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameClass to aggregate.
     */
    where?: GameClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameClasses to fetch.
     */
    orderBy?: GameClassOrderByWithRelationInput | GameClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameClasses
    **/
    _count?: true | GameClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameClassMaxAggregateInputType
  }

  export type GetGameClassAggregateType<T extends GameClassAggregateArgs> = {
        [P in keyof T & keyof AggregateGameClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameClass[P]>
      : GetScalarType<T[P], AggregateGameClass[P]>
  }




  export type GameClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameClassWhereInput
    orderBy?: GameClassOrderByWithAggregationInput | GameClassOrderByWithAggregationInput[]
    by: GameClassScalarFieldEnum[] | GameClassScalarFieldEnum
    having?: GameClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameClassCountAggregateInputType | true
    _avg?: GameClassAvgAggregateInputType
    _sum?: GameClassSumAggregateInputType
    _min?: GameClassMinAggregateInputType
    _max?: GameClassMaxAggregateInputType
  }

  export type GameClassGroupByOutputType = {
    id: number
    name: string
    description: string | null
    hitDice: string
    primaryStat: string | null
    createdAt: Date
    updatedAt: Date
    _count: GameClassCountAggregateOutputType | null
    _avg: GameClassAvgAggregateOutputType | null
    _sum: GameClassSumAggregateOutputType | null
    _min: GameClassMinAggregateOutputType | null
    _max: GameClassMaxAggregateOutputType | null
  }

  type GetGameClassGroupByPayload<T extends GameClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameClassGroupByOutputType[P]>
            : GetScalarType<T[P], GameClassGroupByOutputType[P]>
        }
      >
    >


  export type GameClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    hitDice?: boolean
    primaryStat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characters?: boolean | GameClass$charactersArgs<ExtArgs>
    skillAccess?: boolean | GameClass$skillAccessArgs<ExtArgs>
    mobs?: boolean | GameClass$mobsArgs<ExtArgs>
    spellCircles?: boolean | GameClass$spellCirclesArgs<ExtArgs>
    _count?: boolean | GameClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameClass"]>

  export type GameClassSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    hitDice?: boolean
    primaryStat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | GameClass$charactersArgs<ExtArgs>
    skillAccess?: boolean | GameClass$skillAccessArgs<ExtArgs>
    mobs?: boolean | GameClass$mobsArgs<ExtArgs>
    spellCircles?: boolean | GameClass$spellCirclesArgs<ExtArgs>
    _count?: boolean | GameClassCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $GameClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameClass"
    objects: {
      characters: Prisma.$CharacterPayload<ExtArgs>[]
      skillAccess: Prisma.$ClassSkillPayload<ExtArgs>[]
      mobs: Prisma.$MobPayload<ExtArgs>[]
      spellCircles: Prisma.$SpellClassCirclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      hitDice: string
      primaryStat: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameClass"]>
    composites: {}
  }


  type GameClassGetPayload<S extends boolean | null | undefined | GameClassDefaultArgs> = $Result.GetResult<Prisma.$GameClassPayload, S>

  type GameClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameClassFindManyArgs, 'select' | 'include'> & {
      select?: GameClassCountAggregateInputType | true
    }

  export interface GameClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameClass'], meta: { name: 'GameClass' } }
    /**
     * Find zero or one GameClass that matches the filter.
     * @param {GameClassFindUniqueArgs} args - Arguments to find a GameClass
     * @example
     * // Get one GameClass
     * const gameClass = await prisma.gameClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GameClassFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GameClassFindUniqueArgs<ExtArgs>>
    ): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GameClass that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GameClassFindUniqueOrThrowArgs} args - Arguments to find a GameClass
     * @example
     * // Get one GameClass
     * const gameClass = await prisma.gameClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GameClassFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GameClassFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GameClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClassFindFirstArgs} args - Arguments to find a GameClass
     * @example
     * // Get one GameClass
     * const gameClass = await prisma.gameClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GameClassFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GameClassFindFirstArgs<ExtArgs>>
    ): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GameClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClassFindFirstOrThrowArgs} args - Arguments to find a GameClass
     * @example
     * // Get one GameClass
     * const gameClass = await prisma.gameClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GameClassFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GameClassFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GameClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClassFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameClasses
     * const gameClasses = await prisma.gameClass.findMany()
     * 
     * // Get first 10 GameClasses
     * const gameClasses = await prisma.gameClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameClassWithIdOnly = await prisma.gameClass.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GameClassFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GameClassFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GameClass.
     * @param {GameClassCreateArgs} args - Arguments to create a GameClass.
     * @example
     * // Create one GameClass
     * const GameClass = await prisma.gameClass.create({
     *   data: {
     *     // ... data to create a GameClass
     *   }
     * })
     * 
    **/
    create<T extends GameClassCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GameClassCreateArgs<ExtArgs>>
    ): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GameClasses.
     *     @param {GameClassCreateManyArgs} args - Arguments to create many GameClasses.
     *     @example
     *     // Create many GameClasses
     *     const gameClass = await prisma.gameClass.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GameClassCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GameClassCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GameClass.
     * @param {GameClassDeleteArgs} args - Arguments to delete one GameClass.
     * @example
     * // Delete one GameClass
     * const GameClass = await prisma.gameClass.delete({
     *   where: {
     *     // ... filter to delete one GameClass
     *   }
     * })
     * 
    **/
    delete<T extends GameClassDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GameClassDeleteArgs<ExtArgs>>
    ): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GameClass.
     * @param {GameClassUpdateArgs} args - Arguments to update one GameClass.
     * @example
     * // Update one GameClass
     * const gameClass = await prisma.gameClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GameClassUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GameClassUpdateArgs<ExtArgs>>
    ): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GameClasses.
     * @param {GameClassDeleteManyArgs} args - Arguments to filter GameClasses to delete.
     * @example
     * // Delete a few GameClasses
     * const { count } = await prisma.gameClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GameClassDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GameClassDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameClasses
     * const gameClass = await prisma.gameClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GameClassUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GameClassUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameClass.
     * @param {GameClassUpsertArgs} args - Arguments to update or create a GameClass.
     * @example
     * // Update or create a GameClass
     * const gameClass = await prisma.gameClass.upsert({
     *   create: {
     *     // ... data to create a GameClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameClass we want to update
     *   }
     * })
    **/
    upsert<T extends GameClassUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GameClassUpsertArgs<ExtArgs>>
    ): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GameClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClassCountArgs} args - Arguments to filter GameClasses to count.
     * @example
     * // Count the number of GameClasses
     * const count = await prisma.gameClass.count({
     *   where: {
     *     // ... the filter for the GameClasses we want to count
     *   }
     * })
    **/
    count<T extends GameClassCountArgs>(
      args?: Subset<T, GameClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameClassAggregateArgs>(args: Subset<T, GameClassAggregateArgs>): Prisma.PrismaPromise<GetGameClassAggregateType<T>>

    /**
     * Group by GameClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameClassGroupByArgs['orderBy'] }
        : { orderBy?: GameClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameClass model
   */
  readonly fields: GameClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    characters<T extends GameClass$charactersArgs<ExtArgs> = {}>(args?: Subset<T, GameClass$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findMany'> | Null>;

    skillAccess<T extends GameClass$skillAccessArgs<ExtArgs> = {}>(args?: Subset<T, GameClass$skillAccessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    mobs<T extends GameClass$mobsArgs<ExtArgs> = {}>(args?: Subset<T, GameClass$mobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobPayload<ExtArgs>, T, 'findMany'> | Null>;

    spellCircles<T extends GameClass$spellCirclesArgs<ExtArgs> = {}>(args?: Subset<T, GameClass$spellCirclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GameClass model
   */ 
  interface GameClassFieldRefs {
    readonly id: FieldRef<"GameClass", 'Int'>
    readonly name: FieldRef<"GameClass", 'String'>
    readonly description: FieldRef<"GameClass", 'String'>
    readonly hitDice: FieldRef<"GameClass", 'String'>
    readonly primaryStat: FieldRef<"GameClass", 'String'>
    readonly createdAt: FieldRef<"GameClass", 'DateTime'>
    readonly updatedAt: FieldRef<"GameClass", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * GameClass findUnique
   */
  export type GameClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    /**
     * Filter, which GameClass to fetch.
     */
    where: GameClassWhereUniqueInput
  }


  /**
   * GameClass findUniqueOrThrow
   */
  export type GameClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    /**
     * Filter, which GameClass to fetch.
     */
    where: GameClassWhereUniqueInput
  }


  /**
   * GameClass findFirst
   */
  export type GameClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    /**
     * Filter, which GameClass to fetch.
     */
    where?: GameClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameClasses to fetch.
     */
    orderBy?: GameClassOrderByWithRelationInput | GameClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameClasses.
     */
    cursor?: GameClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameClasses.
     */
    distinct?: GameClassScalarFieldEnum | GameClassScalarFieldEnum[]
  }


  /**
   * GameClass findFirstOrThrow
   */
  export type GameClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    /**
     * Filter, which GameClass to fetch.
     */
    where?: GameClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameClasses to fetch.
     */
    orderBy?: GameClassOrderByWithRelationInput | GameClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameClasses.
     */
    cursor?: GameClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameClasses.
     */
    distinct?: GameClassScalarFieldEnum | GameClassScalarFieldEnum[]
  }


  /**
   * GameClass findMany
   */
  export type GameClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    /**
     * Filter, which GameClasses to fetch.
     */
    where?: GameClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameClasses to fetch.
     */
    orderBy?: GameClassOrderByWithRelationInput | GameClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameClasses.
     */
    cursor?: GameClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameClasses.
     */
    skip?: number
    distinct?: GameClassScalarFieldEnum | GameClassScalarFieldEnum[]
  }


  /**
   * GameClass create
   */
  export type GameClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    /**
     * The data needed to create a GameClass.
     */
    data: XOR<GameClassCreateInput, GameClassUncheckedCreateInput>
  }


  /**
   * GameClass createMany
   */
  export type GameClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameClasses.
     */
    data: GameClassCreateManyInput | GameClassCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * GameClass update
   */
  export type GameClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    /**
     * The data needed to update a GameClass.
     */
    data: XOR<GameClassUpdateInput, GameClassUncheckedUpdateInput>
    /**
     * Choose, which GameClass to update.
     */
    where: GameClassWhereUniqueInput
  }


  /**
   * GameClass updateMany
   */
  export type GameClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameClasses.
     */
    data: XOR<GameClassUpdateManyMutationInput, GameClassUncheckedUpdateManyInput>
    /**
     * Filter which GameClasses to update
     */
    where?: GameClassWhereInput
  }


  /**
   * GameClass upsert
   */
  export type GameClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    /**
     * The filter to search for the GameClass to update in case it exists.
     */
    where: GameClassWhereUniqueInput
    /**
     * In case the GameClass found by the `where` argument doesn't exist, create a new GameClass with this data.
     */
    create: XOR<GameClassCreateInput, GameClassUncheckedCreateInput>
    /**
     * In case the GameClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameClassUpdateInput, GameClassUncheckedUpdateInput>
  }


  /**
   * GameClass delete
   */
  export type GameClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
    /**
     * Filter which GameClass to delete.
     */
    where: GameClassWhereUniqueInput
  }


  /**
   * GameClass deleteMany
   */
  export type GameClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameClasses to delete
     */
    where?: GameClassWhereInput
  }


  /**
   * GameClass.characters
   */
  export type GameClass$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * GameClass.skillAccess
   */
  export type GameClass$skillAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    where?: ClassSkillWhereInput
    orderBy?: ClassSkillOrderByWithRelationInput | ClassSkillOrderByWithRelationInput[]
    cursor?: ClassSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSkillScalarFieldEnum | ClassSkillScalarFieldEnum[]
  }


  /**
   * GameClass.mobs
   */
  export type GameClass$mobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mob
     */
    select?: MobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobInclude<ExtArgs> | null
    where?: MobWhereInput
    orderBy?: MobOrderByWithRelationInput | MobOrderByWithRelationInput[]
    cursor?: MobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobScalarFieldEnum | MobScalarFieldEnum[]
  }


  /**
   * GameClass.spellCircles
   */
  export type GameClass$spellCirclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    where?: SpellClassCircleWhereInput
    orderBy?: SpellClassCircleOrderByWithRelationInput | SpellClassCircleOrderByWithRelationInput[]
    cursor?: SpellClassCircleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellClassCircleScalarFieldEnum | SpellClassCircleScalarFieldEnum[]
  }


  /**
   * GameClass without action
   */
  export type GameClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClass
     */
    select?: GameClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameClassInclude<ExtArgs> | null
  }



  /**
   * Model Spell
   */

  export type AggregateSpell = {
    _count: SpellCountAggregateOutputType | null
    _avg: SpellAvgAggregateOutputType | null
    _sum: SpellSumAggregateOutputType | null
    _min: SpellMinAggregateOutputType | null
    _max: SpellMaxAggregateOutputType | null
  }

  export type SpellAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
    castTimeRounds: number | null
    cooldownMs: number | null
  }

  export type SpellSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
    castTimeRounds: number | null
    cooldownMs: number | null
  }

  export type SpellMinAggregateOutputType = {
    id: number | null
    name: string | null
    schoolId: number | null
    minPosition: $Enums.Position | null
    violent: boolean | null
    castTimeRounds: number | null
    cooldownMs: number | null
    inCombatOnly: boolean | null
    isArea: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpellMaxAggregateOutputType = {
    id: number | null
    name: string | null
    schoolId: number | null
    minPosition: $Enums.Position | null
    violent: boolean | null
    castTimeRounds: number | null
    cooldownMs: number | null
    inCombatOnly: boolean | null
    isArea: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpellCountAggregateOutputType = {
    id: number
    name: number
    schoolId: number
    minPosition: number
    violent: number
    castTimeRounds: number
    cooldownMs: number
    inCombatOnly: number
    isArea: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpellAvgAggregateInputType = {
    id?: true
    schoolId?: true
    castTimeRounds?: true
    cooldownMs?: true
  }

  export type SpellSumAggregateInputType = {
    id?: true
    schoolId?: true
    castTimeRounds?: true
    cooldownMs?: true
  }

  export type SpellMinAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    minPosition?: true
    violent?: true
    castTimeRounds?: true
    cooldownMs?: true
    inCombatOnly?: true
    isArea?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpellMaxAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    minPosition?: true
    violent?: true
    castTimeRounds?: true
    cooldownMs?: true
    inCombatOnly?: true
    isArea?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpellCountAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    minPosition?: true
    violent?: true
    castTimeRounds?: true
    cooldownMs?: true
    inCombatOnly?: true
    isArea?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spell to aggregate.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spells
    **/
    _count?: true | SpellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellMaxAggregateInputType
  }

  export type GetSpellAggregateType<T extends SpellAggregateArgs> = {
        [P in keyof T & keyof AggregateSpell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpell[P]>
      : GetScalarType<T[P], AggregateSpell[P]>
  }




  export type SpellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellWhereInput
    orderBy?: SpellOrderByWithAggregationInput | SpellOrderByWithAggregationInput[]
    by: SpellScalarFieldEnum[] | SpellScalarFieldEnum
    having?: SpellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellCountAggregateInputType | true
    _avg?: SpellAvgAggregateInputType
    _sum?: SpellSumAggregateInputType
    _min?: SpellMinAggregateInputType
    _max?: SpellMaxAggregateInputType
  }

  export type SpellGroupByOutputType = {
    id: number
    name: string
    schoolId: number | null
    minPosition: $Enums.Position
    violent: boolean
    castTimeRounds: number
    cooldownMs: number
    inCombatOnly: boolean
    isArea: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SpellCountAggregateOutputType | null
    _avg: SpellAvgAggregateOutputType | null
    _sum: SpellSumAggregateOutputType | null
    _min: SpellMinAggregateOutputType | null
    _max: SpellMaxAggregateOutputType | null
  }

  type GetSpellGroupByPayload<T extends SpellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellGroupByOutputType[P]>
            : GetScalarType<T[P], SpellGroupByOutputType[P]>
        }
      >
    >


  export type SpellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    minPosition?: boolean
    violent?: boolean
    castTimeRounds?: boolean
    cooldownMs?: boolean
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characterSpells?: boolean | Spell$characterSpellsArgs<ExtArgs>
    mobSpells?: boolean | Spell$mobSpellsArgs<ExtArgs>
    classCircles?: boolean | Spell$classCirclesArgs<ExtArgs>
    components?: boolean | Spell$componentsArgs<ExtArgs>
    effects?: boolean | Spell$effectsArgs<ExtArgs>
    messages?: boolean | Spell$messagesArgs<ExtArgs>
    restrictions?: boolean | Spell$restrictionsArgs<ExtArgs>
    savingThrows?: boolean | Spell$savingThrowsArgs<ExtArgs>
    targeting?: boolean | Spell$targetingArgs<ExtArgs>
    school?: boolean | Spell$schoolArgs<ExtArgs>
    _count?: boolean | SpellCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spell"]>

  export type SpellSelectScalar = {
    id?: boolean
    name?: boolean
    schoolId?: boolean
    minPosition?: boolean
    violent?: boolean
    castTimeRounds?: boolean
    cooldownMs?: boolean
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterSpells?: boolean | Spell$characterSpellsArgs<ExtArgs>
    mobSpells?: boolean | Spell$mobSpellsArgs<ExtArgs>
    classCircles?: boolean | Spell$classCirclesArgs<ExtArgs>
    components?: boolean | Spell$componentsArgs<ExtArgs>
    effects?: boolean | Spell$effectsArgs<ExtArgs>
    messages?: boolean | Spell$messagesArgs<ExtArgs>
    restrictions?: boolean | Spell$restrictionsArgs<ExtArgs>
    savingThrows?: boolean | Spell$savingThrowsArgs<ExtArgs>
    targeting?: boolean | Spell$targetingArgs<ExtArgs>
    school?: boolean | Spell$schoolArgs<ExtArgs>
    _count?: boolean | SpellCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SpellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Spell"
    objects: {
      characterSpells: Prisma.$CharacterSpellPayload<ExtArgs>[]
      mobSpells: Prisma.$MobSpellPayload<ExtArgs>[]
      classCircles: Prisma.$SpellClassCirclePayload<ExtArgs>[]
      components: Prisma.$SpellComponentPayload<ExtArgs>[]
      effects: Prisma.$SpellEffectPayload<ExtArgs>[]
      messages: Prisma.$SpellMessagePayload<ExtArgs> | null
      restrictions: Prisma.$SpellRestrictionPayload<ExtArgs> | null
      savingThrows: Prisma.$SpellSavingThrowPayload<ExtArgs>[]
      targeting: Prisma.$SpellTargetingPayload<ExtArgs> | null
      school: Prisma.$SpellSchoolPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      schoolId: number | null
      minPosition: $Enums.Position
      violent: boolean
      castTimeRounds: number
      cooldownMs: number
      inCombatOnly: boolean
      isArea: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["spell"]>
    composites: {}
  }


  type SpellGetPayload<S extends boolean | null | undefined | SpellDefaultArgs> = $Result.GetResult<Prisma.$SpellPayload, S>

  type SpellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpellFindManyArgs, 'select' | 'include'> & {
      select?: SpellCountAggregateInputType | true
    }

  export interface SpellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Spell'], meta: { name: 'Spell' } }
    /**
     * Find zero or one Spell that matches the filter.
     * @param {SpellFindUniqueArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpellFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpellFindUniqueArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Spell that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpellFindUniqueOrThrowArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpellFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Spell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindFirstArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpellFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellFindFirstArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Spell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindFirstOrThrowArgs} args - Arguments to find a Spell
     * @example
     * // Get one Spell
     * const spell = await prisma.spell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpellFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Spells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spells
     * const spells = await prisma.spell.findMany()
     * 
     * // Get first 10 Spells
     * const spells = await prisma.spell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellWithIdOnly = await prisma.spell.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpellFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Spell.
     * @param {SpellCreateArgs} args - Arguments to create a Spell.
     * @example
     * // Create one Spell
     * const Spell = await prisma.spell.create({
     *   data: {
     *     // ... data to create a Spell
     *   }
     * })
     * 
    **/
    create<T extends SpellCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellCreateArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Spells.
     *     @param {SpellCreateManyArgs} args - Arguments to create many Spells.
     *     @example
     *     // Create many Spells
     *     const spell = await prisma.spell.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpellCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Spell.
     * @param {SpellDeleteArgs} args - Arguments to delete one Spell.
     * @example
     * // Delete one Spell
     * const Spell = await prisma.spell.delete({
     *   where: {
     *     // ... filter to delete one Spell
     *   }
     * })
     * 
    **/
    delete<T extends SpellDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpellDeleteArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Spell.
     * @param {SpellUpdateArgs} args - Arguments to update one Spell.
     * @example
     * // Update one Spell
     * const spell = await prisma.spell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpellUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellUpdateArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Spells.
     * @param {SpellDeleteManyArgs} args - Arguments to filter Spells to delete.
     * @example
     * // Delete a few Spells
     * const { count } = await prisma.spell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpellDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spells
     * const spell = await prisma.spell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpellUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpellUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Spell.
     * @param {SpellUpsertArgs} args - Arguments to update or create a Spell.
     * @example
     * // Update or create a Spell
     * const spell = await prisma.spell.upsert({
     *   create: {
     *     // ... data to create a Spell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spell we want to update
     *   }
     * })
    **/
    upsert<T extends SpellUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpellUpsertArgs<ExtArgs>>
    ): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Spells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellCountArgs} args - Arguments to filter Spells to count.
     * @example
     * // Count the number of Spells
     * const count = await prisma.spell.count({
     *   where: {
     *     // ... the filter for the Spells we want to count
     *   }
     * })
    **/
    count<T extends SpellCountArgs>(
      args?: Subset<T, SpellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellAggregateArgs>(args: Subset<T, SpellAggregateArgs>): Prisma.PrismaPromise<GetSpellAggregateType<T>>

    /**
     * Group by Spell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellGroupByArgs['orderBy'] }
        : { orderBy?: SpellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Spell model
   */
  readonly fields: SpellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Spell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    characterSpells<T extends Spell$characterSpellsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$characterSpellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'findMany'> | Null>;

    mobSpells<T extends Spell$mobSpellsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$mobSpellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobSpellPayload<ExtArgs>, T, 'findMany'> | Null>;

    classCircles<T extends Spell$classCirclesArgs<ExtArgs> = {}>(args?: Subset<T, Spell$classCirclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'findMany'> | Null>;

    components<T extends Spell$componentsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellComponentPayload<ExtArgs>, T, 'findMany'> | Null>;

    effects<T extends Spell$effectsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$effectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellEffectPayload<ExtArgs>, T, 'findMany'> | Null>;

    messages<T extends Spell$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Spell$messagesArgs<ExtArgs>>): Prisma__SpellMessageClient<$Result.GetResult<Prisma.$SpellMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    restrictions<T extends Spell$restrictionsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$restrictionsArgs<ExtArgs>>): Prisma__SpellRestrictionClient<$Result.GetResult<Prisma.$SpellRestrictionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    savingThrows<T extends Spell$savingThrowsArgs<ExtArgs> = {}>(args?: Subset<T, Spell$savingThrowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellSavingThrowPayload<ExtArgs>, T, 'findMany'> | Null>;

    targeting<T extends Spell$targetingArgs<ExtArgs> = {}>(args?: Subset<T, Spell$targetingArgs<ExtArgs>>): Prisma__SpellTargetingClient<$Result.GetResult<Prisma.$SpellTargetingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    school<T extends Spell$schoolArgs<ExtArgs> = {}>(args?: Subset<T, Spell$schoolArgs<ExtArgs>>): Prisma__SpellSchoolClient<$Result.GetResult<Prisma.$SpellSchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Spell model
   */ 
  interface SpellFieldRefs {
    readonly id: FieldRef<"Spell", 'Int'>
    readonly name: FieldRef<"Spell", 'String'>
    readonly schoolId: FieldRef<"Spell", 'Int'>
    readonly minPosition: FieldRef<"Spell", 'Position'>
    readonly violent: FieldRef<"Spell", 'Boolean'>
    readonly castTimeRounds: FieldRef<"Spell", 'Int'>
    readonly cooldownMs: FieldRef<"Spell", 'Int'>
    readonly inCombatOnly: FieldRef<"Spell", 'Boolean'>
    readonly isArea: FieldRef<"Spell", 'Boolean'>
    readonly notes: FieldRef<"Spell", 'String'>
    readonly createdAt: FieldRef<"Spell", 'DateTime'>
    readonly updatedAt: FieldRef<"Spell", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Spell findUnique
   */
  export type SpellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where: SpellWhereUniqueInput
  }


  /**
   * Spell findUniqueOrThrow
   */
  export type SpellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where: SpellWhereUniqueInput
  }


  /**
   * Spell findFirst
   */
  export type SpellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spells.
     */
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }


  /**
   * Spell findFirstOrThrow
   */
  export type SpellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spell to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spells.
     */
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }


  /**
   * Spell findMany
   */
  export type SpellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter, which Spells to fetch.
     */
    where?: SpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spells to fetch.
     */
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spells.
     */
    cursor?: SpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spells.
     */
    skip?: number
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }


  /**
   * Spell create
   */
  export type SpellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The data needed to create a Spell.
     */
    data: XOR<SpellCreateInput, SpellUncheckedCreateInput>
  }


  /**
   * Spell createMany
   */
  export type SpellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spells.
     */
    data: SpellCreateManyInput | SpellCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Spell update
   */
  export type SpellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The data needed to update a Spell.
     */
    data: XOR<SpellUpdateInput, SpellUncheckedUpdateInput>
    /**
     * Choose, which Spell to update.
     */
    where: SpellWhereUniqueInput
  }


  /**
   * Spell updateMany
   */
  export type SpellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spells.
     */
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyInput>
    /**
     * Filter which Spells to update
     */
    where?: SpellWhereInput
  }


  /**
   * Spell upsert
   */
  export type SpellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * The filter to search for the Spell to update in case it exists.
     */
    where: SpellWhereUniqueInput
    /**
     * In case the Spell found by the `where` argument doesn't exist, create a new Spell with this data.
     */
    create: XOR<SpellCreateInput, SpellUncheckedCreateInput>
    /**
     * In case the Spell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellUpdateInput, SpellUncheckedUpdateInput>
  }


  /**
   * Spell delete
   */
  export type SpellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    /**
     * Filter which Spell to delete.
     */
    where: SpellWhereUniqueInput
  }


  /**
   * Spell deleteMany
   */
  export type SpellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spells to delete
     */
    where?: SpellWhereInput
  }


  /**
   * Spell.characterSpells
   */
  export type Spell$characterSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    where?: CharacterSpellWhereInput
    orderBy?: CharacterSpellOrderByWithRelationInput | CharacterSpellOrderByWithRelationInput[]
    cursor?: CharacterSpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterSpellScalarFieldEnum | CharacterSpellScalarFieldEnum[]
  }


  /**
   * Spell.mobSpells
   */
  export type Spell$mobSpellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSpell
     */
    select?: MobSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSpellInclude<ExtArgs> | null
    where?: MobSpellWhereInput
    orderBy?: MobSpellOrderByWithRelationInput | MobSpellOrderByWithRelationInput[]
    cursor?: MobSpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobSpellScalarFieldEnum | MobSpellScalarFieldEnum[]
  }


  /**
   * Spell.classCircles
   */
  export type Spell$classCirclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    where?: SpellClassCircleWhereInput
    orderBy?: SpellClassCircleOrderByWithRelationInput | SpellClassCircleOrderByWithRelationInput[]
    cursor?: SpellClassCircleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellClassCircleScalarFieldEnum | SpellClassCircleScalarFieldEnum[]
  }


  /**
   * Spell.components
   */
  export type Spell$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
    where?: SpellComponentWhereInput
    orderBy?: SpellComponentOrderByWithRelationInput | SpellComponentOrderByWithRelationInput[]
    cursor?: SpellComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellComponentScalarFieldEnum | SpellComponentScalarFieldEnum[]
  }


  /**
   * Spell.effects
   */
  export type Spell$effectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
    where?: SpellEffectWhereInput
    orderBy?: SpellEffectOrderByWithRelationInput | SpellEffectOrderByWithRelationInput[]
    cursor?: SpellEffectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellEffectScalarFieldEnum | SpellEffectScalarFieldEnum[]
  }


  /**
   * Spell.messages
   */
  export type Spell$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
    where?: SpellMessageWhereInput
  }


  /**
   * Spell.restrictions
   */
  export type Spell$restrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
    where?: SpellRestrictionWhereInput
  }


  /**
   * Spell.savingThrows
   */
  export type Spell$savingThrowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
    where?: SpellSavingThrowWhereInput
    orderBy?: SpellSavingThrowOrderByWithRelationInput | SpellSavingThrowOrderByWithRelationInput[]
    cursor?: SpellSavingThrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellSavingThrowScalarFieldEnum | SpellSavingThrowScalarFieldEnum[]
  }


  /**
   * Spell.targeting
   */
  export type Spell$targetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
    where?: SpellTargetingWhereInput
  }


  /**
   * Spell.school
   */
  export type Spell$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
    where?: SpellSchoolWhereInput
  }


  /**
   * Spell without action
   */
  export type SpellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
  }



  /**
   * Model SpellSchool
   */

  export type AggregateSpellSchool = {
    _count: SpellSchoolCountAggregateOutputType | null
    _avg: SpellSchoolAvgAggregateOutputType | null
    _sum: SpellSchoolSumAggregateOutputType | null
    _min: SpellSchoolMinAggregateOutputType | null
    _max: SpellSchoolMaxAggregateOutputType | null
  }

  export type SpellSchoolAvgAggregateOutputType = {
    id: number | null
  }

  export type SpellSchoolSumAggregateOutputType = {
    id: number | null
  }

  export type SpellSchoolMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type SpellSchoolMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type SpellSchoolCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type SpellSchoolAvgAggregateInputType = {
    id?: true
  }

  export type SpellSchoolSumAggregateInputType = {
    id?: true
  }

  export type SpellSchoolMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SpellSchoolMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SpellSchoolCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type SpellSchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellSchool to aggregate.
     */
    where?: SpellSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSchools to fetch.
     */
    orderBy?: SpellSchoolOrderByWithRelationInput | SpellSchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSchools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellSchools
    **/
    _count?: true | SpellSchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellSchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellSchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellSchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellSchoolMaxAggregateInputType
  }

  export type GetSpellSchoolAggregateType<T extends SpellSchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellSchool[P]>
      : GetScalarType<T[P], AggregateSpellSchool[P]>
  }




  export type SpellSchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellSchoolWhereInput
    orderBy?: SpellSchoolOrderByWithAggregationInput | SpellSchoolOrderByWithAggregationInput[]
    by: SpellSchoolScalarFieldEnum[] | SpellSchoolScalarFieldEnum
    having?: SpellSchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellSchoolCountAggregateInputType | true
    _avg?: SpellSchoolAvgAggregateInputType
    _sum?: SpellSchoolSumAggregateInputType
    _min?: SpellSchoolMinAggregateInputType
    _max?: SpellSchoolMaxAggregateInputType
  }

  export type SpellSchoolGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: SpellSchoolCountAggregateOutputType | null
    _avg: SpellSchoolAvgAggregateOutputType | null
    _sum: SpellSchoolSumAggregateOutputType | null
    _min: SpellSchoolMinAggregateOutputType | null
    _max: SpellSchoolMaxAggregateOutputType | null
  }

  type GetSpellSchoolGroupByPayload<T extends SpellSchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellSchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellSchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellSchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SpellSchoolGroupByOutputType[P]>
        }
      >
    >


  export type SpellSchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    spells?: boolean | SpellSchool$spellsArgs<ExtArgs>
    _count?: boolean | SpellSchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellSchool"]>

  export type SpellSchoolSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type SpellSchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spells?: boolean | SpellSchool$spellsArgs<ExtArgs>
    _count?: boolean | SpellSchoolCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SpellSchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellSchool"
    objects: {
      spells: Prisma.$SpellPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["spellSchool"]>
    composites: {}
  }


  type SpellSchoolGetPayload<S extends boolean | null | undefined | SpellSchoolDefaultArgs> = $Result.GetResult<Prisma.$SpellSchoolPayload, S>

  type SpellSchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpellSchoolFindManyArgs, 'select' | 'include'> & {
      select?: SpellSchoolCountAggregateInputType | true
    }

  export interface SpellSchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellSchool'], meta: { name: 'SpellSchool' } }
    /**
     * Find zero or one SpellSchool that matches the filter.
     * @param {SpellSchoolFindUniqueArgs} args - Arguments to find a SpellSchool
     * @example
     * // Get one SpellSchool
     * const spellSchool = await prisma.spellSchool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpellSchoolFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSchoolFindUniqueArgs<ExtArgs>>
    ): Prisma__SpellSchoolClient<$Result.GetResult<Prisma.$SpellSchoolPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpellSchool that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpellSchoolFindUniqueOrThrowArgs} args - Arguments to find a SpellSchool
     * @example
     * // Get one SpellSchool
     * const spellSchool = await prisma.spellSchool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpellSchoolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSchoolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpellSchoolClient<$Result.GetResult<Prisma.$SpellSchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpellSchool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolFindFirstArgs} args - Arguments to find a SpellSchool
     * @example
     * // Get one SpellSchool
     * const spellSchool = await prisma.spellSchool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpellSchoolFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSchoolFindFirstArgs<ExtArgs>>
    ): Prisma__SpellSchoolClient<$Result.GetResult<Prisma.$SpellSchoolPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpellSchool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolFindFirstOrThrowArgs} args - Arguments to find a SpellSchool
     * @example
     * // Get one SpellSchool
     * const spellSchool = await prisma.spellSchool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpellSchoolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSchoolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpellSchoolClient<$Result.GetResult<Prisma.$SpellSchoolPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpellSchools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellSchools
     * const spellSchools = await prisma.spellSchool.findMany()
     * 
     * // Get first 10 SpellSchools
     * const spellSchools = await prisma.spellSchool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellSchoolWithIdOnly = await prisma.spellSchool.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpellSchoolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSchoolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellSchoolPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpellSchool.
     * @param {SpellSchoolCreateArgs} args - Arguments to create a SpellSchool.
     * @example
     * // Create one SpellSchool
     * const SpellSchool = await prisma.spellSchool.create({
     *   data: {
     *     // ... data to create a SpellSchool
     *   }
     * })
     * 
    **/
    create<T extends SpellSchoolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSchoolCreateArgs<ExtArgs>>
    ): Prisma__SpellSchoolClient<$Result.GetResult<Prisma.$SpellSchoolPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpellSchools.
     *     @param {SpellSchoolCreateManyArgs} args - Arguments to create many SpellSchools.
     *     @example
     *     // Create many SpellSchools
     *     const spellSchool = await prisma.spellSchool.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpellSchoolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSchoolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellSchool.
     * @param {SpellSchoolDeleteArgs} args - Arguments to delete one SpellSchool.
     * @example
     * // Delete one SpellSchool
     * const SpellSchool = await prisma.spellSchool.delete({
     *   where: {
     *     // ... filter to delete one SpellSchool
     *   }
     * })
     * 
    **/
    delete<T extends SpellSchoolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSchoolDeleteArgs<ExtArgs>>
    ): Prisma__SpellSchoolClient<$Result.GetResult<Prisma.$SpellSchoolPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpellSchool.
     * @param {SpellSchoolUpdateArgs} args - Arguments to update one SpellSchool.
     * @example
     * // Update one SpellSchool
     * const spellSchool = await prisma.spellSchool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpellSchoolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSchoolUpdateArgs<ExtArgs>>
    ): Prisma__SpellSchoolClient<$Result.GetResult<Prisma.$SpellSchoolPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpellSchools.
     * @param {SpellSchoolDeleteManyArgs} args - Arguments to filter SpellSchools to delete.
     * @example
     * // Delete a few SpellSchools
     * const { count } = await prisma.spellSchool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpellSchoolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSchoolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellSchools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellSchools
     * const spellSchool = await prisma.spellSchool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpellSchoolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSchoolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellSchool.
     * @param {SpellSchoolUpsertArgs} args - Arguments to update or create a SpellSchool.
     * @example
     * // Update or create a SpellSchool
     * const spellSchool = await prisma.spellSchool.upsert({
     *   create: {
     *     // ... data to create a SpellSchool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellSchool we want to update
     *   }
     * })
    **/
    upsert<T extends SpellSchoolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSchoolUpsertArgs<ExtArgs>>
    ): Prisma__SpellSchoolClient<$Result.GetResult<Prisma.$SpellSchoolPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpellSchools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolCountArgs} args - Arguments to filter SpellSchools to count.
     * @example
     * // Count the number of SpellSchools
     * const count = await prisma.spellSchool.count({
     *   where: {
     *     // ... the filter for the SpellSchools we want to count
     *   }
     * })
    **/
    count<T extends SpellSchoolCountArgs>(
      args?: Subset<T, SpellSchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellSchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellSchool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellSchoolAggregateArgs>(args: Subset<T, SpellSchoolAggregateArgs>): Prisma.PrismaPromise<GetSpellSchoolAggregateType<T>>

    /**
     * Group by SpellSchool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellSchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellSchoolGroupByArgs['orderBy'] }
        : { orderBy?: SpellSchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellSchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellSchool model
   */
  readonly fields: SpellSchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellSchool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellSchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    spells<T extends SpellSchool$spellsArgs<ExtArgs> = {}>(args?: Subset<T, SpellSchool$spellsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpellSchool model
   */ 
  interface SpellSchoolFieldRefs {
    readonly id: FieldRef<"SpellSchool", 'Int'>
    readonly name: FieldRef<"SpellSchool", 'String'>
    readonly description: FieldRef<"SpellSchool", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SpellSchool findUnique
   */
  export type SpellSchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
    /**
     * Filter, which SpellSchool to fetch.
     */
    where: SpellSchoolWhereUniqueInput
  }


  /**
   * SpellSchool findUniqueOrThrow
   */
  export type SpellSchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
    /**
     * Filter, which SpellSchool to fetch.
     */
    where: SpellSchoolWhereUniqueInput
  }


  /**
   * SpellSchool findFirst
   */
  export type SpellSchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
    /**
     * Filter, which SpellSchool to fetch.
     */
    where?: SpellSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSchools to fetch.
     */
    orderBy?: SpellSchoolOrderByWithRelationInput | SpellSchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellSchools.
     */
    cursor?: SpellSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSchools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellSchools.
     */
    distinct?: SpellSchoolScalarFieldEnum | SpellSchoolScalarFieldEnum[]
  }


  /**
   * SpellSchool findFirstOrThrow
   */
  export type SpellSchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
    /**
     * Filter, which SpellSchool to fetch.
     */
    where?: SpellSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSchools to fetch.
     */
    orderBy?: SpellSchoolOrderByWithRelationInput | SpellSchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellSchools.
     */
    cursor?: SpellSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSchools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellSchools.
     */
    distinct?: SpellSchoolScalarFieldEnum | SpellSchoolScalarFieldEnum[]
  }


  /**
   * SpellSchool findMany
   */
  export type SpellSchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
    /**
     * Filter, which SpellSchools to fetch.
     */
    where?: SpellSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSchools to fetch.
     */
    orderBy?: SpellSchoolOrderByWithRelationInput | SpellSchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellSchools.
     */
    cursor?: SpellSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSchools.
     */
    skip?: number
    distinct?: SpellSchoolScalarFieldEnum | SpellSchoolScalarFieldEnum[]
  }


  /**
   * SpellSchool create
   */
  export type SpellSchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellSchool.
     */
    data: XOR<SpellSchoolCreateInput, SpellSchoolUncheckedCreateInput>
  }


  /**
   * SpellSchool createMany
   */
  export type SpellSchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellSchools.
     */
    data: SpellSchoolCreateManyInput | SpellSchoolCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SpellSchool update
   */
  export type SpellSchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellSchool.
     */
    data: XOR<SpellSchoolUpdateInput, SpellSchoolUncheckedUpdateInput>
    /**
     * Choose, which SpellSchool to update.
     */
    where: SpellSchoolWhereUniqueInput
  }


  /**
   * SpellSchool updateMany
   */
  export type SpellSchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellSchools.
     */
    data: XOR<SpellSchoolUpdateManyMutationInput, SpellSchoolUncheckedUpdateManyInput>
    /**
     * Filter which SpellSchools to update
     */
    where?: SpellSchoolWhereInput
  }


  /**
   * SpellSchool upsert
   */
  export type SpellSchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellSchool to update in case it exists.
     */
    where: SpellSchoolWhereUniqueInput
    /**
     * In case the SpellSchool found by the `where` argument doesn't exist, create a new SpellSchool with this data.
     */
    create: XOR<SpellSchoolCreateInput, SpellSchoolUncheckedCreateInput>
    /**
     * In case the SpellSchool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellSchoolUpdateInput, SpellSchoolUncheckedUpdateInput>
  }


  /**
   * SpellSchool delete
   */
  export type SpellSchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
    /**
     * Filter which SpellSchool to delete.
     */
    where: SpellSchoolWhereUniqueInput
  }


  /**
   * SpellSchool deleteMany
   */
  export type SpellSchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellSchools to delete
     */
    where?: SpellSchoolWhereInput
  }


  /**
   * SpellSchool.spells
   */
  export type SpellSchool$spellsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spell
     */
    select?: SpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellInclude<ExtArgs> | null
    where?: SpellWhereInput
    orderBy?: SpellOrderByWithRelationInput | SpellOrderByWithRelationInput[]
    cursor?: SpellWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpellScalarFieldEnum | SpellScalarFieldEnum[]
  }


  /**
   * SpellSchool without action
   */
  export type SpellSchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSchool
     */
    select?: SpellSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSchoolInclude<ExtArgs> | null
  }



  /**
   * Model SpellClassCircle
   */

  export type AggregateSpellClassCircle = {
    _count: SpellClassCircleCountAggregateOutputType | null
    _avg: SpellClassCircleAvgAggregateOutputType | null
    _sum: SpellClassCircleSumAggregateOutputType | null
    _min: SpellClassCircleMinAggregateOutputType | null
    _max: SpellClassCircleMaxAggregateOutputType | null
  }

  export type SpellClassCircleAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    classId: number | null
    circle: number | null
    minLevel: number | null
    proficiencyGain: number | null
  }

  export type SpellClassCircleSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    classId: number | null
    circle: number | null
    minLevel: number | null
    proficiencyGain: number | null
  }

  export type SpellClassCircleMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    classId: number | null
    circle: number | null
    minLevel: number | null
    proficiencyGain: number | null
  }

  export type SpellClassCircleMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    classId: number | null
    circle: number | null
    minLevel: number | null
    proficiencyGain: number | null
  }

  export type SpellClassCircleCountAggregateOutputType = {
    id: number
    spellId: number
    classId: number
    circle: number
    minLevel: number
    proficiencyGain: number
    _all: number
  }


  export type SpellClassCircleAvgAggregateInputType = {
    id?: true
    spellId?: true
    classId?: true
    circle?: true
    minLevel?: true
    proficiencyGain?: true
  }

  export type SpellClassCircleSumAggregateInputType = {
    id?: true
    spellId?: true
    classId?: true
    circle?: true
    minLevel?: true
    proficiencyGain?: true
  }

  export type SpellClassCircleMinAggregateInputType = {
    id?: true
    spellId?: true
    classId?: true
    circle?: true
    minLevel?: true
    proficiencyGain?: true
  }

  export type SpellClassCircleMaxAggregateInputType = {
    id?: true
    spellId?: true
    classId?: true
    circle?: true
    minLevel?: true
    proficiencyGain?: true
  }

  export type SpellClassCircleCountAggregateInputType = {
    id?: true
    spellId?: true
    classId?: true
    circle?: true
    minLevel?: true
    proficiencyGain?: true
    _all?: true
  }

  export type SpellClassCircleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellClassCircle to aggregate.
     */
    where?: SpellClassCircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellClassCircles to fetch.
     */
    orderBy?: SpellClassCircleOrderByWithRelationInput | SpellClassCircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellClassCircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellClassCircles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellClassCircles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellClassCircles
    **/
    _count?: true | SpellClassCircleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellClassCircleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellClassCircleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellClassCircleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellClassCircleMaxAggregateInputType
  }

  export type GetSpellClassCircleAggregateType<T extends SpellClassCircleAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellClassCircle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellClassCircle[P]>
      : GetScalarType<T[P], AggregateSpellClassCircle[P]>
  }




  export type SpellClassCircleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellClassCircleWhereInput
    orderBy?: SpellClassCircleOrderByWithAggregationInput | SpellClassCircleOrderByWithAggregationInput[]
    by: SpellClassCircleScalarFieldEnum[] | SpellClassCircleScalarFieldEnum
    having?: SpellClassCircleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellClassCircleCountAggregateInputType | true
    _avg?: SpellClassCircleAvgAggregateInputType
    _sum?: SpellClassCircleSumAggregateInputType
    _min?: SpellClassCircleMinAggregateInputType
    _max?: SpellClassCircleMaxAggregateInputType
  }

  export type SpellClassCircleGroupByOutputType = {
    id: number
    spellId: number
    classId: number
    circle: number
    minLevel: number | null
    proficiencyGain: number | null
    _count: SpellClassCircleCountAggregateOutputType | null
    _avg: SpellClassCircleAvgAggregateOutputType | null
    _sum: SpellClassCircleSumAggregateOutputType | null
    _min: SpellClassCircleMinAggregateOutputType | null
    _max: SpellClassCircleMaxAggregateOutputType | null
  }

  type GetSpellClassCircleGroupByPayload<T extends SpellClassCircleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellClassCircleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellClassCircleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellClassCircleGroupByOutputType[P]>
            : GetScalarType<T[P], SpellClassCircleGroupByOutputType[P]>
        }
      >
    >


  export type SpellClassCircleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    classId?: boolean
    circle?: boolean
    minLevel?: boolean
    proficiencyGain?: boolean
    gameClass?: boolean | GameClassDefaultArgs<ExtArgs>
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellClassCircle"]>

  export type SpellClassCircleSelectScalar = {
    id?: boolean
    spellId?: boolean
    classId?: boolean
    circle?: boolean
    minLevel?: boolean
    proficiencyGain?: boolean
  }

  export type SpellClassCircleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameClass?: boolean | GameClassDefaultArgs<ExtArgs>
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }


  export type $SpellClassCirclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellClassCircle"
    objects: {
      gameClass: Prisma.$GameClassPayload<ExtArgs>
      spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      classId: number
      circle: number
      minLevel: number | null
      proficiencyGain: number | null
    }, ExtArgs["result"]["spellClassCircle"]>
    composites: {}
  }


  type SpellClassCircleGetPayload<S extends boolean | null | undefined | SpellClassCircleDefaultArgs> = $Result.GetResult<Prisma.$SpellClassCirclePayload, S>

  type SpellClassCircleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpellClassCircleFindManyArgs, 'select' | 'include'> & {
      select?: SpellClassCircleCountAggregateInputType | true
    }

  export interface SpellClassCircleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellClassCircle'], meta: { name: 'SpellClassCircle' } }
    /**
     * Find zero or one SpellClassCircle that matches the filter.
     * @param {SpellClassCircleFindUniqueArgs} args - Arguments to find a SpellClassCircle
     * @example
     * // Get one SpellClassCircle
     * const spellClassCircle = await prisma.spellClassCircle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpellClassCircleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpellClassCircleFindUniqueArgs<ExtArgs>>
    ): Prisma__SpellClassCircleClient<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpellClassCircle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpellClassCircleFindUniqueOrThrowArgs} args - Arguments to find a SpellClassCircle
     * @example
     * // Get one SpellClassCircle
     * const spellClassCircle = await prisma.spellClassCircle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpellClassCircleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellClassCircleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpellClassCircleClient<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpellClassCircle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassCircleFindFirstArgs} args - Arguments to find a SpellClassCircle
     * @example
     * // Get one SpellClassCircle
     * const spellClassCircle = await prisma.spellClassCircle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpellClassCircleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellClassCircleFindFirstArgs<ExtArgs>>
    ): Prisma__SpellClassCircleClient<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpellClassCircle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassCircleFindFirstOrThrowArgs} args - Arguments to find a SpellClassCircle
     * @example
     * // Get one SpellClassCircle
     * const spellClassCircle = await prisma.spellClassCircle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpellClassCircleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellClassCircleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpellClassCircleClient<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpellClassCircles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassCircleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellClassCircles
     * const spellClassCircles = await prisma.spellClassCircle.findMany()
     * 
     * // Get first 10 SpellClassCircles
     * const spellClassCircles = await prisma.spellClassCircle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellClassCircleWithIdOnly = await prisma.spellClassCircle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpellClassCircleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellClassCircleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpellClassCircle.
     * @param {SpellClassCircleCreateArgs} args - Arguments to create a SpellClassCircle.
     * @example
     * // Create one SpellClassCircle
     * const SpellClassCircle = await prisma.spellClassCircle.create({
     *   data: {
     *     // ... data to create a SpellClassCircle
     *   }
     * })
     * 
    **/
    create<T extends SpellClassCircleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellClassCircleCreateArgs<ExtArgs>>
    ): Prisma__SpellClassCircleClient<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpellClassCircles.
     *     @param {SpellClassCircleCreateManyArgs} args - Arguments to create many SpellClassCircles.
     *     @example
     *     // Create many SpellClassCircles
     *     const spellClassCircle = await prisma.spellClassCircle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpellClassCircleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellClassCircleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellClassCircle.
     * @param {SpellClassCircleDeleteArgs} args - Arguments to delete one SpellClassCircle.
     * @example
     * // Delete one SpellClassCircle
     * const SpellClassCircle = await prisma.spellClassCircle.delete({
     *   where: {
     *     // ... filter to delete one SpellClassCircle
     *   }
     * })
     * 
    **/
    delete<T extends SpellClassCircleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpellClassCircleDeleteArgs<ExtArgs>>
    ): Prisma__SpellClassCircleClient<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpellClassCircle.
     * @param {SpellClassCircleUpdateArgs} args - Arguments to update one SpellClassCircle.
     * @example
     * // Update one SpellClassCircle
     * const spellClassCircle = await prisma.spellClassCircle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpellClassCircleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellClassCircleUpdateArgs<ExtArgs>>
    ): Prisma__SpellClassCircleClient<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpellClassCircles.
     * @param {SpellClassCircleDeleteManyArgs} args - Arguments to filter SpellClassCircles to delete.
     * @example
     * // Delete a few SpellClassCircles
     * const { count } = await prisma.spellClassCircle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpellClassCircleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellClassCircleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellClassCircles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassCircleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellClassCircles
     * const spellClassCircle = await prisma.spellClassCircle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpellClassCircleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpellClassCircleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellClassCircle.
     * @param {SpellClassCircleUpsertArgs} args - Arguments to update or create a SpellClassCircle.
     * @example
     * // Update or create a SpellClassCircle
     * const spellClassCircle = await prisma.spellClassCircle.upsert({
     *   create: {
     *     // ... data to create a SpellClassCircle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellClassCircle we want to update
     *   }
     * })
    **/
    upsert<T extends SpellClassCircleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpellClassCircleUpsertArgs<ExtArgs>>
    ): Prisma__SpellClassCircleClient<$Result.GetResult<Prisma.$SpellClassCirclePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpellClassCircles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassCircleCountArgs} args - Arguments to filter SpellClassCircles to count.
     * @example
     * // Count the number of SpellClassCircles
     * const count = await prisma.spellClassCircle.count({
     *   where: {
     *     // ... the filter for the SpellClassCircles we want to count
     *   }
     * })
    **/
    count<T extends SpellClassCircleCountArgs>(
      args?: Subset<T, SpellClassCircleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellClassCircleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellClassCircle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassCircleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellClassCircleAggregateArgs>(args: Subset<T, SpellClassCircleAggregateArgs>): Prisma.PrismaPromise<GetSpellClassCircleAggregateType<T>>

    /**
     * Group by SpellClassCircle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellClassCircleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellClassCircleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellClassCircleGroupByArgs['orderBy'] }
        : { orderBy?: SpellClassCircleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellClassCircleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellClassCircleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellClassCircle model
   */
  readonly fields: SpellClassCircleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellClassCircle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellClassCircleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    gameClass<T extends GameClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameClassDefaultArgs<ExtArgs>>): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpellClassCircle model
   */ 
  interface SpellClassCircleFieldRefs {
    readonly id: FieldRef<"SpellClassCircle", 'Int'>
    readonly spellId: FieldRef<"SpellClassCircle", 'Int'>
    readonly classId: FieldRef<"SpellClassCircle", 'Int'>
    readonly circle: FieldRef<"SpellClassCircle", 'Int'>
    readonly minLevel: FieldRef<"SpellClassCircle", 'Int'>
    readonly proficiencyGain: FieldRef<"SpellClassCircle", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SpellClassCircle findUnique
   */
  export type SpellClassCircleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    /**
     * Filter, which SpellClassCircle to fetch.
     */
    where: SpellClassCircleWhereUniqueInput
  }


  /**
   * SpellClassCircle findUniqueOrThrow
   */
  export type SpellClassCircleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    /**
     * Filter, which SpellClassCircle to fetch.
     */
    where: SpellClassCircleWhereUniqueInput
  }


  /**
   * SpellClassCircle findFirst
   */
  export type SpellClassCircleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    /**
     * Filter, which SpellClassCircle to fetch.
     */
    where?: SpellClassCircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellClassCircles to fetch.
     */
    orderBy?: SpellClassCircleOrderByWithRelationInput | SpellClassCircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellClassCircles.
     */
    cursor?: SpellClassCircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellClassCircles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellClassCircles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellClassCircles.
     */
    distinct?: SpellClassCircleScalarFieldEnum | SpellClassCircleScalarFieldEnum[]
  }


  /**
   * SpellClassCircle findFirstOrThrow
   */
  export type SpellClassCircleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    /**
     * Filter, which SpellClassCircle to fetch.
     */
    where?: SpellClassCircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellClassCircles to fetch.
     */
    orderBy?: SpellClassCircleOrderByWithRelationInput | SpellClassCircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellClassCircles.
     */
    cursor?: SpellClassCircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellClassCircles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellClassCircles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellClassCircles.
     */
    distinct?: SpellClassCircleScalarFieldEnum | SpellClassCircleScalarFieldEnum[]
  }


  /**
   * SpellClassCircle findMany
   */
  export type SpellClassCircleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    /**
     * Filter, which SpellClassCircles to fetch.
     */
    where?: SpellClassCircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellClassCircles to fetch.
     */
    orderBy?: SpellClassCircleOrderByWithRelationInput | SpellClassCircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellClassCircles.
     */
    cursor?: SpellClassCircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellClassCircles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellClassCircles.
     */
    skip?: number
    distinct?: SpellClassCircleScalarFieldEnum | SpellClassCircleScalarFieldEnum[]
  }


  /**
   * SpellClassCircle create
   */
  export type SpellClassCircleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellClassCircle.
     */
    data: XOR<SpellClassCircleCreateInput, SpellClassCircleUncheckedCreateInput>
  }


  /**
   * SpellClassCircle createMany
   */
  export type SpellClassCircleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellClassCircles.
     */
    data: SpellClassCircleCreateManyInput | SpellClassCircleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SpellClassCircle update
   */
  export type SpellClassCircleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellClassCircle.
     */
    data: XOR<SpellClassCircleUpdateInput, SpellClassCircleUncheckedUpdateInput>
    /**
     * Choose, which SpellClassCircle to update.
     */
    where: SpellClassCircleWhereUniqueInput
  }


  /**
   * SpellClassCircle updateMany
   */
  export type SpellClassCircleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellClassCircles.
     */
    data: XOR<SpellClassCircleUpdateManyMutationInput, SpellClassCircleUncheckedUpdateManyInput>
    /**
     * Filter which SpellClassCircles to update
     */
    where?: SpellClassCircleWhereInput
  }


  /**
   * SpellClassCircle upsert
   */
  export type SpellClassCircleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellClassCircle to update in case it exists.
     */
    where: SpellClassCircleWhereUniqueInput
    /**
     * In case the SpellClassCircle found by the `where` argument doesn't exist, create a new SpellClassCircle with this data.
     */
    create: XOR<SpellClassCircleCreateInput, SpellClassCircleUncheckedCreateInput>
    /**
     * In case the SpellClassCircle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellClassCircleUpdateInput, SpellClassCircleUncheckedUpdateInput>
  }


  /**
   * SpellClassCircle delete
   */
  export type SpellClassCircleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
    /**
     * Filter which SpellClassCircle to delete.
     */
    where: SpellClassCircleWhereUniqueInput
  }


  /**
   * SpellClassCircle deleteMany
   */
  export type SpellClassCircleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellClassCircles to delete
     */
    where?: SpellClassCircleWhereInput
  }


  /**
   * SpellClassCircle without action
   */
  export type SpellClassCircleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellClassCircle
     */
    select?: SpellClassCircleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellClassCircleInclude<ExtArgs> | null
  }



  /**
   * Model SpellTargeting
   */

  export type AggregateSpellTargeting = {
    _count: SpellTargetingCountAggregateOutputType | null
    _avg: SpellTargetingAvgAggregateOutputType | null
    _sum: SpellTargetingSumAggregateOutputType | null
    _min: SpellTargetingMinAggregateOutputType | null
    _max: SpellTargetingMaxAggregateOutputType | null
  }

  export type SpellTargetingAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    allowedTargetsMask: number | null
    maxTargets: number | null
    filtersMask: number | null
  }

  export type SpellTargetingSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    allowedTargetsMask: number | null
    maxTargets: number | null
    filtersMask: number | null
  }

  export type SpellTargetingMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    allowedTargetsMask: number | null
    targetScope: $Enums.TargetScope | null
    maxTargets: number | null
    range: $Enums.SpellRange | null
    requireLos: boolean | null
    filtersMask: number | null
  }

  export type SpellTargetingMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    allowedTargetsMask: number | null
    targetScope: $Enums.TargetScope | null
    maxTargets: number | null
    range: $Enums.SpellRange | null
    requireLos: boolean | null
    filtersMask: number | null
  }

  export type SpellTargetingCountAggregateOutputType = {
    id: number
    spellId: number
    allowedTargetsMask: number
    targetScope: number
    maxTargets: number
    range: number
    requireLos: number
    filtersMask: number
    _all: number
  }


  export type SpellTargetingAvgAggregateInputType = {
    id?: true
    spellId?: true
    allowedTargetsMask?: true
    maxTargets?: true
    filtersMask?: true
  }

  export type SpellTargetingSumAggregateInputType = {
    id?: true
    spellId?: true
    allowedTargetsMask?: true
    maxTargets?: true
    filtersMask?: true
  }

  export type SpellTargetingMinAggregateInputType = {
    id?: true
    spellId?: true
    allowedTargetsMask?: true
    targetScope?: true
    maxTargets?: true
    range?: true
    requireLos?: true
    filtersMask?: true
  }

  export type SpellTargetingMaxAggregateInputType = {
    id?: true
    spellId?: true
    allowedTargetsMask?: true
    targetScope?: true
    maxTargets?: true
    range?: true
    requireLos?: true
    filtersMask?: true
  }

  export type SpellTargetingCountAggregateInputType = {
    id?: true
    spellId?: true
    allowedTargetsMask?: true
    targetScope?: true
    maxTargets?: true
    range?: true
    requireLos?: true
    filtersMask?: true
    _all?: true
  }

  export type SpellTargetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellTargeting to aggregate.
     */
    where?: SpellTargetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellTargetings to fetch.
     */
    orderBy?: SpellTargetingOrderByWithRelationInput | SpellTargetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellTargetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellTargetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellTargetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellTargetings
    **/
    _count?: true | SpellTargetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellTargetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellTargetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellTargetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellTargetingMaxAggregateInputType
  }

  export type GetSpellTargetingAggregateType<T extends SpellTargetingAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellTargeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellTargeting[P]>
      : GetScalarType<T[P], AggregateSpellTargeting[P]>
  }




  export type SpellTargetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellTargetingWhereInput
    orderBy?: SpellTargetingOrderByWithAggregationInput | SpellTargetingOrderByWithAggregationInput[]
    by: SpellTargetingScalarFieldEnum[] | SpellTargetingScalarFieldEnum
    having?: SpellTargetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellTargetingCountAggregateInputType | true
    _avg?: SpellTargetingAvgAggregateInputType
    _sum?: SpellTargetingSumAggregateInputType
    _min?: SpellTargetingMinAggregateInputType
    _max?: SpellTargetingMaxAggregateInputType
  }

  export type SpellTargetingGroupByOutputType = {
    id: number
    spellId: number
    allowedTargetsMask: number
    targetScope: $Enums.TargetScope
    maxTargets: number
    range: $Enums.SpellRange
    requireLos: boolean
    filtersMask: number | null
    _count: SpellTargetingCountAggregateOutputType | null
    _avg: SpellTargetingAvgAggregateOutputType | null
    _sum: SpellTargetingSumAggregateOutputType | null
    _min: SpellTargetingMinAggregateOutputType | null
    _max: SpellTargetingMaxAggregateOutputType | null
  }

  type GetSpellTargetingGroupByPayload<T extends SpellTargetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellTargetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellTargetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellTargetingGroupByOutputType[P]>
            : GetScalarType<T[P], SpellTargetingGroupByOutputType[P]>
        }
      >
    >


  export type SpellTargetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    allowedTargetsMask?: boolean
    targetScope?: boolean
    maxTargets?: boolean
    range?: boolean
    requireLos?: boolean
    filtersMask?: boolean
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellTargeting"]>

  export type SpellTargetingSelectScalar = {
    id?: boolean
    spellId?: boolean
    allowedTargetsMask?: boolean
    targetScope?: boolean
    maxTargets?: boolean
    range?: boolean
    requireLos?: boolean
    filtersMask?: boolean
  }

  export type SpellTargetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }


  export type $SpellTargetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellTargeting"
    objects: {
      spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      allowedTargetsMask: number
      targetScope: $Enums.TargetScope
      maxTargets: number
      range: $Enums.SpellRange
      requireLos: boolean
      filtersMask: number | null
    }, ExtArgs["result"]["spellTargeting"]>
    composites: {}
  }


  type SpellTargetingGetPayload<S extends boolean | null | undefined | SpellTargetingDefaultArgs> = $Result.GetResult<Prisma.$SpellTargetingPayload, S>

  type SpellTargetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpellTargetingFindManyArgs, 'select' | 'include'> & {
      select?: SpellTargetingCountAggregateInputType | true
    }

  export interface SpellTargetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellTargeting'], meta: { name: 'SpellTargeting' } }
    /**
     * Find zero or one SpellTargeting that matches the filter.
     * @param {SpellTargetingFindUniqueArgs} args - Arguments to find a SpellTargeting
     * @example
     * // Get one SpellTargeting
     * const spellTargeting = await prisma.spellTargeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpellTargetingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpellTargetingFindUniqueArgs<ExtArgs>>
    ): Prisma__SpellTargetingClient<$Result.GetResult<Prisma.$SpellTargetingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpellTargeting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpellTargetingFindUniqueOrThrowArgs} args - Arguments to find a SpellTargeting
     * @example
     * // Get one SpellTargeting
     * const spellTargeting = await prisma.spellTargeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpellTargetingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellTargetingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpellTargetingClient<$Result.GetResult<Prisma.$SpellTargetingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpellTargeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellTargetingFindFirstArgs} args - Arguments to find a SpellTargeting
     * @example
     * // Get one SpellTargeting
     * const spellTargeting = await prisma.spellTargeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpellTargetingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellTargetingFindFirstArgs<ExtArgs>>
    ): Prisma__SpellTargetingClient<$Result.GetResult<Prisma.$SpellTargetingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpellTargeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellTargetingFindFirstOrThrowArgs} args - Arguments to find a SpellTargeting
     * @example
     * // Get one SpellTargeting
     * const spellTargeting = await prisma.spellTargeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpellTargetingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellTargetingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpellTargetingClient<$Result.GetResult<Prisma.$SpellTargetingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpellTargetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellTargetingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellTargetings
     * const spellTargetings = await prisma.spellTargeting.findMany()
     * 
     * // Get first 10 SpellTargetings
     * const spellTargetings = await prisma.spellTargeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellTargetingWithIdOnly = await prisma.spellTargeting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpellTargetingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellTargetingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellTargetingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpellTargeting.
     * @param {SpellTargetingCreateArgs} args - Arguments to create a SpellTargeting.
     * @example
     * // Create one SpellTargeting
     * const SpellTargeting = await prisma.spellTargeting.create({
     *   data: {
     *     // ... data to create a SpellTargeting
     *   }
     * })
     * 
    **/
    create<T extends SpellTargetingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellTargetingCreateArgs<ExtArgs>>
    ): Prisma__SpellTargetingClient<$Result.GetResult<Prisma.$SpellTargetingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpellTargetings.
     *     @param {SpellTargetingCreateManyArgs} args - Arguments to create many SpellTargetings.
     *     @example
     *     // Create many SpellTargetings
     *     const spellTargeting = await prisma.spellTargeting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpellTargetingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellTargetingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellTargeting.
     * @param {SpellTargetingDeleteArgs} args - Arguments to delete one SpellTargeting.
     * @example
     * // Delete one SpellTargeting
     * const SpellTargeting = await prisma.spellTargeting.delete({
     *   where: {
     *     // ... filter to delete one SpellTargeting
     *   }
     * })
     * 
    **/
    delete<T extends SpellTargetingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpellTargetingDeleteArgs<ExtArgs>>
    ): Prisma__SpellTargetingClient<$Result.GetResult<Prisma.$SpellTargetingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpellTargeting.
     * @param {SpellTargetingUpdateArgs} args - Arguments to update one SpellTargeting.
     * @example
     * // Update one SpellTargeting
     * const spellTargeting = await prisma.spellTargeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpellTargetingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellTargetingUpdateArgs<ExtArgs>>
    ): Prisma__SpellTargetingClient<$Result.GetResult<Prisma.$SpellTargetingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpellTargetings.
     * @param {SpellTargetingDeleteManyArgs} args - Arguments to filter SpellTargetings to delete.
     * @example
     * // Delete a few SpellTargetings
     * const { count } = await prisma.spellTargeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpellTargetingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellTargetingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellTargetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellTargetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellTargetings
     * const spellTargeting = await prisma.spellTargeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpellTargetingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpellTargetingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellTargeting.
     * @param {SpellTargetingUpsertArgs} args - Arguments to update or create a SpellTargeting.
     * @example
     * // Update or create a SpellTargeting
     * const spellTargeting = await prisma.spellTargeting.upsert({
     *   create: {
     *     // ... data to create a SpellTargeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellTargeting we want to update
     *   }
     * })
    **/
    upsert<T extends SpellTargetingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpellTargetingUpsertArgs<ExtArgs>>
    ): Prisma__SpellTargetingClient<$Result.GetResult<Prisma.$SpellTargetingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpellTargetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellTargetingCountArgs} args - Arguments to filter SpellTargetings to count.
     * @example
     * // Count the number of SpellTargetings
     * const count = await prisma.spellTargeting.count({
     *   where: {
     *     // ... the filter for the SpellTargetings we want to count
     *   }
     * })
    **/
    count<T extends SpellTargetingCountArgs>(
      args?: Subset<T, SpellTargetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellTargetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellTargeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellTargetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellTargetingAggregateArgs>(args: Subset<T, SpellTargetingAggregateArgs>): Prisma.PrismaPromise<GetSpellTargetingAggregateType<T>>

    /**
     * Group by SpellTargeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellTargetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellTargetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellTargetingGroupByArgs['orderBy'] }
        : { orderBy?: SpellTargetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellTargetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellTargetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellTargeting model
   */
  readonly fields: SpellTargetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellTargeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellTargetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpellTargeting model
   */ 
  interface SpellTargetingFieldRefs {
    readonly id: FieldRef<"SpellTargeting", 'Int'>
    readonly spellId: FieldRef<"SpellTargeting", 'Int'>
    readonly allowedTargetsMask: FieldRef<"SpellTargeting", 'Int'>
    readonly targetScope: FieldRef<"SpellTargeting", 'TargetScope'>
    readonly maxTargets: FieldRef<"SpellTargeting", 'Int'>
    readonly range: FieldRef<"SpellTargeting", 'SpellRange'>
    readonly requireLos: FieldRef<"SpellTargeting", 'Boolean'>
    readonly filtersMask: FieldRef<"SpellTargeting", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SpellTargeting findUnique
   */
  export type SpellTargetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
    /**
     * Filter, which SpellTargeting to fetch.
     */
    where: SpellTargetingWhereUniqueInput
  }


  /**
   * SpellTargeting findUniqueOrThrow
   */
  export type SpellTargetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
    /**
     * Filter, which SpellTargeting to fetch.
     */
    where: SpellTargetingWhereUniqueInput
  }


  /**
   * SpellTargeting findFirst
   */
  export type SpellTargetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
    /**
     * Filter, which SpellTargeting to fetch.
     */
    where?: SpellTargetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellTargetings to fetch.
     */
    orderBy?: SpellTargetingOrderByWithRelationInput | SpellTargetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellTargetings.
     */
    cursor?: SpellTargetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellTargetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellTargetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellTargetings.
     */
    distinct?: SpellTargetingScalarFieldEnum | SpellTargetingScalarFieldEnum[]
  }


  /**
   * SpellTargeting findFirstOrThrow
   */
  export type SpellTargetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
    /**
     * Filter, which SpellTargeting to fetch.
     */
    where?: SpellTargetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellTargetings to fetch.
     */
    orderBy?: SpellTargetingOrderByWithRelationInput | SpellTargetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellTargetings.
     */
    cursor?: SpellTargetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellTargetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellTargetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellTargetings.
     */
    distinct?: SpellTargetingScalarFieldEnum | SpellTargetingScalarFieldEnum[]
  }


  /**
   * SpellTargeting findMany
   */
  export type SpellTargetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
    /**
     * Filter, which SpellTargetings to fetch.
     */
    where?: SpellTargetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellTargetings to fetch.
     */
    orderBy?: SpellTargetingOrderByWithRelationInput | SpellTargetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellTargetings.
     */
    cursor?: SpellTargetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellTargetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellTargetings.
     */
    skip?: number
    distinct?: SpellTargetingScalarFieldEnum | SpellTargetingScalarFieldEnum[]
  }


  /**
   * SpellTargeting create
   */
  export type SpellTargetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellTargeting.
     */
    data: XOR<SpellTargetingCreateInput, SpellTargetingUncheckedCreateInput>
  }


  /**
   * SpellTargeting createMany
   */
  export type SpellTargetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellTargetings.
     */
    data: SpellTargetingCreateManyInput | SpellTargetingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SpellTargeting update
   */
  export type SpellTargetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellTargeting.
     */
    data: XOR<SpellTargetingUpdateInput, SpellTargetingUncheckedUpdateInput>
    /**
     * Choose, which SpellTargeting to update.
     */
    where: SpellTargetingWhereUniqueInput
  }


  /**
   * SpellTargeting updateMany
   */
  export type SpellTargetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellTargetings.
     */
    data: XOR<SpellTargetingUpdateManyMutationInput, SpellTargetingUncheckedUpdateManyInput>
    /**
     * Filter which SpellTargetings to update
     */
    where?: SpellTargetingWhereInput
  }


  /**
   * SpellTargeting upsert
   */
  export type SpellTargetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellTargeting to update in case it exists.
     */
    where: SpellTargetingWhereUniqueInput
    /**
     * In case the SpellTargeting found by the `where` argument doesn't exist, create a new SpellTargeting with this data.
     */
    create: XOR<SpellTargetingCreateInput, SpellTargetingUncheckedCreateInput>
    /**
     * In case the SpellTargeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellTargetingUpdateInput, SpellTargetingUncheckedUpdateInput>
  }


  /**
   * SpellTargeting delete
   */
  export type SpellTargetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
    /**
     * Filter which SpellTargeting to delete.
     */
    where: SpellTargetingWhereUniqueInput
  }


  /**
   * SpellTargeting deleteMany
   */
  export type SpellTargetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellTargetings to delete
     */
    where?: SpellTargetingWhereInput
  }


  /**
   * SpellTargeting without action
   */
  export type SpellTargetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellTargeting
     */
    select?: SpellTargetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellTargetingInclude<ExtArgs> | null
  }



  /**
   * Model SpellSavingThrow
   */

  export type AggregateSpellSavingThrow = {
    _count: SpellSavingThrowCountAggregateOutputType | null
    _avg: SpellSavingThrowAvgAggregateOutputType | null
    _sum: SpellSavingThrowSumAggregateOutputType | null
    _min: SpellSavingThrowMinAggregateOutputType | null
    _max: SpellSavingThrowMaxAggregateOutputType | null
  }

  export type SpellSavingThrowAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    saveModifierMask: number | null
  }

  export type SpellSavingThrowSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    saveModifierMask: number | null
  }

  export type SpellSavingThrowMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    saveType: $Enums.SaveType | null
    onSave: $Enums.SaveResult | null
    dcFormula: string | null
    saveModifierMask: number | null
  }

  export type SpellSavingThrowMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    saveType: $Enums.SaveType | null
    onSave: $Enums.SaveResult | null
    dcFormula: string | null
    saveModifierMask: number | null
  }

  export type SpellSavingThrowCountAggregateOutputType = {
    id: number
    spellId: number
    saveType: number
    onSave: number
    dcFormula: number
    saveModifierMask: number
    _all: number
  }


  export type SpellSavingThrowAvgAggregateInputType = {
    id?: true
    spellId?: true
    saveModifierMask?: true
  }

  export type SpellSavingThrowSumAggregateInputType = {
    id?: true
    spellId?: true
    saveModifierMask?: true
  }

  export type SpellSavingThrowMinAggregateInputType = {
    id?: true
    spellId?: true
    saveType?: true
    onSave?: true
    dcFormula?: true
    saveModifierMask?: true
  }

  export type SpellSavingThrowMaxAggregateInputType = {
    id?: true
    spellId?: true
    saveType?: true
    onSave?: true
    dcFormula?: true
    saveModifierMask?: true
  }

  export type SpellSavingThrowCountAggregateInputType = {
    id?: true
    spellId?: true
    saveType?: true
    onSave?: true
    dcFormula?: true
    saveModifierMask?: true
    _all?: true
  }

  export type SpellSavingThrowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellSavingThrow to aggregate.
     */
    where?: SpellSavingThrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSavingThrows to fetch.
     */
    orderBy?: SpellSavingThrowOrderByWithRelationInput | SpellSavingThrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellSavingThrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSavingThrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSavingThrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellSavingThrows
    **/
    _count?: true | SpellSavingThrowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellSavingThrowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellSavingThrowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellSavingThrowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellSavingThrowMaxAggregateInputType
  }

  export type GetSpellSavingThrowAggregateType<T extends SpellSavingThrowAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellSavingThrow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellSavingThrow[P]>
      : GetScalarType<T[P], AggregateSpellSavingThrow[P]>
  }




  export type SpellSavingThrowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellSavingThrowWhereInput
    orderBy?: SpellSavingThrowOrderByWithAggregationInput | SpellSavingThrowOrderByWithAggregationInput[]
    by: SpellSavingThrowScalarFieldEnum[] | SpellSavingThrowScalarFieldEnum
    having?: SpellSavingThrowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellSavingThrowCountAggregateInputType | true
    _avg?: SpellSavingThrowAvgAggregateInputType
    _sum?: SpellSavingThrowSumAggregateInputType
    _min?: SpellSavingThrowMinAggregateInputType
    _max?: SpellSavingThrowMaxAggregateInputType
  }

  export type SpellSavingThrowGroupByOutputType = {
    id: number
    spellId: number
    saveType: $Enums.SaveType
    onSave: $Enums.SaveResult
    dcFormula: string
    saveModifierMask: number | null
    _count: SpellSavingThrowCountAggregateOutputType | null
    _avg: SpellSavingThrowAvgAggregateOutputType | null
    _sum: SpellSavingThrowSumAggregateOutputType | null
    _min: SpellSavingThrowMinAggregateOutputType | null
    _max: SpellSavingThrowMaxAggregateOutputType | null
  }

  type GetSpellSavingThrowGroupByPayload<T extends SpellSavingThrowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellSavingThrowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellSavingThrowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellSavingThrowGroupByOutputType[P]>
            : GetScalarType<T[P], SpellSavingThrowGroupByOutputType[P]>
        }
      >
    >


  export type SpellSavingThrowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    saveType?: boolean
    onSave?: boolean
    dcFormula?: boolean
    saveModifierMask?: boolean
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellSavingThrow"]>

  export type SpellSavingThrowSelectScalar = {
    id?: boolean
    spellId?: boolean
    saveType?: boolean
    onSave?: boolean
    dcFormula?: boolean
    saveModifierMask?: boolean
  }

  export type SpellSavingThrowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }


  export type $SpellSavingThrowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellSavingThrow"
    objects: {
      spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      saveType: $Enums.SaveType
      onSave: $Enums.SaveResult
      dcFormula: string
      saveModifierMask: number | null
    }, ExtArgs["result"]["spellSavingThrow"]>
    composites: {}
  }


  type SpellSavingThrowGetPayload<S extends boolean | null | undefined | SpellSavingThrowDefaultArgs> = $Result.GetResult<Prisma.$SpellSavingThrowPayload, S>

  type SpellSavingThrowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpellSavingThrowFindManyArgs, 'select' | 'include'> & {
      select?: SpellSavingThrowCountAggregateInputType | true
    }

  export interface SpellSavingThrowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellSavingThrow'], meta: { name: 'SpellSavingThrow' } }
    /**
     * Find zero or one SpellSavingThrow that matches the filter.
     * @param {SpellSavingThrowFindUniqueArgs} args - Arguments to find a SpellSavingThrow
     * @example
     * // Get one SpellSavingThrow
     * const spellSavingThrow = await prisma.spellSavingThrow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpellSavingThrowFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSavingThrowFindUniqueArgs<ExtArgs>>
    ): Prisma__SpellSavingThrowClient<$Result.GetResult<Prisma.$SpellSavingThrowPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpellSavingThrow that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpellSavingThrowFindUniqueOrThrowArgs} args - Arguments to find a SpellSavingThrow
     * @example
     * // Get one SpellSavingThrow
     * const spellSavingThrow = await prisma.spellSavingThrow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpellSavingThrowFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSavingThrowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpellSavingThrowClient<$Result.GetResult<Prisma.$SpellSavingThrowPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpellSavingThrow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSavingThrowFindFirstArgs} args - Arguments to find a SpellSavingThrow
     * @example
     * // Get one SpellSavingThrow
     * const spellSavingThrow = await prisma.spellSavingThrow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpellSavingThrowFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSavingThrowFindFirstArgs<ExtArgs>>
    ): Prisma__SpellSavingThrowClient<$Result.GetResult<Prisma.$SpellSavingThrowPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpellSavingThrow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSavingThrowFindFirstOrThrowArgs} args - Arguments to find a SpellSavingThrow
     * @example
     * // Get one SpellSavingThrow
     * const spellSavingThrow = await prisma.spellSavingThrow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpellSavingThrowFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSavingThrowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpellSavingThrowClient<$Result.GetResult<Prisma.$SpellSavingThrowPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpellSavingThrows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSavingThrowFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellSavingThrows
     * const spellSavingThrows = await prisma.spellSavingThrow.findMany()
     * 
     * // Get first 10 SpellSavingThrows
     * const spellSavingThrows = await prisma.spellSavingThrow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellSavingThrowWithIdOnly = await prisma.spellSavingThrow.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpellSavingThrowFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSavingThrowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellSavingThrowPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpellSavingThrow.
     * @param {SpellSavingThrowCreateArgs} args - Arguments to create a SpellSavingThrow.
     * @example
     * // Create one SpellSavingThrow
     * const SpellSavingThrow = await prisma.spellSavingThrow.create({
     *   data: {
     *     // ... data to create a SpellSavingThrow
     *   }
     * })
     * 
    **/
    create<T extends SpellSavingThrowCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSavingThrowCreateArgs<ExtArgs>>
    ): Prisma__SpellSavingThrowClient<$Result.GetResult<Prisma.$SpellSavingThrowPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpellSavingThrows.
     *     @param {SpellSavingThrowCreateManyArgs} args - Arguments to create many SpellSavingThrows.
     *     @example
     *     // Create many SpellSavingThrows
     *     const spellSavingThrow = await prisma.spellSavingThrow.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpellSavingThrowCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSavingThrowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellSavingThrow.
     * @param {SpellSavingThrowDeleteArgs} args - Arguments to delete one SpellSavingThrow.
     * @example
     * // Delete one SpellSavingThrow
     * const SpellSavingThrow = await prisma.spellSavingThrow.delete({
     *   where: {
     *     // ... filter to delete one SpellSavingThrow
     *   }
     * })
     * 
    **/
    delete<T extends SpellSavingThrowDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSavingThrowDeleteArgs<ExtArgs>>
    ): Prisma__SpellSavingThrowClient<$Result.GetResult<Prisma.$SpellSavingThrowPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpellSavingThrow.
     * @param {SpellSavingThrowUpdateArgs} args - Arguments to update one SpellSavingThrow.
     * @example
     * // Update one SpellSavingThrow
     * const spellSavingThrow = await prisma.spellSavingThrow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpellSavingThrowUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSavingThrowUpdateArgs<ExtArgs>>
    ): Prisma__SpellSavingThrowClient<$Result.GetResult<Prisma.$SpellSavingThrowPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpellSavingThrows.
     * @param {SpellSavingThrowDeleteManyArgs} args - Arguments to filter SpellSavingThrows to delete.
     * @example
     * // Delete a few SpellSavingThrows
     * const { count } = await prisma.spellSavingThrow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpellSavingThrowDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellSavingThrowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellSavingThrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSavingThrowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellSavingThrows
     * const spellSavingThrow = await prisma.spellSavingThrow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpellSavingThrowUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSavingThrowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellSavingThrow.
     * @param {SpellSavingThrowUpsertArgs} args - Arguments to update or create a SpellSavingThrow.
     * @example
     * // Update or create a SpellSavingThrow
     * const spellSavingThrow = await prisma.spellSavingThrow.upsert({
     *   create: {
     *     // ... data to create a SpellSavingThrow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellSavingThrow we want to update
     *   }
     * })
    **/
    upsert<T extends SpellSavingThrowUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpellSavingThrowUpsertArgs<ExtArgs>>
    ): Prisma__SpellSavingThrowClient<$Result.GetResult<Prisma.$SpellSavingThrowPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpellSavingThrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSavingThrowCountArgs} args - Arguments to filter SpellSavingThrows to count.
     * @example
     * // Count the number of SpellSavingThrows
     * const count = await prisma.spellSavingThrow.count({
     *   where: {
     *     // ... the filter for the SpellSavingThrows we want to count
     *   }
     * })
    **/
    count<T extends SpellSavingThrowCountArgs>(
      args?: Subset<T, SpellSavingThrowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellSavingThrowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellSavingThrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSavingThrowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellSavingThrowAggregateArgs>(args: Subset<T, SpellSavingThrowAggregateArgs>): Prisma.PrismaPromise<GetSpellSavingThrowAggregateType<T>>

    /**
     * Group by SpellSavingThrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellSavingThrowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellSavingThrowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellSavingThrowGroupByArgs['orderBy'] }
        : { orderBy?: SpellSavingThrowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellSavingThrowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellSavingThrowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellSavingThrow model
   */
  readonly fields: SpellSavingThrowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellSavingThrow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellSavingThrowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpellSavingThrow model
   */ 
  interface SpellSavingThrowFieldRefs {
    readonly id: FieldRef<"SpellSavingThrow", 'Int'>
    readonly spellId: FieldRef<"SpellSavingThrow", 'Int'>
    readonly saveType: FieldRef<"SpellSavingThrow", 'SaveType'>
    readonly onSave: FieldRef<"SpellSavingThrow", 'SaveResult'>
    readonly dcFormula: FieldRef<"SpellSavingThrow", 'String'>
    readonly saveModifierMask: FieldRef<"SpellSavingThrow", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SpellSavingThrow findUnique
   */
  export type SpellSavingThrowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
    /**
     * Filter, which SpellSavingThrow to fetch.
     */
    where: SpellSavingThrowWhereUniqueInput
  }


  /**
   * SpellSavingThrow findUniqueOrThrow
   */
  export type SpellSavingThrowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
    /**
     * Filter, which SpellSavingThrow to fetch.
     */
    where: SpellSavingThrowWhereUniqueInput
  }


  /**
   * SpellSavingThrow findFirst
   */
  export type SpellSavingThrowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
    /**
     * Filter, which SpellSavingThrow to fetch.
     */
    where?: SpellSavingThrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSavingThrows to fetch.
     */
    orderBy?: SpellSavingThrowOrderByWithRelationInput | SpellSavingThrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellSavingThrows.
     */
    cursor?: SpellSavingThrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSavingThrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSavingThrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellSavingThrows.
     */
    distinct?: SpellSavingThrowScalarFieldEnum | SpellSavingThrowScalarFieldEnum[]
  }


  /**
   * SpellSavingThrow findFirstOrThrow
   */
  export type SpellSavingThrowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
    /**
     * Filter, which SpellSavingThrow to fetch.
     */
    where?: SpellSavingThrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSavingThrows to fetch.
     */
    orderBy?: SpellSavingThrowOrderByWithRelationInput | SpellSavingThrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellSavingThrows.
     */
    cursor?: SpellSavingThrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSavingThrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSavingThrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellSavingThrows.
     */
    distinct?: SpellSavingThrowScalarFieldEnum | SpellSavingThrowScalarFieldEnum[]
  }


  /**
   * SpellSavingThrow findMany
   */
  export type SpellSavingThrowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
    /**
     * Filter, which SpellSavingThrows to fetch.
     */
    where?: SpellSavingThrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellSavingThrows to fetch.
     */
    orderBy?: SpellSavingThrowOrderByWithRelationInput | SpellSavingThrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellSavingThrows.
     */
    cursor?: SpellSavingThrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellSavingThrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellSavingThrows.
     */
    skip?: number
    distinct?: SpellSavingThrowScalarFieldEnum | SpellSavingThrowScalarFieldEnum[]
  }


  /**
   * SpellSavingThrow create
   */
  export type SpellSavingThrowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellSavingThrow.
     */
    data: XOR<SpellSavingThrowCreateInput, SpellSavingThrowUncheckedCreateInput>
  }


  /**
   * SpellSavingThrow createMany
   */
  export type SpellSavingThrowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellSavingThrows.
     */
    data: SpellSavingThrowCreateManyInput | SpellSavingThrowCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SpellSavingThrow update
   */
  export type SpellSavingThrowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellSavingThrow.
     */
    data: XOR<SpellSavingThrowUpdateInput, SpellSavingThrowUncheckedUpdateInput>
    /**
     * Choose, which SpellSavingThrow to update.
     */
    where: SpellSavingThrowWhereUniqueInput
  }


  /**
   * SpellSavingThrow updateMany
   */
  export type SpellSavingThrowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellSavingThrows.
     */
    data: XOR<SpellSavingThrowUpdateManyMutationInput, SpellSavingThrowUncheckedUpdateManyInput>
    /**
     * Filter which SpellSavingThrows to update
     */
    where?: SpellSavingThrowWhereInput
  }


  /**
   * SpellSavingThrow upsert
   */
  export type SpellSavingThrowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellSavingThrow to update in case it exists.
     */
    where: SpellSavingThrowWhereUniqueInput
    /**
     * In case the SpellSavingThrow found by the `where` argument doesn't exist, create a new SpellSavingThrow with this data.
     */
    create: XOR<SpellSavingThrowCreateInput, SpellSavingThrowUncheckedCreateInput>
    /**
     * In case the SpellSavingThrow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellSavingThrowUpdateInput, SpellSavingThrowUncheckedUpdateInput>
  }


  /**
   * SpellSavingThrow delete
   */
  export type SpellSavingThrowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
    /**
     * Filter which SpellSavingThrow to delete.
     */
    where: SpellSavingThrowWhereUniqueInput
  }


  /**
   * SpellSavingThrow deleteMany
   */
  export type SpellSavingThrowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellSavingThrows to delete
     */
    where?: SpellSavingThrowWhereInput
  }


  /**
   * SpellSavingThrow without action
   */
  export type SpellSavingThrowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellSavingThrow
     */
    select?: SpellSavingThrowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellSavingThrowInclude<ExtArgs> | null
  }



  /**
   * Model SpellMessage
   */

  export type AggregateSpellMessage = {
    _count: SpellMessageCountAggregateOutputType | null
    _avg: SpellMessageAvgAggregateOutputType | null
    _sum: SpellMessageSumAggregateOutputType | null
    _min: SpellMessageMinAggregateOutputType | null
    _max: SpellMessageMaxAggregateOutputType | null
  }

  export type SpellMessageAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
  }

  export type SpellMessageSumAggregateOutputType = {
    id: number | null
    spellId: number | null
  }

  export type SpellMessageMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    startToCaster: string | null
    startToVictim: string | null
    startToRoom: string | null
    successToCaster: string | null
    successToVictim: string | null
    successToRoom: string | null
    failToCaster: string | null
    failToVictim: string | null
    failToRoom: string | null
    wearoffToTarget: string | null
    wearoffToRoom: string | null
  }

  export type SpellMessageMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    startToCaster: string | null
    startToVictim: string | null
    startToRoom: string | null
    successToCaster: string | null
    successToVictim: string | null
    successToRoom: string | null
    failToCaster: string | null
    failToVictim: string | null
    failToRoom: string | null
    wearoffToTarget: string | null
    wearoffToRoom: string | null
  }

  export type SpellMessageCountAggregateOutputType = {
    id: number
    spellId: number
    startToCaster: number
    startToVictim: number
    startToRoom: number
    successToCaster: number
    successToVictim: number
    successToRoom: number
    failToCaster: number
    failToVictim: number
    failToRoom: number
    wearoffToTarget: number
    wearoffToRoom: number
    _all: number
  }


  export type SpellMessageAvgAggregateInputType = {
    id?: true
    spellId?: true
  }

  export type SpellMessageSumAggregateInputType = {
    id?: true
    spellId?: true
  }

  export type SpellMessageMinAggregateInputType = {
    id?: true
    spellId?: true
    startToCaster?: true
    startToVictim?: true
    startToRoom?: true
    successToCaster?: true
    successToVictim?: true
    successToRoom?: true
    failToCaster?: true
    failToVictim?: true
    failToRoom?: true
    wearoffToTarget?: true
    wearoffToRoom?: true
  }

  export type SpellMessageMaxAggregateInputType = {
    id?: true
    spellId?: true
    startToCaster?: true
    startToVictim?: true
    startToRoom?: true
    successToCaster?: true
    successToVictim?: true
    successToRoom?: true
    failToCaster?: true
    failToVictim?: true
    failToRoom?: true
    wearoffToTarget?: true
    wearoffToRoom?: true
  }

  export type SpellMessageCountAggregateInputType = {
    id?: true
    spellId?: true
    startToCaster?: true
    startToVictim?: true
    startToRoom?: true
    successToCaster?: true
    successToVictim?: true
    successToRoom?: true
    failToCaster?: true
    failToVictim?: true
    failToRoom?: true
    wearoffToTarget?: true
    wearoffToRoom?: true
    _all?: true
  }

  export type SpellMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellMessage to aggregate.
     */
    where?: SpellMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellMessages to fetch.
     */
    orderBy?: SpellMessageOrderByWithRelationInput | SpellMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellMessages
    **/
    _count?: true | SpellMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellMessageMaxAggregateInputType
  }

  export type GetSpellMessageAggregateType<T extends SpellMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellMessage[P]>
      : GetScalarType<T[P], AggregateSpellMessage[P]>
  }




  export type SpellMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellMessageWhereInput
    orderBy?: SpellMessageOrderByWithAggregationInput | SpellMessageOrderByWithAggregationInput[]
    by: SpellMessageScalarFieldEnum[] | SpellMessageScalarFieldEnum
    having?: SpellMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellMessageCountAggregateInputType | true
    _avg?: SpellMessageAvgAggregateInputType
    _sum?: SpellMessageSumAggregateInputType
    _min?: SpellMessageMinAggregateInputType
    _max?: SpellMessageMaxAggregateInputType
  }

  export type SpellMessageGroupByOutputType = {
    id: number
    spellId: number
    startToCaster: string | null
    startToVictim: string | null
    startToRoom: string | null
    successToCaster: string | null
    successToVictim: string | null
    successToRoom: string | null
    failToCaster: string | null
    failToVictim: string | null
    failToRoom: string | null
    wearoffToTarget: string | null
    wearoffToRoom: string | null
    _count: SpellMessageCountAggregateOutputType | null
    _avg: SpellMessageAvgAggregateOutputType | null
    _sum: SpellMessageSumAggregateOutputType | null
    _min: SpellMessageMinAggregateOutputType | null
    _max: SpellMessageMaxAggregateOutputType | null
  }

  type GetSpellMessageGroupByPayload<T extends SpellMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellMessageGroupByOutputType[P]>
            : GetScalarType<T[P], SpellMessageGroupByOutputType[P]>
        }
      >
    >


  export type SpellMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    startToCaster?: boolean
    startToVictim?: boolean
    startToRoom?: boolean
    successToCaster?: boolean
    successToVictim?: boolean
    successToRoom?: boolean
    failToCaster?: boolean
    failToVictim?: boolean
    failToRoom?: boolean
    wearoffToTarget?: boolean
    wearoffToRoom?: boolean
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellMessage"]>

  export type SpellMessageSelectScalar = {
    id?: boolean
    spellId?: boolean
    startToCaster?: boolean
    startToVictim?: boolean
    startToRoom?: boolean
    successToCaster?: boolean
    successToVictim?: boolean
    successToRoom?: boolean
    failToCaster?: boolean
    failToVictim?: boolean
    failToRoom?: boolean
    wearoffToTarget?: boolean
    wearoffToRoom?: boolean
  }

  export type SpellMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }


  export type $SpellMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellMessage"
    objects: {
      spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      startToCaster: string | null
      startToVictim: string | null
      startToRoom: string | null
      successToCaster: string | null
      successToVictim: string | null
      successToRoom: string | null
      failToCaster: string | null
      failToVictim: string | null
      failToRoom: string | null
      wearoffToTarget: string | null
      wearoffToRoom: string | null
    }, ExtArgs["result"]["spellMessage"]>
    composites: {}
  }


  type SpellMessageGetPayload<S extends boolean | null | undefined | SpellMessageDefaultArgs> = $Result.GetResult<Prisma.$SpellMessagePayload, S>

  type SpellMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpellMessageFindManyArgs, 'select' | 'include'> & {
      select?: SpellMessageCountAggregateInputType | true
    }

  export interface SpellMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellMessage'], meta: { name: 'SpellMessage' } }
    /**
     * Find zero or one SpellMessage that matches the filter.
     * @param {SpellMessageFindUniqueArgs} args - Arguments to find a SpellMessage
     * @example
     * // Get one SpellMessage
     * const spellMessage = await prisma.spellMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpellMessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpellMessageFindUniqueArgs<ExtArgs>>
    ): Prisma__SpellMessageClient<$Result.GetResult<Prisma.$SpellMessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpellMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpellMessageFindUniqueOrThrowArgs} args - Arguments to find a SpellMessage
     * @example
     * // Get one SpellMessage
     * const spellMessage = await prisma.spellMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpellMessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellMessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpellMessageClient<$Result.GetResult<Prisma.$SpellMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpellMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellMessageFindFirstArgs} args - Arguments to find a SpellMessage
     * @example
     * // Get one SpellMessage
     * const spellMessage = await prisma.spellMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpellMessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellMessageFindFirstArgs<ExtArgs>>
    ): Prisma__SpellMessageClient<$Result.GetResult<Prisma.$SpellMessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpellMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellMessageFindFirstOrThrowArgs} args - Arguments to find a SpellMessage
     * @example
     * // Get one SpellMessage
     * const spellMessage = await prisma.spellMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpellMessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellMessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpellMessageClient<$Result.GetResult<Prisma.$SpellMessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpellMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellMessages
     * const spellMessages = await prisma.spellMessage.findMany()
     * 
     * // Get first 10 SpellMessages
     * const spellMessages = await prisma.spellMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellMessageWithIdOnly = await prisma.spellMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpellMessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellMessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellMessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpellMessage.
     * @param {SpellMessageCreateArgs} args - Arguments to create a SpellMessage.
     * @example
     * // Create one SpellMessage
     * const SpellMessage = await prisma.spellMessage.create({
     *   data: {
     *     // ... data to create a SpellMessage
     *   }
     * })
     * 
    **/
    create<T extends SpellMessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellMessageCreateArgs<ExtArgs>>
    ): Prisma__SpellMessageClient<$Result.GetResult<Prisma.$SpellMessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpellMessages.
     *     @param {SpellMessageCreateManyArgs} args - Arguments to create many SpellMessages.
     *     @example
     *     // Create many SpellMessages
     *     const spellMessage = await prisma.spellMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpellMessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellMessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellMessage.
     * @param {SpellMessageDeleteArgs} args - Arguments to delete one SpellMessage.
     * @example
     * // Delete one SpellMessage
     * const SpellMessage = await prisma.spellMessage.delete({
     *   where: {
     *     // ... filter to delete one SpellMessage
     *   }
     * })
     * 
    **/
    delete<T extends SpellMessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpellMessageDeleteArgs<ExtArgs>>
    ): Prisma__SpellMessageClient<$Result.GetResult<Prisma.$SpellMessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpellMessage.
     * @param {SpellMessageUpdateArgs} args - Arguments to update one SpellMessage.
     * @example
     * // Update one SpellMessage
     * const spellMessage = await prisma.spellMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpellMessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellMessageUpdateArgs<ExtArgs>>
    ): Prisma__SpellMessageClient<$Result.GetResult<Prisma.$SpellMessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpellMessages.
     * @param {SpellMessageDeleteManyArgs} args - Arguments to filter SpellMessages to delete.
     * @example
     * // Delete a few SpellMessages
     * const { count } = await prisma.spellMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpellMessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellMessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellMessages
     * const spellMessage = await prisma.spellMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpellMessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpellMessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellMessage.
     * @param {SpellMessageUpsertArgs} args - Arguments to update or create a SpellMessage.
     * @example
     * // Update or create a SpellMessage
     * const spellMessage = await prisma.spellMessage.upsert({
     *   create: {
     *     // ... data to create a SpellMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellMessage we want to update
     *   }
     * })
    **/
    upsert<T extends SpellMessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpellMessageUpsertArgs<ExtArgs>>
    ): Prisma__SpellMessageClient<$Result.GetResult<Prisma.$SpellMessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpellMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellMessageCountArgs} args - Arguments to filter SpellMessages to count.
     * @example
     * // Count the number of SpellMessages
     * const count = await prisma.spellMessage.count({
     *   where: {
     *     // ... the filter for the SpellMessages we want to count
     *   }
     * })
    **/
    count<T extends SpellMessageCountArgs>(
      args?: Subset<T, SpellMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellMessageAggregateArgs>(args: Subset<T, SpellMessageAggregateArgs>): Prisma.PrismaPromise<GetSpellMessageAggregateType<T>>

    /**
     * Group by SpellMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellMessageGroupByArgs['orderBy'] }
        : { orderBy?: SpellMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellMessage model
   */
  readonly fields: SpellMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpellMessage model
   */ 
  interface SpellMessageFieldRefs {
    readonly id: FieldRef<"SpellMessage", 'Int'>
    readonly spellId: FieldRef<"SpellMessage", 'Int'>
    readonly startToCaster: FieldRef<"SpellMessage", 'String'>
    readonly startToVictim: FieldRef<"SpellMessage", 'String'>
    readonly startToRoom: FieldRef<"SpellMessage", 'String'>
    readonly successToCaster: FieldRef<"SpellMessage", 'String'>
    readonly successToVictim: FieldRef<"SpellMessage", 'String'>
    readonly successToRoom: FieldRef<"SpellMessage", 'String'>
    readonly failToCaster: FieldRef<"SpellMessage", 'String'>
    readonly failToVictim: FieldRef<"SpellMessage", 'String'>
    readonly failToRoom: FieldRef<"SpellMessage", 'String'>
    readonly wearoffToTarget: FieldRef<"SpellMessage", 'String'>
    readonly wearoffToRoom: FieldRef<"SpellMessage", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SpellMessage findUnique
   */
  export type SpellMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
    /**
     * Filter, which SpellMessage to fetch.
     */
    where: SpellMessageWhereUniqueInput
  }


  /**
   * SpellMessage findUniqueOrThrow
   */
  export type SpellMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
    /**
     * Filter, which SpellMessage to fetch.
     */
    where: SpellMessageWhereUniqueInput
  }


  /**
   * SpellMessage findFirst
   */
  export type SpellMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
    /**
     * Filter, which SpellMessage to fetch.
     */
    where?: SpellMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellMessages to fetch.
     */
    orderBy?: SpellMessageOrderByWithRelationInput | SpellMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellMessages.
     */
    cursor?: SpellMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellMessages.
     */
    distinct?: SpellMessageScalarFieldEnum | SpellMessageScalarFieldEnum[]
  }


  /**
   * SpellMessage findFirstOrThrow
   */
  export type SpellMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
    /**
     * Filter, which SpellMessage to fetch.
     */
    where?: SpellMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellMessages to fetch.
     */
    orderBy?: SpellMessageOrderByWithRelationInput | SpellMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellMessages.
     */
    cursor?: SpellMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellMessages.
     */
    distinct?: SpellMessageScalarFieldEnum | SpellMessageScalarFieldEnum[]
  }


  /**
   * SpellMessage findMany
   */
  export type SpellMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
    /**
     * Filter, which SpellMessages to fetch.
     */
    where?: SpellMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellMessages to fetch.
     */
    orderBy?: SpellMessageOrderByWithRelationInput | SpellMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellMessages.
     */
    cursor?: SpellMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellMessages.
     */
    skip?: number
    distinct?: SpellMessageScalarFieldEnum | SpellMessageScalarFieldEnum[]
  }


  /**
   * SpellMessage create
   */
  export type SpellMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellMessage.
     */
    data: XOR<SpellMessageCreateInput, SpellMessageUncheckedCreateInput>
  }


  /**
   * SpellMessage createMany
   */
  export type SpellMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellMessages.
     */
    data: SpellMessageCreateManyInput | SpellMessageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SpellMessage update
   */
  export type SpellMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellMessage.
     */
    data: XOR<SpellMessageUpdateInput, SpellMessageUncheckedUpdateInput>
    /**
     * Choose, which SpellMessage to update.
     */
    where: SpellMessageWhereUniqueInput
  }


  /**
   * SpellMessage updateMany
   */
  export type SpellMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellMessages.
     */
    data: XOR<SpellMessageUpdateManyMutationInput, SpellMessageUncheckedUpdateManyInput>
    /**
     * Filter which SpellMessages to update
     */
    where?: SpellMessageWhereInput
  }


  /**
   * SpellMessage upsert
   */
  export type SpellMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellMessage to update in case it exists.
     */
    where: SpellMessageWhereUniqueInput
    /**
     * In case the SpellMessage found by the `where` argument doesn't exist, create a new SpellMessage with this data.
     */
    create: XOR<SpellMessageCreateInput, SpellMessageUncheckedCreateInput>
    /**
     * In case the SpellMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellMessageUpdateInput, SpellMessageUncheckedUpdateInput>
  }


  /**
   * SpellMessage delete
   */
  export type SpellMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
    /**
     * Filter which SpellMessage to delete.
     */
    where: SpellMessageWhereUniqueInput
  }


  /**
   * SpellMessage deleteMany
   */
  export type SpellMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellMessages to delete
     */
    where?: SpellMessageWhereInput
  }


  /**
   * SpellMessage without action
   */
  export type SpellMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellMessage
     */
    select?: SpellMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellMessageInclude<ExtArgs> | null
  }



  /**
   * Model SpellComponent
   */

  export type AggregateSpellComponent = {
    _count: SpellComponentCountAggregateOutputType | null
    _avg: SpellComponentAvgAggregateOutputType | null
    _sum: SpellComponentSumAggregateOutputType | null
    _min: SpellComponentMinAggregateOutputType | null
    _max: SpellComponentMaxAggregateOutputType | null
  }

  export type SpellComponentAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    objectId: number | null
  }

  export type SpellComponentSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    objectId: number | null
  }

  export type SpellComponentMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    objectId: number | null
    consumed: boolean | null
    required: boolean | null
  }

  export type SpellComponentMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    objectId: number | null
    consumed: boolean | null
    required: boolean | null
  }

  export type SpellComponentCountAggregateOutputType = {
    id: number
    spellId: number
    objectId: number
    consumed: number
    required: number
    _all: number
  }


  export type SpellComponentAvgAggregateInputType = {
    id?: true
    spellId?: true
    objectId?: true
  }

  export type SpellComponentSumAggregateInputType = {
    id?: true
    spellId?: true
    objectId?: true
  }

  export type SpellComponentMinAggregateInputType = {
    id?: true
    spellId?: true
    objectId?: true
    consumed?: true
    required?: true
  }

  export type SpellComponentMaxAggregateInputType = {
    id?: true
    spellId?: true
    objectId?: true
    consumed?: true
    required?: true
  }

  export type SpellComponentCountAggregateInputType = {
    id?: true
    spellId?: true
    objectId?: true
    consumed?: true
    required?: true
    _all?: true
  }

  export type SpellComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellComponent to aggregate.
     */
    where?: SpellComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellComponents to fetch.
     */
    orderBy?: SpellComponentOrderByWithRelationInput | SpellComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellComponents
    **/
    _count?: true | SpellComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellComponentMaxAggregateInputType
  }

  export type GetSpellComponentAggregateType<T extends SpellComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellComponent[P]>
      : GetScalarType<T[P], AggregateSpellComponent[P]>
  }




  export type SpellComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellComponentWhereInput
    orderBy?: SpellComponentOrderByWithAggregationInput | SpellComponentOrderByWithAggregationInput[]
    by: SpellComponentScalarFieldEnum[] | SpellComponentScalarFieldEnum
    having?: SpellComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellComponentCountAggregateInputType | true
    _avg?: SpellComponentAvgAggregateInputType
    _sum?: SpellComponentSumAggregateInputType
    _min?: SpellComponentMinAggregateInputType
    _max?: SpellComponentMaxAggregateInputType
  }

  export type SpellComponentGroupByOutputType = {
    id: number
    spellId: number
    objectId: number
    consumed: boolean
    required: boolean
    _count: SpellComponentCountAggregateOutputType | null
    _avg: SpellComponentAvgAggregateOutputType | null
    _sum: SpellComponentSumAggregateOutputType | null
    _min: SpellComponentMinAggregateOutputType | null
    _max: SpellComponentMaxAggregateOutputType | null
  }

  type GetSpellComponentGroupByPayload<T extends SpellComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellComponentGroupByOutputType[P]>
            : GetScalarType<T[P], SpellComponentGroupByOutputType[P]>
        }
      >
    >


  export type SpellComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    objectId?: boolean
    consumed?: boolean
    required?: boolean
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellComponent"]>

  export type SpellComponentSelectScalar = {
    id?: boolean
    spellId?: boolean
    objectId?: boolean
    consumed?: boolean
    required?: boolean
  }

  export type SpellComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }


  export type $SpellComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellComponent"
    objects: {
      spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      objectId: number
      consumed: boolean
      required: boolean
    }, ExtArgs["result"]["spellComponent"]>
    composites: {}
  }


  type SpellComponentGetPayload<S extends boolean | null | undefined | SpellComponentDefaultArgs> = $Result.GetResult<Prisma.$SpellComponentPayload, S>

  type SpellComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpellComponentFindManyArgs, 'select' | 'include'> & {
      select?: SpellComponentCountAggregateInputType | true
    }

  export interface SpellComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellComponent'], meta: { name: 'SpellComponent' } }
    /**
     * Find zero or one SpellComponent that matches the filter.
     * @param {SpellComponentFindUniqueArgs} args - Arguments to find a SpellComponent
     * @example
     * // Get one SpellComponent
     * const spellComponent = await prisma.spellComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpellComponentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpellComponentFindUniqueArgs<ExtArgs>>
    ): Prisma__SpellComponentClient<$Result.GetResult<Prisma.$SpellComponentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpellComponent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpellComponentFindUniqueOrThrowArgs} args - Arguments to find a SpellComponent
     * @example
     * // Get one SpellComponent
     * const spellComponent = await prisma.spellComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpellComponentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellComponentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpellComponentClient<$Result.GetResult<Prisma.$SpellComponentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpellComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentFindFirstArgs} args - Arguments to find a SpellComponent
     * @example
     * // Get one SpellComponent
     * const spellComponent = await prisma.spellComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpellComponentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellComponentFindFirstArgs<ExtArgs>>
    ): Prisma__SpellComponentClient<$Result.GetResult<Prisma.$SpellComponentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpellComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentFindFirstOrThrowArgs} args - Arguments to find a SpellComponent
     * @example
     * // Get one SpellComponent
     * const spellComponent = await prisma.spellComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpellComponentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellComponentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpellComponentClient<$Result.GetResult<Prisma.$SpellComponentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpellComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellComponents
     * const spellComponents = await prisma.spellComponent.findMany()
     * 
     * // Get first 10 SpellComponents
     * const spellComponents = await prisma.spellComponent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellComponentWithIdOnly = await prisma.spellComponent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpellComponentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellComponentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellComponentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpellComponent.
     * @param {SpellComponentCreateArgs} args - Arguments to create a SpellComponent.
     * @example
     * // Create one SpellComponent
     * const SpellComponent = await prisma.spellComponent.create({
     *   data: {
     *     // ... data to create a SpellComponent
     *   }
     * })
     * 
    **/
    create<T extends SpellComponentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellComponentCreateArgs<ExtArgs>>
    ): Prisma__SpellComponentClient<$Result.GetResult<Prisma.$SpellComponentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpellComponents.
     *     @param {SpellComponentCreateManyArgs} args - Arguments to create many SpellComponents.
     *     @example
     *     // Create many SpellComponents
     *     const spellComponent = await prisma.spellComponent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpellComponentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellComponentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellComponent.
     * @param {SpellComponentDeleteArgs} args - Arguments to delete one SpellComponent.
     * @example
     * // Delete one SpellComponent
     * const SpellComponent = await prisma.spellComponent.delete({
     *   where: {
     *     // ... filter to delete one SpellComponent
     *   }
     * })
     * 
    **/
    delete<T extends SpellComponentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpellComponentDeleteArgs<ExtArgs>>
    ): Prisma__SpellComponentClient<$Result.GetResult<Prisma.$SpellComponentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpellComponent.
     * @param {SpellComponentUpdateArgs} args - Arguments to update one SpellComponent.
     * @example
     * // Update one SpellComponent
     * const spellComponent = await prisma.spellComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpellComponentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellComponentUpdateArgs<ExtArgs>>
    ): Prisma__SpellComponentClient<$Result.GetResult<Prisma.$SpellComponentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpellComponents.
     * @param {SpellComponentDeleteManyArgs} args - Arguments to filter SpellComponents to delete.
     * @example
     * // Delete a few SpellComponents
     * const { count } = await prisma.spellComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpellComponentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellComponentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellComponents
     * const spellComponent = await prisma.spellComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpellComponentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpellComponentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellComponent.
     * @param {SpellComponentUpsertArgs} args - Arguments to update or create a SpellComponent.
     * @example
     * // Update or create a SpellComponent
     * const spellComponent = await prisma.spellComponent.upsert({
     *   create: {
     *     // ... data to create a SpellComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellComponent we want to update
     *   }
     * })
    **/
    upsert<T extends SpellComponentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpellComponentUpsertArgs<ExtArgs>>
    ): Prisma__SpellComponentClient<$Result.GetResult<Prisma.$SpellComponentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpellComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentCountArgs} args - Arguments to filter SpellComponents to count.
     * @example
     * // Count the number of SpellComponents
     * const count = await prisma.spellComponent.count({
     *   where: {
     *     // ... the filter for the SpellComponents we want to count
     *   }
     * })
    **/
    count<T extends SpellComponentCountArgs>(
      args?: Subset<T, SpellComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellComponentAggregateArgs>(args: Subset<T, SpellComponentAggregateArgs>): Prisma.PrismaPromise<GetSpellComponentAggregateType<T>>

    /**
     * Group by SpellComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellComponentGroupByArgs['orderBy'] }
        : { orderBy?: SpellComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellComponent model
   */
  readonly fields: SpellComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpellComponent model
   */ 
  interface SpellComponentFieldRefs {
    readonly id: FieldRef<"SpellComponent", 'Int'>
    readonly spellId: FieldRef<"SpellComponent", 'Int'>
    readonly objectId: FieldRef<"SpellComponent", 'Int'>
    readonly consumed: FieldRef<"SpellComponent", 'Boolean'>
    readonly required: FieldRef<"SpellComponent", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * SpellComponent findUnique
   */
  export type SpellComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
    /**
     * Filter, which SpellComponent to fetch.
     */
    where: SpellComponentWhereUniqueInput
  }


  /**
   * SpellComponent findUniqueOrThrow
   */
  export type SpellComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
    /**
     * Filter, which SpellComponent to fetch.
     */
    where: SpellComponentWhereUniqueInput
  }


  /**
   * SpellComponent findFirst
   */
  export type SpellComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
    /**
     * Filter, which SpellComponent to fetch.
     */
    where?: SpellComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellComponents to fetch.
     */
    orderBy?: SpellComponentOrderByWithRelationInput | SpellComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellComponents.
     */
    cursor?: SpellComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellComponents.
     */
    distinct?: SpellComponentScalarFieldEnum | SpellComponentScalarFieldEnum[]
  }


  /**
   * SpellComponent findFirstOrThrow
   */
  export type SpellComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
    /**
     * Filter, which SpellComponent to fetch.
     */
    where?: SpellComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellComponents to fetch.
     */
    orderBy?: SpellComponentOrderByWithRelationInput | SpellComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellComponents.
     */
    cursor?: SpellComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellComponents.
     */
    distinct?: SpellComponentScalarFieldEnum | SpellComponentScalarFieldEnum[]
  }


  /**
   * SpellComponent findMany
   */
  export type SpellComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
    /**
     * Filter, which SpellComponents to fetch.
     */
    where?: SpellComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellComponents to fetch.
     */
    orderBy?: SpellComponentOrderByWithRelationInput | SpellComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellComponents.
     */
    cursor?: SpellComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellComponents.
     */
    skip?: number
    distinct?: SpellComponentScalarFieldEnum | SpellComponentScalarFieldEnum[]
  }


  /**
   * SpellComponent create
   */
  export type SpellComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellComponent.
     */
    data: XOR<SpellComponentCreateInput, SpellComponentUncheckedCreateInput>
  }


  /**
   * SpellComponent createMany
   */
  export type SpellComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellComponents.
     */
    data: SpellComponentCreateManyInput | SpellComponentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SpellComponent update
   */
  export type SpellComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellComponent.
     */
    data: XOR<SpellComponentUpdateInput, SpellComponentUncheckedUpdateInput>
    /**
     * Choose, which SpellComponent to update.
     */
    where: SpellComponentWhereUniqueInput
  }


  /**
   * SpellComponent updateMany
   */
  export type SpellComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellComponents.
     */
    data: XOR<SpellComponentUpdateManyMutationInput, SpellComponentUncheckedUpdateManyInput>
    /**
     * Filter which SpellComponents to update
     */
    where?: SpellComponentWhereInput
  }


  /**
   * SpellComponent upsert
   */
  export type SpellComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellComponent to update in case it exists.
     */
    where: SpellComponentWhereUniqueInput
    /**
     * In case the SpellComponent found by the `where` argument doesn't exist, create a new SpellComponent with this data.
     */
    create: XOR<SpellComponentCreateInput, SpellComponentUncheckedCreateInput>
    /**
     * In case the SpellComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellComponentUpdateInput, SpellComponentUncheckedUpdateInput>
  }


  /**
   * SpellComponent delete
   */
  export type SpellComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
    /**
     * Filter which SpellComponent to delete.
     */
    where: SpellComponentWhereUniqueInput
  }


  /**
   * SpellComponent deleteMany
   */
  export type SpellComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellComponents to delete
     */
    where?: SpellComponentWhereInput
  }


  /**
   * SpellComponent without action
   */
  export type SpellComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellComponent
     */
    select?: SpellComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellComponentInclude<ExtArgs> | null
  }



  /**
   * Model SpellRestriction
   */

  export type AggregateSpellRestriction = {
    _count: SpellRestrictionCountAggregateOutputType | null
    _avg: SpellRestrictionAvgAggregateOutputType | null
    _sum: SpellRestrictionSumAggregateOutputType | null
    _min: SpellRestrictionMinAggregateOutputType | null
    _max: SpellRestrictionMaxAggregateOutputType | null
  }

  export type SpellRestrictionAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    noTeleportFlagsMask: number | null
    terrainMask: number | null
    disallowStatesMask: number | null
  }

  export type SpellRestrictionSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    noTeleportFlagsMask: number | null
    terrainMask: number | null
    disallowStatesMask: number | null
  }

  export type SpellRestrictionMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    indoorsOnly: boolean | null
    outdoorsOnly: boolean | null
    noSafeRooms: boolean | null
    noTeleportFlagsMask: number | null
    terrainMask: number | null
    disallowStatesMask: number | null
  }

  export type SpellRestrictionMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    indoorsOnly: boolean | null
    outdoorsOnly: boolean | null
    noSafeRooms: boolean | null
    noTeleportFlagsMask: number | null
    terrainMask: number | null
    disallowStatesMask: number | null
  }

  export type SpellRestrictionCountAggregateOutputType = {
    id: number
    spellId: number
    indoorsOnly: number
    outdoorsOnly: number
    noSafeRooms: number
    noTeleportFlagsMask: number
    terrainMask: number
    disallowStatesMask: number
    _all: number
  }


  export type SpellRestrictionAvgAggregateInputType = {
    id?: true
    spellId?: true
    noTeleportFlagsMask?: true
    terrainMask?: true
    disallowStatesMask?: true
  }

  export type SpellRestrictionSumAggregateInputType = {
    id?: true
    spellId?: true
    noTeleportFlagsMask?: true
    terrainMask?: true
    disallowStatesMask?: true
  }

  export type SpellRestrictionMinAggregateInputType = {
    id?: true
    spellId?: true
    indoorsOnly?: true
    outdoorsOnly?: true
    noSafeRooms?: true
    noTeleportFlagsMask?: true
    terrainMask?: true
    disallowStatesMask?: true
  }

  export type SpellRestrictionMaxAggregateInputType = {
    id?: true
    spellId?: true
    indoorsOnly?: true
    outdoorsOnly?: true
    noSafeRooms?: true
    noTeleportFlagsMask?: true
    terrainMask?: true
    disallowStatesMask?: true
  }

  export type SpellRestrictionCountAggregateInputType = {
    id?: true
    spellId?: true
    indoorsOnly?: true
    outdoorsOnly?: true
    noSafeRooms?: true
    noTeleportFlagsMask?: true
    terrainMask?: true
    disallowStatesMask?: true
    _all?: true
  }

  export type SpellRestrictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellRestriction to aggregate.
     */
    where?: SpellRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellRestrictions to fetch.
     */
    orderBy?: SpellRestrictionOrderByWithRelationInput | SpellRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellRestrictions
    **/
    _count?: true | SpellRestrictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellRestrictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellRestrictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellRestrictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellRestrictionMaxAggregateInputType
  }

  export type GetSpellRestrictionAggregateType<T extends SpellRestrictionAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellRestriction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellRestriction[P]>
      : GetScalarType<T[P], AggregateSpellRestriction[P]>
  }




  export type SpellRestrictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellRestrictionWhereInput
    orderBy?: SpellRestrictionOrderByWithAggregationInput | SpellRestrictionOrderByWithAggregationInput[]
    by: SpellRestrictionScalarFieldEnum[] | SpellRestrictionScalarFieldEnum
    having?: SpellRestrictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellRestrictionCountAggregateInputType | true
    _avg?: SpellRestrictionAvgAggregateInputType
    _sum?: SpellRestrictionSumAggregateInputType
    _min?: SpellRestrictionMinAggregateInputType
    _max?: SpellRestrictionMaxAggregateInputType
  }

  export type SpellRestrictionGroupByOutputType = {
    id: number
    spellId: number
    indoorsOnly: boolean
    outdoorsOnly: boolean
    noSafeRooms: boolean
    noTeleportFlagsMask: number | null
    terrainMask: number | null
    disallowStatesMask: number | null
    _count: SpellRestrictionCountAggregateOutputType | null
    _avg: SpellRestrictionAvgAggregateOutputType | null
    _sum: SpellRestrictionSumAggregateOutputType | null
    _min: SpellRestrictionMinAggregateOutputType | null
    _max: SpellRestrictionMaxAggregateOutputType | null
  }

  type GetSpellRestrictionGroupByPayload<T extends SpellRestrictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellRestrictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellRestrictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellRestrictionGroupByOutputType[P]>
            : GetScalarType<T[P], SpellRestrictionGroupByOutputType[P]>
        }
      >
    >


  export type SpellRestrictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    indoorsOnly?: boolean
    outdoorsOnly?: boolean
    noSafeRooms?: boolean
    noTeleportFlagsMask?: boolean
    terrainMask?: boolean
    disallowStatesMask?: boolean
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellRestriction"]>

  export type SpellRestrictionSelectScalar = {
    id?: boolean
    spellId?: boolean
    indoorsOnly?: boolean
    outdoorsOnly?: boolean
    noSafeRooms?: boolean
    noTeleportFlagsMask?: boolean
    terrainMask?: boolean
    disallowStatesMask?: boolean
  }

  export type SpellRestrictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }


  export type $SpellRestrictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellRestriction"
    objects: {
      spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      indoorsOnly: boolean
      outdoorsOnly: boolean
      noSafeRooms: boolean
      noTeleportFlagsMask: number | null
      terrainMask: number | null
      disallowStatesMask: number | null
    }, ExtArgs["result"]["spellRestriction"]>
    composites: {}
  }


  type SpellRestrictionGetPayload<S extends boolean | null | undefined | SpellRestrictionDefaultArgs> = $Result.GetResult<Prisma.$SpellRestrictionPayload, S>

  type SpellRestrictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpellRestrictionFindManyArgs, 'select' | 'include'> & {
      select?: SpellRestrictionCountAggregateInputType | true
    }

  export interface SpellRestrictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellRestriction'], meta: { name: 'SpellRestriction' } }
    /**
     * Find zero or one SpellRestriction that matches the filter.
     * @param {SpellRestrictionFindUniqueArgs} args - Arguments to find a SpellRestriction
     * @example
     * // Get one SpellRestriction
     * const spellRestriction = await prisma.spellRestriction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpellRestrictionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpellRestrictionFindUniqueArgs<ExtArgs>>
    ): Prisma__SpellRestrictionClient<$Result.GetResult<Prisma.$SpellRestrictionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpellRestriction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpellRestrictionFindUniqueOrThrowArgs} args - Arguments to find a SpellRestriction
     * @example
     * // Get one SpellRestriction
     * const spellRestriction = await prisma.spellRestriction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpellRestrictionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellRestrictionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpellRestrictionClient<$Result.GetResult<Prisma.$SpellRestrictionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpellRestriction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRestrictionFindFirstArgs} args - Arguments to find a SpellRestriction
     * @example
     * // Get one SpellRestriction
     * const spellRestriction = await prisma.spellRestriction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpellRestrictionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellRestrictionFindFirstArgs<ExtArgs>>
    ): Prisma__SpellRestrictionClient<$Result.GetResult<Prisma.$SpellRestrictionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpellRestriction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRestrictionFindFirstOrThrowArgs} args - Arguments to find a SpellRestriction
     * @example
     * // Get one SpellRestriction
     * const spellRestriction = await prisma.spellRestriction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpellRestrictionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellRestrictionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpellRestrictionClient<$Result.GetResult<Prisma.$SpellRestrictionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpellRestrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRestrictionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellRestrictions
     * const spellRestrictions = await prisma.spellRestriction.findMany()
     * 
     * // Get first 10 SpellRestrictions
     * const spellRestrictions = await prisma.spellRestriction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellRestrictionWithIdOnly = await prisma.spellRestriction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpellRestrictionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellRestrictionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellRestrictionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpellRestriction.
     * @param {SpellRestrictionCreateArgs} args - Arguments to create a SpellRestriction.
     * @example
     * // Create one SpellRestriction
     * const SpellRestriction = await prisma.spellRestriction.create({
     *   data: {
     *     // ... data to create a SpellRestriction
     *   }
     * })
     * 
    **/
    create<T extends SpellRestrictionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellRestrictionCreateArgs<ExtArgs>>
    ): Prisma__SpellRestrictionClient<$Result.GetResult<Prisma.$SpellRestrictionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpellRestrictions.
     *     @param {SpellRestrictionCreateManyArgs} args - Arguments to create many SpellRestrictions.
     *     @example
     *     // Create many SpellRestrictions
     *     const spellRestriction = await prisma.spellRestriction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpellRestrictionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellRestrictionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellRestriction.
     * @param {SpellRestrictionDeleteArgs} args - Arguments to delete one SpellRestriction.
     * @example
     * // Delete one SpellRestriction
     * const SpellRestriction = await prisma.spellRestriction.delete({
     *   where: {
     *     // ... filter to delete one SpellRestriction
     *   }
     * })
     * 
    **/
    delete<T extends SpellRestrictionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpellRestrictionDeleteArgs<ExtArgs>>
    ): Prisma__SpellRestrictionClient<$Result.GetResult<Prisma.$SpellRestrictionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpellRestriction.
     * @param {SpellRestrictionUpdateArgs} args - Arguments to update one SpellRestriction.
     * @example
     * // Update one SpellRestriction
     * const spellRestriction = await prisma.spellRestriction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpellRestrictionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellRestrictionUpdateArgs<ExtArgs>>
    ): Prisma__SpellRestrictionClient<$Result.GetResult<Prisma.$SpellRestrictionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpellRestrictions.
     * @param {SpellRestrictionDeleteManyArgs} args - Arguments to filter SpellRestrictions to delete.
     * @example
     * // Delete a few SpellRestrictions
     * const { count } = await prisma.spellRestriction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpellRestrictionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellRestrictionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRestrictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellRestrictions
     * const spellRestriction = await prisma.spellRestriction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpellRestrictionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpellRestrictionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellRestriction.
     * @param {SpellRestrictionUpsertArgs} args - Arguments to update or create a SpellRestriction.
     * @example
     * // Update or create a SpellRestriction
     * const spellRestriction = await prisma.spellRestriction.upsert({
     *   create: {
     *     // ... data to create a SpellRestriction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellRestriction we want to update
     *   }
     * })
    **/
    upsert<T extends SpellRestrictionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpellRestrictionUpsertArgs<ExtArgs>>
    ): Prisma__SpellRestrictionClient<$Result.GetResult<Prisma.$SpellRestrictionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpellRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRestrictionCountArgs} args - Arguments to filter SpellRestrictions to count.
     * @example
     * // Count the number of SpellRestrictions
     * const count = await prisma.spellRestriction.count({
     *   where: {
     *     // ... the filter for the SpellRestrictions we want to count
     *   }
     * })
    **/
    count<T extends SpellRestrictionCountArgs>(
      args?: Subset<T, SpellRestrictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellRestrictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellRestriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRestrictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellRestrictionAggregateArgs>(args: Subset<T, SpellRestrictionAggregateArgs>): Prisma.PrismaPromise<GetSpellRestrictionAggregateType<T>>

    /**
     * Group by SpellRestriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellRestrictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellRestrictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellRestrictionGroupByArgs['orderBy'] }
        : { orderBy?: SpellRestrictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellRestrictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellRestrictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellRestriction model
   */
  readonly fields: SpellRestrictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellRestriction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellRestrictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpellRestriction model
   */ 
  interface SpellRestrictionFieldRefs {
    readonly id: FieldRef<"SpellRestriction", 'Int'>
    readonly spellId: FieldRef<"SpellRestriction", 'Int'>
    readonly indoorsOnly: FieldRef<"SpellRestriction", 'Boolean'>
    readonly outdoorsOnly: FieldRef<"SpellRestriction", 'Boolean'>
    readonly noSafeRooms: FieldRef<"SpellRestriction", 'Boolean'>
    readonly noTeleportFlagsMask: FieldRef<"SpellRestriction", 'Int'>
    readonly terrainMask: FieldRef<"SpellRestriction", 'Int'>
    readonly disallowStatesMask: FieldRef<"SpellRestriction", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SpellRestriction findUnique
   */
  export type SpellRestrictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which SpellRestriction to fetch.
     */
    where: SpellRestrictionWhereUniqueInput
  }


  /**
   * SpellRestriction findUniqueOrThrow
   */
  export type SpellRestrictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which SpellRestriction to fetch.
     */
    where: SpellRestrictionWhereUniqueInput
  }


  /**
   * SpellRestriction findFirst
   */
  export type SpellRestrictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which SpellRestriction to fetch.
     */
    where?: SpellRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellRestrictions to fetch.
     */
    orderBy?: SpellRestrictionOrderByWithRelationInput | SpellRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellRestrictions.
     */
    cursor?: SpellRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellRestrictions.
     */
    distinct?: SpellRestrictionScalarFieldEnum | SpellRestrictionScalarFieldEnum[]
  }


  /**
   * SpellRestriction findFirstOrThrow
   */
  export type SpellRestrictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which SpellRestriction to fetch.
     */
    where?: SpellRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellRestrictions to fetch.
     */
    orderBy?: SpellRestrictionOrderByWithRelationInput | SpellRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellRestrictions.
     */
    cursor?: SpellRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellRestrictions.
     */
    distinct?: SpellRestrictionScalarFieldEnum | SpellRestrictionScalarFieldEnum[]
  }


  /**
   * SpellRestriction findMany
   */
  export type SpellRestrictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which SpellRestrictions to fetch.
     */
    where?: SpellRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellRestrictions to fetch.
     */
    orderBy?: SpellRestrictionOrderByWithRelationInput | SpellRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellRestrictions.
     */
    cursor?: SpellRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellRestrictions.
     */
    skip?: number
    distinct?: SpellRestrictionScalarFieldEnum | SpellRestrictionScalarFieldEnum[]
  }


  /**
   * SpellRestriction create
   */
  export type SpellRestrictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellRestriction.
     */
    data: XOR<SpellRestrictionCreateInput, SpellRestrictionUncheckedCreateInput>
  }


  /**
   * SpellRestriction createMany
   */
  export type SpellRestrictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellRestrictions.
     */
    data: SpellRestrictionCreateManyInput | SpellRestrictionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SpellRestriction update
   */
  export type SpellRestrictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellRestriction.
     */
    data: XOR<SpellRestrictionUpdateInput, SpellRestrictionUncheckedUpdateInput>
    /**
     * Choose, which SpellRestriction to update.
     */
    where: SpellRestrictionWhereUniqueInput
  }


  /**
   * SpellRestriction updateMany
   */
  export type SpellRestrictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellRestrictions.
     */
    data: XOR<SpellRestrictionUpdateManyMutationInput, SpellRestrictionUncheckedUpdateManyInput>
    /**
     * Filter which SpellRestrictions to update
     */
    where?: SpellRestrictionWhereInput
  }


  /**
   * SpellRestriction upsert
   */
  export type SpellRestrictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellRestriction to update in case it exists.
     */
    where: SpellRestrictionWhereUniqueInput
    /**
     * In case the SpellRestriction found by the `where` argument doesn't exist, create a new SpellRestriction with this data.
     */
    create: XOR<SpellRestrictionCreateInput, SpellRestrictionUncheckedCreateInput>
    /**
     * In case the SpellRestriction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellRestrictionUpdateInput, SpellRestrictionUncheckedUpdateInput>
  }


  /**
   * SpellRestriction delete
   */
  export type SpellRestrictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
    /**
     * Filter which SpellRestriction to delete.
     */
    where: SpellRestrictionWhereUniqueInput
  }


  /**
   * SpellRestriction deleteMany
   */
  export type SpellRestrictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellRestrictions to delete
     */
    where?: SpellRestrictionWhereInput
  }


  /**
   * SpellRestriction without action
   */
  export type SpellRestrictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellRestriction
     */
    select?: SpellRestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellRestrictionInclude<ExtArgs> | null
  }



  /**
   * Model SpellEffect
   */

  export type AggregateSpellEffect = {
    _count: SpellEffectCountAggregateOutputType | null
    _avg: SpellEffectAvgAggregateOutputType | null
    _sum: SpellEffectSumAggregateOutputType | null
    _min: SpellEffectMinAggregateOutputType | null
    _max: SpellEffectMaxAggregateOutputType | null
  }

  export type SpellEffectAvgAggregateOutputType = {
    id: number | null
    spellId: number | null
    order: number | null
    chancePct: number | null
  }

  export type SpellEffectSumAggregateOutputType = {
    id: number | null
    spellId: number | null
    order: number | null
    chancePct: number | null
  }

  export type SpellEffectMinAggregateOutputType = {
    id: number | null
    spellId: number | null
    effectType: $Enums.EffectType | null
    order: number | null
    chancePct: number | null
    trigger: $Enums.EffectTrigger | null
    durationFormula: string | null
    stackingRule: $Enums.StackingRule | null
  }

  export type SpellEffectMaxAggregateOutputType = {
    id: number | null
    spellId: number | null
    effectType: $Enums.EffectType | null
    order: number | null
    chancePct: number | null
    trigger: $Enums.EffectTrigger | null
    durationFormula: string | null
    stackingRule: $Enums.StackingRule | null
  }

  export type SpellEffectCountAggregateOutputType = {
    id: number
    spellId: number
    effectType: number
    order: number
    chancePct: number
    trigger: number
    durationFormula: number
    stackingRule: number
    conditionFilter: number
    params: number
    _all: number
  }


  export type SpellEffectAvgAggregateInputType = {
    id?: true
    spellId?: true
    order?: true
    chancePct?: true
  }

  export type SpellEffectSumAggregateInputType = {
    id?: true
    spellId?: true
    order?: true
    chancePct?: true
  }

  export type SpellEffectMinAggregateInputType = {
    id?: true
    spellId?: true
    effectType?: true
    order?: true
    chancePct?: true
    trigger?: true
    durationFormula?: true
    stackingRule?: true
  }

  export type SpellEffectMaxAggregateInputType = {
    id?: true
    spellId?: true
    effectType?: true
    order?: true
    chancePct?: true
    trigger?: true
    durationFormula?: true
    stackingRule?: true
  }

  export type SpellEffectCountAggregateInputType = {
    id?: true
    spellId?: true
    effectType?: true
    order?: true
    chancePct?: true
    trigger?: true
    durationFormula?: true
    stackingRule?: true
    conditionFilter?: true
    params?: true
    _all?: true
  }

  export type SpellEffectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellEffect to aggregate.
     */
    where?: SpellEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellEffects to fetch.
     */
    orderBy?: SpellEffectOrderByWithRelationInput | SpellEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpellEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpellEffects
    **/
    _count?: true | SpellEffectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpellEffectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpellEffectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpellEffectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpellEffectMaxAggregateInputType
  }

  export type GetSpellEffectAggregateType<T extends SpellEffectAggregateArgs> = {
        [P in keyof T & keyof AggregateSpellEffect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpellEffect[P]>
      : GetScalarType<T[P], AggregateSpellEffect[P]>
  }




  export type SpellEffectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpellEffectWhereInput
    orderBy?: SpellEffectOrderByWithAggregationInput | SpellEffectOrderByWithAggregationInput[]
    by: SpellEffectScalarFieldEnum[] | SpellEffectScalarFieldEnum
    having?: SpellEffectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpellEffectCountAggregateInputType | true
    _avg?: SpellEffectAvgAggregateInputType
    _sum?: SpellEffectSumAggregateInputType
    _min?: SpellEffectMinAggregateInputType
    _max?: SpellEffectMaxAggregateInputType
  }

  export type SpellEffectGroupByOutputType = {
    id: number
    spellId: number
    effectType: $Enums.EffectType
    order: number
    chancePct: number
    trigger: $Enums.EffectTrigger | null
    durationFormula: string | null
    stackingRule: $Enums.StackingRule
    conditionFilter: JsonValue | null
    params: JsonValue
    _count: SpellEffectCountAggregateOutputType | null
    _avg: SpellEffectAvgAggregateOutputType | null
    _sum: SpellEffectSumAggregateOutputType | null
    _min: SpellEffectMinAggregateOutputType | null
    _max: SpellEffectMaxAggregateOutputType | null
  }

  type GetSpellEffectGroupByPayload<T extends SpellEffectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpellEffectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpellEffectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpellEffectGroupByOutputType[P]>
            : GetScalarType<T[P], SpellEffectGroupByOutputType[P]>
        }
      >
    >


  export type SpellEffectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spellId?: boolean
    effectType?: boolean
    order?: boolean
    chancePct?: boolean
    trigger?: boolean
    durationFormula?: boolean
    stackingRule?: boolean
    conditionFilter?: boolean
    params?: boolean
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spellEffect"]>

  export type SpellEffectSelectScalar = {
    id?: boolean
    spellId?: boolean
    effectType?: boolean
    order?: boolean
    chancePct?: boolean
    trigger?: boolean
    durationFormula?: boolean
    stackingRule?: boolean
    conditionFilter?: boolean
    params?: boolean
  }

  export type SpellEffectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }


  export type $SpellEffectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpellEffect"
    objects: {
      spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      spellId: number
      effectType: $Enums.EffectType
      order: number
      chancePct: number
      trigger: $Enums.EffectTrigger | null
      durationFormula: string | null
      stackingRule: $Enums.StackingRule
      conditionFilter: Prisma.JsonValue | null
      params: Prisma.JsonValue
    }, ExtArgs["result"]["spellEffect"]>
    composites: {}
  }


  type SpellEffectGetPayload<S extends boolean | null | undefined | SpellEffectDefaultArgs> = $Result.GetResult<Prisma.$SpellEffectPayload, S>

  type SpellEffectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpellEffectFindManyArgs, 'select' | 'include'> & {
      select?: SpellEffectCountAggregateInputType | true
    }

  export interface SpellEffectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpellEffect'], meta: { name: 'SpellEffect' } }
    /**
     * Find zero or one SpellEffect that matches the filter.
     * @param {SpellEffectFindUniqueArgs} args - Arguments to find a SpellEffect
     * @example
     * // Get one SpellEffect
     * const spellEffect = await prisma.spellEffect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpellEffectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpellEffectFindUniqueArgs<ExtArgs>>
    ): Prisma__SpellEffectClient<$Result.GetResult<Prisma.$SpellEffectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpellEffect that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpellEffectFindUniqueOrThrowArgs} args - Arguments to find a SpellEffect
     * @example
     * // Get one SpellEffect
     * const spellEffect = await prisma.spellEffect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpellEffectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellEffectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpellEffectClient<$Result.GetResult<Prisma.$SpellEffectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpellEffect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellEffectFindFirstArgs} args - Arguments to find a SpellEffect
     * @example
     * // Get one SpellEffect
     * const spellEffect = await prisma.spellEffect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpellEffectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellEffectFindFirstArgs<ExtArgs>>
    ): Prisma__SpellEffectClient<$Result.GetResult<Prisma.$SpellEffectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpellEffect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellEffectFindFirstOrThrowArgs} args - Arguments to find a SpellEffect
     * @example
     * // Get one SpellEffect
     * const spellEffect = await prisma.spellEffect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpellEffectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellEffectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpellEffectClient<$Result.GetResult<Prisma.$SpellEffectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpellEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellEffectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpellEffects
     * const spellEffects = await prisma.spellEffect.findMany()
     * 
     * // Get first 10 SpellEffects
     * const spellEffects = await prisma.spellEffect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spellEffectWithIdOnly = await prisma.spellEffect.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpellEffectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellEffectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpellEffectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpellEffect.
     * @param {SpellEffectCreateArgs} args - Arguments to create a SpellEffect.
     * @example
     * // Create one SpellEffect
     * const SpellEffect = await prisma.spellEffect.create({
     *   data: {
     *     // ... data to create a SpellEffect
     *   }
     * })
     * 
    **/
    create<T extends SpellEffectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellEffectCreateArgs<ExtArgs>>
    ): Prisma__SpellEffectClient<$Result.GetResult<Prisma.$SpellEffectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpellEffects.
     *     @param {SpellEffectCreateManyArgs} args - Arguments to create many SpellEffects.
     *     @example
     *     // Create many SpellEffects
     *     const spellEffect = await prisma.spellEffect.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpellEffectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellEffectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpellEffect.
     * @param {SpellEffectDeleteArgs} args - Arguments to delete one SpellEffect.
     * @example
     * // Delete one SpellEffect
     * const SpellEffect = await prisma.spellEffect.delete({
     *   where: {
     *     // ... filter to delete one SpellEffect
     *   }
     * })
     * 
    **/
    delete<T extends SpellEffectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpellEffectDeleteArgs<ExtArgs>>
    ): Prisma__SpellEffectClient<$Result.GetResult<Prisma.$SpellEffectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpellEffect.
     * @param {SpellEffectUpdateArgs} args - Arguments to update one SpellEffect.
     * @example
     * // Update one SpellEffect
     * const spellEffect = await prisma.spellEffect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpellEffectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpellEffectUpdateArgs<ExtArgs>>
    ): Prisma__SpellEffectClient<$Result.GetResult<Prisma.$SpellEffectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpellEffects.
     * @param {SpellEffectDeleteManyArgs} args - Arguments to filter SpellEffects to delete.
     * @example
     * // Delete a few SpellEffects
     * const { count } = await prisma.spellEffect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpellEffectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpellEffectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpellEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellEffectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpellEffects
     * const spellEffect = await prisma.spellEffect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpellEffectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpellEffectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpellEffect.
     * @param {SpellEffectUpsertArgs} args - Arguments to update or create a SpellEffect.
     * @example
     * // Update or create a SpellEffect
     * const spellEffect = await prisma.spellEffect.upsert({
     *   create: {
     *     // ... data to create a SpellEffect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpellEffect we want to update
     *   }
     * })
    **/
    upsert<T extends SpellEffectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpellEffectUpsertArgs<ExtArgs>>
    ): Prisma__SpellEffectClient<$Result.GetResult<Prisma.$SpellEffectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpellEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellEffectCountArgs} args - Arguments to filter SpellEffects to count.
     * @example
     * // Count the number of SpellEffects
     * const count = await prisma.spellEffect.count({
     *   where: {
     *     // ... the filter for the SpellEffects we want to count
     *   }
     * })
    **/
    count<T extends SpellEffectCountArgs>(
      args?: Subset<T, SpellEffectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpellEffectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpellEffect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellEffectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpellEffectAggregateArgs>(args: Subset<T, SpellEffectAggregateArgs>): Prisma.PrismaPromise<GetSpellEffectAggregateType<T>>

    /**
     * Group by SpellEffect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpellEffectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpellEffectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpellEffectGroupByArgs['orderBy'] }
        : { orderBy?: SpellEffectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpellEffectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpellEffectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpellEffect model
   */
  readonly fields: SpellEffectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpellEffect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpellEffectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpellEffect model
   */ 
  interface SpellEffectFieldRefs {
    readonly id: FieldRef<"SpellEffect", 'Int'>
    readonly spellId: FieldRef<"SpellEffect", 'Int'>
    readonly effectType: FieldRef<"SpellEffect", 'EffectType'>
    readonly order: FieldRef<"SpellEffect", 'Int'>
    readonly chancePct: FieldRef<"SpellEffect", 'Int'>
    readonly trigger: FieldRef<"SpellEffect", 'EffectTrigger'>
    readonly durationFormula: FieldRef<"SpellEffect", 'String'>
    readonly stackingRule: FieldRef<"SpellEffect", 'StackingRule'>
    readonly conditionFilter: FieldRef<"SpellEffect", 'Json'>
    readonly params: FieldRef<"SpellEffect", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * SpellEffect findUnique
   */
  export type SpellEffectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
    /**
     * Filter, which SpellEffect to fetch.
     */
    where: SpellEffectWhereUniqueInput
  }


  /**
   * SpellEffect findUniqueOrThrow
   */
  export type SpellEffectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
    /**
     * Filter, which SpellEffect to fetch.
     */
    where: SpellEffectWhereUniqueInput
  }


  /**
   * SpellEffect findFirst
   */
  export type SpellEffectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
    /**
     * Filter, which SpellEffect to fetch.
     */
    where?: SpellEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellEffects to fetch.
     */
    orderBy?: SpellEffectOrderByWithRelationInput | SpellEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellEffects.
     */
    cursor?: SpellEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellEffects.
     */
    distinct?: SpellEffectScalarFieldEnum | SpellEffectScalarFieldEnum[]
  }


  /**
   * SpellEffect findFirstOrThrow
   */
  export type SpellEffectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
    /**
     * Filter, which SpellEffect to fetch.
     */
    where?: SpellEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellEffects to fetch.
     */
    orderBy?: SpellEffectOrderByWithRelationInput | SpellEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpellEffects.
     */
    cursor?: SpellEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpellEffects.
     */
    distinct?: SpellEffectScalarFieldEnum | SpellEffectScalarFieldEnum[]
  }


  /**
   * SpellEffect findMany
   */
  export type SpellEffectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
    /**
     * Filter, which SpellEffects to fetch.
     */
    where?: SpellEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpellEffects to fetch.
     */
    orderBy?: SpellEffectOrderByWithRelationInput | SpellEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpellEffects.
     */
    cursor?: SpellEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpellEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpellEffects.
     */
    skip?: number
    distinct?: SpellEffectScalarFieldEnum | SpellEffectScalarFieldEnum[]
  }


  /**
   * SpellEffect create
   */
  export type SpellEffectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
    /**
     * The data needed to create a SpellEffect.
     */
    data: XOR<SpellEffectCreateInput, SpellEffectUncheckedCreateInput>
  }


  /**
   * SpellEffect createMany
   */
  export type SpellEffectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpellEffects.
     */
    data: SpellEffectCreateManyInput | SpellEffectCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SpellEffect update
   */
  export type SpellEffectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
    /**
     * The data needed to update a SpellEffect.
     */
    data: XOR<SpellEffectUpdateInput, SpellEffectUncheckedUpdateInput>
    /**
     * Choose, which SpellEffect to update.
     */
    where: SpellEffectWhereUniqueInput
  }


  /**
   * SpellEffect updateMany
   */
  export type SpellEffectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpellEffects.
     */
    data: XOR<SpellEffectUpdateManyMutationInput, SpellEffectUncheckedUpdateManyInput>
    /**
     * Filter which SpellEffects to update
     */
    where?: SpellEffectWhereInput
  }


  /**
   * SpellEffect upsert
   */
  export type SpellEffectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
    /**
     * The filter to search for the SpellEffect to update in case it exists.
     */
    where: SpellEffectWhereUniqueInput
    /**
     * In case the SpellEffect found by the `where` argument doesn't exist, create a new SpellEffect with this data.
     */
    create: XOR<SpellEffectCreateInput, SpellEffectUncheckedCreateInput>
    /**
     * In case the SpellEffect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpellEffectUpdateInput, SpellEffectUncheckedUpdateInput>
  }


  /**
   * SpellEffect delete
   */
  export type SpellEffectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
    /**
     * Filter which SpellEffect to delete.
     */
    where: SpellEffectWhereUniqueInput
  }


  /**
   * SpellEffect deleteMany
   */
  export type SpellEffectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpellEffects to delete
     */
    where?: SpellEffectWhereInput
  }


  /**
   * SpellEffect without action
   */
  export type SpellEffectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpellEffect
     */
    select?: SpellEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpellEffectInclude<ExtArgs> | null
  }



  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    id: number | null
    maxLevel: number | null
  }

  export type SkillSumAggregateOutputType = {
    id: number | null
    maxLevel: number | null
  }

  export type SkillMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: $Enums.SkillType | null
    category: $Enums.SkillCategory | null
    maxLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: $Enums.SkillType | null
    category: $Enums.SkillCategory | null
    maxLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    category: number
    maxLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    id?: true
    maxLevel?: true
  }

  export type SkillSumAggregateInputType = {
    id?: true
    maxLevel?: true
  }

  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    category?: true
    maxLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    category?: true
    maxLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    category?: true
    maxLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: number
    name: string
    description: string | null
    type: $Enums.SkillType
    category: $Enums.SkillCategory
    maxLevel: number
    createdAt: Date
    updatedAt: Date
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    maxLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characterSkills?: boolean | Skill$characterSkillsArgs<ExtArgs>
    classSkills?: boolean | Skill$classSkillsArgs<ExtArgs>
    mobSkills?: boolean | Skill$mobSkillsArgs<ExtArgs>
    raceSkills?: boolean | Skill$raceSkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    maxLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterSkills?: boolean | Skill$characterSkillsArgs<ExtArgs>
    classSkills?: boolean | Skill$classSkillsArgs<ExtArgs>
    mobSkills?: boolean | Skill$mobSkillsArgs<ExtArgs>
    raceSkills?: boolean | Skill$raceSkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      characterSkills: Prisma.$CharacterSkillPayload<ExtArgs>[]
      classSkills: Prisma.$ClassSkillPayload<ExtArgs>[]
      mobSkills: Prisma.$MobSkillPayload<ExtArgs>[]
      raceSkills: Prisma.$RaceSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      type: $Enums.SkillType
      category: $Enums.SkillCategory
      maxLevel: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }


  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillFindManyArgs, 'select' | 'include'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Skill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
    **/
    create<T extends SkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SkillCreateArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Skills.
     *     @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     *     @example
     *     // Create many Skills
     *     const skill = await prisma.skill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
    **/
    delete<T extends SkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
    **/
    upsert<T extends SkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>
    ): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    characterSkills<T extends Skill$characterSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$characterSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    classSkills<T extends Skill$classSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$classSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    mobSkills<T extends Skill$mobSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$mobSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    raceSkills<T extends Skill$raceSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$raceSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceSkillPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Skill model
   */ 
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'Int'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly type: FieldRef<"Skill", 'SkillType'>
    readonly category: FieldRef<"Skill", 'SkillCategory'>
    readonly maxLevel: FieldRef<"Skill", 'Int'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
    readonly updatedAt: FieldRef<"Skill", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }


  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }


  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }


  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }


  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }


  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }


  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }


  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
  }


  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }


  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }


  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
  }


  /**
   * Skill.characterSkills
   */
  export type Skill$characterSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    where?: CharacterSkillWhereInput
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    cursor?: CharacterSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }


  /**
   * Skill.classSkills
   */
  export type Skill$classSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    where?: ClassSkillWhereInput
    orderBy?: ClassSkillOrderByWithRelationInput | ClassSkillOrderByWithRelationInput[]
    cursor?: ClassSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSkillScalarFieldEnum | ClassSkillScalarFieldEnum[]
  }


  /**
   * Skill.mobSkills
   */
  export type Skill$mobSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobSkill
     */
    select?: MobSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobSkillInclude<ExtArgs> | null
    where?: MobSkillWhereInput
    orderBy?: MobSkillOrderByWithRelationInput | MobSkillOrderByWithRelationInput[]
    cursor?: MobSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobSkillScalarFieldEnum | MobSkillScalarFieldEnum[]
  }


  /**
   * Skill.raceSkills
   */
  export type Skill$raceSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
    where?: RaceSkillWhereInput
    orderBy?: RaceSkillOrderByWithRelationInput | RaceSkillOrderByWithRelationInput[]
    cursor?: RaceSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceSkillScalarFieldEnum | RaceSkillScalarFieldEnum[]
  }


  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SkillInclude<ExtArgs> | null
  }



  /**
   * Model ClassSkill
   */

  export type AggregateClassSkill = {
    _count: ClassSkillCountAggregateOutputType | null
    _avg: ClassSkillAvgAggregateOutputType | null
    _sum: ClassSkillSumAggregateOutputType | null
    _min: ClassSkillMinAggregateOutputType | null
    _max: ClassSkillMaxAggregateOutputType | null
  }

  export type ClassSkillAvgAggregateOutputType = {
    id: number | null
    classId: number | null
    skillId: number | null
    minLevel: number | null
    maxLevel: number | null
  }

  export type ClassSkillSumAggregateOutputType = {
    id: number | null
    classId: number | null
    skillId: number | null
    minLevel: number | null
    maxLevel: number | null
  }

  export type ClassSkillMinAggregateOutputType = {
    id: number | null
    classId: number | null
    skillId: number | null
    category: $Enums.SkillCategory | null
    minLevel: number | null
    maxLevel: number | null
  }

  export type ClassSkillMaxAggregateOutputType = {
    id: number | null
    classId: number | null
    skillId: number | null
    category: $Enums.SkillCategory | null
    minLevel: number | null
    maxLevel: number | null
  }

  export type ClassSkillCountAggregateOutputType = {
    id: number
    classId: number
    skillId: number
    category: number
    minLevel: number
    maxLevel: number
    _all: number
  }


  export type ClassSkillAvgAggregateInputType = {
    id?: true
    classId?: true
    skillId?: true
    minLevel?: true
    maxLevel?: true
  }

  export type ClassSkillSumAggregateInputType = {
    id?: true
    classId?: true
    skillId?: true
    minLevel?: true
    maxLevel?: true
  }

  export type ClassSkillMinAggregateInputType = {
    id?: true
    classId?: true
    skillId?: true
    category?: true
    minLevel?: true
    maxLevel?: true
  }

  export type ClassSkillMaxAggregateInputType = {
    id?: true
    classId?: true
    skillId?: true
    category?: true
    minLevel?: true
    maxLevel?: true
  }

  export type ClassSkillCountAggregateInputType = {
    id?: true
    classId?: true
    skillId?: true
    category?: true
    minLevel?: true
    maxLevel?: true
    _all?: true
  }

  export type ClassSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSkill to aggregate.
     */
    where?: ClassSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSkills to fetch.
     */
    orderBy?: ClassSkillOrderByWithRelationInput | ClassSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSkills
    **/
    _count?: true | ClassSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassSkillMaxAggregateInputType
  }

  export type GetClassSkillAggregateType<T extends ClassSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSkill[P]>
      : GetScalarType<T[P], AggregateClassSkill[P]>
  }




  export type ClassSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSkillWhereInput
    orderBy?: ClassSkillOrderByWithAggregationInput | ClassSkillOrderByWithAggregationInput[]
    by: ClassSkillScalarFieldEnum[] | ClassSkillScalarFieldEnum
    having?: ClassSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassSkillCountAggregateInputType | true
    _avg?: ClassSkillAvgAggregateInputType
    _sum?: ClassSkillSumAggregateInputType
    _min?: ClassSkillMinAggregateInputType
    _max?: ClassSkillMaxAggregateInputType
  }

  export type ClassSkillGroupByOutputType = {
    id: number
    classId: number
    skillId: number
    category: $Enums.SkillCategory
    minLevel: number
    maxLevel: number
    _count: ClassSkillCountAggregateOutputType | null
    _avg: ClassSkillAvgAggregateOutputType | null
    _sum: ClassSkillSumAggregateOutputType | null
    _min: ClassSkillMinAggregateOutputType | null
    _max: ClassSkillMaxAggregateOutputType | null
  }

  type GetClassSkillGroupByPayload<T extends ClassSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassSkillGroupByOutputType[P]>
            : GetScalarType<T[P], ClassSkillGroupByOutputType[P]>
        }
      >
    >


  export type ClassSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    skillId?: boolean
    category?: boolean
    minLevel?: boolean
    maxLevel?: boolean
    gameClass?: boolean | GameClassDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSkill"]>

  export type ClassSkillSelectScalar = {
    id?: boolean
    classId?: boolean
    skillId?: boolean
    category?: boolean
    minLevel?: boolean
    maxLevel?: boolean
  }

  export type ClassSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameClass?: boolean | GameClassDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }


  export type $ClassSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSkill"
    objects: {
      gameClass: Prisma.$GameClassPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classId: number
      skillId: number
      category: $Enums.SkillCategory
      minLevel: number
      maxLevel: number
    }, ExtArgs["result"]["classSkill"]>
    composites: {}
  }


  type ClassSkillGetPayload<S extends boolean | null | undefined | ClassSkillDefaultArgs> = $Result.GetResult<Prisma.$ClassSkillPayload, S>

  type ClassSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassSkillFindManyArgs, 'select' | 'include'> & {
      select?: ClassSkillCountAggregateInputType | true
    }

  export interface ClassSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSkill'], meta: { name: 'ClassSkill' } }
    /**
     * Find zero or one ClassSkill that matches the filter.
     * @param {ClassSkillFindUniqueArgs} args - Arguments to find a ClassSkill
     * @example
     * // Get one ClassSkill
     * const classSkill = await prisma.classSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClassSkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClassSkillFindUniqueArgs<ExtArgs>>
    ): Prisma__ClassSkillClient<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClassSkill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClassSkillFindUniqueOrThrowArgs} args - Arguments to find a ClassSkill
     * @example
     * // Get one ClassSkill
     * const classSkill = await prisma.classSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClassSkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassSkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClassSkillClient<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClassSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillFindFirstArgs} args - Arguments to find a ClassSkill
     * @example
     * // Get one ClassSkill
     * const classSkill = await prisma.classSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClassSkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassSkillFindFirstArgs<ExtArgs>>
    ): Prisma__ClassSkillClient<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClassSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillFindFirstOrThrowArgs} args - Arguments to find a ClassSkill
     * @example
     * // Get one ClassSkill
     * const classSkill = await prisma.classSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClassSkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassSkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClassSkillClient<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClassSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSkills
     * const classSkills = await prisma.classSkill.findMany()
     * 
     * // Get first 10 ClassSkills
     * const classSkills = await prisma.classSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classSkillWithIdOnly = await prisma.classSkill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClassSkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassSkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClassSkill.
     * @param {ClassSkillCreateArgs} args - Arguments to create a ClassSkill.
     * @example
     * // Create one ClassSkill
     * const ClassSkill = await prisma.classSkill.create({
     *   data: {
     *     // ... data to create a ClassSkill
     *   }
     * })
     * 
    **/
    create<T extends ClassSkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClassSkillCreateArgs<ExtArgs>>
    ): Prisma__ClassSkillClient<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClassSkills.
     *     @param {ClassSkillCreateManyArgs} args - Arguments to create many ClassSkills.
     *     @example
     *     // Create many ClassSkills
     *     const classSkill = await prisma.classSkill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClassSkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassSkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassSkill.
     * @param {ClassSkillDeleteArgs} args - Arguments to delete one ClassSkill.
     * @example
     * // Delete one ClassSkill
     * const ClassSkill = await prisma.classSkill.delete({
     *   where: {
     *     // ... filter to delete one ClassSkill
     *   }
     * })
     * 
    **/
    delete<T extends ClassSkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClassSkillDeleteArgs<ExtArgs>>
    ): Prisma__ClassSkillClient<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClassSkill.
     * @param {ClassSkillUpdateArgs} args - Arguments to update one ClassSkill.
     * @example
     * // Update one ClassSkill
     * const classSkill = await prisma.classSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClassSkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClassSkillUpdateArgs<ExtArgs>>
    ): Prisma__ClassSkillClient<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClassSkills.
     * @param {ClassSkillDeleteManyArgs} args - Arguments to filter ClassSkills to delete.
     * @example
     * // Delete a few ClassSkills
     * const { count } = await prisma.classSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClassSkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClassSkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSkills
     * const classSkill = await prisma.classSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClassSkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClassSkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassSkill.
     * @param {ClassSkillUpsertArgs} args - Arguments to update or create a ClassSkill.
     * @example
     * // Update or create a ClassSkill
     * const classSkill = await prisma.classSkill.upsert({
     *   create: {
     *     // ... data to create a ClassSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSkill we want to update
     *   }
     * })
    **/
    upsert<T extends ClassSkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClassSkillUpsertArgs<ExtArgs>>
    ): Prisma__ClassSkillClient<$Result.GetResult<Prisma.$ClassSkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClassSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillCountArgs} args - Arguments to filter ClassSkills to count.
     * @example
     * // Count the number of ClassSkills
     * const count = await prisma.classSkill.count({
     *   where: {
     *     // ... the filter for the ClassSkills we want to count
     *   }
     * })
    **/
    count<T extends ClassSkillCountArgs>(
      args?: Subset<T, ClassSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassSkillAggregateArgs>(args: Subset<T, ClassSkillAggregateArgs>): Prisma.PrismaPromise<GetClassSkillAggregateType<T>>

    /**
     * Group by ClassSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassSkillGroupByArgs['orderBy'] }
        : { orderBy?: ClassSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSkill model
   */
  readonly fields: ClassSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    gameClass<T extends GameClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameClassDefaultArgs<ExtArgs>>): Prisma__GameClassClient<$Result.GetResult<Prisma.$GameClassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClassSkill model
   */ 
  interface ClassSkillFieldRefs {
    readonly id: FieldRef<"ClassSkill", 'Int'>
    readonly classId: FieldRef<"ClassSkill", 'Int'>
    readonly skillId: FieldRef<"ClassSkill", 'Int'>
    readonly category: FieldRef<"ClassSkill", 'SkillCategory'>
    readonly minLevel: FieldRef<"ClassSkill", 'Int'>
    readonly maxLevel: FieldRef<"ClassSkill", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ClassSkill findUnique
   */
  export type ClassSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    /**
     * Filter, which ClassSkill to fetch.
     */
    where: ClassSkillWhereUniqueInput
  }


  /**
   * ClassSkill findUniqueOrThrow
   */
  export type ClassSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    /**
     * Filter, which ClassSkill to fetch.
     */
    where: ClassSkillWhereUniqueInput
  }


  /**
   * ClassSkill findFirst
   */
  export type ClassSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    /**
     * Filter, which ClassSkill to fetch.
     */
    where?: ClassSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSkills to fetch.
     */
    orderBy?: ClassSkillOrderByWithRelationInput | ClassSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSkills.
     */
    cursor?: ClassSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSkills.
     */
    distinct?: ClassSkillScalarFieldEnum | ClassSkillScalarFieldEnum[]
  }


  /**
   * ClassSkill findFirstOrThrow
   */
  export type ClassSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    /**
     * Filter, which ClassSkill to fetch.
     */
    where?: ClassSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSkills to fetch.
     */
    orderBy?: ClassSkillOrderByWithRelationInput | ClassSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSkills.
     */
    cursor?: ClassSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSkills.
     */
    distinct?: ClassSkillScalarFieldEnum | ClassSkillScalarFieldEnum[]
  }


  /**
   * ClassSkill findMany
   */
  export type ClassSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    /**
     * Filter, which ClassSkills to fetch.
     */
    where?: ClassSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSkills to fetch.
     */
    orderBy?: ClassSkillOrderByWithRelationInput | ClassSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSkills.
     */
    cursor?: ClassSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSkills.
     */
    skip?: number
    distinct?: ClassSkillScalarFieldEnum | ClassSkillScalarFieldEnum[]
  }


  /**
   * ClassSkill create
   */
  export type ClassSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSkill.
     */
    data: XOR<ClassSkillCreateInput, ClassSkillUncheckedCreateInput>
  }


  /**
   * ClassSkill createMany
   */
  export type ClassSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSkills.
     */
    data: ClassSkillCreateManyInput | ClassSkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ClassSkill update
   */
  export type ClassSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSkill.
     */
    data: XOR<ClassSkillUpdateInput, ClassSkillUncheckedUpdateInput>
    /**
     * Choose, which ClassSkill to update.
     */
    where: ClassSkillWhereUniqueInput
  }


  /**
   * ClassSkill updateMany
   */
  export type ClassSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSkills.
     */
    data: XOR<ClassSkillUpdateManyMutationInput, ClassSkillUncheckedUpdateManyInput>
    /**
     * Filter which ClassSkills to update
     */
    where?: ClassSkillWhereInput
  }


  /**
   * ClassSkill upsert
   */
  export type ClassSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSkill to update in case it exists.
     */
    where: ClassSkillWhereUniqueInput
    /**
     * In case the ClassSkill found by the `where` argument doesn't exist, create a new ClassSkill with this data.
     */
    create: XOR<ClassSkillCreateInput, ClassSkillUncheckedCreateInput>
    /**
     * In case the ClassSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassSkillUpdateInput, ClassSkillUncheckedUpdateInput>
  }


  /**
   * ClassSkill delete
   */
  export type ClassSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
    /**
     * Filter which ClassSkill to delete.
     */
    where: ClassSkillWhereUniqueInput
  }


  /**
   * ClassSkill deleteMany
   */
  export type ClassSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSkills to delete
     */
    where?: ClassSkillWhereInput
  }


  /**
   * ClassSkill without action
   */
  export type ClassSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSkill
     */
    select?: ClassSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassSkillInclude<ExtArgs> | null
  }



  /**
   * Model RaceSkill
   */

  export type AggregateRaceSkill = {
    _count: RaceSkillCountAggregateOutputType | null
    _avg: RaceSkillAvgAggregateOutputType | null
    _sum: RaceSkillSumAggregateOutputType | null
    _min: RaceSkillMinAggregateOutputType | null
    _max: RaceSkillMaxAggregateOutputType | null
  }

  export type RaceSkillAvgAggregateOutputType = {
    id: number | null
    skillId: number | null
    bonus: number | null
  }

  export type RaceSkillSumAggregateOutputType = {
    id: number | null
    skillId: number | null
    bonus: number | null
  }

  export type RaceSkillMinAggregateOutputType = {
    id: number | null
    race: $Enums.Race | null
    skillId: number | null
    category: $Enums.SkillCategory | null
    bonus: number | null
  }

  export type RaceSkillMaxAggregateOutputType = {
    id: number | null
    race: $Enums.Race | null
    skillId: number | null
    category: $Enums.SkillCategory | null
    bonus: number | null
  }

  export type RaceSkillCountAggregateOutputType = {
    id: number
    race: number
    skillId: number
    category: number
    bonus: number
    _all: number
  }


  export type RaceSkillAvgAggregateInputType = {
    id?: true
    skillId?: true
    bonus?: true
  }

  export type RaceSkillSumAggregateInputType = {
    id?: true
    skillId?: true
    bonus?: true
  }

  export type RaceSkillMinAggregateInputType = {
    id?: true
    race?: true
    skillId?: true
    category?: true
    bonus?: true
  }

  export type RaceSkillMaxAggregateInputType = {
    id?: true
    race?: true
    skillId?: true
    category?: true
    bonus?: true
  }

  export type RaceSkillCountAggregateInputType = {
    id?: true
    race?: true
    skillId?: true
    category?: true
    bonus?: true
    _all?: true
  }

  export type RaceSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceSkill to aggregate.
     */
    where?: RaceSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceSkills to fetch.
     */
    orderBy?: RaceSkillOrderByWithRelationInput | RaceSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceSkills
    **/
    _count?: true | RaceSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceSkillMaxAggregateInputType
  }

  export type GetRaceSkillAggregateType<T extends RaceSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceSkill[P]>
      : GetScalarType<T[P], AggregateRaceSkill[P]>
  }




  export type RaceSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceSkillWhereInput
    orderBy?: RaceSkillOrderByWithAggregationInput | RaceSkillOrderByWithAggregationInput[]
    by: RaceSkillScalarFieldEnum[] | RaceSkillScalarFieldEnum
    having?: RaceSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceSkillCountAggregateInputType | true
    _avg?: RaceSkillAvgAggregateInputType
    _sum?: RaceSkillSumAggregateInputType
    _min?: RaceSkillMinAggregateInputType
    _max?: RaceSkillMaxAggregateInputType
  }

  export type RaceSkillGroupByOutputType = {
    id: number
    race: $Enums.Race
    skillId: number
    category: $Enums.SkillCategory
    bonus: number
    _count: RaceSkillCountAggregateOutputType | null
    _avg: RaceSkillAvgAggregateOutputType | null
    _sum: RaceSkillSumAggregateOutputType | null
    _min: RaceSkillMinAggregateOutputType | null
    _max: RaceSkillMaxAggregateOutputType | null
  }

  type GetRaceSkillGroupByPayload<T extends RaceSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceSkillGroupByOutputType[P]>
            : GetScalarType<T[P], RaceSkillGroupByOutputType[P]>
        }
      >
    >


  export type RaceSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    race?: boolean
    skillId?: boolean
    category?: boolean
    bonus?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceSkill"]>

  export type RaceSkillSelectScalar = {
    id?: boolean
    race?: boolean
    skillId?: boolean
    category?: boolean
    bonus?: boolean
  }

  export type RaceSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }


  export type $RaceSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceSkill"
    objects: {
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      race: $Enums.Race
      skillId: number
      category: $Enums.SkillCategory
      bonus: number
    }, ExtArgs["result"]["raceSkill"]>
    composites: {}
  }


  type RaceSkillGetPayload<S extends boolean | null | undefined | RaceSkillDefaultArgs> = $Result.GetResult<Prisma.$RaceSkillPayload, S>

  type RaceSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RaceSkillFindManyArgs, 'select' | 'include'> & {
      select?: RaceSkillCountAggregateInputType | true
    }

  export interface RaceSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceSkill'], meta: { name: 'RaceSkill' } }
    /**
     * Find zero or one RaceSkill that matches the filter.
     * @param {RaceSkillFindUniqueArgs} args - Arguments to find a RaceSkill
     * @example
     * // Get one RaceSkill
     * const raceSkill = await prisma.raceSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RaceSkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RaceSkillFindUniqueArgs<ExtArgs>>
    ): Prisma__RaceSkillClient<$Result.GetResult<Prisma.$RaceSkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RaceSkill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RaceSkillFindUniqueOrThrowArgs} args - Arguments to find a RaceSkill
     * @example
     * // Get one RaceSkill
     * const raceSkill = await prisma.raceSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RaceSkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RaceSkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RaceSkillClient<$Result.GetResult<Prisma.$RaceSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RaceSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSkillFindFirstArgs} args - Arguments to find a RaceSkill
     * @example
     * // Get one RaceSkill
     * const raceSkill = await prisma.raceSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RaceSkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RaceSkillFindFirstArgs<ExtArgs>>
    ): Prisma__RaceSkillClient<$Result.GetResult<Prisma.$RaceSkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RaceSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSkillFindFirstOrThrowArgs} args - Arguments to find a RaceSkill
     * @example
     * // Get one RaceSkill
     * const raceSkill = await prisma.raceSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RaceSkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RaceSkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RaceSkillClient<$Result.GetResult<Prisma.$RaceSkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RaceSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceSkills
     * const raceSkills = await prisma.raceSkill.findMany()
     * 
     * // Get first 10 RaceSkills
     * const raceSkills = await prisma.raceSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raceSkillWithIdOnly = await prisma.raceSkill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RaceSkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RaceSkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceSkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RaceSkill.
     * @param {RaceSkillCreateArgs} args - Arguments to create a RaceSkill.
     * @example
     * // Create one RaceSkill
     * const RaceSkill = await prisma.raceSkill.create({
     *   data: {
     *     // ... data to create a RaceSkill
     *   }
     * })
     * 
    **/
    create<T extends RaceSkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RaceSkillCreateArgs<ExtArgs>>
    ): Prisma__RaceSkillClient<$Result.GetResult<Prisma.$RaceSkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RaceSkills.
     *     @param {RaceSkillCreateManyArgs} args - Arguments to create many RaceSkills.
     *     @example
     *     // Create many RaceSkills
     *     const raceSkill = await prisma.raceSkill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RaceSkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RaceSkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RaceSkill.
     * @param {RaceSkillDeleteArgs} args - Arguments to delete one RaceSkill.
     * @example
     * // Delete one RaceSkill
     * const RaceSkill = await prisma.raceSkill.delete({
     *   where: {
     *     // ... filter to delete one RaceSkill
     *   }
     * })
     * 
    **/
    delete<T extends RaceSkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RaceSkillDeleteArgs<ExtArgs>>
    ): Prisma__RaceSkillClient<$Result.GetResult<Prisma.$RaceSkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RaceSkill.
     * @param {RaceSkillUpdateArgs} args - Arguments to update one RaceSkill.
     * @example
     * // Update one RaceSkill
     * const raceSkill = await prisma.raceSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RaceSkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RaceSkillUpdateArgs<ExtArgs>>
    ): Prisma__RaceSkillClient<$Result.GetResult<Prisma.$RaceSkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RaceSkills.
     * @param {RaceSkillDeleteManyArgs} args - Arguments to filter RaceSkills to delete.
     * @example
     * // Delete a few RaceSkills
     * const { count } = await prisma.raceSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RaceSkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RaceSkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceSkills
     * const raceSkill = await prisma.raceSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RaceSkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RaceSkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RaceSkill.
     * @param {RaceSkillUpsertArgs} args - Arguments to update or create a RaceSkill.
     * @example
     * // Update or create a RaceSkill
     * const raceSkill = await prisma.raceSkill.upsert({
     *   create: {
     *     // ... data to create a RaceSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceSkill we want to update
     *   }
     * })
    **/
    upsert<T extends RaceSkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RaceSkillUpsertArgs<ExtArgs>>
    ): Prisma__RaceSkillClient<$Result.GetResult<Prisma.$RaceSkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RaceSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSkillCountArgs} args - Arguments to filter RaceSkills to count.
     * @example
     * // Count the number of RaceSkills
     * const count = await prisma.raceSkill.count({
     *   where: {
     *     // ... the filter for the RaceSkills we want to count
     *   }
     * })
    **/
    count<T extends RaceSkillCountArgs>(
      args?: Subset<T, RaceSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceSkillAggregateArgs>(args: Subset<T, RaceSkillAggregateArgs>): Prisma.PrismaPromise<GetRaceSkillAggregateType<T>>

    /**
     * Group by RaceSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceSkillGroupByArgs['orderBy'] }
        : { orderBy?: RaceSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceSkill model
   */
  readonly fields: RaceSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RaceSkill model
   */ 
  interface RaceSkillFieldRefs {
    readonly id: FieldRef<"RaceSkill", 'Int'>
    readonly race: FieldRef<"RaceSkill", 'Race'>
    readonly skillId: FieldRef<"RaceSkill", 'Int'>
    readonly category: FieldRef<"RaceSkill", 'SkillCategory'>
    readonly bonus: FieldRef<"RaceSkill", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RaceSkill findUnique
   */
  export type RaceSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
    /**
     * Filter, which RaceSkill to fetch.
     */
    where: RaceSkillWhereUniqueInput
  }


  /**
   * RaceSkill findUniqueOrThrow
   */
  export type RaceSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
    /**
     * Filter, which RaceSkill to fetch.
     */
    where: RaceSkillWhereUniqueInput
  }


  /**
   * RaceSkill findFirst
   */
  export type RaceSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
    /**
     * Filter, which RaceSkill to fetch.
     */
    where?: RaceSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceSkills to fetch.
     */
    orderBy?: RaceSkillOrderByWithRelationInput | RaceSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceSkills.
     */
    cursor?: RaceSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceSkills.
     */
    distinct?: RaceSkillScalarFieldEnum | RaceSkillScalarFieldEnum[]
  }


  /**
   * RaceSkill findFirstOrThrow
   */
  export type RaceSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
    /**
     * Filter, which RaceSkill to fetch.
     */
    where?: RaceSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceSkills to fetch.
     */
    orderBy?: RaceSkillOrderByWithRelationInput | RaceSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceSkills.
     */
    cursor?: RaceSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceSkills.
     */
    distinct?: RaceSkillScalarFieldEnum | RaceSkillScalarFieldEnum[]
  }


  /**
   * RaceSkill findMany
   */
  export type RaceSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
    /**
     * Filter, which RaceSkills to fetch.
     */
    where?: RaceSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceSkills to fetch.
     */
    orderBy?: RaceSkillOrderByWithRelationInput | RaceSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceSkills.
     */
    cursor?: RaceSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceSkills.
     */
    skip?: number
    distinct?: RaceSkillScalarFieldEnum | RaceSkillScalarFieldEnum[]
  }


  /**
   * RaceSkill create
   */
  export type RaceSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceSkill.
     */
    data: XOR<RaceSkillCreateInput, RaceSkillUncheckedCreateInput>
  }


  /**
   * RaceSkill createMany
   */
  export type RaceSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceSkills.
     */
    data: RaceSkillCreateManyInput | RaceSkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RaceSkill update
   */
  export type RaceSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceSkill.
     */
    data: XOR<RaceSkillUpdateInput, RaceSkillUncheckedUpdateInput>
    /**
     * Choose, which RaceSkill to update.
     */
    where: RaceSkillWhereUniqueInput
  }


  /**
   * RaceSkill updateMany
   */
  export type RaceSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceSkills.
     */
    data: XOR<RaceSkillUpdateManyMutationInput, RaceSkillUncheckedUpdateManyInput>
    /**
     * Filter which RaceSkills to update
     */
    where?: RaceSkillWhereInput
  }


  /**
   * RaceSkill upsert
   */
  export type RaceSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceSkill to update in case it exists.
     */
    where: RaceSkillWhereUniqueInput
    /**
     * In case the RaceSkill found by the `where` argument doesn't exist, create a new RaceSkill with this data.
     */
    create: XOR<RaceSkillCreateInput, RaceSkillUncheckedCreateInput>
    /**
     * In case the RaceSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceSkillUpdateInput, RaceSkillUncheckedUpdateInput>
  }


  /**
   * RaceSkill delete
   */
  export type RaceSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
    /**
     * Filter which RaceSkill to delete.
     */
    where: RaceSkillWhereUniqueInput
  }


  /**
   * RaceSkill deleteMany
   */
  export type RaceSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceSkills to delete
     */
    where?: RaceSkillWhereInput
  }


  /**
   * RaceSkill without action
   */
  export type RaceSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceSkill
     */
    select?: RaceSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RaceSkillInclude<ExtArgs> | null
  }



  /**
   * Model CharacterSkill
   */

  export type AggregateCharacterSkill = {
    _count: CharacterSkillCountAggregateOutputType | null
    _avg: CharacterSkillAvgAggregateOutputType | null
    _sum: CharacterSkillSumAggregateOutputType | null
    _min: CharacterSkillMinAggregateOutputType | null
    _max: CharacterSkillMaxAggregateOutputType | null
  }

  export type CharacterSkillAvgAggregateOutputType = {
    skillId: number | null
    level: number | null
    experience: number | null
  }

  export type CharacterSkillSumAggregateOutputType = {
    skillId: number | null
    level: number | null
    experience: number | null
  }

  export type CharacterSkillMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    skillId: number | null
    level: number | null
    experience: number | null
    lastUsed: Date | null
  }

  export type CharacterSkillMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    skillId: number | null
    level: number | null
    experience: number | null
    lastUsed: Date | null
  }

  export type CharacterSkillCountAggregateOutputType = {
    id: number
    characterId: number
    skillId: number
    level: number
    experience: number
    lastUsed: number
    _all: number
  }


  export type CharacterSkillAvgAggregateInputType = {
    skillId?: true
    level?: true
    experience?: true
  }

  export type CharacterSkillSumAggregateInputType = {
    skillId?: true
    level?: true
    experience?: true
  }

  export type CharacterSkillMinAggregateInputType = {
    id?: true
    characterId?: true
    skillId?: true
    level?: true
    experience?: true
    lastUsed?: true
  }

  export type CharacterSkillMaxAggregateInputType = {
    id?: true
    characterId?: true
    skillId?: true
    level?: true
    experience?: true
    lastUsed?: true
  }

  export type CharacterSkillCountAggregateInputType = {
    id?: true
    characterId?: true
    skillId?: true
    level?: true
    experience?: true
    lastUsed?: true
    _all?: true
  }

  export type CharacterSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSkill to aggregate.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterSkills
    **/
    _count?: true | CharacterSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterSkillMaxAggregateInputType
  }

  export type GetCharacterSkillAggregateType<T extends CharacterSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterSkill[P]>
      : GetScalarType<T[P], AggregateCharacterSkill[P]>
  }




  export type CharacterSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSkillWhereInput
    orderBy?: CharacterSkillOrderByWithAggregationInput | CharacterSkillOrderByWithAggregationInput[]
    by: CharacterSkillScalarFieldEnum[] | CharacterSkillScalarFieldEnum
    having?: CharacterSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterSkillCountAggregateInputType | true
    _avg?: CharacterSkillAvgAggregateInputType
    _sum?: CharacterSkillSumAggregateInputType
    _min?: CharacterSkillMinAggregateInputType
    _max?: CharacterSkillMaxAggregateInputType
  }

  export type CharacterSkillGroupByOutputType = {
    id: string
    characterId: string
    skillId: number
    level: number
    experience: number
    lastUsed: Date | null
    _count: CharacterSkillCountAggregateOutputType | null
    _avg: CharacterSkillAvgAggregateOutputType | null
    _sum: CharacterSkillSumAggregateOutputType | null
    _min: CharacterSkillMinAggregateOutputType | null
    _max: CharacterSkillMaxAggregateOutputType | null
  }

  type GetCharacterSkillGroupByPayload<T extends CharacterSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterSkillGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterSkillGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    skillId?: boolean
    level?: boolean
    experience?: boolean
    lastUsed?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterSkill"]>

  export type CharacterSkillSelectScalar = {
    id?: boolean
    characterId?: boolean
    skillId?: boolean
    level?: boolean
    experience?: boolean
    lastUsed?: boolean
  }

  export type CharacterSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }


  export type $CharacterSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterSkill"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      skillId: number
      level: number
      experience: number
      lastUsed: Date | null
    }, ExtArgs["result"]["characterSkill"]>
    composites: {}
  }


  type CharacterSkillGetPayload<S extends boolean | null | undefined | CharacterSkillDefaultArgs> = $Result.GetResult<Prisma.$CharacterSkillPayload, S>

  type CharacterSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterSkillFindManyArgs, 'select' | 'include'> & {
      select?: CharacterSkillCountAggregateInputType | true
    }

  export interface CharacterSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterSkill'], meta: { name: 'CharacterSkill' } }
    /**
     * Find zero or one CharacterSkill that matches the filter.
     * @param {CharacterSkillFindUniqueArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterSkillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSkillFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CharacterSkill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterSkillFindUniqueOrThrowArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterSkillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSkillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CharacterSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindFirstArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterSkillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSkillFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CharacterSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindFirstOrThrowArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterSkillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSkillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CharacterSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterSkills
     * const characterSkills = await prisma.characterSkill.findMany()
     * 
     * // Get first 10 CharacterSkills
     * const characterSkills = await prisma.characterSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterSkillWithIdOnly = await prisma.characterSkill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterSkillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSkillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CharacterSkill.
     * @param {CharacterSkillCreateArgs} args - Arguments to create a CharacterSkill.
     * @example
     * // Create one CharacterSkill
     * const CharacterSkill = await prisma.characterSkill.create({
     *   data: {
     *     // ... data to create a CharacterSkill
     *   }
     * })
     * 
    **/
    create<T extends CharacterSkillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSkillCreateArgs<ExtArgs>>
    ): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CharacterSkills.
     *     @param {CharacterSkillCreateManyArgs} args - Arguments to create many CharacterSkills.
     *     @example
     *     // Create many CharacterSkills
     *     const characterSkill = await prisma.characterSkill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterSkillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSkillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CharacterSkill.
     * @param {CharacterSkillDeleteArgs} args - Arguments to delete one CharacterSkill.
     * @example
     * // Delete one CharacterSkill
     * const CharacterSkill = await prisma.characterSkill.delete({
     *   where: {
     *     // ... filter to delete one CharacterSkill
     *   }
     * })
     * 
    **/
    delete<T extends CharacterSkillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSkillDeleteArgs<ExtArgs>>
    ): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CharacterSkill.
     * @param {CharacterSkillUpdateArgs} args - Arguments to update one CharacterSkill.
     * @example
     * // Update one CharacterSkill
     * const characterSkill = await prisma.characterSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterSkillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSkillUpdateArgs<ExtArgs>>
    ): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CharacterSkills.
     * @param {CharacterSkillDeleteManyArgs} args - Arguments to filter CharacterSkills to delete.
     * @example
     * // Delete a few CharacterSkills
     * const { count } = await prisma.characterSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterSkillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSkillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterSkills
     * const characterSkill = await prisma.characterSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterSkillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSkillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterSkill.
     * @param {CharacterSkillUpsertArgs} args - Arguments to update or create a CharacterSkill.
     * @example
     * // Update or create a CharacterSkill
     * const characterSkill = await prisma.characterSkill.upsert({
     *   create: {
     *     // ... data to create a CharacterSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterSkill we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterSkillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSkillUpsertArgs<ExtArgs>>
    ): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CharacterSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillCountArgs} args - Arguments to filter CharacterSkills to count.
     * @example
     * // Count the number of CharacterSkills
     * const count = await prisma.characterSkill.count({
     *   where: {
     *     // ... the filter for the CharacterSkills we want to count
     *   }
     * })
    **/
    count<T extends CharacterSkillCountArgs>(
      args?: Subset<T, CharacterSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterSkillAggregateArgs>(args: Subset<T, CharacterSkillAggregateArgs>): Prisma.PrismaPromise<GetCharacterSkillAggregateType<T>>

    /**
     * Group by CharacterSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterSkillGroupByArgs['orderBy'] }
        : { orderBy?: CharacterSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterSkill model
   */
  readonly fields: CharacterSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CharacterSkill model
   */ 
  interface CharacterSkillFieldRefs {
    readonly id: FieldRef<"CharacterSkill", 'String'>
    readonly characterId: FieldRef<"CharacterSkill", 'String'>
    readonly skillId: FieldRef<"CharacterSkill", 'Int'>
    readonly level: FieldRef<"CharacterSkill", 'Int'>
    readonly experience: FieldRef<"CharacterSkill", 'Int'>
    readonly lastUsed: FieldRef<"CharacterSkill", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CharacterSkill findUnique
   */
  export type CharacterSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where: CharacterSkillWhereUniqueInput
  }


  /**
   * CharacterSkill findUniqueOrThrow
   */
  export type CharacterSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where: CharacterSkillWhereUniqueInput
  }


  /**
   * CharacterSkill findFirst
   */
  export type CharacterSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSkills.
     */
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }


  /**
   * CharacterSkill findFirstOrThrow
   */
  export type CharacterSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSkills.
     */
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }


  /**
   * CharacterSkill findMany
   */
  export type CharacterSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkills to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }


  /**
   * CharacterSkill create
   */
  export type CharacterSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterSkill.
     */
    data: XOR<CharacterSkillCreateInput, CharacterSkillUncheckedCreateInput>
  }


  /**
   * CharacterSkill createMany
   */
  export type CharacterSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterSkills.
     */
    data: CharacterSkillCreateManyInput | CharacterSkillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CharacterSkill update
   */
  export type CharacterSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterSkill.
     */
    data: XOR<CharacterSkillUpdateInput, CharacterSkillUncheckedUpdateInput>
    /**
     * Choose, which CharacterSkill to update.
     */
    where: CharacterSkillWhereUniqueInput
  }


  /**
   * CharacterSkill updateMany
   */
  export type CharacterSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterSkills.
     */
    data: XOR<CharacterSkillUpdateManyMutationInput, CharacterSkillUncheckedUpdateManyInput>
    /**
     * Filter which CharacterSkills to update
     */
    where?: CharacterSkillWhereInput
  }


  /**
   * CharacterSkill upsert
   */
  export type CharacterSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterSkill to update in case it exists.
     */
    where: CharacterSkillWhereUniqueInput
    /**
     * In case the CharacterSkill found by the `where` argument doesn't exist, create a new CharacterSkill with this data.
     */
    create: XOR<CharacterSkillCreateInput, CharacterSkillUncheckedCreateInput>
    /**
     * In case the CharacterSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterSkillUpdateInput, CharacterSkillUncheckedUpdateInput>
  }


  /**
   * CharacterSkill delete
   */
  export type CharacterSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter which CharacterSkill to delete.
     */
    where: CharacterSkillWhereUniqueInput
  }


  /**
   * CharacterSkill deleteMany
   */
  export type CharacterSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSkills to delete
     */
    where?: CharacterSkillWhereInput
  }


  /**
   * CharacterSkill without action
   */
  export type CharacterSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSkillInclude<ExtArgs> | null
  }



  /**
   * Model CharacterSpell
   */

  export type AggregateCharacterSpell = {
    _count: CharacterSpellCountAggregateOutputType | null
    _avg: CharacterSpellAvgAggregateOutputType | null
    _sum: CharacterSpellSumAggregateOutputType | null
    _min: CharacterSpellMinAggregateOutputType | null
    _max: CharacterSpellMaxAggregateOutputType | null
  }

  export type CharacterSpellAvgAggregateOutputType = {
    spellId: number | null
    proficiency: number | null
  }

  export type CharacterSpellSumAggregateOutputType = {
    spellId: number | null
    proficiency: number | null
  }

  export type CharacterSpellMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    spellId: number | null
    known: boolean | null
    proficiency: number | null
    lastCast: Date | null
  }

  export type CharacterSpellMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    spellId: number | null
    known: boolean | null
    proficiency: number | null
    lastCast: Date | null
  }

  export type CharacterSpellCountAggregateOutputType = {
    id: number
    characterId: number
    spellId: number
    known: number
    proficiency: number
    lastCast: number
    _all: number
  }


  export type CharacterSpellAvgAggregateInputType = {
    spellId?: true
    proficiency?: true
  }

  export type CharacterSpellSumAggregateInputType = {
    spellId?: true
    proficiency?: true
  }

  export type CharacterSpellMinAggregateInputType = {
    id?: true
    characterId?: true
    spellId?: true
    known?: true
    proficiency?: true
    lastCast?: true
  }

  export type CharacterSpellMaxAggregateInputType = {
    id?: true
    characterId?: true
    spellId?: true
    known?: true
    proficiency?: true
    lastCast?: true
  }

  export type CharacterSpellCountAggregateInputType = {
    id?: true
    characterId?: true
    spellId?: true
    known?: true
    proficiency?: true
    lastCast?: true
    _all?: true
  }

  export type CharacterSpellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSpell to aggregate.
     */
    where?: CharacterSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSpells to fetch.
     */
    orderBy?: CharacterSpellOrderByWithRelationInput | CharacterSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterSpells
    **/
    _count?: true | CharacterSpellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterSpellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSpellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterSpellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterSpellMaxAggregateInputType
  }

  export type GetCharacterSpellAggregateType<T extends CharacterSpellAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterSpell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterSpell[P]>
      : GetScalarType<T[P], AggregateCharacterSpell[P]>
  }




  export type CharacterSpellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSpellWhereInput
    orderBy?: CharacterSpellOrderByWithAggregationInput | CharacterSpellOrderByWithAggregationInput[]
    by: CharacterSpellScalarFieldEnum[] | CharacterSpellScalarFieldEnum
    having?: CharacterSpellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterSpellCountAggregateInputType | true
    _avg?: CharacterSpellAvgAggregateInputType
    _sum?: CharacterSpellSumAggregateInputType
    _min?: CharacterSpellMinAggregateInputType
    _max?: CharacterSpellMaxAggregateInputType
  }

  export type CharacterSpellGroupByOutputType = {
    id: string
    characterId: string
    spellId: number
    known: boolean
    proficiency: number
    lastCast: Date | null
    _count: CharacterSpellCountAggregateOutputType | null
    _avg: CharacterSpellAvgAggregateOutputType | null
    _sum: CharacterSpellSumAggregateOutputType | null
    _min: CharacterSpellMinAggregateOutputType | null
    _max: CharacterSpellMaxAggregateOutputType | null
  }

  type GetCharacterSpellGroupByPayload<T extends CharacterSpellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterSpellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterSpellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterSpellGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterSpellGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSpellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    spellId?: boolean
    known?: boolean
    proficiency?: boolean
    lastCast?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterSpell"]>

  export type CharacterSpellSelectScalar = {
    id?: boolean
    characterId?: boolean
    spellId?: boolean
    known?: boolean
    proficiency?: boolean
    lastCast?: boolean
  }

  export type CharacterSpellInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    spell?: boolean | SpellDefaultArgs<ExtArgs>
  }


  export type $CharacterSpellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterSpell"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
      spell: Prisma.$SpellPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      spellId: number
      known: boolean
      proficiency: number
      lastCast: Date | null
    }, ExtArgs["result"]["characterSpell"]>
    composites: {}
  }


  type CharacterSpellGetPayload<S extends boolean | null | undefined | CharacterSpellDefaultArgs> = $Result.GetResult<Prisma.$CharacterSpellPayload, S>

  type CharacterSpellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterSpellFindManyArgs, 'select' | 'include'> & {
      select?: CharacterSpellCountAggregateInputType | true
    }

  export interface CharacterSpellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterSpell'], meta: { name: 'CharacterSpell' } }
    /**
     * Find zero or one CharacterSpell that matches the filter.
     * @param {CharacterSpellFindUniqueArgs} args - Arguments to find a CharacterSpell
     * @example
     * // Get one CharacterSpell
     * const characterSpell = await prisma.characterSpell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterSpellFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSpellFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterSpellClient<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CharacterSpell that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterSpellFindUniqueOrThrowArgs} args - Arguments to find a CharacterSpell
     * @example
     * // Get one CharacterSpell
     * const characterSpell = await prisma.characterSpell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterSpellFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSpellFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterSpellClient<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CharacterSpell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellFindFirstArgs} args - Arguments to find a CharacterSpell
     * @example
     * // Get one CharacterSpell
     * const characterSpell = await prisma.characterSpell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterSpellFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSpellFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterSpellClient<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CharacterSpell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellFindFirstOrThrowArgs} args - Arguments to find a CharacterSpell
     * @example
     * // Get one CharacterSpell
     * const characterSpell = await prisma.characterSpell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterSpellFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSpellFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterSpellClient<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CharacterSpells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterSpells
     * const characterSpells = await prisma.characterSpell.findMany()
     * 
     * // Get first 10 CharacterSpells
     * const characterSpells = await prisma.characterSpell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterSpellWithIdOnly = await prisma.characterSpell.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterSpellFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSpellFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CharacterSpell.
     * @param {CharacterSpellCreateArgs} args - Arguments to create a CharacterSpell.
     * @example
     * // Create one CharacterSpell
     * const CharacterSpell = await prisma.characterSpell.create({
     *   data: {
     *     // ... data to create a CharacterSpell
     *   }
     * })
     * 
    **/
    create<T extends CharacterSpellCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSpellCreateArgs<ExtArgs>>
    ): Prisma__CharacterSpellClient<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CharacterSpells.
     *     @param {CharacterSpellCreateManyArgs} args - Arguments to create many CharacterSpells.
     *     @example
     *     // Create many CharacterSpells
     *     const characterSpell = await prisma.characterSpell.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterSpellCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSpellCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CharacterSpell.
     * @param {CharacterSpellDeleteArgs} args - Arguments to delete one CharacterSpell.
     * @example
     * // Delete one CharacterSpell
     * const CharacterSpell = await prisma.characterSpell.delete({
     *   where: {
     *     // ... filter to delete one CharacterSpell
     *   }
     * })
     * 
    **/
    delete<T extends CharacterSpellDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSpellDeleteArgs<ExtArgs>>
    ): Prisma__CharacterSpellClient<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CharacterSpell.
     * @param {CharacterSpellUpdateArgs} args - Arguments to update one CharacterSpell.
     * @example
     * // Update one CharacterSpell
     * const characterSpell = await prisma.characterSpell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterSpellUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSpellUpdateArgs<ExtArgs>>
    ): Prisma__CharacterSpellClient<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CharacterSpells.
     * @param {CharacterSpellDeleteManyArgs} args - Arguments to filter CharacterSpells to delete.
     * @example
     * // Delete a few CharacterSpells
     * const { count } = await prisma.characterSpell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterSpellDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterSpellDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterSpells
     * const characterSpell = await prisma.characterSpell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterSpellUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSpellUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterSpell.
     * @param {CharacterSpellUpsertArgs} args - Arguments to update or create a CharacterSpell.
     * @example
     * // Update or create a CharacterSpell
     * const characterSpell = await prisma.characterSpell.upsert({
     *   create: {
     *     // ... data to create a CharacterSpell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterSpell we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterSpellUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterSpellUpsertArgs<ExtArgs>>
    ): Prisma__CharacterSpellClient<$Result.GetResult<Prisma.$CharacterSpellPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CharacterSpells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellCountArgs} args - Arguments to filter CharacterSpells to count.
     * @example
     * // Count the number of CharacterSpells
     * const count = await prisma.characterSpell.count({
     *   where: {
     *     // ... the filter for the CharacterSpells we want to count
     *   }
     * })
    **/
    count<T extends CharacterSpellCountArgs>(
      args?: Subset<T, CharacterSpellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterSpellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterSpell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterSpellAggregateArgs>(args: Subset<T, CharacterSpellAggregateArgs>): Prisma.PrismaPromise<GetCharacterSpellAggregateType<T>>

    /**
     * Group by CharacterSpell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSpellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterSpellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterSpellGroupByArgs['orderBy'] }
        : { orderBy?: CharacterSpellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterSpellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterSpellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterSpell model
   */
  readonly fields: CharacterSpellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterSpell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterSpellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    spell<T extends SpellDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpellDefaultArgs<ExtArgs>>): Prisma__SpellClient<$Result.GetResult<Prisma.$SpellPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CharacterSpell model
   */ 
  interface CharacterSpellFieldRefs {
    readonly id: FieldRef<"CharacterSpell", 'String'>
    readonly characterId: FieldRef<"CharacterSpell", 'String'>
    readonly spellId: FieldRef<"CharacterSpell", 'Int'>
    readonly known: FieldRef<"CharacterSpell", 'Boolean'>
    readonly proficiency: FieldRef<"CharacterSpell", 'Int'>
    readonly lastCast: FieldRef<"CharacterSpell", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CharacterSpell findUnique
   */
  export type CharacterSpellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSpell to fetch.
     */
    where: CharacterSpellWhereUniqueInput
  }


  /**
   * CharacterSpell findUniqueOrThrow
   */
  export type CharacterSpellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSpell to fetch.
     */
    where: CharacterSpellWhereUniqueInput
  }


  /**
   * CharacterSpell findFirst
   */
  export type CharacterSpellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSpell to fetch.
     */
    where?: CharacterSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSpells to fetch.
     */
    orderBy?: CharacterSpellOrderByWithRelationInput | CharacterSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSpells.
     */
    cursor?: CharacterSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSpells.
     */
    distinct?: CharacterSpellScalarFieldEnum | CharacterSpellScalarFieldEnum[]
  }


  /**
   * CharacterSpell findFirstOrThrow
   */
  export type CharacterSpellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSpell to fetch.
     */
    where?: CharacterSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSpells to fetch.
     */
    orderBy?: CharacterSpellOrderByWithRelationInput | CharacterSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSpells.
     */
    cursor?: CharacterSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSpells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSpells.
     */
    distinct?: CharacterSpellScalarFieldEnum | CharacterSpellScalarFieldEnum[]
  }


  /**
   * CharacterSpell findMany
   */
  export type CharacterSpellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSpells to fetch.
     */
    where?: CharacterSpellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSpells to fetch.
     */
    orderBy?: CharacterSpellOrderByWithRelationInput | CharacterSpellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterSpells.
     */
    cursor?: CharacterSpellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSpells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSpells.
     */
    skip?: number
    distinct?: CharacterSpellScalarFieldEnum | CharacterSpellScalarFieldEnum[]
  }


  /**
   * CharacterSpell create
   */
  export type CharacterSpellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterSpell.
     */
    data: XOR<CharacterSpellCreateInput, CharacterSpellUncheckedCreateInput>
  }


  /**
   * CharacterSpell createMany
   */
  export type CharacterSpellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterSpells.
     */
    data: CharacterSpellCreateManyInput | CharacterSpellCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CharacterSpell update
   */
  export type CharacterSpellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterSpell.
     */
    data: XOR<CharacterSpellUpdateInput, CharacterSpellUncheckedUpdateInput>
    /**
     * Choose, which CharacterSpell to update.
     */
    where: CharacterSpellWhereUniqueInput
  }


  /**
   * CharacterSpell updateMany
   */
  export type CharacterSpellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterSpells.
     */
    data: XOR<CharacterSpellUpdateManyMutationInput, CharacterSpellUncheckedUpdateManyInput>
    /**
     * Filter which CharacterSpells to update
     */
    where?: CharacterSpellWhereInput
  }


  /**
   * CharacterSpell upsert
   */
  export type CharacterSpellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterSpell to update in case it exists.
     */
    where: CharacterSpellWhereUniqueInput
    /**
     * In case the CharacterSpell found by the `where` argument doesn't exist, create a new CharacterSpell with this data.
     */
    create: XOR<CharacterSpellCreateInput, CharacterSpellUncheckedCreateInput>
    /**
     * In case the CharacterSpell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterSpellUpdateInput, CharacterSpellUncheckedUpdateInput>
  }


  /**
   * CharacterSpell delete
   */
  export type CharacterSpellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
    /**
     * Filter which CharacterSpell to delete.
     */
    where: CharacterSpellWhereUniqueInput
  }


  /**
   * CharacterSpell deleteMany
   */
  export type CharacterSpellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSpells to delete
     */
    where?: CharacterSpellWhereInput
  }


  /**
   * CharacterSpell without action
   */
  export type CharacterSpellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSpell
     */
    select?: CharacterSpellSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterSpellInclude<ExtArgs> | null
  }



  /**
   * Model ChangeLog
   */

  export type AggregateChangeLog = {
    _count: ChangeLogCountAggregateOutputType | null
    _min: ChangeLogMinAggregateOutputType | null
    _max: ChangeLogMaxAggregateOutputType | null
  }

  export type ChangeLogMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    userId: string | null
    timestamp: Date | null
    description: string | null
  }

  export type ChangeLogMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    userId: string | null
    timestamp: Date | null
    description: string | null
  }

  export type ChangeLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    action: number
    changes: number
    userId: number
    timestamp: number
    description: number
    _all: number
  }


  export type ChangeLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    timestamp?: true
    description?: true
  }

  export type ChangeLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    timestamp?: true
    description?: true
  }

  export type ChangeLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    changes?: true
    userId?: true
    timestamp?: true
    description?: true
    _all?: true
  }

  export type ChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeLog to aggregate.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangeLogs
    **/
    _count?: true | ChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeLogMaxAggregateInputType
  }

  export type GetChangeLogAggregateType<T extends ChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeLog[P]>
      : GetScalarType<T[P], AggregateChangeLog[P]>
  }




  export type ChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeLogWhereInput
    orderBy?: ChangeLogOrderByWithAggregationInput | ChangeLogOrderByWithAggregationInput[]
    by: ChangeLogScalarFieldEnum[] | ChangeLogScalarFieldEnum
    having?: ChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeLogCountAggregateInputType | true
    _min?: ChangeLogMinAggregateInputType
    _max?: ChangeLogMaxAggregateInputType
  }

  export type ChangeLogGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    action: string
    changes: JsonValue
    userId: string
    timestamp: Date
    description: string | null
    _count: ChangeLogCountAggregateOutputType | null
    _min: ChangeLogMinAggregateOutputType | null
    _max: ChangeLogMaxAggregateOutputType | null
  }

  type GetChangeLogGroupByPayload<T extends ChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type ChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    changes?: boolean
    userId?: boolean
    timestamp?: boolean
    description?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeLog"]>

  export type ChangeLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    changes?: boolean
    userId?: boolean
    timestamp?: boolean
    description?: boolean
  }

  export type ChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChangeLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      action: string
      changes: Prisma.JsonValue
      userId: string
      timestamp: Date
      description: string | null
    }, ExtArgs["result"]["changeLog"]>
    composites: {}
  }


  type ChangeLogGetPayload<S extends boolean | null | undefined | ChangeLogDefaultArgs> = $Result.GetResult<Prisma.$ChangeLogPayload, S>

  type ChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChangeLogFindManyArgs, 'select' | 'include'> & {
      select?: ChangeLogCountAggregateInputType | true
    }

  export interface ChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChangeLog'], meta: { name: 'ChangeLog' } }
    /**
     * Find zero or one ChangeLog that matches the filter.
     * @param {ChangeLogFindUniqueArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChangeLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogFindUniqueArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ChangeLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChangeLogFindUniqueOrThrowArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChangeLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindFirstArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChangeLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogFindFirstArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindFirstOrThrowArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChangeLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangeLogs
     * const changeLogs = await prisma.changeLog.findMany()
     * 
     * // Get first 10 ChangeLogs
     * const changeLogs = await prisma.changeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeLogWithIdOnly = await prisma.changeLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChangeLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ChangeLog.
     * @param {ChangeLogCreateArgs} args - Arguments to create a ChangeLog.
     * @example
     * // Create one ChangeLog
     * const ChangeLog = await prisma.changeLog.create({
     *   data: {
     *     // ... data to create a ChangeLog
     *   }
     * })
     * 
    **/
    create<T extends ChangeLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogCreateArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ChangeLogs.
     *     @param {ChangeLogCreateManyArgs} args - Arguments to create many ChangeLogs.
     *     @example
     *     // Create many ChangeLogs
     *     const changeLog = await prisma.changeLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChangeLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChangeLog.
     * @param {ChangeLogDeleteArgs} args - Arguments to delete one ChangeLog.
     * @example
     * // Delete one ChangeLog
     * const ChangeLog = await prisma.changeLog.delete({
     *   where: {
     *     // ... filter to delete one ChangeLog
     *   }
     * })
     * 
    **/
    delete<T extends ChangeLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogDeleteArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ChangeLog.
     * @param {ChangeLogUpdateArgs} args - Arguments to update one ChangeLog.
     * @example
     * // Update one ChangeLog
     * const changeLog = await prisma.changeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChangeLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogUpdateArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ChangeLogs.
     * @param {ChangeLogDeleteManyArgs} args - Arguments to filter ChangeLogs to delete.
     * @example
     * // Delete a few ChangeLogs
     * const { count } = await prisma.changeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChangeLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChangeLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangeLogs
     * const changeLog = await prisma.changeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChangeLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChangeLog.
     * @param {ChangeLogUpsertArgs} args - Arguments to update or create a ChangeLog.
     * @example
     * // Update or create a ChangeLog
     * const changeLog = await prisma.changeLog.upsert({
     *   create: {
     *     // ... data to create a ChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangeLog we want to update
     *   }
     * })
    **/
    upsert<T extends ChangeLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ChangeLogUpsertArgs<ExtArgs>>
    ): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogCountArgs} args - Arguments to filter ChangeLogs to count.
     * @example
     * // Count the number of ChangeLogs
     * const count = await prisma.changeLog.count({
     *   where: {
     *     // ... the filter for the ChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends ChangeLogCountArgs>(
      args?: Subset<T, ChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeLogAggregateArgs>(args: Subset<T, ChangeLogAggregateArgs>): Prisma.PrismaPromise<GetChangeLogAggregateType<T>>

    /**
     * Group by ChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: ChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChangeLog model
   */
  readonly fields: ChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ChangeLog model
   */ 
  interface ChangeLogFieldRefs {
    readonly id: FieldRef<"ChangeLog", 'String'>
    readonly entityType: FieldRef<"ChangeLog", 'String'>
    readonly entityId: FieldRef<"ChangeLog", 'String'>
    readonly action: FieldRef<"ChangeLog", 'String'>
    readonly changes: FieldRef<"ChangeLog", 'Json'>
    readonly userId: FieldRef<"ChangeLog", 'String'>
    readonly timestamp: FieldRef<"ChangeLog", 'DateTime'>
    readonly description: FieldRef<"ChangeLog", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ChangeLog findUnique
   */
  export type ChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where: ChangeLogWhereUniqueInput
  }


  /**
   * ChangeLog findUniqueOrThrow
   */
  export type ChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where: ChangeLogWhereUniqueInput
  }


  /**
   * ChangeLog findFirst
   */
  export type ChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeLogs.
     */
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }


  /**
   * ChangeLog findFirstOrThrow
   */
  export type ChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeLogs.
     */
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }


  /**
   * ChangeLog findMany
   */
  export type ChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLogs to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }


  /**
   * ChangeLog create
   */
  export type ChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ChangeLog.
     */
    data: XOR<ChangeLogCreateInput, ChangeLogUncheckedCreateInput>
  }


  /**
   * ChangeLog createMany
   */
  export type ChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChangeLogs.
     */
    data: ChangeLogCreateManyInput | ChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ChangeLog update
   */
  export type ChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ChangeLog.
     */
    data: XOR<ChangeLogUpdateInput, ChangeLogUncheckedUpdateInput>
    /**
     * Choose, which ChangeLog to update.
     */
    where: ChangeLogWhereUniqueInput
  }


  /**
   * ChangeLog updateMany
   */
  export type ChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChangeLogs.
     */
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which ChangeLogs to update
     */
    where?: ChangeLogWhereInput
  }


  /**
   * ChangeLog upsert
   */
  export type ChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ChangeLog to update in case it exists.
     */
    where: ChangeLogWhereUniqueInput
    /**
     * In case the ChangeLog found by the `where` argument doesn't exist, create a new ChangeLog with this data.
     */
    create: XOR<ChangeLogCreateInput, ChangeLogUncheckedCreateInput>
    /**
     * In case the ChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeLogUpdateInput, ChangeLogUncheckedUpdateInput>
  }


  /**
   * ChangeLog delete
   */
  export type ChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter which ChangeLog to delete.
     */
    where: ChangeLogWhereUniqueInput
  }


  /**
   * ChangeLog deleteMany
   */
  export type ChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeLogs to delete
     */
    where?: ChangeLogWhereInput
  }


  /**
   * ChangeLog without action
   */
  export type ChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChangeLogInclude<ExtArgs> | null
  }



  /**
   * Model BanRecord
   */

  export type AggregateBanRecord = {
    _count: BanRecordCountAggregateOutputType | null
    _min: BanRecordMinAggregateOutputType | null
    _max: BanRecordMaxAggregateOutputType | null
  }

  export type BanRecordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bannedBy: string | null
    reason: string | null
    bannedAt: Date | null
    expiresAt: Date | null
    unbannedAt: Date | null
    unbannedBy: string | null
    active: boolean | null
  }

  export type BanRecordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bannedBy: string | null
    reason: string | null
    bannedAt: Date | null
    expiresAt: Date | null
    unbannedAt: Date | null
    unbannedBy: string | null
    active: boolean | null
  }

  export type BanRecordCountAggregateOutputType = {
    id: number
    userId: number
    bannedBy: number
    reason: number
    bannedAt: number
    expiresAt: number
    unbannedAt: number
    unbannedBy: number
    active: number
    _all: number
  }


  export type BanRecordMinAggregateInputType = {
    id?: true
    userId?: true
    bannedBy?: true
    reason?: true
    bannedAt?: true
    expiresAt?: true
    unbannedAt?: true
    unbannedBy?: true
    active?: true
  }

  export type BanRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    bannedBy?: true
    reason?: true
    bannedAt?: true
    expiresAt?: true
    unbannedAt?: true
    unbannedBy?: true
    active?: true
  }

  export type BanRecordCountAggregateInputType = {
    id?: true
    userId?: true
    bannedBy?: true
    reason?: true
    bannedAt?: true
    expiresAt?: true
    unbannedAt?: true
    unbannedBy?: true
    active?: true
    _all?: true
  }

  export type BanRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BanRecord to aggregate.
     */
    where?: BanRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanRecords to fetch.
     */
    orderBy?: BanRecordOrderByWithRelationInput | BanRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BanRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BanRecords
    **/
    _count?: true | BanRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BanRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BanRecordMaxAggregateInputType
  }

  export type GetBanRecordAggregateType<T extends BanRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateBanRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanRecord[P]>
      : GetScalarType<T[P], AggregateBanRecord[P]>
  }




  export type BanRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BanRecordWhereInput
    orderBy?: BanRecordOrderByWithAggregationInput | BanRecordOrderByWithAggregationInput[]
    by: BanRecordScalarFieldEnum[] | BanRecordScalarFieldEnum
    having?: BanRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BanRecordCountAggregateInputType | true
    _min?: BanRecordMinAggregateInputType
    _max?: BanRecordMaxAggregateInputType
  }

  export type BanRecordGroupByOutputType = {
    id: string
    userId: string
    bannedBy: string
    reason: string
    bannedAt: Date
    expiresAt: Date | null
    unbannedAt: Date | null
    unbannedBy: string | null
    active: boolean
    _count: BanRecordCountAggregateOutputType | null
    _min: BanRecordMinAggregateOutputType | null
    _max: BanRecordMaxAggregateOutputType | null
  }

  type GetBanRecordGroupByPayload<T extends BanRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BanRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BanRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BanRecordGroupByOutputType[P]>
            : GetScalarType<T[P], BanRecordGroupByOutputType[P]>
        }
      >
    >


  export type BanRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bannedBy?: boolean
    reason?: boolean
    bannedAt?: boolean
    expiresAt?: boolean
    unbannedAt?: boolean
    unbannedBy?: boolean
    active?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banRecord"]>

  export type BanRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    bannedBy?: boolean
    reason?: boolean
    bannedAt?: boolean
    expiresAt?: boolean
    unbannedAt?: boolean
    unbannedBy?: boolean
    active?: boolean
  }

  export type BanRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $BanRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BanRecord"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bannedBy: string
      reason: string
      bannedAt: Date
      expiresAt: Date | null
      unbannedAt: Date | null
      unbannedBy: string | null
      active: boolean
    }, ExtArgs["result"]["banRecord"]>
    composites: {}
  }


  type BanRecordGetPayload<S extends boolean | null | undefined | BanRecordDefaultArgs> = $Result.GetResult<Prisma.$BanRecordPayload, S>

  type BanRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BanRecordFindManyArgs, 'select' | 'include'> & {
      select?: BanRecordCountAggregateInputType | true
    }

  export interface BanRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BanRecord'], meta: { name: 'BanRecord' } }
    /**
     * Find zero or one BanRecord that matches the filter.
     * @param {BanRecordFindUniqueArgs} args - Arguments to find a BanRecord
     * @example
     * // Get one BanRecord
     * const banRecord = await prisma.banRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BanRecordFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BanRecordFindUniqueArgs<ExtArgs>>
    ): Prisma__BanRecordClient<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BanRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BanRecordFindUniqueOrThrowArgs} args - Arguments to find a BanRecord
     * @example
     * // Get one BanRecord
     * const banRecord = await prisma.banRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BanRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BanRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BanRecordClient<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BanRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanRecordFindFirstArgs} args - Arguments to find a BanRecord
     * @example
     * // Get one BanRecord
     * const banRecord = await prisma.banRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BanRecordFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BanRecordFindFirstArgs<ExtArgs>>
    ): Prisma__BanRecordClient<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BanRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanRecordFindFirstOrThrowArgs} args - Arguments to find a BanRecord
     * @example
     * // Get one BanRecord
     * const banRecord = await prisma.banRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BanRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BanRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BanRecordClient<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BanRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BanRecords
     * const banRecords = await prisma.banRecord.findMany()
     * 
     * // Get first 10 BanRecords
     * const banRecords = await prisma.banRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banRecordWithIdOnly = await prisma.banRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BanRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BanRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BanRecord.
     * @param {BanRecordCreateArgs} args - Arguments to create a BanRecord.
     * @example
     * // Create one BanRecord
     * const BanRecord = await prisma.banRecord.create({
     *   data: {
     *     // ... data to create a BanRecord
     *   }
     * })
     * 
    **/
    create<T extends BanRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BanRecordCreateArgs<ExtArgs>>
    ): Prisma__BanRecordClient<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BanRecords.
     *     @param {BanRecordCreateManyArgs} args - Arguments to create many BanRecords.
     *     @example
     *     // Create many BanRecords
     *     const banRecord = await prisma.banRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BanRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BanRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BanRecord.
     * @param {BanRecordDeleteArgs} args - Arguments to delete one BanRecord.
     * @example
     * // Delete one BanRecord
     * const BanRecord = await prisma.banRecord.delete({
     *   where: {
     *     // ... filter to delete one BanRecord
     *   }
     * })
     * 
    **/
    delete<T extends BanRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BanRecordDeleteArgs<ExtArgs>>
    ): Prisma__BanRecordClient<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BanRecord.
     * @param {BanRecordUpdateArgs} args - Arguments to update one BanRecord.
     * @example
     * // Update one BanRecord
     * const banRecord = await prisma.banRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BanRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BanRecordUpdateArgs<ExtArgs>>
    ): Prisma__BanRecordClient<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BanRecords.
     * @param {BanRecordDeleteManyArgs} args - Arguments to filter BanRecords to delete.
     * @example
     * // Delete a few BanRecords
     * const { count } = await prisma.banRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BanRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BanRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BanRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BanRecords
     * const banRecord = await prisma.banRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BanRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BanRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BanRecord.
     * @param {BanRecordUpsertArgs} args - Arguments to update or create a BanRecord.
     * @example
     * // Update or create a BanRecord
     * const banRecord = await prisma.banRecord.upsert({
     *   create: {
     *     // ... data to create a BanRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BanRecord we want to update
     *   }
     * })
    **/
    upsert<T extends BanRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BanRecordUpsertArgs<ExtArgs>>
    ): Prisma__BanRecordClient<$Result.GetResult<Prisma.$BanRecordPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BanRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanRecordCountArgs} args - Arguments to filter BanRecords to count.
     * @example
     * // Count the number of BanRecords
     * const count = await prisma.banRecord.count({
     *   where: {
     *     // ... the filter for the BanRecords we want to count
     *   }
     * })
    **/
    count<T extends BanRecordCountArgs>(
      args?: Subset<T, BanRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BanRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BanRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BanRecordAggregateArgs>(args: Subset<T, BanRecordAggregateArgs>): Prisma.PrismaPromise<GetBanRecordAggregateType<T>>

    /**
     * Group by BanRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BanRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BanRecordGroupByArgs['orderBy'] }
        : { orderBy?: BanRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BanRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BanRecord model
   */
  readonly fields: BanRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BanRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BanRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BanRecord model
   */ 
  interface BanRecordFieldRefs {
    readonly id: FieldRef<"BanRecord", 'String'>
    readonly userId: FieldRef<"BanRecord", 'String'>
    readonly bannedBy: FieldRef<"BanRecord", 'String'>
    readonly reason: FieldRef<"BanRecord", 'String'>
    readonly bannedAt: FieldRef<"BanRecord", 'DateTime'>
    readonly expiresAt: FieldRef<"BanRecord", 'DateTime'>
    readonly unbannedAt: FieldRef<"BanRecord", 'DateTime'>
    readonly unbannedBy: FieldRef<"BanRecord", 'String'>
    readonly active: FieldRef<"BanRecord", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * BanRecord findUnique
   */
  export type BanRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    /**
     * Filter, which BanRecord to fetch.
     */
    where: BanRecordWhereUniqueInput
  }


  /**
   * BanRecord findUniqueOrThrow
   */
  export type BanRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    /**
     * Filter, which BanRecord to fetch.
     */
    where: BanRecordWhereUniqueInput
  }


  /**
   * BanRecord findFirst
   */
  export type BanRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    /**
     * Filter, which BanRecord to fetch.
     */
    where?: BanRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanRecords to fetch.
     */
    orderBy?: BanRecordOrderByWithRelationInput | BanRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BanRecords.
     */
    cursor?: BanRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BanRecords.
     */
    distinct?: BanRecordScalarFieldEnum | BanRecordScalarFieldEnum[]
  }


  /**
   * BanRecord findFirstOrThrow
   */
  export type BanRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    /**
     * Filter, which BanRecord to fetch.
     */
    where?: BanRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanRecords to fetch.
     */
    orderBy?: BanRecordOrderByWithRelationInput | BanRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BanRecords.
     */
    cursor?: BanRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BanRecords.
     */
    distinct?: BanRecordScalarFieldEnum | BanRecordScalarFieldEnum[]
  }


  /**
   * BanRecord findMany
   */
  export type BanRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    /**
     * Filter, which BanRecords to fetch.
     */
    where?: BanRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanRecords to fetch.
     */
    orderBy?: BanRecordOrderByWithRelationInput | BanRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BanRecords.
     */
    cursor?: BanRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanRecords.
     */
    skip?: number
    distinct?: BanRecordScalarFieldEnum | BanRecordScalarFieldEnum[]
  }


  /**
   * BanRecord create
   */
  export type BanRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a BanRecord.
     */
    data: XOR<BanRecordCreateInput, BanRecordUncheckedCreateInput>
  }


  /**
   * BanRecord createMany
   */
  export type BanRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BanRecords.
     */
    data: BanRecordCreateManyInput | BanRecordCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BanRecord update
   */
  export type BanRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a BanRecord.
     */
    data: XOR<BanRecordUpdateInput, BanRecordUncheckedUpdateInput>
    /**
     * Choose, which BanRecord to update.
     */
    where: BanRecordWhereUniqueInput
  }


  /**
   * BanRecord updateMany
   */
  export type BanRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BanRecords.
     */
    data: XOR<BanRecordUpdateManyMutationInput, BanRecordUncheckedUpdateManyInput>
    /**
     * Filter which BanRecords to update
     */
    where?: BanRecordWhereInput
  }


  /**
   * BanRecord upsert
   */
  export type BanRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the BanRecord to update in case it exists.
     */
    where: BanRecordWhereUniqueInput
    /**
     * In case the BanRecord found by the `where` argument doesn't exist, create a new BanRecord with this data.
     */
    create: XOR<BanRecordCreateInput, BanRecordUncheckedCreateInput>
    /**
     * In case the BanRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BanRecordUpdateInput, BanRecordUncheckedUpdateInput>
  }


  /**
   * BanRecord delete
   */
  export type BanRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
    /**
     * Filter which BanRecord to delete.
     */
    where: BanRecordWhereUniqueInput
  }


  /**
   * BanRecord deleteMany
   */
  export type BanRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BanRecords to delete
     */
    where?: BanRecordWhereInput
  }


  /**
   * BanRecord without action
   */
  export type BanRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanRecord
     */
    select?: BanRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BanRecordInclude<ExtArgs> | null
  }



  /**
   * Model CharacterItem
   */

  export type AggregateCharacterItem = {
    _count: CharacterItemCountAggregateOutputType | null
    _avg: CharacterItemAvgAggregateOutputType | null
    _sum: CharacterItemSumAggregateOutputType | null
    _min: CharacterItemMinAggregateOutputType | null
    _max: CharacterItemMaxAggregateOutputType | null
  }

  export type CharacterItemAvgAggregateOutputType = {
    object_zone_id: number | null
    object_id: number | null
    condition: number | null
    charges: number | null
  }

  export type CharacterItemSumAggregateOutputType = {
    object_zone_id: number | null
    object_id: number | null
    condition: number | null
    charges: number | null
  }

  export type CharacterItemMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    object_zone_id: number | null
    object_id: number | null
    containerId: string | null
    equippedLocation: string | null
    condition: number | null
    charges: number | null
    customShortDesc: string | null
    customLongDesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterItemMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    object_zone_id: number | null
    object_id: number | null
    containerId: string | null
    equippedLocation: string | null
    condition: number | null
    charges: number | null
    customShortDesc: string | null
    customLongDesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterItemCountAggregateOutputType = {
    id: number
    characterId: number
    object_zone_id: number
    object_id: number
    containerId: number
    equippedLocation: number
    condition: number
    charges: number
    instanceFlags: number
    customShortDesc: number
    customLongDesc: number
    customValues: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CharacterItemAvgAggregateInputType = {
    object_zone_id?: true
    object_id?: true
    condition?: true
    charges?: true
  }

  export type CharacterItemSumAggregateInputType = {
    object_zone_id?: true
    object_id?: true
    condition?: true
    charges?: true
  }

  export type CharacterItemMinAggregateInputType = {
    id?: true
    characterId?: true
    object_zone_id?: true
    object_id?: true
    containerId?: true
    equippedLocation?: true
    condition?: true
    charges?: true
    customShortDesc?: true
    customLongDesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterItemMaxAggregateInputType = {
    id?: true
    characterId?: true
    object_zone_id?: true
    object_id?: true
    containerId?: true
    equippedLocation?: true
    condition?: true
    charges?: true
    customShortDesc?: true
    customLongDesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterItemCountAggregateInputType = {
    id?: true
    characterId?: true
    object_zone_id?: true
    object_id?: true
    containerId?: true
    equippedLocation?: true
    condition?: true
    charges?: true
    instanceFlags?: true
    customShortDesc?: true
    customLongDesc?: true
    customValues?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CharacterItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterItem to aggregate.
     */
    where?: CharacterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterItems to fetch.
     */
    orderBy?: CharacterItemOrderByWithRelationInput | CharacterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterItems
    **/
    _count?: true | CharacterItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterItemMaxAggregateInputType
  }

  export type GetCharacterItemAggregateType<T extends CharacterItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterItem[P]>
      : GetScalarType<T[P], AggregateCharacterItem[P]>
  }




  export type CharacterItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterItemWhereInput
    orderBy?: CharacterItemOrderByWithAggregationInput | CharacterItemOrderByWithAggregationInput[]
    by: CharacterItemScalarFieldEnum[] | CharacterItemScalarFieldEnum
    having?: CharacterItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterItemCountAggregateInputType | true
    _avg?: CharacterItemAvgAggregateInputType
    _sum?: CharacterItemSumAggregateInputType
    _min?: CharacterItemMinAggregateInputType
    _max?: CharacterItemMaxAggregateInputType
  }

  export type CharacterItemGroupByOutputType = {
    id: string
    characterId: string
    object_zone_id: number
    object_id: number
    containerId: string | null
    equippedLocation: string | null
    condition: number
    charges: number
    instanceFlags: string[]
    customShortDesc: string | null
    customLongDesc: string | null
    customValues: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CharacterItemCountAggregateOutputType | null
    _avg: CharacterItemAvgAggregateOutputType | null
    _sum: CharacterItemSumAggregateOutputType | null
    _min: CharacterItemMinAggregateOutputType | null
    _max: CharacterItemMaxAggregateOutputType | null
  }

  type GetCharacterItemGroupByPayload<T extends CharacterItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterItemGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterItemGroupByOutputType[P]>
        }
      >
    >


  export type CharacterItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    object_zone_id?: boolean
    object_id?: boolean
    containerId?: boolean
    equippedLocation?: boolean
    condition?: boolean
    charges?: boolean
    instanceFlags?: boolean
    customShortDesc?: boolean
    customLongDesc?: boolean
    customValues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    container?: boolean | CharacterItem$containerArgs<ExtArgs>
    containedItems?: boolean | CharacterItem$containedItemsArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    _count?: boolean | CharacterItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterItem"]>

  export type CharacterItemSelectScalar = {
    id?: boolean
    characterId?: boolean
    object_zone_id?: boolean
    object_id?: boolean
    containerId?: boolean
    equippedLocation?: boolean
    condition?: boolean
    charges?: boolean
    instanceFlags?: boolean
    customShortDesc?: boolean
    customLongDesc?: boolean
    customValues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CharacterItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    container?: boolean | CharacterItem$containerArgs<ExtArgs>
    containedItems?: boolean | CharacterItem$containedItemsArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    _count?: boolean | CharacterItemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CharacterItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterItem"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
      container: Prisma.$CharacterItemPayload<ExtArgs> | null
      containedItems: Prisma.$CharacterItemPayload<ExtArgs>[]
      object: Prisma.$ObjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      object_zone_id: number
      object_id: number
      containerId: string | null
      equippedLocation: string | null
      condition: number
      charges: number
      instanceFlags: string[]
      customShortDesc: string | null
      customLongDesc: string | null
      customValues: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["characterItem"]>
    composites: {}
  }


  type CharacterItemGetPayload<S extends boolean | null | undefined | CharacterItemDefaultArgs> = $Result.GetResult<Prisma.$CharacterItemPayload, S>

  type CharacterItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterItemFindManyArgs, 'select' | 'include'> & {
      select?: CharacterItemCountAggregateInputType | true
    }

  export interface CharacterItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterItem'], meta: { name: 'CharacterItem' } }
    /**
     * Find zero or one CharacterItem that matches the filter.
     * @param {CharacterItemFindUniqueArgs} args - Arguments to find a CharacterItem
     * @example
     * // Get one CharacterItem
     * const characterItem = await prisma.characterItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterItemFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterItemClient<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CharacterItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterItemFindUniqueOrThrowArgs} args - Arguments to find a CharacterItem
     * @example
     * // Get one CharacterItem
     * const characterItem = await prisma.characterItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterItemClient<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CharacterItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterItemFindFirstArgs} args - Arguments to find a CharacterItem
     * @example
     * // Get one CharacterItem
     * const characterItem = await prisma.characterItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterItemFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterItemClient<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CharacterItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterItemFindFirstOrThrowArgs} args - Arguments to find a CharacterItem
     * @example
     * // Get one CharacterItem
     * const characterItem = await prisma.characterItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterItemClient<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CharacterItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterItems
     * const characterItems = await prisma.characterItem.findMany()
     * 
     * // Get first 10 CharacterItems
     * const characterItems = await prisma.characterItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterItemWithIdOnly = await prisma.characterItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CharacterItem.
     * @param {CharacterItemCreateArgs} args - Arguments to create a CharacterItem.
     * @example
     * // Create one CharacterItem
     * const CharacterItem = await prisma.characterItem.create({
     *   data: {
     *     // ... data to create a CharacterItem
     *   }
     * })
     * 
    **/
    create<T extends CharacterItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterItemCreateArgs<ExtArgs>>
    ): Prisma__CharacterItemClient<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CharacterItems.
     *     @param {CharacterItemCreateManyArgs} args - Arguments to create many CharacterItems.
     *     @example
     *     // Create many CharacterItems
     *     const characterItem = await prisma.characterItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CharacterItem.
     * @param {CharacterItemDeleteArgs} args - Arguments to delete one CharacterItem.
     * @example
     * // Delete one CharacterItem
     * const CharacterItem = await prisma.characterItem.delete({
     *   where: {
     *     // ... filter to delete one CharacterItem
     *   }
     * })
     * 
    **/
    delete<T extends CharacterItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterItemDeleteArgs<ExtArgs>>
    ): Prisma__CharacterItemClient<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CharacterItem.
     * @param {CharacterItemUpdateArgs} args - Arguments to update one CharacterItem.
     * @example
     * // Update one CharacterItem
     * const characterItem = await prisma.characterItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterItemUpdateArgs<ExtArgs>>
    ): Prisma__CharacterItemClient<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CharacterItems.
     * @param {CharacterItemDeleteManyArgs} args - Arguments to filter CharacterItems to delete.
     * @example
     * // Delete a few CharacterItems
     * const { count } = await prisma.characterItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterItems
     * const characterItem = await prisma.characterItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterItem.
     * @param {CharacterItemUpsertArgs} args - Arguments to update or create a CharacterItem.
     * @example
     * // Update or create a CharacterItem
     * const characterItem = await prisma.characterItem.upsert({
     *   create: {
     *     // ... data to create a CharacterItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterItem we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterItemUpsertArgs<ExtArgs>>
    ): Prisma__CharacterItemClient<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CharacterItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterItemCountArgs} args - Arguments to filter CharacterItems to count.
     * @example
     * // Count the number of CharacterItems
     * const count = await prisma.characterItem.count({
     *   where: {
     *     // ... the filter for the CharacterItems we want to count
     *   }
     * })
    **/
    count<T extends CharacterItemCountArgs>(
      args?: Subset<T, CharacterItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterItemAggregateArgs>(args: Subset<T, CharacterItemAggregateArgs>): Prisma.PrismaPromise<GetCharacterItemAggregateType<T>>

    /**
     * Group by CharacterItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterItemGroupByArgs['orderBy'] }
        : { orderBy?: CharacterItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterItem model
   */
  readonly fields: CharacterItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    container<T extends CharacterItem$containerArgs<ExtArgs> = {}>(args?: Subset<T, CharacterItem$containerArgs<ExtArgs>>): Prisma__CharacterItemClient<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    containedItems<T extends CharacterItem$containedItemsArgs<ExtArgs> = {}>(args?: Subset<T, CharacterItem$containedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CharacterItem model
   */ 
  interface CharacterItemFieldRefs {
    readonly id: FieldRef<"CharacterItem", 'String'>
    readonly characterId: FieldRef<"CharacterItem", 'String'>
    readonly object_zone_id: FieldRef<"CharacterItem", 'Int'>
    readonly object_id: FieldRef<"CharacterItem", 'Int'>
    readonly containerId: FieldRef<"CharacterItem", 'String'>
    readonly equippedLocation: FieldRef<"CharacterItem", 'String'>
    readonly condition: FieldRef<"CharacterItem", 'Int'>
    readonly charges: FieldRef<"CharacterItem", 'Int'>
    readonly instanceFlags: FieldRef<"CharacterItem", 'String[]'>
    readonly customShortDesc: FieldRef<"CharacterItem", 'String'>
    readonly customLongDesc: FieldRef<"CharacterItem", 'String'>
    readonly customValues: FieldRef<"CharacterItem", 'Json'>
    readonly createdAt: FieldRef<"CharacterItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CharacterItem", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CharacterItem findUnique
   */
  export type CharacterItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    /**
     * Filter, which CharacterItem to fetch.
     */
    where: CharacterItemWhereUniqueInput
  }


  /**
   * CharacterItem findUniqueOrThrow
   */
  export type CharacterItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    /**
     * Filter, which CharacterItem to fetch.
     */
    where: CharacterItemWhereUniqueInput
  }


  /**
   * CharacterItem findFirst
   */
  export type CharacterItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    /**
     * Filter, which CharacterItem to fetch.
     */
    where?: CharacterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterItems to fetch.
     */
    orderBy?: CharacterItemOrderByWithRelationInput | CharacterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterItems.
     */
    cursor?: CharacterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterItems.
     */
    distinct?: CharacterItemScalarFieldEnum | CharacterItemScalarFieldEnum[]
  }


  /**
   * CharacterItem findFirstOrThrow
   */
  export type CharacterItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    /**
     * Filter, which CharacterItem to fetch.
     */
    where?: CharacterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterItems to fetch.
     */
    orderBy?: CharacterItemOrderByWithRelationInput | CharacterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterItems.
     */
    cursor?: CharacterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterItems.
     */
    distinct?: CharacterItemScalarFieldEnum | CharacterItemScalarFieldEnum[]
  }


  /**
   * CharacterItem findMany
   */
  export type CharacterItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    /**
     * Filter, which CharacterItems to fetch.
     */
    where?: CharacterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterItems to fetch.
     */
    orderBy?: CharacterItemOrderByWithRelationInput | CharacterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterItems.
     */
    cursor?: CharacterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterItems.
     */
    skip?: number
    distinct?: CharacterItemScalarFieldEnum | CharacterItemScalarFieldEnum[]
  }


  /**
   * CharacterItem create
   */
  export type CharacterItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterItem.
     */
    data: XOR<CharacterItemCreateInput, CharacterItemUncheckedCreateInput>
  }


  /**
   * CharacterItem createMany
   */
  export type CharacterItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterItems.
     */
    data: CharacterItemCreateManyInput | CharacterItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CharacterItem update
   */
  export type CharacterItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterItem.
     */
    data: XOR<CharacterItemUpdateInput, CharacterItemUncheckedUpdateInput>
    /**
     * Choose, which CharacterItem to update.
     */
    where: CharacterItemWhereUniqueInput
  }


  /**
   * CharacterItem updateMany
   */
  export type CharacterItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterItems.
     */
    data: XOR<CharacterItemUpdateManyMutationInput, CharacterItemUncheckedUpdateManyInput>
    /**
     * Filter which CharacterItems to update
     */
    where?: CharacterItemWhereInput
  }


  /**
   * CharacterItem upsert
   */
  export type CharacterItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterItem to update in case it exists.
     */
    where: CharacterItemWhereUniqueInput
    /**
     * In case the CharacterItem found by the `where` argument doesn't exist, create a new CharacterItem with this data.
     */
    create: XOR<CharacterItemCreateInput, CharacterItemUncheckedCreateInput>
    /**
     * In case the CharacterItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterItemUpdateInput, CharacterItemUncheckedUpdateInput>
  }


  /**
   * CharacterItem delete
   */
  export type CharacterItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    /**
     * Filter which CharacterItem to delete.
     */
    where: CharacterItemWhereUniqueInput
  }


  /**
   * CharacterItem deleteMany
   */
  export type CharacterItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterItems to delete
     */
    where?: CharacterItemWhereInput
  }


  /**
   * CharacterItem.container
   */
  export type CharacterItem$containerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    where?: CharacterItemWhereInput
  }


  /**
   * CharacterItem.containedItems
   */
  export type CharacterItem$containedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
    where?: CharacterItemWhereInput
    orderBy?: CharacterItemOrderByWithRelationInput | CharacterItemOrderByWithRelationInput[]
    cursor?: CharacterItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterItemScalarFieldEnum | CharacterItemScalarFieldEnum[]
  }


  /**
   * CharacterItem without action
   */
  export type CharacterItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterItem
     */
    select?: CharacterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterItemInclude<ExtArgs> | null
  }



  /**
   * Model CharacterEffect
   */

  export type AggregateCharacterEffect = {
    _count: CharacterEffectCountAggregateOutputType | null
    _avg: CharacterEffectAvgAggregateOutputType | null
    _sum: CharacterEffectSumAggregateOutputType | null
    _min: CharacterEffectMinAggregateOutputType | null
    _max: CharacterEffectMaxAggregateOutputType | null
  }

  export type CharacterEffectAvgAggregateOutputType = {
    duration: number | null
    strength: number | null
    sourceId: number | null
  }

  export type CharacterEffectSumAggregateOutputType = {
    duration: number | null
    strength: number | null
    sourceId: number | null
  }

  export type CharacterEffectMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    effectName: string | null
    effectType: string | null
    duration: number | null
    strength: number | null
    sourceType: string | null
    sourceId: number | null
    appliedAt: Date | null
    expiresAt: Date | null
  }

  export type CharacterEffectMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    effectName: string | null
    effectType: string | null
    duration: number | null
    strength: number | null
    sourceType: string | null
    sourceId: number | null
    appliedAt: Date | null
    expiresAt: Date | null
  }

  export type CharacterEffectCountAggregateOutputType = {
    id: number
    characterId: number
    effectName: number
    effectType: number
    duration: number
    strength: number
    modifierData: number
    sourceType: number
    sourceId: number
    appliedAt: number
    expiresAt: number
    _all: number
  }


  export type CharacterEffectAvgAggregateInputType = {
    duration?: true
    strength?: true
    sourceId?: true
  }

  export type CharacterEffectSumAggregateInputType = {
    duration?: true
    strength?: true
    sourceId?: true
  }

  export type CharacterEffectMinAggregateInputType = {
    id?: true
    characterId?: true
    effectName?: true
    effectType?: true
    duration?: true
    strength?: true
    sourceType?: true
    sourceId?: true
    appliedAt?: true
    expiresAt?: true
  }

  export type CharacterEffectMaxAggregateInputType = {
    id?: true
    characterId?: true
    effectName?: true
    effectType?: true
    duration?: true
    strength?: true
    sourceType?: true
    sourceId?: true
    appliedAt?: true
    expiresAt?: true
  }

  export type CharacterEffectCountAggregateInputType = {
    id?: true
    characterId?: true
    effectName?: true
    effectType?: true
    duration?: true
    strength?: true
    modifierData?: true
    sourceType?: true
    sourceId?: true
    appliedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type CharacterEffectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterEffect to aggregate.
     */
    where?: CharacterEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEffects to fetch.
     */
    orderBy?: CharacterEffectOrderByWithRelationInput | CharacterEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterEffects
    **/
    _count?: true | CharacterEffectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterEffectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterEffectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterEffectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterEffectMaxAggregateInputType
  }

  export type GetCharacterEffectAggregateType<T extends CharacterEffectAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterEffect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterEffect[P]>
      : GetScalarType<T[P], AggregateCharacterEffect[P]>
  }




  export type CharacterEffectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterEffectWhereInput
    orderBy?: CharacterEffectOrderByWithAggregationInput | CharacterEffectOrderByWithAggregationInput[]
    by: CharacterEffectScalarFieldEnum[] | CharacterEffectScalarFieldEnum
    having?: CharacterEffectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterEffectCountAggregateInputType | true
    _avg?: CharacterEffectAvgAggregateInputType
    _sum?: CharacterEffectSumAggregateInputType
    _min?: CharacterEffectMinAggregateInputType
    _max?: CharacterEffectMaxAggregateInputType
  }

  export type CharacterEffectGroupByOutputType = {
    id: string
    characterId: string
    effectName: string
    effectType: string | null
    duration: number | null
    strength: number
    modifierData: JsonValue
    sourceType: string | null
    sourceId: number | null
    appliedAt: Date
    expiresAt: Date | null
    _count: CharacterEffectCountAggregateOutputType | null
    _avg: CharacterEffectAvgAggregateOutputType | null
    _sum: CharacterEffectSumAggregateOutputType | null
    _min: CharacterEffectMinAggregateOutputType | null
    _max: CharacterEffectMaxAggregateOutputType | null
  }

  type GetCharacterEffectGroupByPayload<T extends CharacterEffectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterEffectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterEffectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterEffectGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterEffectGroupByOutputType[P]>
        }
      >
    >


  export type CharacterEffectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    effectName?: boolean
    effectType?: boolean
    duration?: boolean
    strength?: boolean
    modifierData?: boolean
    sourceType?: boolean
    sourceId?: boolean
    appliedAt?: boolean
    expiresAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterEffect"]>

  export type CharacterEffectSelectScalar = {
    id?: boolean
    characterId?: boolean
    effectName?: boolean
    effectType?: boolean
    duration?: boolean
    strength?: boolean
    modifierData?: boolean
    sourceType?: boolean
    sourceId?: boolean
    appliedAt?: boolean
    expiresAt?: boolean
  }

  export type CharacterEffectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }


  export type $CharacterEffectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterEffect"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      effectName: string
      effectType: string | null
      duration: number | null
      strength: number
      modifierData: Prisma.JsonValue
      sourceType: string | null
      sourceId: number | null
      appliedAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["characterEffect"]>
    composites: {}
  }


  type CharacterEffectGetPayload<S extends boolean | null | undefined | CharacterEffectDefaultArgs> = $Result.GetResult<Prisma.$CharacterEffectPayload, S>

  type CharacterEffectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterEffectFindManyArgs, 'select' | 'include'> & {
      select?: CharacterEffectCountAggregateInputType | true
    }

  export interface CharacterEffectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterEffect'], meta: { name: 'CharacterEffect' } }
    /**
     * Find zero or one CharacterEffect that matches the filter.
     * @param {CharacterEffectFindUniqueArgs} args - Arguments to find a CharacterEffect
     * @example
     * // Get one CharacterEffect
     * const characterEffect = await prisma.characterEffect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterEffectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEffectFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterEffectClient<$Result.GetResult<Prisma.$CharacterEffectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CharacterEffect that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterEffectFindUniqueOrThrowArgs} args - Arguments to find a CharacterEffect
     * @example
     * // Get one CharacterEffect
     * const characterEffect = await prisma.characterEffect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterEffectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEffectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterEffectClient<$Result.GetResult<Prisma.$CharacterEffectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CharacterEffect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEffectFindFirstArgs} args - Arguments to find a CharacterEffect
     * @example
     * // Get one CharacterEffect
     * const characterEffect = await prisma.characterEffect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterEffectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEffectFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterEffectClient<$Result.GetResult<Prisma.$CharacterEffectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CharacterEffect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEffectFindFirstOrThrowArgs} args - Arguments to find a CharacterEffect
     * @example
     * // Get one CharacterEffect
     * const characterEffect = await prisma.characterEffect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterEffectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEffectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterEffectClient<$Result.GetResult<Prisma.$CharacterEffectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CharacterEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEffectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterEffects
     * const characterEffects = await prisma.characterEffect.findMany()
     * 
     * // Get first 10 CharacterEffects
     * const characterEffects = await prisma.characterEffect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterEffectWithIdOnly = await prisma.characterEffect.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CharacterEffectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEffectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterEffectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CharacterEffect.
     * @param {CharacterEffectCreateArgs} args - Arguments to create a CharacterEffect.
     * @example
     * // Create one CharacterEffect
     * const CharacterEffect = await prisma.characterEffect.create({
     *   data: {
     *     // ... data to create a CharacterEffect
     *   }
     * })
     * 
    **/
    create<T extends CharacterEffectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEffectCreateArgs<ExtArgs>>
    ): Prisma__CharacterEffectClient<$Result.GetResult<Prisma.$CharacterEffectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CharacterEffects.
     *     @param {CharacterEffectCreateManyArgs} args - Arguments to create many CharacterEffects.
     *     @example
     *     // Create many CharacterEffects
     *     const characterEffect = await prisma.characterEffect.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterEffectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEffectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CharacterEffect.
     * @param {CharacterEffectDeleteArgs} args - Arguments to delete one CharacterEffect.
     * @example
     * // Delete one CharacterEffect
     * const CharacterEffect = await prisma.characterEffect.delete({
     *   where: {
     *     // ... filter to delete one CharacterEffect
     *   }
     * })
     * 
    **/
    delete<T extends CharacterEffectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEffectDeleteArgs<ExtArgs>>
    ): Prisma__CharacterEffectClient<$Result.GetResult<Prisma.$CharacterEffectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CharacterEffect.
     * @param {CharacterEffectUpdateArgs} args - Arguments to update one CharacterEffect.
     * @example
     * // Update one CharacterEffect
     * const characterEffect = await prisma.characterEffect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterEffectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEffectUpdateArgs<ExtArgs>>
    ): Prisma__CharacterEffectClient<$Result.GetResult<Prisma.$CharacterEffectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CharacterEffects.
     * @param {CharacterEffectDeleteManyArgs} args - Arguments to filter CharacterEffects to delete.
     * @example
     * // Delete a few CharacterEffects
     * const { count } = await prisma.characterEffect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterEffectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterEffectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEffectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterEffects
     * const characterEffect = await prisma.characterEffect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterEffectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEffectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterEffect.
     * @param {CharacterEffectUpsertArgs} args - Arguments to update or create a CharacterEffect.
     * @example
     * // Update or create a CharacterEffect
     * const characterEffect = await prisma.characterEffect.upsert({
     *   create: {
     *     // ... data to create a CharacterEffect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterEffect we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterEffectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterEffectUpsertArgs<ExtArgs>>
    ): Prisma__CharacterEffectClient<$Result.GetResult<Prisma.$CharacterEffectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CharacterEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEffectCountArgs} args - Arguments to filter CharacterEffects to count.
     * @example
     * // Count the number of CharacterEffects
     * const count = await prisma.characterEffect.count({
     *   where: {
     *     // ... the filter for the CharacterEffects we want to count
     *   }
     * })
    **/
    count<T extends CharacterEffectCountArgs>(
      args?: Subset<T, CharacterEffectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterEffectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterEffect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEffectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterEffectAggregateArgs>(args: Subset<T, CharacterEffectAggregateArgs>): Prisma.PrismaPromise<GetCharacterEffectAggregateType<T>>

    /**
     * Group by CharacterEffect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEffectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterEffectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterEffectGroupByArgs['orderBy'] }
        : { orderBy?: CharacterEffectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterEffectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterEffectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterEffect model
   */
  readonly fields: CharacterEffectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterEffect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterEffectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CharacterEffect model
   */ 
  interface CharacterEffectFieldRefs {
    readonly id: FieldRef<"CharacterEffect", 'String'>
    readonly characterId: FieldRef<"CharacterEffect", 'String'>
    readonly effectName: FieldRef<"CharacterEffect", 'String'>
    readonly effectType: FieldRef<"CharacterEffect", 'String'>
    readonly duration: FieldRef<"CharacterEffect", 'Int'>
    readonly strength: FieldRef<"CharacterEffect", 'Int'>
    readonly modifierData: FieldRef<"CharacterEffect", 'Json'>
    readonly sourceType: FieldRef<"CharacterEffect", 'String'>
    readonly sourceId: FieldRef<"CharacterEffect", 'Int'>
    readonly appliedAt: FieldRef<"CharacterEffect", 'DateTime'>
    readonly expiresAt: FieldRef<"CharacterEffect", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CharacterEffect findUnique
   */
  export type CharacterEffectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEffect to fetch.
     */
    where: CharacterEffectWhereUniqueInput
  }


  /**
   * CharacterEffect findUniqueOrThrow
   */
  export type CharacterEffectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEffect to fetch.
     */
    where: CharacterEffectWhereUniqueInput
  }


  /**
   * CharacterEffect findFirst
   */
  export type CharacterEffectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEffect to fetch.
     */
    where?: CharacterEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEffects to fetch.
     */
    orderBy?: CharacterEffectOrderByWithRelationInput | CharacterEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterEffects.
     */
    cursor?: CharacterEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterEffects.
     */
    distinct?: CharacterEffectScalarFieldEnum | CharacterEffectScalarFieldEnum[]
  }


  /**
   * CharacterEffect findFirstOrThrow
   */
  export type CharacterEffectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEffect to fetch.
     */
    where?: CharacterEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEffects to fetch.
     */
    orderBy?: CharacterEffectOrderByWithRelationInput | CharacterEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterEffects.
     */
    cursor?: CharacterEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterEffects.
     */
    distinct?: CharacterEffectScalarFieldEnum | CharacterEffectScalarFieldEnum[]
  }


  /**
   * CharacterEffect findMany
   */
  export type CharacterEffectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEffects to fetch.
     */
    where?: CharacterEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEffects to fetch.
     */
    orderBy?: CharacterEffectOrderByWithRelationInput | CharacterEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterEffects.
     */
    cursor?: CharacterEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEffects.
     */
    skip?: number
    distinct?: CharacterEffectScalarFieldEnum | CharacterEffectScalarFieldEnum[]
  }


  /**
   * CharacterEffect create
   */
  export type CharacterEffectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterEffect.
     */
    data: XOR<CharacterEffectCreateInput, CharacterEffectUncheckedCreateInput>
  }


  /**
   * CharacterEffect createMany
   */
  export type CharacterEffectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterEffects.
     */
    data: CharacterEffectCreateManyInput | CharacterEffectCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CharacterEffect update
   */
  export type CharacterEffectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterEffect.
     */
    data: XOR<CharacterEffectUpdateInput, CharacterEffectUncheckedUpdateInput>
    /**
     * Choose, which CharacterEffect to update.
     */
    where: CharacterEffectWhereUniqueInput
  }


  /**
   * CharacterEffect updateMany
   */
  export type CharacterEffectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterEffects.
     */
    data: XOR<CharacterEffectUpdateManyMutationInput, CharacterEffectUncheckedUpdateManyInput>
    /**
     * Filter which CharacterEffects to update
     */
    where?: CharacterEffectWhereInput
  }


  /**
   * CharacterEffect upsert
   */
  export type CharacterEffectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterEffect to update in case it exists.
     */
    where: CharacterEffectWhereUniqueInput
    /**
     * In case the CharacterEffect found by the `where` argument doesn't exist, create a new CharacterEffect with this data.
     */
    create: XOR<CharacterEffectCreateInput, CharacterEffectUncheckedCreateInput>
    /**
     * In case the CharacterEffect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterEffectUpdateInput, CharacterEffectUncheckedUpdateInput>
  }


  /**
   * CharacterEffect delete
   */
  export type CharacterEffectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
    /**
     * Filter which CharacterEffect to delete.
     */
    where: CharacterEffectWhereUniqueInput
  }


  /**
   * CharacterEffect deleteMany
   */
  export type CharacterEffectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterEffects to delete
     */
    where?: CharacterEffectWhereInput
  }


  /**
   * CharacterEffect without action
   */
  export type CharacterEffectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEffect
     */
    select?: CharacterEffectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CharacterEffectInclude<ExtArgs> | null
  }



  /**
   * Model EquipmentSetItem
   */

  export type AggregateEquipmentSetItem = {
    _count: EquipmentSetItemCountAggregateOutputType | null
    _avg: EquipmentSetItemAvgAggregateOutputType | null
    _sum: EquipmentSetItemSumAggregateOutputType | null
    _min: EquipmentSetItemMinAggregateOutputType | null
    _max: EquipmentSetItemMaxAggregateOutputType | null
  }

  export type EquipmentSetItemAvgAggregateOutputType = {
    objectZoneId: number | null
    objectId: number | null
    quantity: number | null
    probability: number | null
  }

  export type EquipmentSetItemSumAggregateOutputType = {
    objectZoneId: number | null
    objectId: number | null
    quantity: number | null
    probability: number | null
  }

  export type EquipmentSetItemMinAggregateOutputType = {
    id: string | null
    equipmentSetId: string | null
    objectZoneId: number | null
    objectId: number | null
    slot: string | null
    quantity: number | null
    probability: number | null
  }

  export type EquipmentSetItemMaxAggregateOutputType = {
    id: string | null
    equipmentSetId: string | null
    objectZoneId: number | null
    objectId: number | null
    slot: string | null
    quantity: number | null
    probability: number | null
  }

  export type EquipmentSetItemCountAggregateOutputType = {
    id: number
    equipmentSetId: number
    objectZoneId: number
    objectId: number
    slot: number
    quantity: number
    probability: number
    _all: number
  }


  export type EquipmentSetItemAvgAggregateInputType = {
    objectZoneId?: true
    objectId?: true
    quantity?: true
    probability?: true
  }

  export type EquipmentSetItemSumAggregateInputType = {
    objectZoneId?: true
    objectId?: true
    quantity?: true
    probability?: true
  }

  export type EquipmentSetItemMinAggregateInputType = {
    id?: true
    equipmentSetId?: true
    objectZoneId?: true
    objectId?: true
    slot?: true
    quantity?: true
    probability?: true
  }

  export type EquipmentSetItemMaxAggregateInputType = {
    id?: true
    equipmentSetId?: true
    objectZoneId?: true
    objectId?: true
    slot?: true
    quantity?: true
    probability?: true
  }

  export type EquipmentSetItemCountAggregateInputType = {
    id?: true
    equipmentSetId?: true
    objectZoneId?: true
    objectId?: true
    slot?: true
    quantity?: true
    probability?: true
    _all?: true
  }

  export type EquipmentSetItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentSetItem to aggregate.
     */
    where?: EquipmentSetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentSetItems to fetch.
     */
    orderBy?: EquipmentSetItemOrderByWithRelationInput | EquipmentSetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentSetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentSetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentSetItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentSetItems
    **/
    _count?: true | EquipmentSetItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentSetItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSetItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentSetItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentSetItemMaxAggregateInputType
  }

  export type GetEquipmentSetItemAggregateType<T extends EquipmentSetItemAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentSetItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentSetItem[P]>
      : GetScalarType<T[P], AggregateEquipmentSetItem[P]>
  }




  export type EquipmentSetItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentSetItemWhereInput
    orderBy?: EquipmentSetItemOrderByWithAggregationInput | EquipmentSetItemOrderByWithAggregationInput[]
    by: EquipmentSetItemScalarFieldEnum[] | EquipmentSetItemScalarFieldEnum
    having?: EquipmentSetItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentSetItemCountAggregateInputType | true
    _avg?: EquipmentSetItemAvgAggregateInputType
    _sum?: EquipmentSetItemSumAggregateInputType
    _min?: EquipmentSetItemMinAggregateInputType
    _max?: EquipmentSetItemMaxAggregateInputType
  }

  export type EquipmentSetItemGroupByOutputType = {
    id: string
    equipmentSetId: string
    objectZoneId: number
    objectId: number
    slot: string | null
    quantity: number
    probability: number
    _count: EquipmentSetItemCountAggregateOutputType | null
    _avg: EquipmentSetItemAvgAggregateOutputType | null
    _sum: EquipmentSetItemSumAggregateOutputType | null
    _min: EquipmentSetItemMinAggregateOutputType | null
    _max: EquipmentSetItemMaxAggregateOutputType | null
  }

  type GetEquipmentSetItemGroupByPayload<T extends EquipmentSetItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentSetItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentSetItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentSetItemGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentSetItemGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSetItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentSetId?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    slot?: boolean
    quantity?: boolean
    probability?: boolean
    equipmentSet?: boolean | EquipmentSetDefaultArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentSetItem"]>

  export type EquipmentSetItemSelectScalar = {
    id?: boolean
    equipmentSetId?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    slot?: boolean
    quantity?: boolean
    probability?: boolean
  }

  export type EquipmentSetItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipmentSet?: boolean | EquipmentSetDefaultArgs<ExtArgs>
    object?: boolean | ObjectDefaultArgs<ExtArgs>
  }


  export type $EquipmentSetItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentSetItem"
    objects: {
      equipmentSet: Prisma.$EquipmentSetPayload<ExtArgs>
      object: Prisma.$ObjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentSetId: string
      objectZoneId: number
      objectId: number
      slot: string | null
      quantity: number
      probability: number
    }, ExtArgs["result"]["equipmentSetItem"]>
    composites: {}
  }


  type EquipmentSetItemGetPayload<S extends boolean | null | undefined | EquipmentSetItemDefaultArgs> = $Result.GetResult<Prisma.$EquipmentSetItemPayload, S>

  type EquipmentSetItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EquipmentSetItemFindManyArgs, 'select' | 'include'> & {
      select?: EquipmentSetItemCountAggregateInputType | true
    }

  export interface EquipmentSetItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentSetItem'], meta: { name: 'EquipmentSetItem' } }
    /**
     * Find zero or one EquipmentSetItem that matches the filter.
     * @param {EquipmentSetItemFindUniqueArgs} args - Arguments to find a EquipmentSetItem
     * @example
     * // Get one EquipmentSetItem
     * const equipmentSetItem = await prisma.equipmentSetItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EquipmentSetItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetItemFindUniqueArgs<ExtArgs>>
    ): Prisma__EquipmentSetItemClient<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EquipmentSetItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EquipmentSetItemFindUniqueOrThrowArgs} args - Arguments to find a EquipmentSetItem
     * @example
     * // Get one EquipmentSetItem
     * const equipmentSetItem = await prisma.equipmentSetItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EquipmentSetItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EquipmentSetItemClient<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EquipmentSetItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetItemFindFirstArgs} args - Arguments to find a EquipmentSetItem
     * @example
     * // Get one EquipmentSetItem
     * const equipmentSetItem = await prisma.equipmentSetItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EquipmentSetItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetItemFindFirstArgs<ExtArgs>>
    ): Prisma__EquipmentSetItemClient<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EquipmentSetItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetItemFindFirstOrThrowArgs} args - Arguments to find a EquipmentSetItem
     * @example
     * // Get one EquipmentSetItem
     * const equipmentSetItem = await prisma.equipmentSetItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EquipmentSetItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EquipmentSetItemClient<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EquipmentSetItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentSetItems
     * const equipmentSetItems = await prisma.equipmentSetItem.findMany()
     * 
     * // Get first 10 EquipmentSetItems
     * const equipmentSetItems = await prisma.equipmentSetItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentSetItemWithIdOnly = await prisma.equipmentSetItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EquipmentSetItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EquipmentSetItem.
     * @param {EquipmentSetItemCreateArgs} args - Arguments to create a EquipmentSetItem.
     * @example
     * // Create one EquipmentSetItem
     * const EquipmentSetItem = await prisma.equipmentSetItem.create({
     *   data: {
     *     // ... data to create a EquipmentSetItem
     *   }
     * })
     * 
    **/
    create<T extends EquipmentSetItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetItemCreateArgs<ExtArgs>>
    ): Prisma__EquipmentSetItemClient<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EquipmentSetItems.
     *     @param {EquipmentSetItemCreateManyArgs} args - Arguments to create many EquipmentSetItems.
     *     @example
     *     // Create many EquipmentSetItems
     *     const equipmentSetItem = await prisma.equipmentSetItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EquipmentSetItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EquipmentSetItem.
     * @param {EquipmentSetItemDeleteArgs} args - Arguments to delete one EquipmentSetItem.
     * @example
     * // Delete one EquipmentSetItem
     * const EquipmentSetItem = await prisma.equipmentSetItem.delete({
     *   where: {
     *     // ... filter to delete one EquipmentSetItem
     *   }
     * })
     * 
    **/
    delete<T extends EquipmentSetItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetItemDeleteArgs<ExtArgs>>
    ): Prisma__EquipmentSetItemClient<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EquipmentSetItem.
     * @param {EquipmentSetItemUpdateArgs} args - Arguments to update one EquipmentSetItem.
     * @example
     * // Update one EquipmentSetItem
     * const equipmentSetItem = await prisma.equipmentSetItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EquipmentSetItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetItemUpdateArgs<ExtArgs>>
    ): Prisma__EquipmentSetItemClient<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EquipmentSetItems.
     * @param {EquipmentSetItemDeleteManyArgs} args - Arguments to filter EquipmentSetItems to delete.
     * @example
     * // Delete a few EquipmentSetItems
     * const { count } = await prisma.equipmentSetItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EquipmentSetItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentSetItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentSetItems
     * const equipmentSetItem = await prisma.equipmentSetItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EquipmentSetItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EquipmentSetItem.
     * @param {EquipmentSetItemUpsertArgs} args - Arguments to update or create a EquipmentSetItem.
     * @example
     * // Update or create a EquipmentSetItem
     * const equipmentSetItem = await prisma.equipmentSetItem.upsert({
     *   create: {
     *     // ... data to create a EquipmentSetItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentSetItem we want to update
     *   }
     * })
    **/
    upsert<T extends EquipmentSetItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetItemUpsertArgs<ExtArgs>>
    ): Prisma__EquipmentSetItemClient<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EquipmentSetItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetItemCountArgs} args - Arguments to filter EquipmentSetItems to count.
     * @example
     * // Count the number of EquipmentSetItems
     * const count = await prisma.equipmentSetItem.count({
     *   where: {
     *     // ... the filter for the EquipmentSetItems we want to count
     *   }
     * })
    **/
    count<T extends EquipmentSetItemCountArgs>(
      args?: Subset<T, EquipmentSetItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentSetItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentSetItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentSetItemAggregateArgs>(args: Subset<T, EquipmentSetItemAggregateArgs>): Prisma.PrismaPromise<GetEquipmentSetItemAggregateType<T>>

    /**
     * Group by EquipmentSetItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentSetItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentSetItemGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentSetItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentSetItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentSetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentSetItem model
   */
  readonly fields: EquipmentSetItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentSetItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentSetItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    equipmentSet<T extends EquipmentSetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentSetDefaultArgs<ExtArgs>>): Prisma__EquipmentSetClient<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EquipmentSetItem model
   */ 
  interface EquipmentSetItemFieldRefs {
    readonly id: FieldRef<"EquipmentSetItem", 'String'>
    readonly equipmentSetId: FieldRef<"EquipmentSetItem", 'String'>
    readonly objectZoneId: FieldRef<"EquipmentSetItem", 'Int'>
    readonly objectId: FieldRef<"EquipmentSetItem", 'Int'>
    readonly slot: FieldRef<"EquipmentSetItem", 'String'>
    readonly quantity: FieldRef<"EquipmentSetItem", 'Int'>
    readonly probability: FieldRef<"EquipmentSetItem", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * EquipmentSetItem findUnique
   */
  export type EquipmentSetItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentSetItem to fetch.
     */
    where: EquipmentSetItemWhereUniqueInput
  }


  /**
   * EquipmentSetItem findUniqueOrThrow
   */
  export type EquipmentSetItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentSetItem to fetch.
     */
    where: EquipmentSetItemWhereUniqueInput
  }


  /**
   * EquipmentSetItem findFirst
   */
  export type EquipmentSetItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentSetItem to fetch.
     */
    where?: EquipmentSetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentSetItems to fetch.
     */
    orderBy?: EquipmentSetItemOrderByWithRelationInput | EquipmentSetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentSetItems.
     */
    cursor?: EquipmentSetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentSetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentSetItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentSetItems.
     */
    distinct?: EquipmentSetItemScalarFieldEnum | EquipmentSetItemScalarFieldEnum[]
  }


  /**
   * EquipmentSetItem findFirstOrThrow
   */
  export type EquipmentSetItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentSetItem to fetch.
     */
    where?: EquipmentSetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentSetItems to fetch.
     */
    orderBy?: EquipmentSetItemOrderByWithRelationInput | EquipmentSetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentSetItems.
     */
    cursor?: EquipmentSetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentSetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentSetItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentSetItems.
     */
    distinct?: EquipmentSetItemScalarFieldEnum | EquipmentSetItemScalarFieldEnum[]
  }


  /**
   * EquipmentSetItem findMany
   */
  export type EquipmentSetItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentSetItems to fetch.
     */
    where?: EquipmentSetItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentSetItems to fetch.
     */
    orderBy?: EquipmentSetItemOrderByWithRelationInput | EquipmentSetItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentSetItems.
     */
    cursor?: EquipmentSetItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentSetItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentSetItems.
     */
    skip?: number
    distinct?: EquipmentSetItemScalarFieldEnum | EquipmentSetItemScalarFieldEnum[]
  }


  /**
   * EquipmentSetItem create
   */
  export type EquipmentSetItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentSetItem.
     */
    data: XOR<EquipmentSetItemCreateInput, EquipmentSetItemUncheckedCreateInput>
  }


  /**
   * EquipmentSetItem createMany
   */
  export type EquipmentSetItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentSetItems.
     */
    data: EquipmentSetItemCreateManyInput | EquipmentSetItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EquipmentSetItem update
   */
  export type EquipmentSetItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentSetItem.
     */
    data: XOR<EquipmentSetItemUpdateInput, EquipmentSetItemUncheckedUpdateInput>
    /**
     * Choose, which EquipmentSetItem to update.
     */
    where: EquipmentSetItemWhereUniqueInput
  }


  /**
   * EquipmentSetItem updateMany
   */
  export type EquipmentSetItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentSetItems.
     */
    data: XOR<EquipmentSetItemUpdateManyMutationInput, EquipmentSetItemUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentSetItems to update
     */
    where?: EquipmentSetItemWhereInput
  }


  /**
   * EquipmentSetItem upsert
   */
  export type EquipmentSetItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentSetItem to update in case it exists.
     */
    where: EquipmentSetItemWhereUniqueInput
    /**
     * In case the EquipmentSetItem found by the `where` argument doesn't exist, create a new EquipmentSetItem with this data.
     */
    create: XOR<EquipmentSetItemCreateInput, EquipmentSetItemUncheckedCreateInput>
    /**
     * In case the EquipmentSetItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentSetItemUpdateInput, EquipmentSetItemUncheckedUpdateInput>
  }


  /**
   * EquipmentSetItem delete
   */
  export type EquipmentSetItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    /**
     * Filter which EquipmentSetItem to delete.
     */
    where: EquipmentSetItemWhereUniqueInput
  }


  /**
   * EquipmentSetItem deleteMany
   */
  export type EquipmentSetItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentSetItems to delete
     */
    where?: EquipmentSetItemWhereInput
  }


  /**
   * EquipmentSetItem without action
   */
  export type EquipmentSetItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
  }



  /**
   * Model EquipmentSet
   */

  export type AggregateEquipmentSet = {
    _count: EquipmentSetCountAggregateOutputType | null
    _min: EquipmentSetMinAggregateOutputType | null
    _max: EquipmentSetMaxAggregateOutputType | null
  }

  export type EquipmentSetMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentSetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentSetCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentSetMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentSetMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentSetCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentSetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentSet to aggregate.
     */
    where?: EquipmentSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentSets to fetch.
     */
    orderBy?: EquipmentSetOrderByWithRelationInput | EquipmentSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentSets
    **/
    _count?: true | EquipmentSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentSetMaxAggregateInputType
  }

  export type GetEquipmentSetAggregateType<T extends EquipmentSetAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentSet[P]>
      : GetScalarType<T[P], AggregateEquipmentSet[P]>
  }




  export type EquipmentSetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentSetWhereInput
    orderBy?: EquipmentSetOrderByWithAggregationInput | EquipmentSetOrderByWithAggregationInput[]
    by: EquipmentSetScalarFieldEnum[] | EquipmentSetScalarFieldEnum
    having?: EquipmentSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentSetCountAggregateInputType | true
    _min?: EquipmentSetMinAggregateInputType
    _max?: EquipmentSetMaxAggregateInputType
  }

  export type EquipmentSetGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: EquipmentSetCountAggregateOutputType | null
    _min: EquipmentSetMinAggregateOutputType | null
    _max: EquipmentSetMaxAggregateOutputType | null
  }

  type GetEquipmentSetGroupByPayload<T extends EquipmentSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentSetGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentSetGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | EquipmentSet$itemsArgs<ExtArgs>
    mobEquipmentSets?: boolean | EquipmentSet$mobEquipmentSetsArgs<ExtArgs>
    _count?: boolean | EquipmentSetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentSet"]>

  export type EquipmentSetSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentSetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | EquipmentSet$itemsArgs<ExtArgs>
    mobEquipmentSets?: boolean | EquipmentSet$mobEquipmentSetsArgs<ExtArgs>
    _count?: boolean | EquipmentSetCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EquipmentSetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentSet"
    objects: {
      items: Prisma.$EquipmentSetItemPayload<ExtArgs>[]
      mobEquipmentSets: Prisma.$MobEquipmentSetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipmentSet"]>
    composites: {}
  }


  type EquipmentSetGetPayload<S extends boolean | null | undefined | EquipmentSetDefaultArgs> = $Result.GetResult<Prisma.$EquipmentSetPayload, S>

  type EquipmentSetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EquipmentSetFindManyArgs, 'select' | 'include'> & {
      select?: EquipmentSetCountAggregateInputType | true
    }

  export interface EquipmentSetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentSet'], meta: { name: 'EquipmentSet' } }
    /**
     * Find zero or one EquipmentSet that matches the filter.
     * @param {EquipmentSetFindUniqueArgs} args - Arguments to find a EquipmentSet
     * @example
     * // Get one EquipmentSet
     * const equipmentSet = await prisma.equipmentSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EquipmentSetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetFindUniqueArgs<ExtArgs>>
    ): Prisma__EquipmentSetClient<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EquipmentSet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EquipmentSetFindUniqueOrThrowArgs} args - Arguments to find a EquipmentSet
     * @example
     * // Get one EquipmentSet
     * const equipmentSet = await prisma.equipmentSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EquipmentSetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EquipmentSetClient<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EquipmentSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetFindFirstArgs} args - Arguments to find a EquipmentSet
     * @example
     * // Get one EquipmentSet
     * const equipmentSet = await prisma.equipmentSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EquipmentSetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetFindFirstArgs<ExtArgs>>
    ): Prisma__EquipmentSetClient<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EquipmentSet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetFindFirstOrThrowArgs} args - Arguments to find a EquipmentSet
     * @example
     * // Get one EquipmentSet
     * const equipmentSet = await prisma.equipmentSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EquipmentSetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EquipmentSetClient<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EquipmentSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentSets
     * const equipmentSets = await prisma.equipmentSet.findMany()
     * 
     * // Get first 10 EquipmentSets
     * const equipmentSets = await prisma.equipmentSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentSetWithIdOnly = await prisma.equipmentSet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EquipmentSetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EquipmentSet.
     * @param {EquipmentSetCreateArgs} args - Arguments to create a EquipmentSet.
     * @example
     * // Create one EquipmentSet
     * const EquipmentSet = await prisma.equipmentSet.create({
     *   data: {
     *     // ... data to create a EquipmentSet
     *   }
     * })
     * 
    **/
    create<T extends EquipmentSetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetCreateArgs<ExtArgs>>
    ): Prisma__EquipmentSetClient<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EquipmentSets.
     *     @param {EquipmentSetCreateManyArgs} args - Arguments to create many EquipmentSets.
     *     @example
     *     // Create many EquipmentSets
     *     const equipmentSet = await prisma.equipmentSet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EquipmentSetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EquipmentSet.
     * @param {EquipmentSetDeleteArgs} args - Arguments to delete one EquipmentSet.
     * @example
     * // Delete one EquipmentSet
     * const EquipmentSet = await prisma.equipmentSet.delete({
     *   where: {
     *     // ... filter to delete one EquipmentSet
     *   }
     * })
     * 
    **/
    delete<T extends EquipmentSetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetDeleteArgs<ExtArgs>>
    ): Prisma__EquipmentSetClient<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EquipmentSet.
     * @param {EquipmentSetUpdateArgs} args - Arguments to update one EquipmentSet.
     * @example
     * // Update one EquipmentSet
     * const equipmentSet = await prisma.equipmentSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EquipmentSetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetUpdateArgs<ExtArgs>>
    ): Prisma__EquipmentSetClient<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EquipmentSets.
     * @param {EquipmentSetDeleteManyArgs} args - Arguments to filter EquipmentSets to delete.
     * @example
     * // Delete a few EquipmentSets
     * const { count } = await prisma.equipmentSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EquipmentSetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentSetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentSets
     * const equipmentSet = await prisma.equipmentSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EquipmentSetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EquipmentSet.
     * @param {EquipmentSetUpsertArgs} args - Arguments to update or create a EquipmentSet.
     * @example
     * // Update or create a EquipmentSet
     * const equipmentSet = await prisma.equipmentSet.upsert({
     *   create: {
     *     // ... data to create a EquipmentSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentSet we want to update
     *   }
     * })
    **/
    upsert<T extends EquipmentSetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentSetUpsertArgs<ExtArgs>>
    ): Prisma__EquipmentSetClient<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EquipmentSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetCountArgs} args - Arguments to filter EquipmentSets to count.
     * @example
     * // Count the number of EquipmentSets
     * const count = await prisma.equipmentSet.count({
     *   where: {
     *     // ... the filter for the EquipmentSets we want to count
     *   }
     * })
    **/
    count<T extends EquipmentSetCountArgs>(
      args?: Subset<T, EquipmentSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentSetAggregateArgs>(args: Subset<T, EquipmentSetAggregateArgs>): Prisma.PrismaPromise<GetEquipmentSetAggregateType<T>>

    /**
     * Group by EquipmentSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentSetGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentSet model
   */
  readonly fields: EquipmentSetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentSetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends EquipmentSet$itemsArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentSet$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentSetItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    mobEquipmentSets<T extends EquipmentSet$mobEquipmentSetsArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentSet$mobEquipmentSetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EquipmentSet model
   */ 
  interface EquipmentSetFieldRefs {
    readonly id: FieldRef<"EquipmentSet", 'String'>
    readonly name: FieldRef<"EquipmentSet", 'String'>
    readonly description: FieldRef<"EquipmentSet", 'String'>
    readonly createdAt: FieldRef<"EquipmentSet", 'DateTime'>
    readonly updatedAt: FieldRef<"EquipmentSet", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EquipmentSet findUnique
   */
  export type EquipmentSetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSet
     */
    select?: EquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentSet to fetch.
     */
    where: EquipmentSetWhereUniqueInput
  }


  /**
   * EquipmentSet findUniqueOrThrow
   */
  export type EquipmentSetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSet
     */
    select?: EquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentSet to fetch.
     */
    where: EquipmentSetWhereUniqueInput
  }


  /**
   * EquipmentSet findFirst
   */
  export type EquipmentSetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSet
     */
    select?: EquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentSet to fetch.
     */
    where?: EquipmentSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentSets to fetch.
     */
    orderBy?: EquipmentSetOrderByWithRelationInput | EquipmentSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentSets.
     */
    cursor?: EquipmentSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentSets.
     */
    distinct?: EquipmentSetScalarFieldEnum | EquipmentSetScalarFieldEnum[]
  }


  /**
   * EquipmentSet findFirstOrThrow
   */
  export type EquipmentSetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSet
     */
    select?: EquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentSet to fetch.
     */
    where?: EquipmentSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentSets to fetch.
     */
    orderBy?: EquipmentSetOrderByWithRelationInput | EquipmentSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentSets.
     */
    cursor?: EquipmentSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentSets.
     */
    distinct?: EquipmentSetScalarFieldEnum | EquipmentSetScalarFieldEnum[]
  }


  /**
   * EquipmentSet findMany
   */
  export type EquipmentSetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSet
     */
    select?: EquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentSets to fetch.
     */
    where?: EquipmentSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentSets to fetch.
     */
    orderBy?: EquipmentSetOrderByWithRelationInput | EquipmentSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentSets.
     */
    cursor?: EquipmentSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentSets.
     */
    skip?: number
    distinct?: EquipmentSetScalarFieldEnum | EquipmentSetScalarFieldEnum[]
  }


  /**
   * EquipmentSet create
   */
  export type EquipmentSetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSet
     */
    select?: EquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentSet.
     */
    data: XOR<EquipmentSetCreateInput, EquipmentSetUncheckedCreateInput>
  }


  /**
   * EquipmentSet createMany
   */
  export type EquipmentSetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentSets.
     */
    data: EquipmentSetCreateManyInput | EquipmentSetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EquipmentSet update
   */
  export type EquipmentSetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSet
     */
    select?: EquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentSet.
     */
    data: XOR<EquipmentSetUpdateInput, EquipmentSetUncheckedUpdateInput>
    /**
     * Choose, which EquipmentSet to update.
     */
    where: EquipmentSetWhereUniqueInput
  }


  /**
   * EquipmentSet updateMany
   */
  export type EquipmentSetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentSets.
     */
    data: XOR<EquipmentSetUpdateManyMutationInput, EquipmentSetUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentSets to update
     */
    where?: EquipmentSetWhereInput
  }


  /**
   * EquipmentSet upsert
   */
  export type EquipmentSetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSet
     */
    select?: EquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentSet to update in case it exists.
     */
    where: EquipmentSetWhereUniqueInput
    /**
     * In case the EquipmentSet found by the `where` argument doesn't exist, create a new EquipmentSet with this data.
     */
    create: XOR<EquipmentSetCreateInput, EquipmentSetUncheckedCreateInput>
    /**
     * In case the EquipmentSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentSetUpdateInput, EquipmentSetUncheckedUpdateInput>
  }


  /**
   * EquipmentSet delete
   */
  export type EquipmentSetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSet
     */
    select?: EquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetInclude<ExtArgs> | null
    /**
     * Filter which EquipmentSet to delete.
     */
    where: EquipmentSetWhereUniqueInput
  }


  /**
   * EquipmentSet deleteMany
   */
  export type EquipmentSetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentSets to delete
     */
    where?: EquipmentSetWhereInput
  }


  /**
   * EquipmentSet.items
   */
  export type EquipmentSet$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSetItem
     */
    select?: EquipmentSetItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetItemInclude<ExtArgs> | null
    where?: EquipmentSetItemWhereInput
    orderBy?: EquipmentSetItemOrderByWithRelationInput | EquipmentSetItemOrderByWithRelationInput[]
    cursor?: EquipmentSetItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentSetItemScalarFieldEnum | EquipmentSetItemScalarFieldEnum[]
  }


  /**
   * EquipmentSet.mobEquipmentSets
   */
  export type EquipmentSet$mobEquipmentSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    where?: MobEquipmentSetWhereInput
    orderBy?: MobEquipmentSetOrderByWithRelationInput | MobEquipmentSetOrderByWithRelationInput[]
    cursor?: MobEquipmentSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MobEquipmentSetScalarFieldEnum | MobEquipmentSetScalarFieldEnum[]
  }


  /**
   * EquipmentSet without action
   */
  export type EquipmentSetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentSet
     */
    select?: EquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentSetInclude<ExtArgs> | null
  }



  /**
   * Model MobEquipmentSet
   */

  export type AggregateMobEquipmentSet = {
    _count: MobEquipmentSetCountAggregateOutputType | null
    _avg: MobEquipmentSetAvgAggregateOutputType | null
    _sum: MobEquipmentSetSumAggregateOutputType | null
    _min: MobEquipmentSetMinAggregateOutputType | null
    _max: MobEquipmentSetMaxAggregateOutputType | null
  }

  export type MobEquipmentSetAvgAggregateOutputType = {
    probability: number | null
  }

  export type MobEquipmentSetSumAggregateOutputType = {
    probability: number | null
  }

  export type MobEquipmentSetMinAggregateOutputType = {
    id: string | null
    mobResetId: string | null
    equipmentSetId: string | null
    probability: number | null
  }

  export type MobEquipmentSetMaxAggregateOutputType = {
    id: string | null
    mobResetId: string | null
    equipmentSetId: string | null
    probability: number | null
  }

  export type MobEquipmentSetCountAggregateOutputType = {
    id: number
    mobResetId: number
    equipmentSetId: number
    probability: number
    _all: number
  }


  export type MobEquipmentSetAvgAggregateInputType = {
    probability?: true
  }

  export type MobEquipmentSetSumAggregateInputType = {
    probability?: true
  }

  export type MobEquipmentSetMinAggregateInputType = {
    id?: true
    mobResetId?: true
    equipmentSetId?: true
    probability?: true
  }

  export type MobEquipmentSetMaxAggregateInputType = {
    id?: true
    mobResetId?: true
    equipmentSetId?: true
    probability?: true
  }

  export type MobEquipmentSetCountAggregateInputType = {
    id?: true
    mobResetId?: true
    equipmentSetId?: true
    probability?: true
    _all?: true
  }

  export type MobEquipmentSetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobEquipmentSet to aggregate.
     */
    where?: MobEquipmentSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobEquipmentSets to fetch.
     */
    orderBy?: MobEquipmentSetOrderByWithRelationInput | MobEquipmentSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobEquipmentSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobEquipmentSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobEquipmentSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MobEquipmentSets
    **/
    _count?: true | MobEquipmentSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MobEquipmentSetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MobEquipmentSetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobEquipmentSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobEquipmentSetMaxAggregateInputType
  }

  export type GetMobEquipmentSetAggregateType<T extends MobEquipmentSetAggregateArgs> = {
        [P in keyof T & keyof AggregateMobEquipmentSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMobEquipmentSet[P]>
      : GetScalarType<T[P], AggregateMobEquipmentSet[P]>
  }




  export type MobEquipmentSetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobEquipmentSetWhereInput
    orderBy?: MobEquipmentSetOrderByWithAggregationInput | MobEquipmentSetOrderByWithAggregationInput[]
    by: MobEquipmentSetScalarFieldEnum[] | MobEquipmentSetScalarFieldEnum
    having?: MobEquipmentSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobEquipmentSetCountAggregateInputType | true
    _avg?: MobEquipmentSetAvgAggregateInputType
    _sum?: MobEquipmentSetSumAggregateInputType
    _min?: MobEquipmentSetMinAggregateInputType
    _max?: MobEquipmentSetMaxAggregateInputType
  }

  export type MobEquipmentSetGroupByOutputType = {
    id: string
    mobResetId: string
    equipmentSetId: string
    probability: number
    _count: MobEquipmentSetCountAggregateOutputType | null
    _avg: MobEquipmentSetAvgAggregateOutputType | null
    _sum: MobEquipmentSetSumAggregateOutputType | null
    _min: MobEquipmentSetMinAggregateOutputType | null
    _max: MobEquipmentSetMaxAggregateOutputType | null
  }

  type GetMobEquipmentSetGroupByPayload<T extends MobEquipmentSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobEquipmentSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobEquipmentSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobEquipmentSetGroupByOutputType[P]>
            : GetScalarType<T[P], MobEquipmentSetGroupByOutputType[P]>
        }
      >
    >


  export type MobEquipmentSetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mobResetId?: boolean
    equipmentSetId?: boolean
    probability?: boolean
    equipmentSet?: boolean | EquipmentSetDefaultArgs<ExtArgs>
    mobReset?: boolean | MobResetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobEquipmentSet"]>

  export type MobEquipmentSetSelectScalar = {
    id?: boolean
    mobResetId?: boolean
    equipmentSetId?: boolean
    probability?: boolean
  }

  export type MobEquipmentSetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipmentSet?: boolean | EquipmentSetDefaultArgs<ExtArgs>
    mobReset?: boolean | MobResetDefaultArgs<ExtArgs>
  }


  export type $MobEquipmentSetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MobEquipmentSet"
    objects: {
      equipmentSet: Prisma.$EquipmentSetPayload<ExtArgs>
      mobReset: Prisma.$MobResetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mobResetId: string
      equipmentSetId: string
      probability: number
    }, ExtArgs["result"]["mobEquipmentSet"]>
    composites: {}
  }


  type MobEquipmentSetGetPayload<S extends boolean | null | undefined | MobEquipmentSetDefaultArgs> = $Result.GetResult<Prisma.$MobEquipmentSetPayload, S>

  type MobEquipmentSetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MobEquipmentSetFindManyArgs, 'select' | 'include'> & {
      select?: MobEquipmentSetCountAggregateInputType | true
    }

  export interface MobEquipmentSetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MobEquipmentSet'], meta: { name: 'MobEquipmentSet' } }
    /**
     * Find zero or one MobEquipmentSet that matches the filter.
     * @param {MobEquipmentSetFindUniqueArgs} args - Arguments to find a MobEquipmentSet
     * @example
     * // Get one MobEquipmentSet
     * const mobEquipmentSet = await prisma.mobEquipmentSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MobEquipmentSetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquipmentSetFindUniqueArgs<ExtArgs>>
    ): Prisma__MobEquipmentSetClient<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MobEquipmentSet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MobEquipmentSetFindUniqueOrThrowArgs} args - Arguments to find a MobEquipmentSet
     * @example
     * // Get one MobEquipmentSet
     * const mobEquipmentSet = await prisma.mobEquipmentSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MobEquipmentSetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquipmentSetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MobEquipmentSetClient<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MobEquipmentSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquipmentSetFindFirstArgs} args - Arguments to find a MobEquipmentSet
     * @example
     * // Get one MobEquipmentSet
     * const mobEquipmentSet = await prisma.mobEquipmentSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MobEquipmentSetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquipmentSetFindFirstArgs<ExtArgs>>
    ): Prisma__MobEquipmentSetClient<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MobEquipmentSet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquipmentSetFindFirstOrThrowArgs} args - Arguments to find a MobEquipmentSet
     * @example
     * // Get one MobEquipmentSet
     * const mobEquipmentSet = await prisma.mobEquipmentSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MobEquipmentSetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquipmentSetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MobEquipmentSetClient<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MobEquipmentSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquipmentSetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MobEquipmentSets
     * const mobEquipmentSets = await prisma.mobEquipmentSet.findMany()
     * 
     * // Get first 10 MobEquipmentSets
     * const mobEquipmentSets = await prisma.mobEquipmentSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mobEquipmentSetWithIdOnly = await prisma.mobEquipmentSet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MobEquipmentSetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquipmentSetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MobEquipmentSet.
     * @param {MobEquipmentSetCreateArgs} args - Arguments to create a MobEquipmentSet.
     * @example
     * // Create one MobEquipmentSet
     * const MobEquipmentSet = await prisma.mobEquipmentSet.create({
     *   data: {
     *     // ... data to create a MobEquipmentSet
     *   }
     * })
     * 
    **/
    create<T extends MobEquipmentSetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquipmentSetCreateArgs<ExtArgs>>
    ): Prisma__MobEquipmentSetClient<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MobEquipmentSets.
     *     @param {MobEquipmentSetCreateManyArgs} args - Arguments to create many MobEquipmentSets.
     *     @example
     *     // Create many MobEquipmentSets
     *     const mobEquipmentSet = await prisma.mobEquipmentSet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MobEquipmentSetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquipmentSetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MobEquipmentSet.
     * @param {MobEquipmentSetDeleteArgs} args - Arguments to delete one MobEquipmentSet.
     * @example
     * // Delete one MobEquipmentSet
     * const MobEquipmentSet = await prisma.mobEquipmentSet.delete({
     *   where: {
     *     // ... filter to delete one MobEquipmentSet
     *   }
     * })
     * 
    **/
    delete<T extends MobEquipmentSetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquipmentSetDeleteArgs<ExtArgs>>
    ): Prisma__MobEquipmentSetClient<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MobEquipmentSet.
     * @param {MobEquipmentSetUpdateArgs} args - Arguments to update one MobEquipmentSet.
     * @example
     * // Update one MobEquipmentSet
     * const mobEquipmentSet = await prisma.mobEquipmentSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MobEquipmentSetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquipmentSetUpdateArgs<ExtArgs>>
    ): Prisma__MobEquipmentSetClient<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MobEquipmentSets.
     * @param {MobEquipmentSetDeleteManyArgs} args - Arguments to filter MobEquipmentSets to delete.
     * @example
     * // Delete a few MobEquipmentSets
     * const { count } = await prisma.mobEquipmentSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MobEquipmentSetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MobEquipmentSetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobEquipmentSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquipmentSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MobEquipmentSets
     * const mobEquipmentSet = await prisma.mobEquipmentSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MobEquipmentSetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquipmentSetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MobEquipmentSet.
     * @param {MobEquipmentSetUpsertArgs} args - Arguments to update or create a MobEquipmentSet.
     * @example
     * // Update or create a MobEquipmentSet
     * const mobEquipmentSet = await prisma.mobEquipmentSet.upsert({
     *   create: {
     *     // ... data to create a MobEquipmentSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MobEquipmentSet we want to update
     *   }
     * })
    **/
    upsert<T extends MobEquipmentSetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MobEquipmentSetUpsertArgs<ExtArgs>>
    ): Prisma__MobEquipmentSetClient<$Result.GetResult<Prisma.$MobEquipmentSetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MobEquipmentSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquipmentSetCountArgs} args - Arguments to filter MobEquipmentSets to count.
     * @example
     * // Count the number of MobEquipmentSets
     * const count = await prisma.mobEquipmentSet.count({
     *   where: {
     *     // ... the filter for the MobEquipmentSets we want to count
     *   }
     * })
    **/
    count<T extends MobEquipmentSetCountArgs>(
      args?: Subset<T, MobEquipmentSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobEquipmentSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MobEquipmentSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquipmentSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobEquipmentSetAggregateArgs>(args: Subset<T, MobEquipmentSetAggregateArgs>): Prisma.PrismaPromise<GetMobEquipmentSetAggregateType<T>>

    /**
     * Group by MobEquipmentSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobEquipmentSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobEquipmentSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobEquipmentSetGroupByArgs['orderBy'] }
        : { orderBy?: MobEquipmentSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobEquipmentSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobEquipmentSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MobEquipmentSet model
   */
  readonly fields: MobEquipmentSetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MobEquipmentSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobEquipmentSetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    equipmentSet<T extends EquipmentSetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentSetDefaultArgs<ExtArgs>>): Prisma__EquipmentSetClient<$Result.GetResult<Prisma.$EquipmentSetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    mobReset<T extends MobResetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MobResetDefaultArgs<ExtArgs>>): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MobEquipmentSet model
   */ 
  interface MobEquipmentSetFieldRefs {
    readonly id: FieldRef<"MobEquipmentSet", 'String'>
    readonly mobResetId: FieldRef<"MobEquipmentSet", 'String'>
    readonly equipmentSetId: FieldRef<"MobEquipmentSet", 'String'>
    readonly probability: FieldRef<"MobEquipmentSet", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * MobEquipmentSet findUnique
   */
  export type MobEquipmentSetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    /**
     * Filter, which MobEquipmentSet to fetch.
     */
    where: MobEquipmentSetWhereUniqueInput
  }


  /**
   * MobEquipmentSet findUniqueOrThrow
   */
  export type MobEquipmentSetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    /**
     * Filter, which MobEquipmentSet to fetch.
     */
    where: MobEquipmentSetWhereUniqueInput
  }


  /**
   * MobEquipmentSet findFirst
   */
  export type MobEquipmentSetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    /**
     * Filter, which MobEquipmentSet to fetch.
     */
    where?: MobEquipmentSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobEquipmentSets to fetch.
     */
    orderBy?: MobEquipmentSetOrderByWithRelationInput | MobEquipmentSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobEquipmentSets.
     */
    cursor?: MobEquipmentSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobEquipmentSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobEquipmentSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobEquipmentSets.
     */
    distinct?: MobEquipmentSetScalarFieldEnum | MobEquipmentSetScalarFieldEnum[]
  }


  /**
   * MobEquipmentSet findFirstOrThrow
   */
  export type MobEquipmentSetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    /**
     * Filter, which MobEquipmentSet to fetch.
     */
    where?: MobEquipmentSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobEquipmentSets to fetch.
     */
    orderBy?: MobEquipmentSetOrderByWithRelationInput | MobEquipmentSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobEquipmentSets.
     */
    cursor?: MobEquipmentSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobEquipmentSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobEquipmentSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobEquipmentSets.
     */
    distinct?: MobEquipmentSetScalarFieldEnum | MobEquipmentSetScalarFieldEnum[]
  }


  /**
   * MobEquipmentSet findMany
   */
  export type MobEquipmentSetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    /**
     * Filter, which MobEquipmentSets to fetch.
     */
    where?: MobEquipmentSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobEquipmentSets to fetch.
     */
    orderBy?: MobEquipmentSetOrderByWithRelationInput | MobEquipmentSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MobEquipmentSets.
     */
    cursor?: MobEquipmentSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobEquipmentSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobEquipmentSets.
     */
    skip?: number
    distinct?: MobEquipmentSetScalarFieldEnum | MobEquipmentSetScalarFieldEnum[]
  }


  /**
   * MobEquipmentSet create
   */
  export type MobEquipmentSetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    /**
     * The data needed to create a MobEquipmentSet.
     */
    data: XOR<MobEquipmentSetCreateInput, MobEquipmentSetUncheckedCreateInput>
  }


  /**
   * MobEquipmentSet createMany
   */
  export type MobEquipmentSetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MobEquipmentSets.
     */
    data: MobEquipmentSetCreateManyInput | MobEquipmentSetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MobEquipmentSet update
   */
  export type MobEquipmentSetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    /**
     * The data needed to update a MobEquipmentSet.
     */
    data: XOR<MobEquipmentSetUpdateInput, MobEquipmentSetUncheckedUpdateInput>
    /**
     * Choose, which MobEquipmentSet to update.
     */
    where: MobEquipmentSetWhereUniqueInput
  }


  /**
   * MobEquipmentSet updateMany
   */
  export type MobEquipmentSetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MobEquipmentSets.
     */
    data: XOR<MobEquipmentSetUpdateManyMutationInput, MobEquipmentSetUncheckedUpdateManyInput>
    /**
     * Filter which MobEquipmentSets to update
     */
    where?: MobEquipmentSetWhereInput
  }


  /**
   * MobEquipmentSet upsert
   */
  export type MobEquipmentSetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    /**
     * The filter to search for the MobEquipmentSet to update in case it exists.
     */
    where: MobEquipmentSetWhereUniqueInput
    /**
     * In case the MobEquipmentSet found by the `where` argument doesn't exist, create a new MobEquipmentSet with this data.
     */
    create: XOR<MobEquipmentSetCreateInput, MobEquipmentSetUncheckedCreateInput>
    /**
     * In case the MobEquipmentSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobEquipmentSetUpdateInput, MobEquipmentSetUncheckedUpdateInput>
  }


  /**
   * MobEquipmentSet delete
   */
  export type MobEquipmentSetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
    /**
     * Filter which MobEquipmentSet to delete.
     */
    where: MobEquipmentSetWhereUniqueInput
  }


  /**
   * MobEquipmentSet deleteMany
   */
  export type MobEquipmentSetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobEquipmentSets to delete
     */
    where?: MobEquipmentSetWhereInput
  }


  /**
   * MobEquipmentSet without action
   */
  export type MobEquipmentSetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobEquipmentSet
     */
    select?: MobEquipmentSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobEquipmentSetInclude<ExtArgs> | null
  }



  /**
   * Model ObjectReset
   */

  export type AggregateObjectReset = {
    _count: ObjectResetCountAggregateOutputType | null
    _avg: ObjectResetAvgAggregateOutputType | null
    _sum: ObjectResetSumAggregateOutputType | null
    _min: ObjectResetMinAggregateOutputType | null
    _max: ObjectResetMaxAggregateOutputType | null
  }

  export type ObjectResetAvgAggregateOutputType = {
    max: number | null
    objectZoneId: number | null
    objectId: number | null
    roomZoneId: number | null
    roomId: number | null
    zoneId: number | null
    probability: number | null
  }

  export type ObjectResetSumAggregateOutputType = {
    max: number | null
    objectZoneId: number | null
    objectId: number | null
    roomZoneId: number | null
    roomId: number | null
    zoneId: number | null
    probability: number | null
  }

  export type ObjectResetMinAggregateOutputType = {
    id: string | null
    max: number | null
    name: string | null
    objectZoneId: number | null
    objectId: number | null
    roomZoneId: number | null
    roomId: number | null
    zoneId: number | null
    probability: number | null
  }

  export type ObjectResetMaxAggregateOutputType = {
    id: string | null
    max: number | null
    name: string | null
    objectZoneId: number | null
    objectId: number | null
    roomZoneId: number | null
    roomId: number | null
    zoneId: number | null
    probability: number | null
  }

  export type ObjectResetCountAggregateOutputType = {
    id: number
    max: number
    name: number
    objectZoneId: number
    objectId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability: number
    _all: number
  }


  export type ObjectResetAvgAggregateInputType = {
    max?: true
    objectZoneId?: true
    objectId?: true
    roomZoneId?: true
    roomId?: true
    zoneId?: true
    probability?: true
  }

  export type ObjectResetSumAggregateInputType = {
    max?: true
    objectZoneId?: true
    objectId?: true
    roomZoneId?: true
    roomId?: true
    zoneId?: true
    probability?: true
  }

  export type ObjectResetMinAggregateInputType = {
    id?: true
    max?: true
    name?: true
    objectZoneId?: true
    objectId?: true
    roomZoneId?: true
    roomId?: true
    zoneId?: true
    probability?: true
  }

  export type ObjectResetMaxAggregateInputType = {
    id?: true
    max?: true
    name?: true
    objectZoneId?: true
    objectId?: true
    roomZoneId?: true
    roomId?: true
    zoneId?: true
    probability?: true
  }

  export type ObjectResetCountAggregateInputType = {
    id?: true
    max?: true
    name?: true
    objectZoneId?: true
    objectId?: true
    roomZoneId?: true
    roomId?: true
    zoneId?: true
    probability?: true
    _all?: true
  }

  export type ObjectResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectReset to aggregate.
     */
    where?: ObjectResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectResets to fetch.
     */
    orderBy?: ObjectResetOrderByWithRelationInput | ObjectResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObjectResets
    **/
    _count?: true | ObjectResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectResetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectResetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectResetMaxAggregateInputType
  }

  export type GetObjectResetAggregateType<T extends ObjectResetAggregateArgs> = {
        [P in keyof T & keyof AggregateObjectReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjectReset[P]>
      : GetScalarType<T[P], AggregateObjectReset[P]>
  }




  export type ObjectResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectResetWhereInput
    orderBy?: ObjectResetOrderByWithAggregationInput | ObjectResetOrderByWithAggregationInput[]
    by: ObjectResetScalarFieldEnum[] | ObjectResetScalarFieldEnum
    having?: ObjectResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectResetCountAggregateInputType | true
    _avg?: ObjectResetAvgAggregateInputType
    _sum?: ObjectResetSumAggregateInputType
    _min?: ObjectResetMinAggregateInputType
    _max?: ObjectResetMaxAggregateInputType
  }

  export type ObjectResetGroupByOutputType = {
    id: string
    max: number
    name: string | null
    objectZoneId: number
    objectId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability: number
    _count: ObjectResetCountAggregateOutputType | null
    _avg: ObjectResetAvgAggregateOutputType | null
    _sum: ObjectResetSumAggregateOutputType | null
    _min: ObjectResetMinAggregateOutputType | null
    _max: ObjectResetMaxAggregateOutputType | null
  }

  type GetObjectResetGroupByPayload<T extends ObjectResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectResetGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectResetGroupByOutputType[P]>
        }
      >
    >


  export type ObjectResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    name?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    roomZoneId?: boolean
    roomId?: boolean
    zoneId?: boolean
    probability?: boolean
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    spawnConditions?: boolean | ObjectReset$spawnConditionsArgs<ExtArgs>
    _count?: boolean | ObjectResetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objectReset"]>

  export type ObjectResetSelectScalar = {
    id?: boolean
    max?: boolean
    name?: boolean
    objectZoneId?: boolean
    objectId?: boolean
    roomZoneId?: boolean
    roomId?: boolean
    zoneId?: boolean
    probability?: boolean
  }

  export type ObjectResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    spawnConditions?: boolean | ObjectReset$spawnConditionsArgs<ExtArgs>
    _count?: boolean | ObjectResetCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ObjectResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObjectReset"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs>
      spawnConditions: Prisma.$SpawnConditionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      max: number
      name: string | null
      objectZoneId: number
      objectId: number
      roomZoneId: number
      roomId: number
      zoneId: number
      probability: number
    }, ExtArgs["result"]["objectReset"]>
    composites: {}
  }


  type ObjectResetGetPayload<S extends boolean | null | undefined | ObjectResetDefaultArgs> = $Result.GetResult<Prisma.$ObjectResetPayload, S>

  type ObjectResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectResetFindManyArgs, 'select' | 'include'> & {
      select?: ObjectResetCountAggregateInputType | true
    }

  export interface ObjectResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObjectReset'], meta: { name: 'ObjectReset' } }
    /**
     * Find zero or one ObjectReset that matches the filter.
     * @param {ObjectResetFindUniqueArgs} args - Arguments to find a ObjectReset
     * @example
     * // Get one ObjectReset
     * const objectReset = await prisma.objectReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectResetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectResetFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectResetClient<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ObjectReset that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObjectResetFindUniqueOrThrowArgs} args - Arguments to find a ObjectReset
     * @example
     * // Get one ObjectReset
     * const objectReset = await prisma.objectReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectResetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectResetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectResetClient<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ObjectReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectResetFindFirstArgs} args - Arguments to find a ObjectReset
     * @example
     * // Get one ObjectReset
     * const objectReset = await prisma.objectReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectResetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectResetFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectResetClient<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ObjectReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectResetFindFirstOrThrowArgs} args - Arguments to find a ObjectReset
     * @example
     * // Get one ObjectReset
     * const objectReset = await prisma.objectReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectResetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectResetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectResetClient<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ObjectResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectResetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjectResets
     * const objectResets = await prisma.objectReset.findMany()
     * 
     * // Get first 10 ObjectResets
     * const objectResets = await prisma.objectReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectResetWithIdOnly = await prisma.objectReset.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectResetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectResetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ObjectReset.
     * @param {ObjectResetCreateArgs} args - Arguments to create a ObjectReset.
     * @example
     * // Create one ObjectReset
     * const ObjectReset = await prisma.objectReset.create({
     *   data: {
     *     // ... data to create a ObjectReset
     *   }
     * })
     * 
    **/
    create<T extends ObjectResetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectResetCreateArgs<ExtArgs>>
    ): Prisma__ObjectResetClient<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ObjectResets.
     *     @param {ObjectResetCreateManyArgs} args - Arguments to create many ObjectResets.
     *     @example
     *     // Create many ObjectResets
     *     const objectReset = await prisma.objectReset.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectResetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectResetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ObjectReset.
     * @param {ObjectResetDeleteArgs} args - Arguments to delete one ObjectReset.
     * @example
     * // Delete one ObjectReset
     * const ObjectReset = await prisma.objectReset.delete({
     *   where: {
     *     // ... filter to delete one ObjectReset
     *   }
     * })
     * 
    **/
    delete<T extends ObjectResetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectResetDeleteArgs<ExtArgs>>
    ): Prisma__ObjectResetClient<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ObjectReset.
     * @param {ObjectResetUpdateArgs} args - Arguments to update one ObjectReset.
     * @example
     * // Update one ObjectReset
     * const objectReset = await prisma.objectReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectResetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectResetUpdateArgs<ExtArgs>>
    ): Prisma__ObjectResetClient<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ObjectResets.
     * @param {ObjectResetDeleteManyArgs} args - Arguments to filter ObjectResets to delete.
     * @example
     * // Delete a few ObjectResets
     * const { count } = await prisma.objectReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectResetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectResetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjectResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjectResets
     * const objectReset = await prisma.objectReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectResetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectResetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObjectReset.
     * @param {ObjectResetUpsertArgs} args - Arguments to update or create a ObjectReset.
     * @example
     * // Update or create a ObjectReset
     * const objectReset = await prisma.objectReset.upsert({
     *   create: {
     *     // ... data to create a ObjectReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjectReset we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectResetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectResetUpsertArgs<ExtArgs>>
    ): Prisma__ObjectResetClient<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ObjectResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectResetCountArgs} args - Arguments to filter ObjectResets to count.
     * @example
     * // Count the number of ObjectResets
     * const count = await prisma.objectReset.count({
     *   where: {
     *     // ... the filter for the ObjectResets we want to count
     *   }
     * })
    **/
    count<T extends ObjectResetCountArgs>(
      args?: Subset<T, ObjectResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjectReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectResetAggregateArgs>(args: Subset<T, ObjectResetAggregateArgs>): Prisma.PrismaPromise<GetObjectResetAggregateType<T>>

    /**
     * Group by ObjectReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectResetGroupByArgs['orderBy'] }
        : { orderBy?: ObjectResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObjectReset model
   */
  readonly fields: ObjectResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObjectReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObjectDefaultArgs<ExtArgs>>): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    spawnConditions<T extends ObjectReset$spawnConditionsArgs<ExtArgs> = {}>(args?: Subset<T, ObjectReset$spawnConditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ObjectReset model
   */ 
  interface ObjectResetFieldRefs {
    readonly id: FieldRef<"ObjectReset", 'String'>
    readonly max: FieldRef<"ObjectReset", 'Int'>
    readonly name: FieldRef<"ObjectReset", 'String'>
    readonly objectZoneId: FieldRef<"ObjectReset", 'Int'>
    readonly objectId: FieldRef<"ObjectReset", 'Int'>
    readonly roomZoneId: FieldRef<"ObjectReset", 'Int'>
    readonly roomId: FieldRef<"ObjectReset", 'Int'>
    readonly zoneId: FieldRef<"ObjectReset", 'Int'>
    readonly probability: FieldRef<"ObjectReset", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * ObjectReset findUnique
   */
  export type ObjectResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    /**
     * Filter, which ObjectReset to fetch.
     */
    where: ObjectResetWhereUniqueInput
  }


  /**
   * ObjectReset findUniqueOrThrow
   */
  export type ObjectResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    /**
     * Filter, which ObjectReset to fetch.
     */
    where: ObjectResetWhereUniqueInput
  }


  /**
   * ObjectReset findFirst
   */
  export type ObjectResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    /**
     * Filter, which ObjectReset to fetch.
     */
    where?: ObjectResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectResets to fetch.
     */
    orderBy?: ObjectResetOrderByWithRelationInput | ObjectResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectResets.
     */
    cursor?: ObjectResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectResets.
     */
    distinct?: ObjectResetScalarFieldEnum | ObjectResetScalarFieldEnum[]
  }


  /**
   * ObjectReset findFirstOrThrow
   */
  export type ObjectResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    /**
     * Filter, which ObjectReset to fetch.
     */
    where?: ObjectResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectResets to fetch.
     */
    orderBy?: ObjectResetOrderByWithRelationInput | ObjectResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectResets.
     */
    cursor?: ObjectResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectResets.
     */
    distinct?: ObjectResetScalarFieldEnum | ObjectResetScalarFieldEnum[]
  }


  /**
   * ObjectReset findMany
   */
  export type ObjectResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    /**
     * Filter, which ObjectResets to fetch.
     */
    where?: ObjectResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectResets to fetch.
     */
    orderBy?: ObjectResetOrderByWithRelationInput | ObjectResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObjectResets.
     */
    cursor?: ObjectResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectResets.
     */
    skip?: number
    distinct?: ObjectResetScalarFieldEnum | ObjectResetScalarFieldEnum[]
  }


  /**
   * ObjectReset create
   */
  export type ObjectResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    /**
     * The data needed to create a ObjectReset.
     */
    data: XOR<ObjectResetCreateInput, ObjectResetUncheckedCreateInput>
  }


  /**
   * ObjectReset createMany
   */
  export type ObjectResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObjectResets.
     */
    data: ObjectResetCreateManyInput | ObjectResetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ObjectReset update
   */
  export type ObjectResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    /**
     * The data needed to update a ObjectReset.
     */
    data: XOR<ObjectResetUpdateInput, ObjectResetUncheckedUpdateInput>
    /**
     * Choose, which ObjectReset to update.
     */
    where: ObjectResetWhereUniqueInput
  }


  /**
   * ObjectReset updateMany
   */
  export type ObjectResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObjectResets.
     */
    data: XOR<ObjectResetUpdateManyMutationInput, ObjectResetUncheckedUpdateManyInput>
    /**
     * Filter which ObjectResets to update
     */
    where?: ObjectResetWhereInput
  }


  /**
   * ObjectReset upsert
   */
  export type ObjectResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    /**
     * The filter to search for the ObjectReset to update in case it exists.
     */
    where: ObjectResetWhereUniqueInput
    /**
     * In case the ObjectReset found by the `where` argument doesn't exist, create a new ObjectReset with this data.
     */
    create: XOR<ObjectResetCreateInput, ObjectResetUncheckedCreateInput>
    /**
     * In case the ObjectReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectResetUpdateInput, ObjectResetUncheckedUpdateInput>
  }


  /**
   * ObjectReset delete
   */
  export type ObjectResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    /**
     * Filter which ObjectReset to delete.
     */
    where: ObjectResetWhereUniqueInput
  }


  /**
   * ObjectReset deleteMany
   */
  export type ObjectResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectResets to delete
     */
    where?: ObjectResetWhereInput
  }


  /**
   * ObjectReset.spawnConditions
   */
  export type ObjectReset$spawnConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    where?: SpawnConditionWhereInput
    orderBy?: SpawnConditionOrderByWithRelationInput | SpawnConditionOrderByWithRelationInput[]
    cursor?: SpawnConditionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpawnConditionScalarFieldEnum | SpawnConditionScalarFieldEnum[]
  }


  /**
   * ObjectReset without action
   */
  export type ObjectResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
  }



  /**
   * Model SpawnCondition
   */

  export type AggregateSpawnCondition = {
    _count: SpawnConditionCountAggregateOutputType | null
    _min: SpawnConditionMinAggregateOutputType | null
    _max: SpawnConditionMaxAggregateOutputType | null
  }

  export type SpawnConditionMinAggregateOutputType = {
    id: string | null
    type: string | null
    mobResetId: string | null
    objectResetId: string | null
  }

  export type SpawnConditionMaxAggregateOutputType = {
    id: string | null
    type: string | null
    mobResetId: string | null
    objectResetId: string | null
  }

  export type SpawnConditionCountAggregateOutputType = {
    id: number
    type: number
    parameters: number
    mobResetId: number
    objectResetId: number
    _all: number
  }


  export type SpawnConditionMinAggregateInputType = {
    id?: true
    type?: true
    mobResetId?: true
    objectResetId?: true
  }

  export type SpawnConditionMaxAggregateInputType = {
    id?: true
    type?: true
    mobResetId?: true
    objectResetId?: true
  }

  export type SpawnConditionCountAggregateInputType = {
    id?: true
    type?: true
    parameters?: true
    mobResetId?: true
    objectResetId?: true
    _all?: true
  }

  export type SpawnConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpawnCondition to aggregate.
     */
    where?: SpawnConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpawnConditions to fetch.
     */
    orderBy?: SpawnConditionOrderByWithRelationInput | SpawnConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpawnConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpawnConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpawnConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpawnConditions
    **/
    _count?: true | SpawnConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpawnConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpawnConditionMaxAggregateInputType
  }

  export type GetSpawnConditionAggregateType<T extends SpawnConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateSpawnCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpawnCondition[P]>
      : GetScalarType<T[P], AggregateSpawnCondition[P]>
  }




  export type SpawnConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpawnConditionWhereInput
    orderBy?: SpawnConditionOrderByWithAggregationInput | SpawnConditionOrderByWithAggregationInput[]
    by: SpawnConditionScalarFieldEnum[] | SpawnConditionScalarFieldEnum
    having?: SpawnConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpawnConditionCountAggregateInputType | true
    _min?: SpawnConditionMinAggregateInputType
    _max?: SpawnConditionMaxAggregateInputType
  }

  export type SpawnConditionGroupByOutputType = {
    id: string
    type: string
    parameters: JsonValue
    mobResetId: string | null
    objectResetId: string | null
    _count: SpawnConditionCountAggregateOutputType | null
    _min: SpawnConditionMinAggregateOutputType | null
    _max: SpawnConditionMaxAggregateOutputType | null
  }

  type GetSpawnConditionGroupByPayload<T extends SpawnConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpawnConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpawnConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpawnConditionGroupByOutputType[P]>
            : GetScalarType<T[P], SpawnConditionGroupByOutputType[P]>
        }
      >
    >


  export type SpawnConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    parameters?: boolean
    mobResetId?: boolean
    objectResetId?: boolean
    mobReset?: boolean | SpawnCondition$mobResetArgs<ExtArgs>
    objectReset?: boolean | SpawnCondition$objectResetArgs<ExtArgs>
  }, ExtArgs["result"]["spawnCondition"]>

  export type SpawnConditionSelectScalar = {
    id?: boolean
    type?: boolean
    parameters?: boolean
    mobResetId?: boolean
    objectResetId?: boolean
  }

  export type SpawnConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mobReset?: boolean | SpawnCondition$mobResetArgs<ExtArgs>
    objectReset?: boolean | SpawnCondition$objectResetArgs<ExtArgs>
  }


  export type $SpawnConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpawnCondition"
    objects: {
      mobReset: Prisma.$MobResetPayload<ExtArgs> | null
      objectReset: Prisma.$ObjectResetPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      parameters: Prisma.JsonValue
      mobResetId: string | null
      objectResetId: string | null
    }, ExtArgs["result"]["spawnCondition"]>
    composites: {}
  }


  type SpawnConditionGetPayload<S extends boolean | null | undefined | SpawnConditionDefaultArgs> = $Result.GetResult<Prisma.$SpawnConditionPayload, S>

  type SpawnConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpawnConditionFindManyArgs, 'select' | 'include'> & {
      select?: SpawnConditionCountAggregateInputType | true
    }

  export interface SpawnConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpawnCondition'], meta: { name: 'SpawnCondition' } }
    /**
     * Find zero or one SpawnCondition that matches the filter.
     * @param {SpawnConditionFindUniqueArgs} args - Arguments to find a SpawnCondition
     * @example
     * // Get one SpawnCondition
     * const spawnCondition = await prisma.spawnCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpawnConditionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpawnConditionFindUniqueArgs<ExtArgs>>
    ): Prisma__SpawnConditionClient<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpawnCondition that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpawnConditionFindUniqueOrThrowArgs} args - Arguments to find a SpawnCondition
     * @example
     * // Get one SpawnCondition
     * const spawnCondition = await prisma.spawnCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpawnConditionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpawnConditionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpawnConditionClient<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpawnCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpawnConditionFindFirstArgs} args - Arguments to find a SpawnCondition
     * @example
     * // Get one SpawnCondition
     * const spawnCondition = await prisma.spawnCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpawnConditionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpawnConditionFindFirstArgs<ExtArgs>>
    ): Prisma__SpawnConditionClient<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpawnCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpawnConditionFindFirstOrThrowArgs} args - Arguments to find a SpawnCondition
     * @example
     * // Get one SpawnCondition
     * const spawnCondition = await prisma.spawnCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpawnConditionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpawnConditionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpawnConditionClient<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpawnConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpawnConditionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpawnConditions
     * const spawnConditions = await prisma.spawnCondition.findMany()
     * 
     * // Get first 10 SpawnConditions
     * const spawnConditions = await prisma.spawnCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spawnConditionWithIdOnly = await prisma.spawnCondition.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpawnConditionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpawnConditionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpawnCondition.
     * @param {SpawnConditionCreateArgs} args - Arguments to create a SpawnCondition.
     * @example
     * // Create one SpawnCondition
     * const SpawnCondition = await prisma.spawnCondition.create({
     *   data: {
     *     // ... data to create a SpawnCondition
     *   }
     * })
     * 
    **/
    create<T extends SpawnConditionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpawnConditionCreateArgs<ExtArgs>>
    ): Prisma__SpawnConditionClient<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpawnConditions.
     *     @param {SpawnConditionCreateManyArgs} args - Arguments to create many SpawnConditions.
     *     @example
     *     // Create many SpawnConditions
     *     const spawnCondition = await prisma.spawnCondition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpawnConditionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpawnConditionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpawnCondition.
     * @param {SpawnConditionDeleteArgs} args - Arguments to delete one SpawnCondition.
     * @example
     * // Delete one SpawnCondition
     * const SpawnCondition = await prisma.spawnCondition.delete({
     *   where: {
     *     // ... filter to delete one SpawnCondition
     *   }
     * })
     * 
    **/
    delete<T extends SpawnConditionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpawnConditionDeleteArgs<ExtArgs>>
    ): Prisma__SpawnConditionClient<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpawnCondition.
     * @param {SpawnConditionUpdateArgs} args - Arguments to update one SpawnCondition.
     * @example
     * // Update one SpawnCondition
     * const spawnCondition = await prisma.spawnCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpawnConditionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpawnConditionUpdateArgs<ExtArgs>>
    ): Prisma__SpawnConditionClient<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpawnConditions.
     * @param {SpawnConditionDeleteManyArgs} args - Arguments to filter SpawnConditions to delete.
     * @example
     * // Delete a few SpawnConditions
     * const { count } = await prisma.spawnCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpawnConditionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpawnConditionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpawnConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpawnConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpawnConditions
     * const spawnCondition = await prisma.spawnCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpawnConditionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpawnConditionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpawnCondition.
     * @param {SpawnConditionUpsertArgs} args - Arguments to update or create a SpawnCondition.
     * @example
     * // Update or create a SpawnCondition
     * const spawnCondition = await prisma.spawnCondition.upsert({
     *   create: {
     *     // ... data to create a SpawnCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpawnCondition we want to update
     *   }
     * })
    **/
    upsert<T extends SpawnConditionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpawnConditionUpsertArgs<ExtArgs>>
    ): Prisma__SpawnConditionClient<$Result.GetResult<Prisma.$SpawnConditionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpawnConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpawnConditionCountArgs} args - Arguments to filter SpawnConditions to count.
     * @example
     * // Count the number of SpawnConditions
     * const count = await prisma.spawnCondition.count({
     *   where: {
     *     // ... the filter for the SpawnConditions we want to count
     *   }
     * })
    **/
    count<T extends SpawnConditionCountArgs>(
      args?: Subset<T, SpawnConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpawnConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpawnCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpawnConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpawnConditionAggregateArgs>(args: Subset<T, SpawnConditionAggregateArgs>): Prisma.PrismaPromise<GetSpawnConditionAggregateType<T>>

    /**
     * Group by SpawnCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpawnConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpawnConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpawnConditionGroupByArgs['orderBy'] }
        : { orderBy?: SpawnConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpawnConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpawnConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpawnCondition model
   */
  readonly fields: SpawnConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpawnCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpawnConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mobReset<T extends SpawnCondition$mobResetArgs<ExtArgs> = {}>(args?: Subset<T, SpawnCondition$mobResetArgs<ExtArgs>>): Prisma__MobResetClient<$Result.GetResult<Prisma.$MobResetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    objectReset<T extends SpawnCondition$objectResetArgs<ExtArgs> = {}>(args?: Subset<T, SpawnCondition$objectResetArgs<ExtArgs>>): Prisma__ObjectResetClient<$Result.GetResult<Prisma.$ObjectResetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpawnCondition model
   */ 
  interface SpawnConditionFieldRefs {
    readonly id: FieldRef<"SpawnCondition", 'String'>
    readonly type: FieldRef<"SpawnCondition", 'String'>
    readonly parameters: FieldRef<"SpawnCondition", 'Json'>
    readonly mobResetId: FieldRef<"SpawnCondition", 'String'>
    readonly objectResetId: FieldRef<"SpawnCondition", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SpawnCondition findUnique
   */
  export type SpawnConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    /**
     * Filter, which SpawnCondition to fetch.
     */
    where: SpawnConditionWhereUniqueInput
  }


  /**
   * SpawnCondition findUniqueOrThrow
   */
  export type SpawnConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    /**
     * Filter, which SpawnCondition to fetch.
     */
    where: SpawnConditionWhereUniqueInput
  }


  /**
   * SpawnCondition findFirst
   */
  export type SpawnConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    /**
     * Filter, which SpawnCondition to fetch.
     */
    where?: SpawnConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpawnConditions to fetch.
     */
    orderBy?: SpawnConditionOrderByWithRelationInput | SpawnConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpawnConditions.
     */
    cursor?: SpawnConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpawnConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpawnConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpawnConditions.
     */
    distinct?: SpawnConditionScalarFieldEnum | SpawnConditionScalarFieldEnum[]
  }


  /**
   * SpawnCondition findFirstOrThrow
   */
  export type SpawnConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    /**
     * Filter, which SpawnCondition to fetch.
     */
    where?: SpawnConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpawnConditions to fetch.
     */
    orderBy?: SpawnConditionOrderByWithRelationInput | SpawnConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpawnConditions.
     */
    cursor?: SpawnConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpawnConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpawnConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpawnConditions.
     */
    distinct?: SpawnConditionScalarFieldEnum | SpawnConditionScalarFieldEnum[]
  }


  /**
   * SpawnCondition findMany
   */
  export type SpawnConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    /**
     * Filter, which SpawnConditions to fetch.
     */
    where?: SpawnConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpawnConditions to fetch.
     */
    orderBy?: SpawnConditionOrderByWithRelationInput | SpawnConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpawnConditions.
     */
    cursor?: SpawnConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpawnConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpawnConditions.
     */
    skip?: number
    distinct?: SpawnConditionScalarFieldEnum | SpawnConditionScalarFieldEnum[]
  }


  /**
   * SpawnCondition create
   */
  export type SpawnConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a SpawnCondition.
     */
    data: XOR<SpawnConditionCreateInput, SpawnConditionUncheckedCreateInput>
  }


  /**
   * SpawnCondition createMany
   */
  export type SpawnConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpawnConditions.
     */
    data: SpawnConditionCreateManyInput | SpawnConditionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SpawnCondition update
   */
  export type SpawnConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a SpawnCondition.
     */
    data: XOR<SpawnConditionUpdateInput, SpawnConditionUncheckedUpdateInput>
    /**
     * Choose, which SpawnCondition to update.
     */
    where: SpawnConditionWhereUniqueInput
  }


  /**
   * SpawnCondition updateMany
   */
  export type SpawnConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpawnConditions.
     */
    data: XOR<SpawnConditionUpdateManyMutationInput, SpawnConditionUncheckedUpdateManyInput>
    /**
     * Filter which SpawnConditions to update
     */
    where?: SpawnConditionWhereInput
  }


  /**
   * SpawnCondition upsert
   */
  export type SpawnConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the SpawnCondition to update in case it exists.
     */
    where: SpawnConditionWhereUniqueInput
    /**
     * In case the SpawnCondition found by the `where` argument doesn't exist, create a new SpawnCondition with this data.
     */
    create: XOR<SpawnConditionCreateInput, SpawnConditionUncheckedCreateInput>
    /**
     * In case the SpawnCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpawnConditionUpdateInput, SpawnConditionUncheckedUpdateInput>
  }


  /**
   * SpawnCondition delete
   */
  export type SpawnConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
    /**
     * Filter which SpawnCondition to delete.
     */
    where: SpawnConditionWhereUniqueInput
  }


  /**
   * SpawnCondition deleteMany
   */
  export type SpawnConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpawnConditions to delete
     */
    where?: SpawnConditionWhereInput
  }


  /**
   * SpawnCondition.mobReset
   */
  export type SpawnCondition$mobResetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobReset
     */
    select?: MobResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MobResetInclude<ExtArgs> | null
    where?: MobResetWhereInput
  }


  /**
   * SpawnCondition.objectReset
   */
  export type SpawnCondition$objectResetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectReset
     */
    select?: ObjectResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectResetInclude<ExtArgs> | null
    where?: ObjectResetWhereInput
  }


  /**
   * SpawnCondition without action
   */
  export type SpawnConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpawnCondition
     */
    select?: SpawnConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpawnConditionInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    failedLoginAttempts: 'failedLoginAttempts',
    lockedUntil: 'lockedUntil',
    lastFailedLogin: 'lastFailedLogin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    alignment: 'alignment',
    strength: 'strength',
    intelligence: 'intelligence',
    wisdom: 'wisdom',
    dexterity: 'dexterity',
    constitution: 'constitution',
    charisma: 'charisma',
    luck: 'luck',
    hitPoints: 'hitPoints',
    movement: 'movement',
    hitPointsMax: 'hitPointsMax',
    movementMax: 'movementMax',
    copper: 'copper',
    silver: 'silver',
    gold: 'gold',
    platinum: 'platinum',
    bankCopper: 'bankCopper',
    bankSilver: 'bankSilver',
    bankGold: 'bankGold',
    bankPlatinum: 'bankPlatinum',
    total_wealth: 'total_wealth',
    average_stats: 'average_stats',
    passwordHash: 'passwordHash',
    raceType: 'raceType',
    race: 'race',
    gender: 'gender',
    playerClass: 'playerClass',
    height: 'height',
    weight: 'weight',
    baseSize: 'baseSize',
    currentSize: 'currentSize',
    hitRoll: 'hitRoll',
    damageRoll: 'damageRoll',
    armorClass: 'armorClass',
    currentRoom: 'currentRoom',
    saveRoom: 'saveRoom',
    homeRoom: 'homeRoom',
    lastLogin: 'lastLogin',
    timePlayed: 'timePlayed',
    isOnline: 'isOnline',
    hunger: 'hunger',
    thirst: 'thirst',
    description: 'description',
    title: 'title',
    prompt: 'prompt',
    pageLength: 'pageLength',
    playerFlags: 'playerFlags',
    effectFlags: 'effectFlags',
    privilegeFlags: 'privilegeFlags',
    olcZones: 'olcZones',
    invisLevel: 'invisLevel',
    birthTime: 'birthTime',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    classId: 'classId',
    experience: 'experience',
    skillPoints: 'skillPoints'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lifespan: 'lifespan',
    resetMode: 'resetMode',
    hemisphere: 'hemisphere',
    climate: 'climate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted_at: 'deleted_at',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    sector: 'sector',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted_at: 'deleted_at',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    flags: 'flags',
    layoutX: 'layoutX',
    layoutY: 'layoutY',
    layoutZ: 'layoutZ'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const RoomExitScalarFieldEnum: {
    id: 'id',
    direction: 'direction',
    description: 'description',
    keyword: 'keyword',
    key: 'key',
    destination: 'destination',
    roomZoneId: 'roomZoneId',
    roomId: 'roomId',
    flags: 'flags'
  };

  export type RoomExitScalarFieldEnum = (typeof RoomExitScalarFieldEnum)[keyof typeof RoomExitScalarFieldEnum]


  export const RoomExtraDescriptionScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    description: 'description',
    roomZoneId: 'roomZoneId',
    roomId: 'roomId'
  };

  export type RoomExtraDescriptionScalarFieldEnum = (typeof RoomExtraDescriptionScalarFieldEnum)[keyof typeof RoomExtraDescriptionScalarFieldEnum]


  export const MobScalarFieldEnum: {
    id: 'id',
    keywords: 'keywords',
    mobClass: 'mobClass',
    shortDesc: 'shortDesc',
    longDesc: 'longDesc',
    desc: 'desc',
    alignment: 'alignment',
    level: 'level',
    armorClass: 'armorClass',
    hitRoll: 'hitRoll',
    move: 'move',
    hpDiceNum: 'hpDiceNum',
    hpDiceSize: 'hpDiceSize',
    hpDiceBonus: 'hpDiceBonus',
    damageDiceNum: 'damageDiceNum',
    damageDiceSize: 'damageDiceSize',
    damageDiceBonus: 'damageDiceBonus',
    copper: 'copper',
    silver: 'silver',
    gold: 'gold',
    platinum: 'platinum',
    raceAlign: 'raceAlign',
    total_wealth: 'total_wealth',
    average_stats: 'average_stats',
    estimated_hp: 'estimated_hp',
    strength: 'strength',
    intelligence: 'intelligence',
    wisdom: 'wisdom',
    dexterity: 'dexterity',
    constitution: 'constitution',
    charisma: 'charisma',
    perception: 'perception',
    concealment: 'concealment',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted_at: 'deleted_at',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    classId: 'classId',
    race: 'race',
    mobFlags: 'mobFlags',
    effectFlags: 'effectFlags',
    position: 'position',
    defaultPosition: 'defaultPosition',
    gender: 'gender',
    size: 'size',
    lifeForce: 'lifeForce',
    composition: 'composition',
    stance: 'stance',
    damageType: 'damageType'
  };

  export type MobScalarFieldEnum = (typeof MobScalarFieldEnum)[keyof typeof MobScalarFieldEnum]


  export const MobSkillScalarFieldEnum: {
    id: 'id',
    mobZoneId: 'mobZoneId',
    mobId: 'mobId',
    skillId: 'skillId',
    level: 'level'
  };

  export type MobSkillScalarFieldEnum = (typeof MobSkillScalarFieldEnum)[keyof typeof MobSkillScalarFieldEnum]


  export const MobSpellScalarFieldEnum: {
    id: 'id',
    mobZoneId: 'mobZoneId',
    mobId: 'mobId',
    spellId: 'spellId',
    circle: 'circle',
    known: 'known'
  };

  export type MobSpellScalarFieldEnum = (typeof MobSpellScalarFieldEnum)[keyof typeof MobSpellScalarFieldEnum]


  export const MobResetScalarFieldEnum: {
    id: 'id',
    max: 'max',
    name: 'name',
    mobZoneId: 'mobZoneId',
    mobId: 'mobId',
    roomZoneId: 'roomZoneId',
    roomId: 'roomId',
    zoneId: 'zoneId',
    probability: 'probability'
  };

  export type MobResetScalarFieldEnum = (typeof MobResetScalarFieldEnum)[keyof typeof MobResetScalarFieldEnum]


  export const MobCarryingScalarFieldEnum: {
    id: 'id',
    max: 'max',
    name: 'name',
    objectZoneId: 'objectZoneId',
    objectId: 'objectId',
    resetId: 'resetId'
  };

  export type MobCarryingScalarFieldEnum = (typeof MobCarryingScalarFieldEnum)[keyof typeof MobCarryingScalarFieldEnum]


  export const MobEquippedScalarFieldEnum: {
    id: 'id',
    max: 'max',
    location: 'location',
    name: 'name',
    objectZoneId: 'objectZoneId',
    objectId: 'objectId',
    resetId: 'resetId'
  };

  export type MobEquippedScalarFieldEnum = (typeof MobEquippedScalarFieldEnum)[keyof typeof MobEquippedScalarFieldEnum]


  export const ObjectScalarFieldEnum: {
    id: 'id',
    type: 'type',
    keywords: 'keywords',
    shortDesc: 'shortDesc',
    description: 'description',
    actionDesc: 'actionDesc',
    weight: 'weight',
    cost: 'cost',
    timer: 'timer',
    decomposeTimer: 'decomposeTimer',
    level: 'level',
    concealment: 'concealment',
    values: 'values',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted_at: 'deleted_at',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    flags: 'flags',
    effectFlags: 'effectFlags',
    wearFlags: 'wearFlags'
  };

  export type ObjectScalarFieldEnum = (typeof ObjectScalarFieldEnum)[keyof typeof ObjectScalarFieldEnum]


  export const ObjectExtraDescriptionScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    description: 'description',
    objectZoneId: 'objectZoneId',
    objectId: 'objectId'
  };

  export type ObjectExtraDescriptionScalarFieldEnum = (typeof ObjectExtraDescriptionScalarFieldEnum)[keyof typeof ObjectExtraDescriptionScalarFieldEnum]


  export const ObjectAffectScalarFieldEnum: {
    id: 'id',
    location: 'location',
    modifier: 'modifier',
    objectZoneId: 'objectZoneId',
    objectId: 'objectId'
  };

  export type ObjectAffectScalarFieldEnum = (typeof ObjectAffectScalarFieldEnum)[keyof typeof ObjectAffectScalarFieldEnum]


  export const ObjectSpellScalarFieldEnum: {
    id: 'id',
    spell: 'spell',
    level: 'level',
    objectZoneId: 'objectZoneId',
    objectId: 'objectId'
  };

  export type ObjectSpellScalarFieldEnum = (typeof ObjectSpellScalarFieldEnum)[keyof typeof ObjectSpellScalarFieldEnum]


  export const ShopScalarFieldEnum: {
    id: 'id',
    buyProfit: 'buyProfit',
    sellProfit: 'sellProfit',
    temper1: 'temper1',
    noSuchItem1: 'noSuchItem1',
    noSuchItem2: 'noSuchItem2',
    doNotBuy: 'doNotBuy',
    missingCash1: 'missingCash1',
    missingCash2: 'missingCash2',
    messageBuy: 'messageBuy',
    messageSell: 'messageSell',
    keeperZoneId: 'keeperZoneId',
    keeperId: 'keeperId',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    flags: 'flags',
    tradesWithFlags: 'tradesWithFlags'
  };

  export type ShopScalarFieldEnum = (typeof ShopScalarFieldEnum)[keyof typeof ShopScalarFieldEnum]


  export const ShopItemScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    shopZoneId: 'shopZoneId',
    shopId: 'shopId',
    objectZoneId: 'objectZoneId',
    objectId: 'objectId'
  };

  export type ShopItemScalarFieldEnum = (typeof ShopItemScalarFieldEnum)[keyof typeof ShopItemScalarFieldEnum]


  export const ShopAcceptScalarFieldEnum: {
    id: 'id',
    type: 'type',
    keywords: 'keywords',
    shopZoneId: 'shopZoneId',
    shopId: 'shopId'
  };

  export type ShopAcceptScalarFieldEnum = (typeof ShopAcceptScalarFieldEnum)[keyof typeof ShopAcceptScalarFieldEnum]


  export const ShopRoomScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    shopZoneId: 'shopZoneId',
    shopId: 'shopId'
  };

  export type ShopRoomScalarFieldEnum = (typeof ShopRoomScalarFieldEnum)[keyof typeof ShopRoomScalarFieldEnum]


  export const ShopHourScalarFieldEnum: {
    id: 'id',
    open: 'open',
    close: 'close',
    shopZoneId: 'shopZoneId',
    shopId: 'shopId'
  };

  export type ShopHourScalarFieldEnum = (typeof ShopHourScalarFieldEnum)[keyof typeof ShopHourScalarFieldEnum]


  export const TriggerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    attachType: 'attachType',
    numArgs: 'numArgs',
    argList: 'argList',
    commands: 'commands',
    zoneId: 'zoneId',
    mobZoneId: 'mobZoneId',
    mobId: 'mobId',
    objectZoneId: 'objectZoneId',
    objectId: 'objectId',
    variables: 'variables',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    flags: 'flags'
  };

  export type TriggerScalarFieldEnum = (typeof TriggerScalarFieldEnum)[keyof typeof TriggerScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const GameClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    hitDice: 'hitDice',
    primaryStat: 'primaryStat',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameClassScalarFieldEnum = (typeof GameClassScalarFieldEnum)[keyof typeof GameClassScalarFieldEnum]


  export const SpellScalarFieldEnum: {
    id: 'id',
    name: 'name',
    schoolId: 'schoolId',
    minPosition: 'minPosition',
    violent: 'violent',
    castTimeRounds: 'castTimeRounds',
    cooldownMs: 'cooldownMs',
    inCombatOnly: 'inCombatOnly',
    isArea: 'isArea',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpellScalarFieldEnum = (typeof SpellScalarFieldEnum)[keyof typeof SpellScalarFieldEnum]


  export const SpellSchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type SpellSchoolScalarFieldEnum = (typeof SpellSchoolScalarFieldEnum)[keyof typeof SpellSchoolScalarFieldEnum]


  export const SpellClassCircleScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    classId: 'classId',
    circle: 'circle',
    minLevel: 'minLevel',
    proficiencyGain: 'proficiencyGain'
  };

  export type SpellClassCircleScalarFieldEnum = (typeof SpellClassCircleScalarFieldEnum)[keyof typeof SpellClassCircleScalarFieldEnum]


  export const SpellTargetingScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    allowedTargetsMask: 'allowedTargetsMask',
    targetScope: 'targetScope',
    maxTargets: 'maxTargets',
    range: 'range',
    requireLos: 'requireLos',
    filtersMask: 'filtersMask'
  };

  export type SpellTargetingScalarFieldEnum = (typeof SpellTargetingScalarFieldEnum)[keyof typeof SpellTargetingScalarFieldEnum]


  export const SpellSavingThrowScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    saveType: 'saveType',
    onSave: 'onSave',
    dcFormula: 'dcFormula',
    saveModifierMask: 'saveModifierMask'
  };

  export type SpellSavingThrowScalarFieldEnum = (typeof SpellSavingThrowScalarFieldEnum)[keyof typeof SpellSavingThrowScalarFieldEnum]


  export const SpellMessageScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    startToCaster: 'startToCaster',
    startToVictim: 'startToVictim',
    startToRoom: 'startToRoom',
    successToCaster: 'successToCaster',
    successToVictim: 'successToVictim',
    successToRoom: 'successToRoom',
    failToCaster: 'failToCaster',
    failToVictim: 'failToVictim',
    failToRoom: 'failToRoom',
    wearoffToTarget: 'wearoffToTarget',
    wearoffToRoom: 'wearoffToRoom'
  };

  export type SpellMessageScalarFieldEnum = (typeof SpellMessageScalarFieldEnum)[keyof typeof SpellMessageScalarFieldEnum]


  export const SpellComponentScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    objectId: 'objectId',
    consumed: 'consumed',
    required: 'required'
  };

  export type SpellComponentScalarFieldEnum = (typeof SpellComponentScalarFieldEnum)[keyof typeof SpellComponentScalarFieldEnum]


  export const SpellRestrictionScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    indoorsOnly: 'indoorsOnly',
    outdoorsOnly: 'outdoorsOnly',
    noSafeRooms: 'noSafeRooms',
    noTeleportFlagsMask: 'noTeleportFlagsMask',
    terrainMask: 'terrainMask',
    disallowStatesMask: 'disallowStatesMask'
  };

  export type SpellRestrictionScalarFieldEnum = (typeof SpellRestrictionScalarFieldEnum)[keyof typeof SpellRestrictionScalarFieldEnum]


  export const SpellEffectScalarFieldEnum: {
    id: 'id',
    spellId: 'spellId',
    effectType: 'effectType',
    order: 'order',
    chancePct: 'chancePct',
    trigger: 'trigger',
    durationFormula: 'durationFormula',
    stackingRule: 'stackingRule',
    conditionFilter: 'conditionFilter',
    params: 'params'
  };

  export type SpellEffectScalarFieldEnum = (typeof SpellEffectScalarFieldEnum)[keyof typeof SpellEffectScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    category: 'category',
    maxLevel: 'maxLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const ClassSkillScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    skillId: 'skillId',
    category: 'category',
    minLevel: 'minLevel',
    maxLevel: 'maxLevel'
  };

  export type ClassSkillScalarFieldEnum = (typeof ClassSkillScalarFieldEnum)[keyof typeof ClassSkillScalarFieldEnum]


  export const RaceSkillScalarFieldEnum: {
    id: 'id',
    race: 'race',
    skillId: 'skillId',
    category: 'category',
    bonus: 'bonus'
  };

  export type RaceSkillScalarFieldEnum = (typeof RaceSkillScalarFieldEnum)[keyof typeof RaceSkillScalarFieldEnum]


  export const CharacterSkillScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    skillId: 'skillId',
    level: 'level',
    experience: 'experience',
    lastUsed: 'lastUsed'
  };

  export type CharacterSkillScalarFieldEnum = (typeof CharacterSkillScalarFieldEnum)[keyof typeof CharacterSkillScalarFieldEnum]


  export const CharacterSpellScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    spellId: 'spellId',
    known: 'known',
    proficiency: 'proficiency',
    lastCast: 'lastCast'
  };

  export type CharacterSpellScalarFieldEnum = (typeof CharacterSpellScalarFieldEnum)[keyof typeof CharacterSpellScalarFieldEnum]


  export const ChangeLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    changes: 'changes',
    userId: 'userId',
    timestamp: 'timestamp',
    description: 'description'
  };

  export type ChangeLogScalarFieldEnum = (typeof ChangeLogScalarFieldEnum)[keyof typeof ChangeLogScalarFieldEnum]


  export const BanRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bannedBy: 'bannedBy',
    reason: 'reason',
    bannedAt: 'bannedAt',
    expiresAt: 'expiresAt',
    unbannedAt: 'unbannedAt',
    unbannedBy: 'unbannedBy',
    active: 'active'
  };

  export type BanRecordScalarFieldEnum = (typeof BanRecordScalarFieldEnum)[keyof typeof BanRecordScalarFieldEnum]


  export const CharacterItemScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    object_zone_id: 'object_zone_id',
    object_id: 'object_id',
    containerId: 'containerId',
    equippedLocation: 'equippedLocation',
    condition: 'condition',
    charges: 'charges',
    instanceFlags: 'instanceFlags',
    customShortDesc: 'customShortDesc',
    customLongDesc: 'customLongDesc',
    customValues: 'customValues',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CharacterItemScalarFieldEnum = (typeof CharacterItemScalarFieldEnum)[keyof typeof CharacterItemScalarFieldEnum]


  export const CharacterEffectScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    effectName: 'effectName',
    effectType: 'effectType',
    duration: 'duration',
    strength: 'strength',
    modifierData: 'modifierData',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    appliedAt: 'appliedAt',
    expiresAt: 'expiresAt'
  };

  export type CharacterEffectScalarFieldEnum = (typeof CharacterEffectScalarFieldEnum)[keyof typeof CharacterEffectScalarFieldEnum]


  export const EquipmentSetItemScalarFieldEnum: {
    id: 'id',
    equipmentSetId: 'equipmentSetId',
    objectZoneId: 'objectZoneId',
    objectId: 'objectId',
    slot: 'slot',
    quantity: 'quantity',
    probability: 'probability'
  };

  export type EquipmentSetItemScalarFieldEnum = (typeof EquipmentSetItemScalarFieldEnum)[keyof typeof EquipmentSetItemScalarFieldEnum]


  export const EquipmentSetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentSetScalarFieldEnum = (typeof EquipmentSetScalarFieldEnum)[keyof typeof EquipmentSetScalarFieldEnum]


  export const MobEquipmentSetScalarFieldEnum: {
    id: 'id',
    mobResetId: 'mobResetId',
    equipmentSetId: 'equipmentSetId',
    probability: 'probability'
  };

  export type MobEquipmentSetScalarFieldEnum = (typeof MobEquipmentSetScalarFieldEnum)[keyof typeof MobEquipmentSetScalarFieldEnum]


  export const ObjectResetScalarFieldEnum: {
    id: 'id',
    max: 'max',
    name: 'name',
    objectZoneId: 'objectZoneId',
    objectId: 'objectId',
    roomZoneId: 'roomZoneId',
    roomId: 'roomId',
    zoneId: 'zoneId',
    probability: 'probability'
  };

  export type ObjectResetScalarFieldEnum = (typeof ObjectResetScalarFieldEnum)[keyof typeof ObjectResetScalarFieldEnum]


  export const SpawnConditionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    parameters: 'parameters',
    mobResetId: 'mobResetId',
    objectResetId: 'objectResetId'
  };

  export type SpawnConditionScalarFieldEnum = (typeof SpawnConditionScalarFieldEnum)[keyof typeof SpawnConditionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Race'
   */
  export type EnumRaceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Race'>
    


  /**
   * Reference to a field of type 'Race[]'
   */
  export type ListEnumRaceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Race[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ResetMode'
   */
  export type EnumResetModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResetMode'>
    


  /**
   * Reference to a field of type 'ResetMode[]'
   */
  export type ListEnumResetModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResetMode[]'>
    


  /**
   * Reference to a field of type 'Hemisphere'
   */
  export type EnumHemisphereFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Hemisphere'>
    


  /**
   * Reference to a field of type 'Hemisphere[]'
   */
  export type ListEnumHemisphereFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Hemisphere[]'>
    


  /**
   * Reference to a field of type 'Climate'
   */
  export type EnumClimateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Climate'>
    


  /**
   * Reference to a field of type 'Climate[]'
   */
  export type ListEnumClimateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Climate[]'>
    


  /**
   * Reference to a field of type 'Sector'
   */
  export type EnumSectorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sector'>
    


  /**
   * Reference to a field of type 'Sector[]'
   */
  export type ListEnumSectorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sector[]'>
    


  /**
   * Reference to a field of type 'RoomFlag[]'
   */
  export type ListEnumRoomFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomFlag[]'>
    


  /**
   * Reference to a field of type 'RoomFlag'
   */
  export type EnumRoomFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomFlag'>
    


  /**
   * Reference to a field of type 'Direction'
   */
  export type EnumDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Direction'>
    


  /**
   * Reference to a field of type 'Direction[]'
   */
  export type ListEnumDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Direction[]'>
    


  /**
   * Reference to a field of type 'ExitFlag[]'
   */
  export type ListEnumExitFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExitFlag[]'>
    


  /**
   * Reference to a field of type 'ExitFlag'
   */
  export type EnumExitFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExitFlag'>
    


  /**
   * Reference to a field of type 'MobFlag[]'
   */
  export type ListEnumMobFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MobFlag[]'>
    


  /**
   * Reference to a field of type 'MobFlag'
   */
  export type EnumMobFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MobFlag'>
    


  /**
   * Reference to a field of type 'EffectFlag[]'
   */
  export type ListEnumEffectFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EffectFlag[]'>
    


  /**
   * Reference to a field of type 'EffectFlag'
   */
  export type EnumEffectFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EffectFlag'>
    


  /**
   * Reference to a field of type 'Position'
   */
  export type EnumPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Position'>
    


  /**
   * Reference to a field of type 'Position[]'
   */
  export type ListEnumPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Position[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Size'
   */
  export type EnumSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Size'>
    


  /**
   * Reference to a field of type 'Size[]'
   */
  export type ListEnumSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Size[]'>
    


  /**
   * Reference to a field of type 'LifeForce'
   */
  export type EnumLifeForceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LifeForce'>
    


  /**
   * Reference to a field of type 'LifeForce[]'
   */
  export type ListEnumLifeForceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LifeForce[]'>
    


  /**
   * Reference to a field of type 'Composition'
   */
  export type EnumCompositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Composition'>
    


  /**
   * Reference to a field of type 'Composition[]'
   */
  export type ListEnumCompositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Composition[]'>
    


  /**
   * Reference to a field of type 'Stance'
   */
  export type EnumStanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Stance'>
    


  /**
   * Reference to a field of type 'Stance[]'
   */
  export type ListEnumStanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Stance[]'>
    


  /**
   * Reference to a field of type 'DamageType'
   */
  export type EnumDamageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DamageType'>
    


  /**
   * Reference to a field of type 'DamageType[]'
   */
  export type ListEnumDamageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DamageType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ObjectType'
   */
  export type EnumObjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObjectType'>
    


  /**
   * Reference to a field of type 'ObjectType[]'
   */
  export type ListEnumObjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObjectType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ObjectFlag[]'
   */
  export type ListEnumObjectFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObjectFlag[]'>
    


  /**
   * Reference to a field of type 'ObjectFlag'
   */
  export type EnumObjectFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObjectFlag'>
    


  /**
   * Reference to a field of type 'WearFlag[]'
   */
  export type ListEnumWearFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WearFlag[]'>
    


  /**
   * Reference to a field of type 'WearFlag'
   */
  export type EnumWearFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WearFlag'>
    


  /**
   * Reference to a field of type 'ShopFlag[]'
   */
  export type ListEnumShopFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShopFlag[]'>
    


  /**
   * Reference to a field of type 'ShopFlag'
   */
  export type EnumShopFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShopFlag'>
    


  /**
   * Reference to a field of type 'ShopTradesWith[]'
   */
  export type ListEnumShopTradesWithFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShopTradesWith[]'>
    


  /**
   * Reference to a field of type 'ShopTradesWith'
   */
  export type EnumShopTradesWithFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShopTradesWith'>
    


  /**
   * Reference to a field of type 'ScriptType'
   */
  export type EnumScriptTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScriptType'>
    


  /**
   * Reference to a field of type 'ScriptType[]'
   */
  export type ListEnumScriptTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScriptType[]'>
    


  /**
   * Reference to a field of type 'TriggerFlag[]'
   */
  export type ListEnumTriggerFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerFlag[]'>
    


  /**
   * Reference to a field of type 'TriggerFlag'
   */
  export type EnumTriggerFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerFlag'>
    


  /**
   * Reference to a field of type 'TargetScope'
   */
  export type EnumTargetScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TargetScope'>
    


  /**
   * Reference to a field of type 'TargetScope[]'
   */
  export type ListEnumTargetScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TargetScope[]'>
    


  /**
   * Reference to a field of type 'SpellRange'
   */
  export type EnumSpellRangeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpellRange'>
    


  /**
   * Reference to a field of type 'SpellRange[]'
   */
  export type ListEnumSpellRangeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpellRange[]'>
    


  /**
   * Reference to a field of type 'SaveType'
   */
  export type EnumSaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SaveType'>
    


  /**
   * Reference to a field of type 'SaveType[]'
   */
  export type ListEnumSaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SaveType[]'>
    


  /**
   * Reference to a field of type 'SaveResult'
   */
  export type EnumSaveResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SaveResult'>
    


  /**
   * Reference to a field of type 'SaveResult[]'
   */
  export type ListEnumSaveResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SaveResult[]'>
    


  /**
   * Reference to a field of type 'EffectType'
   */
  export type EnumEffectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EffectType'>
    


  /**
   * Reference to a field of type 'EffectType[]'
   */
  export type ListEnumEffectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EffectType[]'>
    


  /**
   * Reference to a field of type 'EffectTrigger'
   */
  export type EnumEffectTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EffectTrigger'>
    


  /**
   * Reference to a field of type 'EffectTrigger[]'
   */
  export type ListEnumEffectTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EffectTrigger[]'>
    


  /**
   * Reference to a field of type 'StackingRule'
   */
  export type EnumStackingRuleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StackingRule'>
    


  /**
   * Reference to a field of type 'StackingRule[]'
   */
  export type ListEnumStackingRuleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StackingRule[]'>
    


  /**
   * Reference to a field of type 'SkillType'
   */
  export type EnumSkillTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillType'>
    


  /**
   * Reference to a field of type 'SkillType[]'
   */
  export type ListEnumSkillTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillType[]'>
    


  /**
   * Reference to a field of type 'SkillCategory'
   */
  export type EnumSkillCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillCategory'>
    


  /**
   * Reference to a field of type 'SkillCategory[]'
   */
  export type ListEnumSkillCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillCategory[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    lastFailedLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    auditLogs?: AuditLogListRelationFilter
    issuedBans?: BanRecordListRelationFilter
    banRecords?: BanRecordListRelationFilter
    changeLogs?: ChangeLogListRelationFilter
    characters?: CharacterListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    lastFailedLogin?: SortOrderInput | SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
    issuedBans?: BanRecordOrderByRelationAggregateInput
    banRecords?: BanRecordOrderByRelationAggregateInput
    changeLogs?: ChangeLogOrderByRelationAggregateInput
    characters?: CharacterOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    lastFailedLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    auditLogs?: AuditLogListRelationFilter
    issuedBans?: BanRecordListRelationFilter
    banRecords?: BanRecordListRelationFilter
    changeLogs?: ChangeLogListRelationFilter
    characters?: CharacterListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    lastFailedLogin?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastFailedLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    id?: StringFilter<"Character"> | string
    name?: StringFilter<"Character"> | string
    level?: IntFilter<"Character"> | number
    alignment?: IntFilter<"Character"> | number
    strength?: IntFilter<"Character"> | number
    intelligence?: IntFilter<"Character"> | number
    wisdom?: IntFilter<"Character"> | number
    dexterity?: IntFilter<"Character"> | number
    constitution?: IntFilter<"Character"> | number
    charisma?: IntFilter<"Character"> | number
    luck?: IntFilter<"Character"> | number
    hitPoints?: IntFilter<"Character"> | number
    movement?: IntFilter<"Character"> | number
    hitPointsMax?: IntFilter<"Character"> | number
    movementMax?: IntFilter<"Character"> | number
    copper?: IntFilter<"Character"> | number
    silver?: IntFilter<"Character"> | number
    gold?: IntFilter<"Character"> | number
    platinum?: IntFilter<"Character"> | number
    bankCopper?: IntFilter<"Character"> | number
    bankSilver?: IntFilter<"Character"> | number
    bankGold?: IntFilter<"Character"> | number
    bankPlatinum?: IntFilter<"Character"> | number
    total_wealth?: IntFilter<"Character"> | number
    average_stats?: IntFilter<"Character"> | number
    passwordHash?: StringNullableFilter<"Character"> | string | null
    raceType?: StringFilter<"Character"> | string
    race?: EnumRaceFilter<"Character"> | $Enums.Race
    gender?: StringFilter<"Character"> | string
    playerClass?: StringNullableFilter<"Character"> | string | null
    height?: IntNullableFilter<"Character"> | number | null
    weight?: IntNullableFilter<"Character"> | number | null
    baseSize?: IntFilter<"Character"> | number
    currentSize?: IntFilter<"Character"> | number
    hitRoll?: IntFilter<"Character"> | number
    damageRoll?: IntFilter<"Character"> | number
    armorClass?: IntFilter<"Character"> | number
    currentRoom?: IntNullableFilter<"Character"> | number | null
    saveRoom?: IntNullableFilter<"Character"> | number | null
    homeRoom?: IntNullableFilter<"Character"> | number | null
    lastLogin?: DateTimeNullableFilter<"Character"> | Date | string | null
    timePlayed?: IntFilter<"Character"> | number
    isOnline?: BoolFilter<"Character"> | boolean
    hunger?: IntFilter<"Character"> | number
    thirst?: IntFilter<"Character"> | number
    description?: StringNullableFilter<"Character"> | string | null
    title?: StringNullableFilter<"Character"> | string | null
    prompt?: StringFilter<"Character"> | string
    pageLength?: IntFilter<"Character"> | number
    playerFlags?: StringNullableListFilter<"Character">
    effectFlags?: StringNullableListFilter<"Character">
    privilegeFlags?: StringNullableListFilter<"Character">
    olcZones?: IntNullableListFilter<"Character">
    invisLevel?: IntFilter<"Character"> | number
    birthTime?: DateTimeFilter<"Character"> | Date | string
    userId?: StringFilter<"Character"> | string
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    classId?: IntNullableFilter<"Character"> | number | null
    experience?: IntFilter<"Character"> | number
    skillPoints?: IntFilter<"Character"> | number
    effects?: CharacterEffectListRelationFilter
    items?: CharacterItemListRelationFilter
    skills?: CharacterSkillListRelationFilter
    spells?: CharacterSpellListRelationFilter
    gameClass?: XOR<GameClassNullableRelationFilter, GameClassWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    alignment?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    luck?: SortOrder
    hitPoints?: SortOrder
    movement?: SortOrder
    hitPointsMax?: SortOrder
    movementMax?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    bankCopper?: SortOrder
    bankSilver?: SortOrder
    bankGold?: SortOrder
    bankPlatinum?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    raceType?: SortOrder
    race?: SortOrder
    gender?: SortOrder
    playerClass?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    baseSize?: SortOrder
    currentSize?: SortOrder
    hitRoll?: SortOrder
    damageRoll?: SortOrder
    armorClass?: SortOrder
    currentRoom?: SortOrderInput | SortOrder
    saveRoom?: SortOrderInput | SortOrder
    homeRoom?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    timePlayed?: SortOrder
    isOnline?: SortOrder
    hunger?: SortOrder
    thirst?: SortOrder
    description?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    prompt?: SortOrder
    pageLength?: SortOrder
    playerFlags?: SortOrder
    effectFlags?: SortOrder
    privilegeFlags?: SortOrder
    olcZones?: SortOrder
    invisLevel?: SortOrder
    birthTime?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classId?: SortOrderInput | SortOrder
    experience?: SortOrder
    skillPoints?: SortOrder
    effects?: CharacterEffectOrderByRelationAggregateInput
    items?: CharacterItemOrderByRelationAggregateInput
    skills?: CharacterSkillOrderByRelationAggregateInput
    spells?: CharacterSpellOrderByRelationAggregateInput
    gameClass?: GameClassOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    level?: IntFilter<"Character"> | number
    alignment?: IntFilter<"Character"> | number
    strength?: IntFilter<"Character"> | number
    intelligence?: IntFilter<"Character"> | number
    wisdom?: IntFilter<"Character"> | number
    dexterity?: IntFilter<"Character"> | number
    constitution?: IntFilter<"Character"> | number
    charisma?: IntFilter<"Character"> | number
    luck?: IntFilter<"Character"> | number
    hitPoints?: IntFilter<"Character"> | number
    movement?: IntFilter<"Character"> | number
    hitPointsMax?: IntFilter<"Character"> | number
    movementMax?: IntFilter<"Character"> | number
    copper?: IntFilter<"Character"> | number
    silver?: IntFilter<"Character"> | number
    gold?: IntFilter<"Character"> | number
    platinum?: IntFilter<"Character"> | number
    bankCopper?: IntFilter<"Character"> | number
    bankSilver?: IntFilter<"Character"> | number
    bankGold?: IntFilter<"Character"> | number
    bankPlatinum?: IntFilter<"Character"> | number
    total_wealth?: IntFilter<"Character"> | number
    average_stats?: IntFilter<"Character"> | number
    passwordHash?: StringNullableFilter<"Character"> | string | null
    raceType?: StringFilter<"Character"> | string
    race?: EnumRaceFilter<"Character"> | $Enums.Race
    gender?: StringFilter<"Character"> | string
    playerClass?: StringNullableFilter<"Character"> | string | null
    height?: IntNullableFilter<"Character"> | number | null
    weight?: IntNullableFilter<"Character"> | number | null
    baseSize?: IntFilter<"Character"> | number
    currentSize?: IntFilter<"Character"> | number
    hitRoll?: IntFilter<"Character"> | number
    damageRoll?: IntFilter<"Character"> | number
    armorClass?: IntFilter<"Character"> | number
    currentRoom?: IntNullableFilter<"Character"> | number | null
    saveRoom?: IntNullableFilter<"Character"> | number | null
    homeRoom?: IntNullableFilter<"Character"> | number | null
    lastLogin?: DateTimeNullableFilter<"Character"> | Date | string | null
    timePlayed?: IntFilter<"Character"> | number
    isOnline?: BoolFilter<"Character"> | boolean
    hunger?: IntFilter<"Character"> | number
    thirst?: IntFilter<"Character"> | number
    description?: StringNullableFilter<"Character"> | string | null
    title?: StringNullableFilter<"Character"> | string | null
    prompt?: StringFilter<"Character"> | string
    pageLength?: IntFilter<"Character"> | number
    playerFlags?: StringNullableListFilter<"Character">
    effectFlags?: StringNullableListFilter<"Character">
    privilegeFlags?: StringNullableListFilter<"Character">
    olcZones?: IntNullableListFilter<"Character">
    invisLevel?: IntFilter<"Character"> | number
    birthTime?: DateTimeFilter<"Character"> | Date | string
    userId?: StringFilter<"Character"> | string
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    classId?: IntNullableFilter<"Character"> | number | null
    experience?: IntFilter<"Character"> | number
    skillPoints?: IntFilter<"Character"> | number
    effects?: CharacterEffectListRelationFilter
    items?: CharacterItemListRelationFilter
    skills?: CharacterSkillListRelationFilter
    spells?: CharacterSpellListRelationFilter
    gameClass?: XOR<GameClassNullableRelationFilter, GameClassWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "name">

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    alignment?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    luck?: SortOrder
    hitPoints?: SortOrder
    movement?: SortOrder
    hitPointsMax?: SortOrder
    movementMax?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    bankCopper?: SortOrder
    bankSilver?: SortOrder
    bankGold?: SortOrder
    bankPlatinum?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    raceType?: SortOrder
    race?: SortOrder
    gender?: SortOrder
    playerClass?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    baseSize?: SortOrder
    currentSize?: SortOrder
    hitRoll?: SortOrder
    damageRoll?: SortOrder
    armorClass?: SortOrder
    currentRoom?: SortOrderInput | SortOrder
    saveRoom?: SortOrderInput | SortOrder
    homeRoom?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    timePlayed?: SortOrder
    isOnline?: SortOrder
    hunger?: SortOrder
    thirst?: SortOrder
    description?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    prompt?: SortOrder
    pageLength?: SortOrder
    playerFlags?: SortOrder
    effectFlags?: SortOrder
    privilegeFlags?: SortOrder
    olcZones?: SortOrder
    invisLevel?: SortOrder
    birthTime?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classId?: SortOrderInput | SortOrder
    experience?: SortOrder
    skillPoints?: SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Character"> | string
    name?: StringWithAggregatesFilter<"Character"> | string
    level?: IntWithAggregatesFilter<"Character"> | number
    alignment?: IntWithAggregatesFilter<"Character"> | number
    strength?: IntWithAggregatesFilter<"Character"> | number
    intelligence?: IntWithAggregatesFilter<"Character"> | number
    wisdom?: IntWithAggregatesFilter<"Character"> | number
    dexterity?: IntWithAggregatesFilter<"Character"> | number
    constitution?: IntWithAggregatesFilter<"Character"> | number
    charisma?: IntWithAggregatesFilter<"Character"> | number
    luck?: IntWithAggregatesFilter<"Character"> | number
    hitPoints?: IntWithAggregatesFilter<"Character"> | number
    movement?: IntWithAggregatesFilter<"Character"> | number
    hitPointsMax?: IntWithAggregatesFilter<"Character"> | number
    movementMax?: IntWithAggregatesFilter<"Character"> | number
    copper?: IntWithAggregatesFilter<"Character"> | number
    silver?: IntWithAggregatesFilter<"Character"> | number
    gold?: IntWithAggregatesFilter<"Character"> | number
    platinum?: IntWithAggregatesFilter<"Character"> | number
    bankCopper?: IntWithAggregatesFilter<"Character"> | number
    bankSilver?: IntWithAggregatesFilter<"Character"> | number
    bankGold?: IntWithAggregatesFilter<"Character"> | number
    bankPlatinum?: IntWithAggregatesFilter<"Character"> | number
    total_wealth?: IntWithAggregatesFilter<"Character"> | number
    average_stats?: IntWithAggregatesFilter<"Character"> | number
    passwordHash?: StringNullableWithAggregatesFilter<"Character"> | string | null
    raceType?: StringWithAggregatesFilter<"Character"> | string
    race?: EnumRaceWithAggregatesFilter<"Character"> | $Enums.Race
    gender?: StringWithAggregatesFilter<"Character"> | string
    playerClass?: StringNullableWithAggregatesFilter<"Character"> | string | null
    height?: IntNullableWithAggregatesFilter<"Character"> | number | null
    weight?: IntNullableWithAggregatesFilter<"Character"> | number | null
    baseSize?: IntWithAggregatesFilter<"Character"> | number
    currentSize?: IntWithAggregatesFilter<"Character"> | number
    hitRoll?: IntWithAggregatesFilter<"Character"> | number
    damageRoll?: IntWithAggregatesFilter<"Character"> | number
    armorClass?: IntWithAggregatesFilter<"Character"> | number
    currentRoom?: IntNullableWithAggregatesFilter<"Character"> | number | null
    saveRoom?: IntNullableWithAggregatesFilter<"Character"> | number | null
    homeRoom?: IntNullableWithAggregatesFilter<"Character"> | number | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"Character"> | Date | string | null
    timePlayed?: IntWithAggregatesFilter<"Character"> | number
    isOnline?: BoolWithAggregatesFilter<"Character"> | boolean
    hunger?: IntWithAggregatesFilter<"Character"> | number
    thirst?: IntWithAggregatesFilter<"Character"> | number
    description?: StringNullableWithAggregatesFilter<"Character"> | string | null
    title?: StringNullableWithAggregatesFilter<"Character"> | string | null
    prompt?: StringWithAggregatesFilter<"Character"> | string
    pageLength?: IntWithAggregatesFilter<"Character"> | number
    playerFlags?: StringNullableListFilter<"Character">
    effectFlags?: StringNullableListFilter<"Character">
    privilegeFlags?: StringNullableListFilter<"Character">
    olcZones?: IntNullableListFilter<"Character">
    invisLevel?: IntWithAggregatesFilter<"Character"> | number
    birthTime?: DateTimeWithAggregatesFilter<"Character"> | Date | string
    userId?: StringWithAggregatesFilter<"Character"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
    classId?: IntNullableWithAggregatesFilter<"Character"> | number | null
    experience?: IntWithAggregatesFilter<"Character"> | number
    skillPoints?: IntWithAggregatesFilter<"Character"> | number
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: IntFilter<"Zone"> | number
    name?: StringFilter<"Zone"> | string
    lifespan?: IntFilter<"Zone"> | number
    resetMode?: EnumResetModeFilter<"Zone"> | $Enums.ResetMode
    hemisphere?: EnumHemisphereFilter<"Zone"> | $Enums.Hemisphere
    climate?: EnumClimateFilter<"Zone"> | $Enums.Climate
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Zone"> | Date | string | null
    createdBy?: StringNullableFilter<"Zone"> | string | null
    updatedBy?: StringNullableFilter<"Zone"> | string | null
    mobResets?: MobResetListRelationFilter
    mobs?: MobListRelationFilter
    objectResets?: ObjectResetListRelationFilter
    objects?: ObjectListRelationFilter
    rooms?: RoomListRelationFilter
    shops?: ShopListRelationFilter
    triggers?: TriggerListRelationFilter
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lifespan?: SortOrder
    resetMode?: SortOrder
    hemisphere?: SortOrder
    climate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    mobResets?: MobResetOrderByRelationAggregateInput
    mobs?: MobOrderByRelationAggregateInput
    objectResets?: ObjectResetOrderByRelationAggregateInput
    objects?: ObjectOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    shops?: ShopOrderByRelationAggregateInput
    triggers?: TriggerOrderByRelationAggregateInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    name?: StringFilter<"Zone"> | string
    lifespan?: IntFilter<"Zone"> | number
    resetMode?: EnumResetModeFilter<"Zone"> | $Enums.ResetMode
    hemisphere?: EnumHemisphereFilter<"Zone"> | $Enums.Hemisphere
    climate?: EnumClimateFilter<"Zone"> | $Enums.Climate
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Zone"> | Date | string | null
    createdBy?: StringNullableFilter<"Zone"> | string | null
    updatedBy?: StringNullableFilter<"Zone"> | string | null
    mobResets?: MobResetListRelationFilter
    mobs?: MobListRelationFilter
    objectResets?: ObjectResetListRelationFilter
    objects?: ObjectListRelationFilter
    rooms?: RoomListRelationFilter
    shops?: ShopListRelationFilter
    triggers?: TriggerListRelationFilter
  }, "id">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lifespan?: SortOrder
    resetMode?: SortOrder
    hemisphere?: SortOrder
    climate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _avg?: ZoneAvgOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
    _sum?: ZoneSumOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Zone"> | number
    name?: StringWithAggregatesFilter<"Zone"> | string
    lifespan?: IntWithAggregatesFilter<"Zone"> | number
    resetMode?: EnumResetModeWithAggregatesFilter<"Zone"> | $Enums.ResetMode
    hemisphere?: EnumHemisphereWithAggregatesFilter<"Zone"> | $Enums.Hemisphere
    climate?: EnumClimateWithAggregatesFilter<"Zone"> | $Enums.Climate
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Zone"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Zone"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Zone"> | string | null
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: IntFilter<"Room"> | number
    name?: StringFilter<"Room"> | string
    description?: StringFilter<"Room"> | string
    sector?: EnumSectorFilter<"Room"> | $Enums.Sector
    zoneId?: IntFilter<"Room"> | number
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Room"> | Date | string | null
    createdBy?: StringNullableFilter<"Room"> | string | null
    updatedBy?: StringNullableFilter<"Room"> | string | null
    flags?: EnumRoomFlagNullableListFilter<"Room">
    layoutX?: IntNullableFilter<"Room"> | number | null
    layoutY?: IntNullableFilter<"Room"> | number | null
    layoutZ?: IntNullableFilter<"Room"> | number | null
    mobResets?: MobResetListRelationFilter
    objectResets?: ObjectResetListRelationFilter
    exits?: RoomExitListRelationFilter
    extraDescs?: RoomExtraDescriptionListRelationFilter
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sector?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    flags?: SortOrder
    layoutX?: SortOrderInput | SortOrder
    layoutY?: SortOrderInput | SortOrder
    layoutZ?: SortOrderInput | SortOrder
    mobResets?: MobResetOrderByRelationAggregateInput
    objectResets?: ObjectResetOrderByRelationAggregateInput
    exits?: RoomExitOrderByRelationAggregateInput
    extraDescs?: RoomExtraDescriptionOrderByRelationAggregateInput
    zone?: ZoneOrderByWithRelationInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    zoneId_id?: RoomZoneIdIdCompoundUniqueInput
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: IntFilter<"Room"> | number
    name?: StringFilter<"Room"> | string
    description?: StringFilter<"Room"> | string
    sector?: EnumSectorFilter<"Room"> | $Enums.Sector
    zoneId?: IntFilter<"Room"> | number
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Room"> | Date | string | null
    createdBy?: StringNullableFilter<"Room"> | string | null
    updatedBy?: StringNullableFilter<"Room"> | string | null
    flags?: EnumRoomFlagNullableListFilter<"Room">
    layoutX?: IntNullableFilter<"Room"> | number | null
    layoutY?: IntNullableFilter<"Room"> | number | null
    layoutZ?: IntNullableFilter<"Room"> | number | null
    mobResets?: MobResetListRelationFilter
    objectResets?: ObjectResetListRelationFilter
    exits?: RoomExitListRelationFilter
    extraDescs?: RoomExtraDescriptionListRelationFilter
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
  }, "zoneId_id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sector?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    flags?: SortOrder
    layoutX?: SortOrderInput | SortOrder
    layoutY?: SortOrderInput | SortOrder
    layoutZ?: SortOrderInput | SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Room"> | number
    name?: StringWithAggregatesFilter<"Room"> | string
    description?: StringWithAggregatesFilter<"Room"> | string
    sector?: EnumSectorWithAggregatesFilter<"Room"> | $Enums.Sector
    zoneId?: IntWithAggregatesFilter<"Room"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Room"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Room"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Room"> | string | null
    flags?: EnumRoomFlagNullableListFilter<"Room">
    layoutX?: IntNullableWithAggregatesFilter<"Room"> | number | null
    layoutY?: IntNullableWithAggregatesFilter<"Room"> | number | null
    layoutZ?: IntNullableWithAggregatesFilter<"Room"> | number | null
  }

  export type RoomExitWhereInput = {
    AND?: RoomExitWhereInput | RoomExitWhereInput[]
    OR?: RoomExitWhereInput[]
    NOT?: RoomExitWhereInput | RoomExitWhereInput[]
    id?: StringFilter<"RoomExit"> | string
    direction?: EnumDirectionFilter<"RoomExit"> | $Enums.Direction
    description?: StringNullableFilter<"RoomExit"> | string | null
    keyword?: StringNullableFilter<"RoomExit"> | string | null
    key?: StringNullableFilter<"RoomExit"> | string | null
    destination?: IntNullableFilter<"RoomExit"> | number | null
    roomZoneId?: IntFilter<"RoomExit"> | number
    roomId?: IntFilter<"RoomExit"> | number
    flags?: EnumExitFlagNullableListFilter<"RoomExit">
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }

  export type RoomExitOrderByWithRelationInput = {
    id?: SortOrder
    direction?: SortOrder
    description?: SortOrderInput | SortOrder
    keyword?: SortOrderInput | SortOrder
    key?: SortOrderInput | SortOrder
    destination?: SortOrderInput | SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    flags?: SortOrder
    room?: RoomOrderByWithRelationInput
  }

  export type RoomExitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomZoneId_roomId_direction?: RoomExitRoomZoneIdRoomIdDirectionCompoundUniqueInput
    AND?: RoomExitWhereInput | RoomExitWhereInput[]
    OR?: RoomExitWhereInput[]
    NOT?: RoomExitWhereInput | RoomExitWhereInput[]
    direction?: EnumDirectionFilter<"RoomExit"> | $Enums.Direction
    description?: StringNullableFilter<"RoomExit"> | string | null
    keyword?: StringNullableFilter<"RoomExit"> | string | null
    key?: StringNullableFilter<"RoomExit"> | string | null
    destination?: IntNullableFilter<"RoomExit"> | number | null
    roomZoneId?: IntFilter<"RoomExit"> | number
    roomId?: IntFilter<"RoomExit"> | number
    flags?: EnumExitFlagNullableListFilter<"RoomExit">
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }, "id" | "roomZoneId_roomId_direction">

  export type RoomExitOrderByWithAggregationInput = {
    id?: SortOrder
    direction?: SortOrder
    description?: SortOrderInput | SortOrder
    keyword?: SortOrderInput | SortOrder
    key?: SortOrderInput | SortOrder
    destination?: SortOrderInput | SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    flags?: SortOrder
    _count?: RoomExitCountOrderByAggregateInput
    _avg?: RoomExitAvgOrderByAggregateInput
    _max?: RoomExitMaxOrderByAggregateInput
    _min?: RoomExitMinOrderByAggregateInput
    _sum?: RoomExitSumOrderByAggregateInput
  }

  export type RoomExitScalarWhereWithAggregatesInput = {
    AND?: RoomExitScalarWhereWithAggregatesInput | RoomExitScalarWhereWithAggregatesInput[]
    OR?: RoomExitScalarWhereWithAggregatesInput[]
    NOT?: RoomExitScalarWhereWithAggregatesInput | RoomExitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomExit"> | string
    direction?: EnumDirectionWithAggregatesFilter<"RoomExit"> | $Enums.Direction
    description?: StringNullableWithAggregatesFilter<"RoomExit"> | string | null
    keyword?: StringNullableWithAggregatesFilter<"RoomExit"> | string | null
    key?: StringNullableWithAggregatesFilter<"RoomExit"> | string | null
    destination?: IntNullableWithAggregatesFilter<"RoomExit"> | number | null
    roomZoneId?: IntWithAggregatesFilter<"RoomExit"> | number
    roomId?: IntWithAggregatesFilter<"RoomExit"> | number
    flags?: EnumExitFlagNullableListFilter<"RoomExit">
  }

  export type RoomExtraDescriptionWhereInput = {
    AND?: RoomExtraDescriptionWhereInput | RoomExtraDescriptionWhereInput[]
    OR?: RoomExtraDescriptionWhereInput[]
    NOT?: RoomExtraDescriptionWhereInput | RoomExtraDescriptionWhereInput[]
    id?: StringFilter<"RoomExtraDescription"> | string
    keyword?: StringFilter<"RoomExtraDescription"> | string
    description?: StringFilter<"RoomExtraDescription"> | string
    roomZoneId?: IntFilter<"RoomExtraDescription"> | number
    roomId?: IntFilter<"RoomExtraDescription"> | number
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }

  export type RoomExtraDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    room?: RoomOrderByWithRelationInput
  }

  export type RoomExtraDescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomExtraDescriptionWhereInput | RoomExtraDescriptionWhereInput[]
    OR?: RoomExtraDescriptionWhereInput[]
    NOT?: RoomExtraDescriptionWhereInput | RoomExtraDescriptionWhereInput[]
    keyword?: StringFilter<"RoomExtraDescription"> | string
    description?: StringFilter<"RoomExtraDescription"> | string
    roomZoneId?: IntFilter<"RoomExtraDescription"> | number
    roomId?: IntFilter<"RoomExtraDescription"> | number
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }, "id">

  export type RoomExtraDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    _count?: RoomExtraDescriptionCountOrderByAggregateInput
    _avg?: RoomExtraDescriptionAvgOrderByAggregateInput
    _max?: RoomExtraDescriptionMaxOrderByAggregateInput
    _min?: RoomExtraDescriptionMinOrderByAggregateInput
    _sum?: RoomExtraDescriptionSumOrderByAggregateInput
  }

  export type RoomExtraDescriptionScalarWhereWithAggregatesInput = {
    AND?: RoomExtraDescriptionScalarWhereWithAggregatesInput | RoomExtraDescriptionScalarWhereWithAggregatesInput[]
    OR?: RoomExtraDescriptionScalarWhereWithAggregatesInput[]
    NOT?: RoomExtraDescriptionScalarWhereWithAggregatesInput | RoomExtraDescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomExtraDescription"> | string
    keyword?: StringWithAggregatesFilter<"RoomExtraDescription"> | string
    description?: StringWithAggregatesFilter<"RoomExtraDescription"> | string
    roomZoneId?: IntWithAggregatesFilter<"RoomExtraDescription"> | number
    roomId?: IntWithAggregatesFilter<"RoomExtraDescription"> | number
  }

  export type MobWhereInput = {
    AND?: MobWhereInput | MobWhereInput[]
    OR?: MobWhereInput[]
    NOT?: MobWhereInput | MobWhereInput[]
    id?: IntFilter<"Mob"> | number
    keywords?: StringNullableListFilter<"Mob">
    mobClass?: StringFilter<"Mob"> | string
    shortDesc?: StringFilter<"Mob"> | string
    longDesc?: StringFilter<"Mob"> | string
    desc?: StringFilter<"Mob"> | string
    alignment?: IntFilter<"Mob"> | number
    level?: IntFilter<"Mob"> | number
    armorClass?: IntFilter<"Mob"> | number
    hitRoll?: IntFilter<"Mob"> | number
    move?: IntFilter<"Mob"> | number
    hpDiceNum?: IntFilter<"Mob"> | number
    hpDiceSize?: IntFilter<"Mob"> | number
    hpDiceBonus?: IntFilter<"Mob"> | number
    damageDiceNum?: IntFilter<"Mob"> | number
    damageDiceSize?: IntFilter<"Mob"> | number
    damageDiceBonus?: IntFilter<"Mob"> | number
    copper?: IntFilter<"Mob"> | number
    silver?: IntFilter<"Mob"> | number
    gold?: IntFilter<"Mob"> | number
    platinum?: IntFilter<"Mob"> | number
    raceAlign?: IntFilter<"Mob"> | number
    total_wealth?: IntFilter<"Mob"> | number
    average_stats?: IntFilter<"Mob"> | number
    estimated_hp?: IntFilter<"Mob"> | number
    strength?: IntFilter<"Mob"> | number
    intelligence?: IntFilter<"Mob"> | number
    wisdom?: IntFilter<"Mob"> | number
    dexterity?: IntFilter<"Mob"> | number
    constitution?: IntFilter<"Mob"> | number
    charisma?: IntFilter<"Mob"> | number
    perception?: IntFilter<"Mob"> | number
    concealment?: IntFilter<"Mob"> | number
    zoneId?: IntFilter<"Mob"> | number
    createdAt?: DateTimeFilter<"Mob"> | Date | string
    updatedAt?: DateTimeFilter<"Mob"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Mob"> | Date | string | null
    createdBy?: StringNullableFilter<"Mob"> | string | null
    updatedBy?: StringNullableFilter<"Mob"> | string | null
    classId?: IntNullableFilter<"Mob"> | number | null
    race?: EnumRaceFilter<"Mob"> | $Enums.Race
    mobFlags?: EnumMobFlagNullableListFilter<"Mob">
    effectFlags?: EnumEffectFlagNullableListFilter<"Mob">
    position?: EnumPositionFilter<"Mob"> | $Enums.Position
    defaultPosition?: EnumPositionFilter<"Mob"> | $Enums.Position
    gender?: EnumGenderFilter<"Mob"> | $Enums.Gender
    size?: EnumSizeFilter<"Mob"> | $Enums.Size
    lifeForce?: EnumLifeForceFilter<"Mob"> | $Enums.LifeForce
    composition?: EnumCompositionFilter<"Mob"> | $Enums.Composition
    stance?: EnumStanceFilter<"Mob"> | $Enums.Stance
    damageType?: EnumDamageTypeFilter<"Mob"> | $Enums.DamageType
    resets?: MobResetListRelationFilter
    skills?: MobSkillListRelationFilter
    spells?: MobSpellListRelationFilter
    gameClass?: XOR<GameClassNullableRelationFilter, GameClassWhereInput> | null
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    shops?: ShopListRelationFilter
    triggers?: TriggerListRelationFilter
  }

  export type MobOrderByWithRelationInput = {
    id?: SortOrder
    keywords?: SortOrder
    mobClass?: SortOrder
    shortDesc?: SortOrder
    longDesc?: SortOrder
    desc?: SortOrder
    alignment?: SortOrder
    level?: SortOrder
    armorClass?: SortOrder
    hitRoll?: SortOrder
    move?: SortOrder
    hpDiceNum?: SortOrder
    hpDiceSize?: SortOrder
    hpDiceBonus?: SortOrder
    damageDiceNum?: SortOrder
    damageDiceSize?: SortOrder
    damageDiceBonus?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    raceAlign?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    estimated_hp?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    perception?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    classId?: SortOrderInput | SortOrder
    race?: SortOrder
    mobFlags?: SortOrder
    effectFlags?: SortOrder
    position?: SortOrder
    defaultPosition?: SortOrder
    gender?: SortOrder
    size?: SortOrder
    lifeForce?: SortOrder
    composition?: SortOrder
    stance?: SortOrder
    damageType?: SortOrder
    resets?: MobResetOrderByRelationAggregateInput
    skills?: MobSkillOrderByRelationAggregateInput
    spells?: MobSpellOrderByRelationAggregateInput
    gameClass?: GameClassOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    shops?: ShopOrderByRelationAggregateInput
    triggers?: TriggerOrderByRelationAggregateInput
  }

  export type MobWhereUniqueInput = Prisma.AtLeast<{
    zoneId_id?: MobZoneIdIdCompoundUniqueInput
    AND?: MobWhereInput | MobWhereInput[]
    OR?: MobWhereInput[]
    NOT?: MobWhereInput | MobWhereInput[]
    id?: IntFilter<"Mob"> | number
    keywords?: StringNullableListFilter<"Mob">
    mobClass?: StringFilter<"Mob"> | string
    shortDesc?: StringFilter<"Mob"> | string
    longDesc?: StringFilter<"Mob"> | string
    desc?: StringFilter<"Mob"> | string
    alignment?: IntFilter<"Mob"> | number
    level?: IntFilter<"Mob"> | number
    armorClass?: IntFilter<"Mob"> | number
    hitRoll?: IntFilter<"Mob"> | number
    move?: IntFilter<"Mob"> | number
    hpDiceNum?: IntFilter<"Mob"> | number
    hpDiceSize?: IntFilter<"Mob"> | number
    hpDiceBonus?: IntFilter<"Mob"> | number
    damageDiceNum?: IntFilter<"Mob"> | number
    damageDiceSize?: IntFilter<"Mob"> | number
    damageDiceBonus?: IntFilter<"Mob"> | number
    copper?: IntFilter<"Mob"> | number
    silver?: IntFilter<"Mob"> | number
    gold?: IntFilter<"Mob"> | number
    platinum?: IntFilter<"Mob"> | number
    raceAlign?: IntFilter<"Mob"> | number
    total_wealth?: IntFilter<"Mob"> | number
    average_stats?: IntFilter<"Mob"> | number
    estimated_hp?: IntFilter<"Mob"> | number
    strength?: IntFilter<"Mob"> | number
    intelligence?: IntFilter<"Mob"> | number
    wisdom?: IntFilter<"Mob"> | number
    dexterity?: IntFilter<"Mob"> | number
    constitution?: IntFilter<"Mob"> | number
    charisma?: IntFilter<"Mob"> | number
    perception?: IntFilter<"Mob"> | number
    concealment?: IntFilter<"Mob"> | number
    zoneId?: IntFilter<"Mob"> | number
    createdAt?: DateTimeFilter<"Mob"> | Date | string
    updatedAt?: DateTimeFilter<"Mob"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Mob"> | Date | string | null
    createdBy?: StringNullableFilter<"Mob"> | string | null
    updatedBy?: StringNullableFilter<"Mob"> | string | null
    classId?: IntNullableFilter<"Mob"> | number | null
    race?: EnumRaceFilter<"Mob"> | $Enums.Race
    mobFlags?: EnumMobFlagNullableListFilter<"Mob">
    effectFlags?: EnumEffectFlagNullableListFilter<"Mob">
    position?: EnumPositionFilter<"Mob"> | $Enums.Position
    defaultPosition?: EnumPositionFilter<"Mob"> | $Enums.Position
    gender?: EnumGenderFilter<"Mob"> | $Enums.Gender
    size?: EnumSizeFilter<"Mob"> | $Enums.Size
    lifeForce?: EnumLifeForceFilter<"Mob"> | $Enums.LifeForce
    composition?: EnumCompositionFilter<"Mob"> | $Enums.Composition
    stance?: EnumStanceFilter<"Mob"> | $Enums.Stance
    damageType?: EnumDamageTypeFilter<"Mob"> | $Enums.DamageType
    resets?: MobResetListRelationFilter
    skills?: MobSkillListRelationFilter
    spells?: MobSpellListRelationFilter
    gameClass?: XOR<GameClassNullableRelationFilter, GameClassWhereInput> | null
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    shops?: ShopListRelationFilter
    triggers?: TriggerListRelationFilter
  }, "zoneId_id">

  export type MobOrderByWithAggregationInput = {
    id?: SortOrder
    keywords?: SortOrder
    mobClass?: SortOrder
    shortDesc?: SortOrder
    longDesc?: SortOrder
    desc?: SortOrder
    alignment?: SortOrder
    level?: SortOrder
    armorClass?: SortOrder
    hitRoll?: SortOrder
    move?: SortOrder
    hpDiceNum?: SortOrder
    hpDiceSize?: SortOrder
    hpDiceBonus?: SortOrder
    damageDiceNum?: SortOrder
    damageDiceSize?: SortOrder
    damageDiceBonus?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    raceAlign?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    estimated_hp?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    perception?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    classId?: SortOrderInput | SortOrder
    race?: SortOrder
    mobFlags?: SortOrder
    effectFlags?: SortOrder
    position?: SortOrder
    defaultPosition?: SortOrder
    gender?: SortOrder
    size?: SortOrder
    lifeForce?: SortOrder
    composition?: SortOrder
    stance?: SortOrder
    damageType?: SortOrder
    _count?: MobCountOrderByAggregateInput
    _avg?: MobAvgOrderByAggregateInput
    _max?: MobMaxOrderByAggregateInput
    _min?: MobMinOrderByAggregateInput
    _sum?: MobSumOrderByAggregateInput
  }

  export type MobScalarWhereWithAggregatesInput = {
    AND?: MobScalarWhereWithAggregatesInput | MobScalarWhereWithAggregatesInput[]
    OR?: MobScalarWhereWithAggregatesInput[]
    NOT?: MobScalarWhereWithAggregatesInput | MobScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mob"> | number
    keywords?: StringNullableListFilter<"Mob">
    mobClass?: StringWithAggregatesFilter<"Mob"> | string
    shortDesc?: StringWithAggregatesFilter<"Mob"> | string
    longDesc?: StringWithAggregatesFilter<"Mob"> | string
    desc?: StringWithAggregatesFilter<"Mob"> | string
    alignment?: IntWithAggregatesFilter<"Mob"> | number
    level?: IntWithAggregatesFilter<"Mob"> | number
    armorClass?: IntWithAggregatesFilter<"Mob"> | number
    hitRoll?: IntWithAggregatesFilter<"Mob"> | number
    move?: IntWithAggregatesFilter<"Mob"> | number
    hpDiceNum?: IntWithAggregatesFilter<"Mob"> | number
    hpDiceSize?: IntWithAggregatesFilter<"Mob"> | number
    hpDiceBonus?: IntWithAggregatesFilter<"Mob"> | number
    damageDiceNum?: IntWithAggregatesFilter<"Mob"> | number
    damageDiceSize?: IntWithAggregatesFilter<"Mob"> | number
    damageDiceBonus?: IntWithAggregatesFilter<"Mob"> | number
    copper?: IntWithAggregatesFilter<"Mob"> | number
    silver?: IntWithAggregatesFilter<"Mob"> | number
    gold?: IntWithAggregatesFilter<"Mob"> | number
    platinum?: IntWithAggregatesFilter<"Mob"> | number
    raceAlign?: IntWithAggregatesFilter<"Mob"> | number
    total_wealth?: IntWithAggregatesFilter<"Mob"> | number
    average_stats?: IntWithAggregatesFilter<"Mob"> | number
    estimated_hp?: IntWithAggregatesFilter<"Mob"> | number
    strength?: IntWithAggregatesFilter<"Mob"> | number
    intelligence?: IntWithAggregatesFilter<"Mob"> | number
    wisdom?: IntWithAggregatesFilter<"Mob"> | number
    dexterity?: IntWithAggregatesFilter<"Mob"> | number
    constitution?: IntWithAggregatesFilter<"Mob"> | number
    charisma?: IntWithAggregatesFilter<"Mob"> | number
    perception?: IntWithAggregatesFilter<"Mob"> | number
    concealment?: IntWithAggregatesFilter<"Mob"> | number
    zoneId?: IntWithAggregatesFilter<"Mob"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Mob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mob"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Mob"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Mob"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Mob"> | string | null
    classId?: IntNullableWithAggregatesFilter<"Mob"> | number | null
    race?: EnumRaceWithAggregatesFilter<"Mob"> | $Enums.Race
    mobFlags?: EnumMobFlagNullableListFilter<"Mob">
    effectFlags?: EnumEffectFlagNullableListFilter<"Mob">
    position?: EnumPositionWithAggregatesFilter<"Mob"> | $Enums.Position
    defaultPosition?: EnumPositionWithAggregatesFilter<"Mob"> | $Enums.Position
    gender?: EnumGenderWithAggregatesFilter<"Mob"> | $Enums.Gender
    size?: EnumSizeWithAggregatesFilter<"Mob"> | $Enums.Size
    lifeForce?: EnumLifeForceWithAggregatesFilter<"Mob"> | $Enums.LifeForce
    composition?: EnumCompositionWithAggregatesFilter<"Mob"> | $Enums.Composition
    stance?: EnumStanceWithAggregatesFilter<"Mob"> | $Enums.Stance
    damageType?: EnumDamageTypeWithAggregatesFilter<"Mob"> | $Enums.DamageType
  }

  export type MobSkillWhereInput = {
    AND?: MobSkillWhereInput | MobSkillWhereInput[]
    OR?: MobSkillWhereInput[]
    NOT?: MobSkillWhereInput | MobSkillWhereInput[]
    id?: IntFilter<"MobSkill"> | number
    mobZoneId?: IntFilter<"MobSkill"> | number
    mobId?: IntFilter<"MobSkill"> | number
    skillId?: IntFilter<"MobSkill"> | number
    level?: IntFilter<"MobSkill"> | number
    mob?: XOR<MobRelationFilter, MobWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type MobSkillOrderByWithRelationInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    mob?: MobOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type MobSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mobZoneId_mobId_skillId?: MobSkillMobZoneIdMobIdSkillIdCompoundUniqueInput
    AND?: MobSkillWhereInput | MobSkillWhereInput[]
    OR?: MobSkillWhereInput[]
    NOT?: MobSkillWhereInput | MobSkillWhereInput[]
    mobZoneId?: IntFilter<"MobSkill"> | number
    mobId?: IntFilter<"MobSkill"> | number
    skillId?: IntFilter<"MobSkill"> | number
    level?: IntFilter<"MobSkill"> | number
    mob?: XOR<MobRelationFilter, MobWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "id" | "mobZoneId_mobId_skillId">

  export type MobSkillOrderByWithAggregationInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    _count?: MobSkillCountOrderByAggregateInput
    _avg?: MobSkillAvgOrderByAggregateInput
    _max?: MobSkillMaxOrderByAggregateInput
    _min?: MobSkillMinOrderByAggregateInput
    _sum?: MobSkillSumOrderByAggregateInput
  }

  export type MobSkillScalarWhereWithAggregatesInput = {
    AND?: MobSkillScalarWhereWithAggregatesInput | MobSkillScalarWhereWithAggregatesInput[]
    OR?: MobSkillScalarWhereWithAggregatesInput[]
    NOT?: MobSkillScalarWhereWithAggregatesInput | MobSkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MobSkill"> | number
    mobZoneId?: IntWithAggregatesFilter<"MobSkill"> | number
    mobId?: IntWithAggregatesFilter<"MobSkill"> | number
    skillId?: IntWithAggregatesFilter<"MobSkill"> | number
    level?: IntWithAggregatesFilter<"MobSkill"> | number
  }

  export type MobSpellWhereInput = {
    AND?: MobSpellWhereInput | MobSpellWhereInput[]
    OR?: MobSpellWhereInput[]
    NOT?: MobSpellWhereInput | MobSpellWhereInput[]
    id?: IntFilter<"MobSpell"> | number
    mobZoneId?: IntFilter<"MobSpell"> | number
    mobId?: IntFilter<"MobSpell"> | number
    spellId?: IntFilter<"MobSpell"> | number
    circle?: IntFilter<"MobSpell"> | number
    known?: BoolFilter<"MobSpell"> | boolean
    mob?: XOR<MobRelationFilter, MobWhereInput>
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }

  export type MobSpellOrderByWithRelationInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    spellId?: SortOrder
    circle?: SortOrder
    known?: SortOrder
    mob?: MobOrderByWithRelationInput
    spell?: SpellOrderByWithRelationInput
  }

  export type MobSpellWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mobZoneId_mobId_spellId?: MobSpellMobZoneIdMobIdSpellIdCompoundUniqueInput
    AND?: MobSpellWhereInput | MobSpellWhereInput[]
    OR?: MobSpellWhereInput[]
    NOT?: MobSpellWhereInput | MobSpellWhereInput[]
    mobZoneId?: IntFilter<"MobSpell"> | number
    mobId?: IntFilter<"MobSpell"> | number
    spellId?: IntFilter<"MobSpell"> | number
    circle?: IntFilter<"MobSpell"> | number
    known?: BoolFilter<"MobSpell"> | boolean
    mob?: XOR<MobRelationFilter, MobWhereInput>
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }, "id" | "mobZoneId_mobId_spellId">

  export type MobSpellOrderByWithAggregationInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    spellId?: SortOrder
    circle?: SortOrder
    known?: SortOrder
    _count?: MobSpellCountOrderByAggregateInput
    _avg?: MobSpellAvgOrderByAggregateInput
    _max?: MobSpellMaxOrderByAggregateInput
    _min?: MobSpellMinOrderByAggregateInput
    _sum?: MobSpellSumOrderByAggregateInput
  }

  export type MobSpellScalarWhereWithAggregatesInput = {
    AND?: MobSpellScalarWhereWithAggregatesInput | MobSpellScalarWhereWithAggregatesInput[]
    OR?: MobSpellScalarWhereWithAggregatesInput[]
    NOT?: MobSpellScalarWhereWithAggregatesInput | MobSpellScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MobSpell"> | number
    mobZoneId?: IntWithAggregatesFilter<"MobSpell"> | number
    mobId?: IntWithAggregatesFilter<"MobSpell"> | number
    spellId?: IntWithAggregatesFilter<"MobSpell"> | number
    circle?: IntWithAggregatesFilter<"MobSpell"> | number
    known?: BoolWithAggregatesFilter<"MobSpell"> | boolean
  }

  export type MobResetWhereInput = {
    AND?: MobResetWhereInput | MobResetWhereInput[]
    OR?: MobResetWhereInput[]
    NOT?: MobResetWhereInput | MobResetWhereInput[]
    id?: StringFilter<"MobReset"> | string
    max?: IntFilter<"MobReset"> | number
    name?: StringNullableFilter<"MobReset"> | string | null
    mobZoneId?: IntFilter<"MobReset"> | number
    mobId?: IntFilter<"MobReset"> | number
    roomZoneId?: IntFilter<"MobReset"> | number
    roomId?: IntFilter<"MobReset"> | number
    zoneId?: IntFilter<"MobReset"> | number
    probability?: FloatFilter<"MobReset"> | number
    carrying?: MobCarryingListRelationFilter
    equipmentSets?: MobEquipmentSetListRelationFilter
    equipped?: MobEquippedListRelationFilter
    mob?: XOR<MobRelationFilter, MobWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    spawnConditions?: SpawnConditionListRelationFilter
  }

  export type MobResetOrderByWithRelationInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrderInput | SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
    carrying?: MobCarryingOrderByRelationAggregateInput
    equipmentSets?: MobEquipmentSetOrderByRelationAggregateInput
    equipped?: MobEquippedOrderByRelationAggregateInput
    mob?: MobOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    spawnConditions?: SpawnConditionOrderByRelationAggregateInput
  }

  export type MobResetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MobResetWhereInput | MobResetWhereInput[]
    OR?: MobResetWhereInput[]
    NOT?: MobResetWhereInput | MobResetWhereInput[]
    max?: IntFilter<"MobReset"> | number
    name?: StringNullableFilter<"MobReset"> | string | null
    mobZoneId?: IntFilter<"MobReset"> | number
    mobId?: IntFilter<"MobReset"> | number
    roomZoneId?: IntFilter<"MobReset"> | number
    roomId?: IntFilter<"MobReset"> | number
    zoneId?: IntFilter<"MobReset"> | number
    probability?: FloatFilter<"MobReset"> | number
    carrying?: MobCarryingListRelationFilter
    equipmentSets?: MobEquipmentSetListRelationFilter
    equipped?: MobEquippedListRelationFilter
    mob?: XOR<MobRelationFilter, MobWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    spawnConditions?: SpawnConditionListRelationFilter
  }, "id">

  export type MobResetOrderByWithAggregationInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrderInput | SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
    _count?: MobResetCountOrderByAggregateInput
    _avg?: MobResetAvgOrderByAggregateInput
    _max?: MobResetMaxOrderByAggregateInput
    _min?: MobResetMinOrderByAggregateInput
    _sum?: MobResetSumOrderByAggregateInput
  }

  export type MobResetScalarWhereWithAggregatesInput = {
    AND?: MobResetScalarWhereWithAggregatesInput | MobResetScalarWhereWithAggregatesInput[]
    OR?: MobResetScalarWhereWithAggregatesInput[]
    NOT?: MobResetScalarWhereWithAggregatesInput | MobResetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MobReset"> | string
    max?: IntWithAggregatesFilter<"MobReset"> | number
    name?: StringNullableWithAggregatesFilter<"MobReset"> | string | null
    mobZoneId?: IntWithAggregatesFilter<"MobReset"> | number
    mobId?: IntWithAggregatesFilter<"MobReset"> | number
    roomZoneId?: IntWithAggregatesFilter<"MobReset"> | number
    roomId?: IntWithAggregatesFilter<"MobReset"> | number
    zoneId?: IntWithAggregatesFilter<"MobReset"> | number
    probability?: FloatWithAggregatesFilter<"MobReset"> | number
  }

  export type MobCarryingWhereInput = {
    AND?: MobCarryingWhereInput | MobCarryingWhereInput[]
    OR?: MobCarryingWhereInput[]
    NOT?: MobCarryingWhereInput | MobCarryingWhereInput[]
    id?: StringFilter<"MobCarrying"> | string
    max?: IntFilter<"MobCarrying"> | number
    name?: StringNullableFilter<"MobCarrying"> | string | null
    objectZoneId?: IntFilter<"MobCarrying"> | number
    objectId?: IntFilter<"MobCarrying"> | number
    resetId?: StringFilter<"MobCarrying"> | string
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    reset?: XOR<MobResetRelationFilter, MobResetWhereInput>
  }

  export type MobCarryingOrderByWithRelationInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrderInput | SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    resetId?: SortOrder
    object?: ObjectOrderByWithRelationInput
    reset?: MobResetOrderByWithRelationInput
  }

  export type MobCarryingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MobCarryingWhereInput | MobCarryingWhereInput[]
    OR?: MobCarryingWhereInput[]
    NOT?: MobCarryingWhereInput | MobCarryingWhereInput[]
    max?: IntFilter<"MobCarrying"> | number
    name?: StringNullableFilter<"MobCarrying"> | string | null
    objectZoneId?: IntFilter<"MobCarrying"> | number
    objectId?: IntFilter<"MobCarrying"> | number
    resetId?: StringFilter<"MobCarrying"> | string
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    reset?: XOR<MobResetRelationFilter, MobResetWhereInput>
  }, "id">

  export type MobCarryingOrderByWithAggregationInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrderInput | SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    resetId?: SortOrder
    _count?: MobCarryingCountOrderByAggregateInput
    _avg?: MobCarryingAvgOrderByAggregateInput
    _max?: MobCarryingMaxOrderByAggregateInput
    _min?: MobCarryingMinOrderByAggregateInput
    _sum?: MobCarryingSumOrderByAggregateInput
  }

  export type MobCarryingScalarWhereWithAggregatesInput = {
    AND?: MobCarryingScalarWhereWithAggregatesInput | MobCarryingScalarWhereWithAggregatesInput[]
    OR?: MobCarryingScalarWhereWithAggregatesInput[]
    NOT?: MobCarryingScalarWhereWithAggregatesInput | MobCarryingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MobCarrying"> | string
    max?: IntWithAggregatesFilter<"MobCarrying"> | number
    name?: StringNullableWithAggregatesFilter<"MobCarrying"> | string | null
    objectZoneId?: IntWithAggregatesFilter<"MobCarrying"> | number
    objectId?: IntWithAggregatesFilter<"MobCarrying"> | number
    resetId?: StringWithAggregatesFilter<"MobCarrying"> | string
  }

  export type MobEquippedWhereInput = {
    AND?: MobEquippedWhereInput | MobEquippedWhereInput[]
    OR?: MobEquippedWhereInput[]
    NOT?: MobEquippedWhereInput | MobEquippedWhereInput[]
    id?: StringFilter<"MobEquipped"> | string
    max?: IntFilter<"MobEquipped"> | number
    location?: StringFilter<"MobEquipped"> | string
    name?: StringNullableFilter<"MobEquipped"> | string | null
    objectZoneId?: IntFilter<"MobEquipped"> | number
    objectId?: IntFilter<"MobEquipped"> | number
    resetId?: StringFilter<"MobEquipped"> | string
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    reset?: XOR<MobResetRelationFilter, MobResetWhereInput>
  }

  export type MobEquippedOrderByWithRelationInput = {
    id?: SortOrder
    max?: SortOrder
    location?: SortOrder
    name?: SortOrderInput | SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    resetId?: SortOrder
    object?: ObjectOrderByWithRelationInput
    reset?: MobResetOrderByWithRelationInput
  }

  export type MobEquippedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MobEquippedWhereInput | MobEquippedWhereInput[]
    OR?: MobEquippedWhereInput[]
    NOT?: MobEquippedWhereInput | MobEquippedWhereInput[]
    max?: IntFilter<"MobEquipped"> | number
    location?: StringFilter<"MobEquipped"> | string
    name?: StringNullableFilter<"MobEquipped"> | string | null
    objectZoneId?: IntFilter<"MobEquipped"> | number
    objectId?: IntFilter<"MobEquipped"> | number
    resetId?: StringFilter<"MobEquipped"> | string
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    reset?: XOR<MobResetRelationFilter, MobResetWhereInput>
  }, "id">

  export type MobEquippedOrderByWithAggregationInput = {
    id?: SortOrder
    max?: SortOrder
    location?: SortOrder
    name?: SortOrderInput | SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    resetId?: SortOrder
    _count?: MobEquippedCountOrderByAggregateInput
    _avg?: MobEquippedAvgOrderByAggregateInput
    _max?: MobEquippedMaxOrderByAggregateInput
    _min?: MobEquippedMinOrderByAggregateInput
    _sum?: MobEquippedSumOrderByAggregateInput
  }

  export type MobEquippedScalarWhereWithAggregatesInput = {
    AND?: MobEquippedScalarWhereWithAggregatesInput | MobEquippedScalarWhereWithAggregatesInput[]
    OR?: MobEquippedScalarWhereWithAggregatesInput[]
    NOT?: MobEquippedScalarWhereWithAggregatesInput | MobEquippedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MobEquipped"> | string
    max?: IntWithAggregatesFilter<"MobEquipped"> | number
    location?: StringWithAggregatesFilter<"MobEquipped"> | string
    name?: StringNullableWithAggregatesFilter<"MobEquipped"> | string | null
    objectZoneId?: IntWithAggregatesFilter<"MobEquipped"> | number
    objectId?: IntWithAggregatesFilter<"MobEquipped"> | number
    resetId?: StringWithAggregatesFilter<"MobEquipped"> | string
  }

  export type ObjectWhereInput = {
    AND?: ObjectWhereInput | ObjectWhereInput[]
    OR?: ObjectWhereInput[]
    NOT?: ObjectWhereInput | ObjectWhereInput[]
    id?: IntFilter<"Object"> | number
    type?: EnumObjectTypeFilter<"Object"> | $Enums.ObjectType
    keywords?: StringNullableListFilter<"Object">
    shortDesc?: StringFilter<"Object"> | string
    description?: StringFilter<"Object"> | string
    actionDesc?: StringNullableFilter<"Object"> | string | null
    weight?: FloatFilter<"Object"> | number
    cost?: IntFilter<"Object"> | number
    timer?: IntFilter<"Object"> | number
    decomposeTimer?: IntFilter<"Object"> | number
    level?: IntFilter<"Object"> | number
    concealment?: IntFilter<"Object"> | number
    values?: JsonFilter<"Object">
    zoneId?: IntFilter<"Object"> | number
    createdAt?: DateTimeFilter<"Object"> | Date | string
    updatedAt?: DateTimeFilter<"Object"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Object"> | Date | string | null
    createdBy?: StringNullableFilter<"Object"> | string | null
    updatedBy?: StringNullableFilter<"Object"> | string | null
    flags?: EnumObjectFlagNullableListFilter<"Object">
    effectFlags?: EnumEffectFlagNullableListFilter<"Object">
    wearFlags?: EnumWearFlagNullableListFilter<"Object">
    characterItems?: CharacterItemListRelationFilter
    equipmentSetItems?: EquipmentSetItemListRelationFilter
    mobCarrying?: MobCarryingListRelationFilter
    mobEquipped?: MobEquippedListRelationFilter
    affects?: ObjectAffectListRelationFilter
    extraDescs?: ObjectExtraDescriptionListRelationFilter
    resets?: ObjectResetListRelationFilter
    spells?: ObjectSpellListRelationFilter
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    shopItems?: ShopItemListRelationFilter
    triggers?: TriggerListRelationFilter
  }

  export type ObjectOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    keywords?: SortOrder
    shortDesc?: SortOrder
    description?: SortOrder
    actionDesc?: SortOrderInput | SortOrder
    weight?: SortOrder
    cost?: SortOrder
    timer?: SortOrder
    decomposeTimer?: SortOrder
    level?: SortOrder
    concealment?: SortOrder
    values?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    flags?: SortOrder
    effectFlags?: SortOrder
    wearFlags?: SortOrder
    characterItems?: CharacterItemOrderByRelationAggregateInput
    equipmentSetItems?: EquipmentSetItemOrderByRelationAggregateInput
    mobCarrying?: MobCarryingOrderByRelationAggregateInput
    mobEquipped?: MobEquippedOrderByRelationAggregateInput
    affects?: ObjectAffectOrderByRelationAggregateInput
    extraDescs?: ObjectExtraDescriptionOrderByRelationAggregateInput
    resets?: ObjectResetOrderByRelationAggregateInput
    spells?: ObjectSpellOrderByRelationAggregateInput
    zone?: ZoneOrderByWithRelationInput
    shopItems?: ShopItemOrderByRelationAggregateInput
    triggers?: TriggerOrderByRelationAggregateInput
  }

  export type ObjectWhereUniqueInput = Prisma.AtLeast<{
    zoneId_id?: ObjectZoneIdIdCompoundUniqueInput
    AND?: ObjectWhereInput | ObjectWhereInput[]
    OR?: ObjectWhereInput[]
    NOT?: ObjectWhereInput | ObjectWhereInput[]
    id?: IntFilter<"Object"> | number
    type?: EnumObjectTypeFilter<"Object"> | $Enums.ObjectType
    keywords?: StringNullableListFilter<"Object">
    shortDesc?: StringFilter<"Object"> | string
    description?: StringFilter<"Object"> | string
    actionDesc?: StringNullableFilter<"Object"> | string | null
    weight?: FloatFilter<"Object"> | number
    cost?: IntFilter<"Object"> | number
    timer?: IntFilter<"Object"> | number
    decomposeTimer?: IntFilter<"Object"> | number
    level?: IntFilter<"Object"> | number
    concealment?: IntFilter<"Object"> | number
    values?: JsonFilter<"Object">
    zoneId?: IntFilter<"Object"> | number
    createdAt?: DateTimeFilter<"Object"> | Date | string
    updatedAt?: DateTimeFilter<"Object"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Object"> | Date | string | null
    createdBy?: StringNullableFilter<"Object"> | string | null
    updatedBy?: StringNullableFilter<"Object"> | string | null
    flags?: EnumObjectFlagNullableListFilter<"Object">
    effectFlags?: EnumEffectFlagNullableListFilter<"Object">
    wearFlags?: EnumWearFlagNullableListFilter<"Object">
    characterItems?: CharacterItemListRelationFilter
    equipmentSetItems?: EquipmentSetItemListRelationFilter
    mobCarrying?: MobCarryingListRelationFilter
    mobEquipped?: MobEquippedListRelationFilter
    affects?: ObjectAffectListRelationFilter
    extraDescs?: ObjectExtraDescriptionListRelationFilter
    resets?: ObjectResetListRelationFilter
    spells?: ObjectSpellListRelationFilter
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    shopItems?: ShopItemListRelationFilter
    triggers?: TriggerListRelationFilter
  }, "zoneId_id">

  export type ObjectOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    keywords?: SortOrder
    shortDesc?: SortOrder
    description?: SortOrder
    actionDesc?: SortOrderInput | SortOrder
    weight?: SortOrder
    cost?: SortOrder
    timer?: SortOrder
    decomposeTimer?: SortOrder
    level?: SortOrder
    concealment?: SortOrder
    values?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    flags?: SortOrder
    effectFlags?: SortOrder
    wearFlags?: SortOrder
    _count?: ObjectCountOrderByAggregateInput
    _avg?: ObjectAvgOrderByAggregateInput
    _max?: ObjectMaxOrderByAggregateInput
    _min?: ObjectMinOrderByAggregateInput
    _sum?: ObjectSumOrderByAggregateInput
  }

  export type ObjectScalarWhereWithAggregatesInput = {
    AND?: ObjectScalarWhereWithAggregatesInput | ObjectScalarWhereWithAggregatesInput[]
    OR?: ObjectScalarWhereWithAggregatesInput[]
    NOT?: ObjectScalarWhereWithAggregatesInput | ObjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Object"> | number
    type?: EnumObjectTypeWithAggregatesFilter<"Object"> | $Enums.ObjectType
    keywords?: StringNullableListFilter<"Object">
    shortDesc?: StringWithAggregatesFilter<"Object"> | string
    description?: StringWithAggregatesFilter<"Object"> | string
    actionDesc?: StringNullableWithAggregatesFilter<"Object"> | string | null
    weight?: FloatWithAggregatesFilter<"Object"> | number
    cost?: IntWithAggregatesFilter<"Object"> | number
    timer?: IntWithAggregatesFilter<"Object"> | number
    decomposeTimer?: IntWithAggregatesFilter<"Object"> | number
    level?: IntWithAggregatesFilter<"Object"> | number
    concealment?: IntWithAggregatesFilter<"Object"> | number
    values?: JsonWithAggregatesFilter<"Object">
    zoneId?: IntWithAggregatesFilter<"Object"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Object"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Object"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Object"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Object"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Object"> | string | null
    flags?: EnumObjectFlagNullableListFilter<"Object">
    effectFlags?: EnumEffectFlagNullableListFilter<"Object">
    wearFlags?: EnumWearFlagNullableListFilter<"Object">
  }

  export type ObjectExtraDescriptionWhereInput = {
    AND?: ObjectExtraDescriptionWhereInput | ObjectExtraDescriptionWhereInput[]
    OR?: ObjectExtraDescriptionWhereInput[]
    NOT?: ObjectExtraDescriptionWhereInput | ObjectExtraDescriptionWhereInput[]
    id?: StringFilter<"ObjectExtraDescription"> | string
    keyword?: StringFilter<"ObjectExtraDescription"> | string
    description?: StringFilter<"ObjectExtraDescription"> | string
    objectZoneId?: IntFilter<"ObjectExtraDescription"> | number
    objectId?: IntFilter<"ObjectExtraDescription"> | number
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }

  export type ObjectExtraDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    object?: ObjectOrderByWithRelationInput
  }

  export type ObjectExtraDescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObjectExtraDescriptionWhereInput | ObjectExtraDescriptionWhereInput[]
    OR?: ObjectExtraDescriptionWhereInput[]
    NOT?: ObjectExtraDescriptionWhereInput | ObjectExtraDescriptionWhereInput[]
    keyword?: StringFilter<"ObjectExtraDescription"> | string
    description?: StringFilter<"ObjectExtraDescription"> | string
    objectZoneId?: IntFilter<"ObjectExtraDescription"> | number
    objectId?: IntFilter<"ObjectExtraDescription"> | number
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }, "id">

  export type ObjectExtraDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    _count?: ObjectExtraDescriptionCountOrderByAggregateInput
    _avg?: ObjectExtraDescriptionAvgOrderByAggregateInput
    _max?: ObjectExtraDescriptionMaxOrderByAggregateInput
    _min?: ObjectExtraDescriptionMinOrderByAggregateInput
    _sum?: ObjectExtraDescriptionSumOrderByAggregateInput
  }

  export type ObjectExtraDescriptionScalarWhereWithAggregatesInput = {
    AND?: ObjectExtraDescriptionScalarWhereWithAggregatesInput | ObjectExtraDescriptionScalarWhereWithAggregatesInput[]
    OR?: ObjectExtraDescriptionScalarWhereWithAggregatesInput[]
    NOT?: ObjectExtraDescriptionScalarWhereWithAggregatesInput | ObjectExtraDescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ObjectExtraDescription"> | string
    keyword?: StringWithAggregatesFilter<"ObjectExtraDescription"> | string
    description?: StringWithAggregatesFilter<"ObjectExtraDescription"> | string
    objectZoneId?: IntWithAggregatesFilter<"ObjectExtraDescription"> | number
    objectId?: IntWithAggregatesFilter<"ObjectExtraDescription"> | number
  }

  export type ObjectAffectWhereInput = {
    AND?: ObjectAffectWhereInput | ObjectAffectWhereInput[]
    OR?: ObjectAffectWhereInput[]
    NOT?: ObjectAffectWhereInput | ObjectAffectWhereInput[]
    id?: StringFilter<"ObjectAffect"> | string
    location?: StringFilter<"ObjectAffect"> | string
    modifier?: IntFilter<"ObjectAffect"> | number
    objectZoneId?: IntFilter<"ObjectAffect"> | number
    objectId?: IntFilter<"ObjectAffect"> | number
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }

  export type ObjectAffectOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    modifier?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    object?: ObjectOrderByWithRelationInput
  }

  export type ObjectAffectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObjectAffectWhereInput | ObjectAffectWhereInput[]
    OR?: ObjectAffectWhereInput[]
    NOT?: ObjectAffectWhereInput | ObjectAffectWhereInput[]
    location?: StringFilter<"ObjectAffect"> | string
    modifier?: IntFilter<"ObjectAffect"> | number
    objectZoneId?: IntFilter<"ObjectAffect"> | number
    objectId?: IntFilter<"ObjectAffect"> | number
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }, "id">

  export type ObjectAffectOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    modifier?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    _count?: ObjectAffectCountOrderByAggregateInput
    _avg?: ObjectAffectAvgOrderByAggregateInput
    _max?: ObjectAffectMaxOrderByAggregateInput
    _min?: ObjectAffectMinOrderByAggregateInput
    _sum?: ObjectAffectSumOrderByAggregateInput
  }

  export type ObjectAffectScalarWhereWithAggregatesInput = {
    AND?: ObjectAffectScalarWhereWithAggregatesInput | ObjectAffectScalarWhereWithAggregatesInput[]
    OR?: ObjectAffectScalarWhereWithAggregatesInput[]
    NOT?: ObjectAffectScalarWhereWithAggregatesInput | ObjectAffectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ObjectAffect"> | string
    location?: StringWithAggregatesFilter<"ObjectAffect"> | string
    modifier?: IntWithAggregatesFilter<"ObjectAffect"> | number
    objectZoneId?: IntWithAggregatesFilter<"ObjectAffect"> | number
    objectId?: IntWithAggregatesFilter<"ObjectAffect"> | number
  }

  export type ObjectSpellWhereInput = {
    AND?: ObjectSpellWhereInput | ObjectSpellWhereInput[]
    OR?: ObjectSpellWhereInput[]
    NOT?: ObjectSpellWhereInput | ObjectSpellWhereInput[]
    id?: StringFilter<"ObjectSpell"> | string
    spell?: StringFilter<"ObjectSpell"> | string
    level?: IntFilter<"ObjectSpell"> | number
    objectZoneId?: IntFilter<"ObjectSpell"> | number
    objectId?: IntFilter<"ObjectSpell"> | number
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }

  export type ObjectSpellOrderByWithRelationInput = {
    id?: SortOrder
    spell?: SortOrder
    level?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    object?: ObjectOrderByWithRelationInput
  }

  export type ObjectSpellWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObjectSpellWhereInput | ObjectSpellWhereInput[]
    OR?: ObjectSpellWhereInput[]
    NOT?: ObjectSpellWhereInput | ObjectSpellWhereInput[]
    spell?: StringFilter<"ObjectSpell"> | string
    level?: IntFilter<"ObjectSpell"> | number
    objectZoneId?: IntFilter<"ObjectSpell"> | number
    objectId?: IntFilter<"ObjectSpell"> | number
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }, "id">

  export type ObjectSpellOrderByWithAggregationInput = {
    id?: SortOrder
    spell?: SortOrder
    level?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    _count?: ObjectSpellCountOrderByAggregateInput
    _avg?: ObjectSpellAvgOrderByAggregateInput
    _max?: ObjectSpellMaxOrderByAggregateInput
    _min?: ObjectSpellMinOrderByAggregateInput
    _sum?: ObjectSpellSumOrderByAggregateInput
  }

  export type ObjectSpellScalarWhereWithAggregatesInput = {
    AND?: ObjectSpellScalarWhereWithAggregatesInput | ObjectSpellScalarWhereWithAggregatesInput[]
    OR?: ObjectSpellScalarWhereWithAggregatesInput[]
    NOT?: ObjectSpellScalarWhereWithAggregatesInput | ObjectSpellScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ObjectSpell"> | string
    spell?: StringWithAggregatesFilter<"ObjectSpell"> | string
    level?: IntWithAggregatesFilter<"ObjectSpell"> | number
    objectZoneId?: IntWithAggregatesFilter<"ObjectSpell"> | number
    objectId?: IntWithAggregatesFilter<"ObjectSpell"> | number
  }

  export type ShopWhereInput = {
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    id?: IntFilter<"Shop"> | number
    buyProfit?: FloatFilter<"Shop"> | number
    sellProfit?: FloatFilter<"Shop"> | number
    temper1?: IntFilter<"Shop"> | number
    noSuchItem1?: StringNullableFilter<"Shop"> | string | null
    noSuchItem2?: StringNullableFilter<"Shop"> | string | null
    doNotBuy?: StringNullableFilter<"Shop"> | string | null
    missingCash1?: StringNullableFilter<"Shop"> | string | null
    missingCash2?: StringNullableFilter<"Shop"> | string | null
    messageBuy?: StringNullableFilter<"Shop"> | string | null
    messageSell?: StringNullableFilter<"Shop"> | string | null
    keeperZoneId?: IntNullableFilter<"Shop"> | number | null
    keeperId?: IntNullableFilter<"Shop"> | number | null
    zoneId?: IntFilter<"Shop"> | number
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    createdBy?: StringNullableFilter<"Shop"> | string | null
    updatedBy?: StringNullableFilter<"Shop"> | string | null
    flags?: EnumShopFlagNullableListFilter<"Shop">
    tradesWithFlags?: EnumShopTradesWithNullableListFilter<"Shop">
    accepts?: ShopAcceptListRelationFilter
    hours?: ShopHourListRelationFilter
    items?: ShopItemListRelationFilter
    rooms?: ShopRoomListRelationFilter
    keeper?: XOR<MobNullableRelationFilter, MobWhereInput> | null
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
  }

  export type ShopOrderByWithRelationInput = {
    id?: SortOrder
    buyProfit?: SortOrder
    sellProfit?: SortOrder
    temper1?: SortOrder
    noSuchItem1?: SortOrderInput | SortOrder
    noSuchItem2?: SortOrderInput | SortOrder
    doNotBuy?: SortOrderInput | SortOrder
    missingCash1?: SortOrderInput | SortOrder
    missingCash2?: SortOrderInput | SortOrder
    messageBuy?: SortOrderInput | SortOrder
    messageSell?: SortOrderInput | SortOrder
    keeperZoneId?: SortOrderInput | SortOrder
    keeperId?: SortOrderInput | SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    flags?: SortOrder
    tradesWithFlags?: SortOrder
    accepts?: ShopAcceptOrderByRelationAggregateInput
    hours?: ShopHourOrderByRelationAggregateInput
    items?: ShopItemOrderByRelationAggregateInput
    rooms?: ShopRoomOrderByRelationAggregateInput
    keeper?: MobOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
  }

  export type ShopWhereUniqueInput = Prisma.AtLeast<{
    zoneId_id?: ShopZoneIdIdCompoundUniqueInput
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    id?: IntFilter<"Shop"> | number
    buyProfit?: FloatFilter<"Shop"> | number
    sellProfit?: FloatFilter<"Shop"> | number
    temper1?: IntFilter<"Shop"> | number
    noSuchItem1?: StringNullableFilter<"Shop"> | string | null
    noSuchItem2?: StringNullableFilter<"Shop"> | string | null
    doNotBuy?: StringNullableFilter<"Shop"> | string | null
    missingCash1?: StringNullableFilter<"Shop"> | string | null
    missingCash2?: StringNullableFilter<"Shop"> | string | null
    messageBuy?: StringNullableFilter<"Shop"> | string | null
    messageSell?: StringNullableFilter<"Shop"> | string | null
    keeperZoneId?: IntNullableFilter<"Shop"> | number | null
    keeperId?: IntNullableFilter<"Shop"> | number | null
    zoneId?: IntFilter<"Shop"> | number
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    createdBy?: StringNullableFilter<"Shop"> | string | null
    updatedBy?: StringNullableFilter<"Shop"> | string | null
    flags?: EnumShopFlagNullableListFilter<"Shop">
    tradesWithFlags?: EnumShopTradesWithNullableListFilter<"Shop">
    accepts?: ShopAcceptListRelationFilter
    hours?: ShopHourListRelationFilter
    items?: ShopItemListRelationFilter
    rooms?: ShopRoomListRelationFilter
    keeper?: XOR<MobNullableRelationFilter, MobWhereInput> | null
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
  }, "zoneId_id">

  export type ShopOrderByWithAggregationInput = {
    id?: SortOrder
    buyProfit?: SortOrder
    sellProfit?: SortOrder
    temper1?: SortOrder
    noSuchItem1?: SortOrderInput | SortOrder
    noSuchItem2?: SortOrderInput | SortOrder
    doNotBuy?: SortOrderInput | SortOrder
    missingCash1?: SortOrderInput | SortOrder
    missingCash2?: SortOrderInput | SortOrder
    messageBuy?: SortOrderInput | SortOrder
    messageSell?: SortOrderInput | SortOrder
    keeperZoneId?: SortOrderInput | SortOrder
    keeperId?: SortOrderInput | SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    flags?: SortOrder
    tradesWithFlags?: SortOrder
    _count?: ShopCountOrderByAggregateInput
    _avg?: ShopAvgOrderByAggregateInput
    _max?: ShopMaxOrderByAggregateInput
    _min?: ShopMinOrderByAggregateInput
    _sum?: ShopSumOrderByAggregateInput
  }

  export type ShopScalarWhereWithAggregatesInput = {
    AND?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    OR?: ShopScalarWhereWithAggregatesInput[]
    NOT?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shop"> | number
    buyProfit?: FloatWithAggregatesFilter<"Shop"> | number
    sellProfit?: FloatWithAggregatesFilter<"Shop"> | number
    temper1?: IntWithAggregatesFilter<"Shop"> | number
    noSuchItem1?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    noSuchItem2?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    doNotBuy?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    missingCash1?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    missingCash2?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    messageBuy?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    messageSell?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    keeperZoneId?: IntNullableWithAggregatesFilter<"Shop"> | number | null
    keeperId?: IntNullableWithAggregatesFilter<"Shop"> | number | null
    zoneId?: IntWithAggregatesFilter<"Shop"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    flags?: EnumShopFlagNullableListFilter<"Shop">
    tradesWithFlags?: EnumShopTradesWithNullableListFilter<"Shop">
  }

  export type ShopItemWhereInput = {
    AND?: ShopItemWhereInput | ShopItemWhereInput[]
    OR?: ShopItemWhereInput[]
    NOT?: ShopItemWhereInput | ShopItemWhereInput[]
    id?: StringFilter<"ShopItem"> | string
    amount?: IntFilter<"ShopItem"> | number
    shopZoneId?: IntFilter<"ShopItem"> | number
    shopId?: IntFilter<"ShopItem"> | number
    objectZoneId?: IntFilter<"ShopItem"> | number
    objectId?: IntFilter<"ShopItem"> | number
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type ShopItemOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    object?: ObjectOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
  }

  export type ShopItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shopZoneId_shopId_objectZoneId_objectId?: ShopItemShopZoneIdShopIdObjectZoneIdObjectIdCompoundUniqueInput
    AND?: ShopItemWhereInput | ShopItemWhereInput[]
    OR?: ShopItemWhereInput[]
    NOT?: ShopItemWhereInput | ShopItemWhereInput[]
    amount?: IntFilter<"ShopItem"> | number
    shopZoneId?: IntFilter<"ShopItem"> | number
    shopId?: IntFilter<"ShopItem"> | number
    objectZoneId?: IntFilter<"ShopItem"> | number
    objectId?: IntFilter<"ShopItem"> | number
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id" | "shopZoneId_shopId_objectZoneId_objectId">

  export type ShopItemOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    _count?: ShopItemCountOrderByAggregateInput
    _avg?: ShopItemAvgOrderByAggregateInput
    _max?: ShopItemMaxOrderByAggregateInput
    _min?: ShopItemMinOrderByAggregateInput
    _sum?: ShopItemSumOrderByAggregateInput
  }

  export type ShopItemScalarWhereWithAggregatesInput = {
    AND?: ShopItemScalarWhereWithAggregatesInput | ShopItemScalarWhereWithAggregatesInput[]
    OR?: ShopItemScalarWhereWithAggregatesInput[]
    NOT?: ShopItemScalarWhereWithAggregatesInput | ShopItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopItem"> | string
    amount?: IntWithAggregatesFilter<"ShopItem"> | number
    shopZoneId?: IntWithAggregatesFilter<"ShopItem"> | number
    shopId?: IntWithAggregatesFilter<"ShopItem"> | number
    objectZoneId?: IntWithAggregatesFilter<"ShopItem"> | number
    objectId?: IntWithAggregatesFilter<"ShopItem"> | number
  }

  export type ShopAcceptWhereInput = {
    AND?: ShopAcceptWhereInput | ShopAcceptWhereInput[]
    OR?: ShopAcceptWhereInput[]
    NOT?: ShopAcceptWhereInput | ShopAcceptWhereInput[]
    id?: StringFilter<"ShopAccept"> | string
    type?: StringFilter<"ShopAccept"> | string
    keywords?: StringNullableListFilter<"ShopAccept">
    shopZoneId?: IntFilter<"ShopAccept"> | number
    shopId?: IntFilter<"ShopAccept"> | number
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type ShopAcceptOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    keywords?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    shop?: ShopOrderByWithRelationInput
  }

  export type ShopAcceptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopAcceptWhereInput | ShopAcceptWhereInput[]
    OR?: ShopAcceptWhereInput[]
    NOT?: ShopAcceptWhereInput | ShopAcceptWhereInput[]
    type?: StringFilter<"ShopAccept"> | string
    keywords?: StringNullableListFilter<"ShopAccept">
    shopZoneId?: IntFilter<"ShopAccept"> | number
    shopId?: IntFilter<"ShopAccept"> | number
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id">

  export type ShopAcceptOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    keywords?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    _count?: ShopAcceptCountOrderByAggregateInput
    _avg?: ShopAcceptAvgOrderByAggregateInput
    _max?: ShopAcceptMaxOrderByAggregateInput
    _min?: ShopAcceptMinOrderByAggregateInput
    _sum?: ShopAcceptSumOrderByAggregateInput
  }

  export type ShopAcceptScalarWhereWithAggregatesInput = {
    AND?: ShopAcceptScalarWhereWithAggregatesInput | ShopAcceptScalarWhereWithAggregatesInput[]
    OR?: ShopAcceptScalarWhereWithAggregatesInput[]
    NOT?: ShopAcceptScalarWhereWithAggregatesInput | ShopAcceptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopAccept"> | string
    type?: StringWithAggregatesFilter<"ShopAccept"> | string
    keywords?: StringNullableListFilter<"ShopAccept">
    shopZoneId?: IntWithAggregatesFilter<"ShopAccept"> | number
    shopId?: IntWithAggregatesFilter<"ShopAccept"> | number
  }

  export type ShopRoomWhereInput = {
    AND?: ShopRoomWhereInput | ShopRoomWhereInput[]
    OR?: ShopRoomWhereInput[]
    NOT?: ShopRoomWhereInput | ShopRoomWhereInput[]
    id?: StringFilter<"ShopRoom"> | string
    roomId?: IntFilter<"ShopRoom"> | number
    shopZoneId?: IntFilter<"ShopRoom"> | number
    shopId?: IntFilter<"ShopRoom"> | number
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type ShopRoomOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    shop?: ShopOrderByWithRelationInput
  }

  export type ShopRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shopZoneId_shopId_roomId?: ShopRoomShopZoneIdShopIdRoomIdCompoundUniqueInput
    AND?: ShopRoomWhereInput | ShopRoomWhereInput[]
    OR?: ShopRoomWhereInput[]
    NOT?: ShopRoomWhereInput | ShopRoomWhereInput[]
    roomId?: IntFilter<"ShopRoom"> | number
    shopZoneId?: IntFilter<"ShopRoom"> | number
    shopId?: IntFilter<"ShopRoom"> | number
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id" | "shopZoneId_shopId_roomId">

  export type ShopRoomOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    _count?: ShopRoomCountOrderByAggregateInput
    _avg?: ShopRoomAvgOrderByAggregateInput
    _max?: ShopRoomMaxOrderByAggregateInput
    _min?: ShopRoomMinOrderByAggregateInput
    _sum?: ShopRoomSumOrderByAggregateInput
  }

  export type ShopRoomScalarWhereWithAggregatesInput = {
    AND?: ShopRoomScalarWhereWithAggregatesInput | ShopRoomScalarWhereWithAggregatesInput[]
    OR?: ShopRoomScalarWhereWithAggregatesInput[]
    NOT?: ShopRoomScalarWhereWithAggregatesInput | ShopRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopRoom"> | string
    roomId?: IntWithAggregatesFilter<"ShopRoom"> | number
    shopZoneId?: IntWithAggregatesFilter<"ShopRoom"> | number
    shopId?: IntWithAggregatesFilter<"ShopRoom"> | number
  }

  export type ShopHourWhereInput = {
    AND?: ShopHourWhereInput | ShopHourWhereInput[]
    OR?: ShopHourWhereInput[]
    NOT?: ShopHourWhereInput | ShopHourWhereInput[]
    id?: StringFilter<"ShopHour"> | string
    open?: IntFilter<"ShopHour"> | number
    close?: IntFilter<"ShopHour"> | number
    shopZoneId?: IntFilter<"ShopHour"> | number
    shopId?: IntFilter<"ShopHour"> | number
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }

  export type ShopHourOrderByWithRelationInput = {
    id?: SortOrder
    open?: SortOrder
    close?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    shop?: ShopOrderByWithRelationInput
  }

  export type ShopHourWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopHourWhereInput | ShopHourWhereInput[]
    OR?: ShopHourWhereInput[]
    NOT?: ShopHourWhereInput | ShopHourWhereInput[]
    open?: IntFilter<"ShopHour"> | number
    close?: IntFilter<"ShopHour"> | number
    shopZoneId?: IntFilter<"ShopHour"> | number
    shopId?: IntFilter<"ShopHour"> | number
    shop?: XOR<ShopRelationFilter, ShopWhereInput>
  }, "id">

  export type ShopHourOrderByWithAggregationInput = {
    id?: SortOrder
    open?: SortOrder
    close?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    _count?: ShopHourCountOrderByAggregateInput
    _avg?: ShopHourAvgOrderByAggregateInput
    _max?: ShopHourMaxOrderByAggregateInput
    _min?: ShopHourMinOrderByAggregateInput
    _sum?: ShopHourSumOrderByAggregateInput
  }

  export type ShopHourScalarWhereWithAggregatesInput = {
    AND?: ShopHourScalarWhereWithAggregatesInput | ShopHourScalarWhereWithAggregatesInput[]
    OR?: ShopHourScalarWhereWithAggregatesInput[]
    NOT?: ShopHourScalarWhereWithAggregatesInput | ShopHourScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopHour"> | string
    open?: IntWithAggregatesFilter<"ShopHour"> | number
    close?: IntWithAggregatesFilter<"ShopHour"> | number
    shopZoneId?: IntWithAggregatesFilter<"ShopHour"> | number
    shopId?: IntWithAggregatesFilter<"ShopHour"> | number
  }

  export type TriggerWhereInput = {
    AND?: TriggerWhereInput | TriggerWhereInput[]
    OR?: TriggerWhereInput[]
    NOT?: TriggerWhereInput | TriggerWhereInput[]
    id?: StringFilter<"Trigger"> | string
    name?: StringFilter<"Trigger"> | string
    attachType?: EnumScriptTypeFilter<"Trigger"> | $Enums.ScriptType
    numArgs?: IntFilter<"Trigger"> | number
    argList?: StringNullableFilter<"Trigger"> | string | null
    commands?: StringFilter<"Trigger"> | string
    zoneId?: IntNullableFilter<"Trigger"> | number | null
    mobZoneId?: IntNullableFilter<"Trigger"> | number | null
    mobId?: IntNullableFilter<"Trigger"> | number | null
    objectZoneId?: IntNullableFilter<"Trigger"> | number | null
    objectId?: IntNullableFilter<"Trigger"> | number | null
    variables?: JsonFilter<"Trigger">
    createdAt?: DateTimeFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeFilter<"Trigger"> | Date | string
    createdBy?: StringNullableFilter<"Trigger"> | string | null
    updatedBy?: StringNullableFilter<"Trigger"> | string | null
    flags?: EnumTriggerFlagNullableListFilter<"Trigger">
    mob?: XOR<MobNullableRelationFilter, MobWhereInput> | null
    object?: XOR<ObjectNullableRelationFilter, ObjectWhereInput> | null
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
  }

  export type TriggerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    attachType?: SortOrder
    numArgs?: SortOrder
    argList?: SortOrderInput | SortOrder
    commands?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    mobZoneId?: SortOrderInput | SortOrder
    mobId?: SortOrderInput | SortOrder
    objectZoneId?: SortOrderInput | SortOrder
    objectId?: SortOrderInput | SortOrder
    variables?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    flags?: SortOrder
    mob?: MobOrderByWithRelationInput
    object?: ObjectOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
  }

  export type TriggerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TriggerWhereInput | TriggerWhereInput[]
    OR?: TriggerWhereInput[]
    NOT?: TriggerWhereInput | TriggerWhereInput[]
    name?: StringFilter<"Trigger"> | string
    attachType?: EnumScriptTypeFilter<"Trigger"> | $Enums.ScriptType
    numArgs?: IntFilter<"Trigger"> | number
    argList?: StringNullableFilter<"Trigger"> | string | null
    commands?: StringFilter<"Trigger"> | string
    zoneId?: IntNullableFilter<"Trigger"> | number | null
    mobZoneId?: IntNullableFilter<"Trigger"> | number | null
    mobId?: IntNullableFilter<"Trigger"> | number | null
    objectZoneId?: IntNullableFilter<"Trigger"> | number | null
    objectId?: IntNullableFilter<"Trigger"> | number | null
    variables?: JsonFilter<"Trigger">
    createdAt?: DateTimeFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeFilter<"Trigger"> | Date | string
    createdBy?: StringNullableFilter<"Trigger"> | string | null
    updatedBy?: StringNullableFilter<"Trigger"> | string | null
    flags?: EnumTriggerFlagNullableListFilter<"Trigger">
    mob?: XOR<MobNullableRelationFilter, MobWhereInput> | null
    object?: XOR<ObjectNullableRelationFilter, ObjectWhereInput> | null
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
  }, "id">

  export type TriggerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    attachType?: SortOrder
    numArgs?: SortOrder
    argList?: SortOrderInput | SortOrder
    commands?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    mobZoneId?: SortOrderInput | SortOrder
    mobId?: SortOrderInput | SortOrder
    objectZoneId?: SortOrderInput | SortOrder
    objectId?: SortOrderInput | SortOrder
    variables?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    flags?: SortOrder
    _count?: TriggerCountOrderByAggregateInput
    _avg?: TriggerAvgOrderByAggregateInput
    _max?: TriggerMaxOrderByAggregateInput
    _min?: TriggerMinOrderByAggregateInput
    _sum?: TriggerSumOrderByAggregateInput
  }

  export type TriggerScalarWhereWithAggregatesInput = {
    AND?: TriggerScalarWhereWithAggregatesInput | TriggerScalarWhereWithAggregatesInput[]
    OR?: TriggerScalarWhereWithAggregatesInput[]
    NOT?: TriggerScalarWhereWithAggregatesInput | TriggerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trigger"> | string
    name?: StringWithAggregatesFilter<"Trigger"> | string
    attachType?: EnumScriptTypeWithAggregatesFilter<"Trigger"> | $Enums.ScriptType
    numArgs?: IntWithAggregatesFilter<"Trigger"> | number
    argList?: StringNullableWithAggregatesFilter<"Trigger"> | string | null
    commands?: StringWithAggregatesFilter<"Trigger"> | string
    zoneId?: IntNullableWithAggregatesFilter<"Trigger"> | number | null
    mobZoneId?: IntNullableWithAggregatesFilter<"Trigger"> | number | null
    mobId?: IntNullableWithAggregatesFilter<"Trigger"> | number | null
    objectZoneId?: IntNullableWithAggregatesFilter<"Trigger"> | number | null
    objectId?: IntNullableWithAggregatesFilter<"Trigger"> | number | null
    variables?: JsonWithAggregatesFilter<"Trigger">
    createdAt?: DateTimeWithAggregatesFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trigger"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Trigger"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Trigger"> | string | null
    flags?: EnumTriggerFlagNullableListFilter<"Trigger">
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    userId?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    userId?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type GameClassWhereInput = {
    AND?: GameClassWhereInput | GameClassWhereInput[]
    OR?: GameClassWhereInput[]
    NOT?: GameClassWhereInput | GameClassWhereInput[]
    id?: IntFilter<"GameClass"> | number
    name?: StringFilter<"GameClass"> | string
    description?: StringNullableFilter<"GameClass"> | string | null
    hitDice?: StringFilter<"GameClass"> | string
    primaryStat?: StringNullableFilter<"GameClass"> | string | null
    createdAt?: DateTimeFilter<"GameClass"> | Date | string
    updatedAt?: DateTimeFilter<"GameClass"> | Date | string
    characters?: CharacterListRelationFilter
    skillAccess?: ClassSkillListRelationFilter
    mobs?: MobListRelationFilter
    spellCircles?: SpellClassCircleListRelationFilter
  }

  export type GameClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    hitDice?: SortOrder
    primaryStat?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characters?: CharacterOrderByRelationAggregateInput
    skillAccess?: ClassSkillOrderByRelationAggregateInput
    mobs?: MobOrderByRelationAggregateInput
    spellCircles?: SpellClassCircleOrderByRelationAggregateInput
  }

  export type GameClassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: GameClassWhereInput | GameClassWhereInput[]
    OR?: GameClassWhereInput[]
    NOT?: GameClassWhereInput | GameClassWhereInput[]
    description?: StringNullableFilter<"GameClass"> | string | null
    hitDice?: StringFilter<"GameClass"> | string
    primaryStat?: StringNullableFilter<"GameClass"> | string | null
    createdAt?: DateTimeFilter<"GameClass"> | Date | string
    updatedAt?: DateTimeFilter<"GameClass"> | Date | string
    characters?: CharacterListRelationFilter
    skillAccess?: ClassSkillListRelationFilter
    mobs?: MobListRelationFilter
    spellCircles?: SpellClassCircleListRelationFilter
  }, "id" | "name">

  export type GameClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    hitDice?: SortOrder
    primaryStat?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameClassCountOrderByAggregateInput
    _avg?: GameClassAvgOrderByAggregateInput
    _max?: GameClassMaxOrderByAggregateInput
    _min?: GameClassMinOrderByAggregateInput
    _sum?: GameClassSumOrderByAggregateInput
  }

  export type GameClassScalarWhereWithAggregatesInput = {
    AND?: GameClassScalarWhereWithAggregatesInput | GameClassScalarWhereWithAggregatesInput[]
    OR?: GameClassScalarWhereWithAggregatesInput[]
    NOT?: GameClassScalarWhereWithAggregatesInput | GameClassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GameClass"> | number
    name?: StringWithAggregatesFilter<"GameClass"> | string
    description?: StringNullableWithAggregatesFilter<"GameClass"> | string | null
    hitDice?: StringWithAggregatesFilter<"GameClass"> | string
    primaryStat?: StringNullableWithAggregatesFilter<"GameClass"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GameClass"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameClass"> | Date | string
  }

  export type SpellWhereInput = {
    AND?: SpellWhereInput | SpellWhereInput[]
    OR?: SpellWhereInput[]
    NOT?: SpellWhereInput | SpellWhereInput[]
    id?: IntFilter<"Spell"> | number
    name?: StringFilter<"Spell"> | string
    schoolId?: IntNullableFilter<"Spell"> | number | null
    minPosition?: EnumPositionFilter<"Spell"> | $Enums.Position
    violent?: BoolFilter<"Spell"> | boolean
    castTimeRounds?: IntFilter<"Spell"> | number
    cooldownMs?: IntFilter<"Spell"> | number
    inCombatOnly?: BoolFilter<"Spell"> | boolean
    isArea?: BoolFilter<"Spell"> | boolean
    notes?: StringNullableFilter<"Spell"> | string | null
    createdAt?: DateTimeFilter<"Spell"> | Date | string
    updatedAt?: DateTimeFilter<"Spell"> | Date | string
    characterSpells?: CharacterSpellListRelationFilter
    mobSpells?: MobSpellListRelationFilter
    classCircles?: SpellClassCircleListRelationFilter
    components?: SpellComponentListRelationFilter
    effects?: SpellEffectListRelationFilter
    messages?: XOR<SpellMessageNullableRelationFilter, SpellMessageWhereInput> | null
    restrictions?: XOR<SpellRestrictionNullableRelationFilter, SpellRestrictionWhereInput> | null
    savingThrows?: SpellSavingThrowListRelationFilter
    targeting?: XOR<SpellTargetingNullableRelationFilter, SpellTargetingWhereInput> | null
    school?: XOR<SpellSchoolNullableRelationFilter, SpellSchoolWhereInput> | null
  }

  export type SpellOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    minPosition?: SortOrder
    violent?: SortOrder
    castTimeRounds?: SortOrder
    cooldownMs?: SortOrder
    inCombatOnly?: SortOrder
    isArea?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characterSpells?: CharacterSpellOrderByRelationAggregateInput
    mobSpells?: MobSpellOrderByRelationAggregateInput
    classCircles?: SpellClassCircleOrderByRelationAggregateInput
    components?: SpellComponentOrderByRelationAggregateInput
    effects?: SpellEffectOrderByRelationAggregateInput
    messages?: SpellMessageOrderByWithRelationInput
    restrictions?: SpellRestrictionOrderByWithRelationInput
    savingThrows?: SpellSavingThrowOrderByRelationAggregateInput
    targeting?: SpellTargetingOrderByWithRelationInput
    school?: SpellSchoolOrderByWithRelationInput
  }

  export type SpellWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: SpellWhereInput | SpellWhereInput[]
    OR?: SpellWhereInput[]
    NOT?: SpellWhereInput | SpellWhereInput[]
    schoolId?: IntNullableFilter<"Spell"> | number | null
    minPosition?: EnumPositionFilter<"Spell"> | $Enums.Position
    violent?: BoolFilter<"Spell"> | boolean
    castTimeRounds?: IntFilter<"Spell"> | number
    cooldownMs?: IntFilter<"Spell"> | number
    inCombatOnly?: BoolFilter<"Spell"> | boolean
    isArea?: BoolFilter<"Spell"> | boolean
    notes?: StringNullableFilter<"Spell"> | string | null
    createdAt?: DateTimeFilter<"Spell"> | Date | string
    updatedAt?: DateTimeFilter<"Spell"> | Date | string
    characterSpells?: CharacterSpellListRelationFilter
    mobSpells?: MobSpellListRelationFilter
    classCircles?: SpellClassCircleListRelationFilter
    components?: SpellComponentListRelationFilter
    effects?: SpellEffectListRelationFilter
    messages?: XOR<SpellMessageNullableRelationFilter, SpellMessageWhereInput> | null
    restrictions?: XOR<SpellRestrictionNullableRelationFilter, SpellRestrictionWhereInput> | null
    savingThrows?: SpellSavingThrowListRelationFilter
    targeting?: XOR<SpellTargetingNullableRelationFilter, SpellTargetingWhereInput> | null
    school?: XOR<SpellSchoolNullableRelationFilter, SpellSchoolWhereInput> | null
  }, "id" | "name">

  export type SpellOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    minPosition?: SortOrder
    violent?: SortOrder
    castTimeRounds?: SortOrder
    cooldownMs?: SortOrder
    inCombatOnly?: SortOrder
    isArea?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpellCountOrderByAggregateInput
    _avg?: SpellAvgOrderByAggregateInput
    _max?: SpellMaxOrderByAggregateInput
    _min?: SpellMinOrderByAggregateInput
    _sum?: SpellSumOrderByAggregateInput
  }

  export type SpellScalarWhereWithAggregatesInput = {
    AND?: SpellScalarWhereWithAggregatesInput | SpellScalarWhereWithAggregatesInput[]
    OR?: SpellScalarWhereWithAggregatesInput[]
    NOT?: SpellScalarWhereWithAggregatesInput | SpellScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Spell"> | number
    name?: StringWithAggregatesFilter<"Spell"> | string
    schoolId?: IntNullableWithAggregatesFilter<"Spell"> | number | null
    minPosition?: EnumPositionWithAggregatesFilter<"Spell"> | $Enums.Position
    violent?: BoolWithAggregatesFilter<"Spell"> | boolean
    castTimeRounds?: IntWithAggregatesFilter<"Spell"> | number
    cooldownMs?: IntWithAggregatesFilter<"Spell"> | number
    inCombatOnly?: BoolWithAggregatesFilter<"Spell"> | boolean
    isArea?: BoolWithAggregatesFilter<"Spell"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Spell"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Spell"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Spell"> | Date | string
  }

  export type SpellSchoolWhereInput = {
    AND?: SpellSchoolWhereInput | SpellSchoolWhereInput[]
    OR?: SpellSchoolWhereInput[]
    NOT?: SpellSchoolWhereInput | SpellSchoolWhereInput[]
    id?: IntFilter<"SpellSchool"> | number
    name?: StringFilter<"SpellSchool"> | string
    description?: StringNullableFilter<"SpellSchool"> | string | null
    spells?: SpellListRelationFilter
  }

  export type SpellSchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    spells?: SpellOrderByRelationAggregateInput
  }

  export type SpellSchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: SpellSchoolWhereInput | SpellSchoolWhereInput[]
    OR?: SpellSchoolWhereInput[]
    NOT?: SpellSchoolWhereInput | SpellSchoolWhereInput[]
    description?: StringNullableFilter<"SpellSchool"> | string | null
    spells?: SpellListRelationFilter
  }, "id" | "name">

  export type SpellSchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: SpellSchoolCountOrderByAggregateInput
    _avg?: SpellSchoolAvgOrderByAggregateInput
    _max?: SpellSchoolMaxOrderByAggregateInput
    _min?: SpellSchoolMinOrderByAggregateInput
    _sum?: SpellSchoolSumOrderByAggregateInput
  }

  export type SpellSchoolScalarWhereWithAggregatesInput = {
    AND?: SpellSchoolScalarWhereWithAggregatesInput | SpellSchoolScalarWhereWithAggregatesInput[]
    OR?: SpellSchoolScalarWhereWithAggregatesInput[]
    NOT?: SpellSchoolScalarWhereWithAggregatesInput | SpellSchoolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellSchool"> | number
    name?: StringWithAggregatesFilter<"SpellSchool"> | string
    description?: StringNullableWithAggregatesFilter<"SpellSchool"> | string | null
  }

  export type SpellClassCircleWhereInput = {
    AND?: SpellClassCircleWhereInput | SpellClassCircleWhereInput[]
    OR?: SpellClassCircleWhereInput[]
    NOT?: SpellClassCircleWhereInput | SpellClassCircleWhereInput[]
    id?: IntFilter<"SpellClassCircle"> | number
    spellId?: IntFilter<"SpellClassCircle"> | number
    classId?: IntFilter<"SpellClassCircle"> | number
    circle?: IntFilter<"SpellClassCircle"> | number
    minLevel?: IntNullableFilter<"SpellClassCircle"> | number | null
    proficiencyGain?: IntNullableFilter<"SpellClassCircle"> | number | null
    gameClass?: XOR<GameClassRelationFilter, GameClassWhereInput>
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }

  export type SpellClassCircleOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    classId?: SortOrder
    circle?: SortOrder
    minLevel?: SortOrderInput | SortOrder
    proficiencyGain?: SortOrderInput | SortOrder
    gameClass?: GameClassOrderByWithRelationInput
    spell?: SpellOrderByWithRelationInput
  }

  export type SpellClassCircleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    spellId_classId?: SpellClassCircleSpellIdClassIdCompoundUniqueInput
    AND?: SpellClassCircleWhereInput | SpellClassCircleWhereInput[]
    OR?: SpellClassCircleWhereInput[]
    NOT?: SpellClassCircleWhereInput | SpellClassCircleWhereInput[]
    spellId?: IntFilter<"SpellClassCircle"> | number
    classId?: IntFilter<"SpellClassCircle"> | number
    circle?: IntFilter<"SpellClassCircle"> | number
    minLevel?: IntNullableFilter<"SpellClassCircle"> | number | null
    proficiencyGain?: IntNullableFilter<"SpellClassCircle"> | number | null
    gameClass?: XOR<GameClassRelationFilter, GameClassWhereInput>
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }, "id" | "spellId_classId">

  export type SpellClassCircleOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    classId?: SortOrder
    circle?: SortOrder
    minLevel?: SortOrderInput | SortOrder
    proficiencyGain?: SortOrderInput | SortOrder
    _count?: SpellClassCircleCountOrderByAggregateInput
    _avg?: SpellClassCircleAvgOrderByAggregateInput
    _max?: SpellClassCircleMaxOrderByAggregateInput
    _min?: SpellClassCircleMinOrderByAggregateInput
    _sum?: SpellClassCircleSumOrderByAggregateInput
  }

  export type SpellClassCircleScalarWhereWithAggregatesInput = {
    AND?: SpellClassCircleScalarWhereWithAggregatesInput | SpellClassCircleScalarWhereWithAggregatesInput[]
    OR?: SpellClassCircleScalarWhereWithAggregatesInput[]
    NOT?: SpellClassCircleScalarWhereWithAggregatesInput | SpellClassCircleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellClassCircle"> | number
    spellId?: IntWithAggregatesFilter<"SpellClassCircle"> | number
    classId?: IntWithAggregatesFilter<"SpellClassCircle"> | number
    circle?: IntWithAggregatesFilter<"SpellClassCircle"> | number
    minLevel?: IntNullableWithAggregatesFilter<"SpellClassCircle"> | number | null
    proficiencyGain?: IntNullableWithAggregatesFilter<"SpellClassCircle"> | number | null
  }

  export type SpellTargetingWhereInput = {
    AND?: SpellTargetingWhereInput | SpellTargetingWhereInput[]
    OR?: SpellTargetingWhereInput[]
    NOT?: SpellTargetingWhereInput | SpellTargetingWhereInput[]
    id?: IntFilter<"SpellTargeting"> | number
    spellId?: IntFilter<"SpellTargeting"> | number
    allowedTargetsMask?: IntFilter<"SpellTargeting"> | number
    targetScope?: EnumTargetScopeFilter<"SpellTargeting"> | $Enums.TargetScope
    maxTargets?: IntFilter<"SpellTargeting"> | number
    range?: EnumSpellRangeFilter<"SpellTargeting"> | $Enums.SpellRange
    requireLos?: BoolFilter<"SpellTargeting"> | boolean
    filtersMask?: IntNullableFilter<"SpellTargeting"> | number | null
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }

  export type SpellTargetingOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    allowedTargetsMask?: SortOrder
    targetScope?: SortOrder
    maxTargets?: SortOrder
    range?: SortOrder
    requireLos?: SortOrder
    filtersMask?: SortOrderInput | SortOrder
    spell?: SpellOrderByWithRelationInput
  }

  export type SpellTargetingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    spellId?: number
    AND?: SpellTargetingWhereInput | SpellTargetingWhereInput[]
    OR?: SpellTargetingWhereInput[]
    NOT?: SpellTargetingWhereInput | SpellTargetingWhereInput[]
    allowedTargetsMask?: IntFilter<"SpellTargeting"> | number
    targetScope?: EnumTargetScopeFilter<"SpellTargeting"> | $Enums.TargetScope
    maxTargets?: IntFilter<"SpellTargeting"> | number
    range?: EnumSpellRangeFilter<"SpellTargeting"> | $Enums.SpellRange
    requireLos?: BoolFilter<"SpellTargeting"> | boolean
    filtersMask?: IntNullableFilter<"SpellTargeting"> | number | null
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }, "id" | "spellId">

  export type SpellTargetingOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    allowedTargetsMask?: SortOrder
    targetScope?: SortOrder
    maxTargets?: SortOrder
    range?: SortOrder
    requireLos?: SortOrder
    filtersMask?: SortOrderInput | SortOrder
    _count?: SpellTargetingCountOrderByAggregateInput
    _avg?: SpellTargetingAvgOrderByAggregateInput
    _max?: SpellTargetingMaxOrderByAggregateInput
    _min?: SpellTargetingMinOrderByAggregateInput
    _sum?: SpellTargetingSumOrderByAggregateInput
  }

  export type SpellTargetingScalarWhereWithAggregatesInput = {
    AND?: SpellTargetingScalarWhereWithAggregatesInput | SpellTargetingScalarWhereWithAggregatesInput[]
    OR?: SpellTargetingScalarWhereWithAggregatesInput[]
    NOT?: SpellTargetingScalarWhereWithAggregatesInput | SpellTargetingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellTargeting"> | number
    spellId?: IntWithAggregatesFilter<"SpellTargeting"> | number
    allowedTargetsMask?: IntWithAggregatesFilter<"SpellTargeting"> | number
    targetScope?: EnumTargetScopeWithAggregatesFilter<"SpellTargeting"> | $Enums.TargetScope
    maxTargets?: IntWithAggregatesFilter<"SpellTargeting"> | number
    range?: EnumSpellRangeWithAggregatesFilter<"SpellTargeting"> | $Enums.SpellRange
    requireLos?: BoolWithAggregatesFilter<"SpellTargeting"> | boolean
    filtersMask?: IntNullableWithAggregatesFilter<"SpellTargeting"> | number | null
  }

  export type SpellSavingThrowWhereInput = {
    AND?: SpellSavingThrowWhereInput | SpellSavingThrowWhereInput[]
    OR?: SpellSavingThrowWhereInput[]
    NOT?: SpellSavingThrowWhereInput | SpellSavingThrowWhereInput[]
    id?: IntFilter<"SpellSavingThrow"> | number
    spellId?: IntFilter<"SpellSavingThrow"> | number
    saveType?: EnumSaveTypeFilter<"SpellSavingThrow"> | $Enums.SaveType
    onSave?: EnumSaveResultFilter<"SpellSavingThrow"> | $Enums.SaveResult
    dcFormula?: StringFilter<"SpellSavingThrow"> | string
    saveModifierMask?: IntNullableFilter<"SpellSavingThrow"> | number | null
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }

  export type SpellSavingThrowOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    saveType?: SortOrder
    onSave?: SortOrder
    dcFormula?: SortOrder
    saveModifierMask?: SortOrderInput | SortOrder
    spell?: SpellOrderByWithRelationInput
  }

  export type SpellSavingThrowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellSavingThrowWhereInput | SpellSavingThrowWhereInput[]
    OR?: SpellSavingThrowWhereInput[]
    NOT?: SpellSavingThrowWhereInput | SpellSavingThrowWhereInput[]
    spellId?: IntFilter<"SpellSavingThrow"> | number
    saveType?: EnumSaveTypeFilter<"SpellSavingThrow"> | $Enums.SaveType
    onSave?: EnumSaveResultFilter<"SpellSavingThrow"> | $Enums.SaveResult
    dcFormula?: StringFilter<"SpellSavingThrow"> | string
    saveModifierMask?: IntNullableFilter<"SpellSavingThrow"> | number | null
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }, "id">

  export type SpellSavingThrowOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    saveType?: SortOrder
    onSave?: SortOrder
    dcFormula?: SortOrder
    saveModifierMask?: SortOrderInput | SortOrder
    _count?: SpellSavingThrowCountOrderByAggregateInput
    _avg?: SpellSavingThrowAvgOrderByAggregateInput
    _max?: SpellSavingThrowMaxOrderByAggregateInput
    _min?: SpellSavingThrowMinOrderByAggregateInput
    _sum?: SpellSavingThrowSumOrderByAggregateInput
  }

  export type SpellSavingThrowScalarWhereWithAggregatesInput = {
    AND?: SpellSavingThrowScalarWhereWithAggregatesInput | SpellSavingThrowScalarWhereWithAggregatesInput[]
    OR?: SpellSavingThrowScalarWhereWithAggregatesInput[]
    NOT?: SpellSavingThrowScalarWhereWithAggregatesInput | SpellSavingThrowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellSavingThrow"> | number
    spellId?: IntWithAggregatesFilter<"SpellSavingThrow"> | number
    saveType?: EnumSaveTypeWithAggregatesFilter<"SpellSavingThrow"> | $Enums.SaveType
    onSave?: EnumSaveResultWithAggregatesFilter<"SpellSavingThrow"> | $Enums.SaveResult
    dcFormula?: StringWithAggregatesFilter<"SpellSavingThrow"> | string
    saveModifierMask?: IntNullableWithAggregatesFilter<"SpellSavingThrow"> | number | null
  }

  export type SpellMessageWhereInput = {
    AND?: SpellMessageWhereInput | SpellMessageWhereInput[]
    OR?: SpellMessageWhereInput[]
    NOT?: SpellMessageWhereInput | SpellMessageWhereInput[]
    id?: IntFilter<"SpellMessage"> | number
    spellId?: IntFilter<"SpellMessage"> | number
    startToCaster?: StringNullableFilter<"SpellMessage"> | string | null
    startToVictim?: StringNullableFilter<"SpellMessage"> | string | null
    startToRoom?: StringNullableFilter<"SpellMessage"> | string | null
    successToCaster?: StringNullableFilter<"SpellMessage"> | string | null
    successToVictim?: StringNullableFilter<"SpellMessage"> | string | null
    successToRoom?: StringNullableFilter<"SpellMessage"> | string | null
    failToCaster?: StringNullableFilter<"SpellMessage"> | string | null
    failToVictim?: StringNullableFilter<"SpellMessage"> | string | null
    failToRoom?: StringNullableFilter<"SpellMessage"> | string | null
    wearoffToTarget?: StringNullableFilter<"SpellMessage"> | string | null
    wearoffToRoom?: StringNullableFilter<"SpellMessage"> | string | null
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }

  export type SpellMessageOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    startToCaster?: SortOrderInput | SortOrder
    startToVictim?: SortOrderInput | SortOrder
    startToRoom?: SortOrderInput | SortOrder
    successToCaster?: SortOrderInput | SortOrder
    successToVictim?: SortOrderInput | SortOrder
    successToRoom?: SortOrderInput | SortOrder
    failToCaster?: SortOrderInput | SortOrder
    failToVictim?: SortOrderInput | SortOrder
    failToRoom?: SortOrderInput | SortOrder
    wearoffToTarget?: SortOrderInput | SortOrder
    wearoffToRoom?: SortOrderInput | SortOrder
    spell?: SpellOrderByWithRelationInput
  }

  export type SpellMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    spellId?: number
    AND?: SpellMessageWhereInput | SpellMessageWhereInput[]
    OR?: SpellMessageWhereInput[]
    NOT?: SpellMessageWhereInput | SpellMessageWhereInput[]
    startToCaster?: StringNullableFilter<"SpellMessage"> | string | null
    startToVictim?: StringNullableFilter<"SpellMessage"> | string | null
    startToRoom?: StringNullableFilter<"SpellMessage"> | string | null
    successToCaster?: StringNullableFilter<"SpellMessage"> | string | null
    successToVictim?: StringNullableFilter<"SpellMessage"> | string | null
    successToRoom?: StringNullableFilter<"SpellMessage"> | string | null
    failToCaster?: StringNullableFilter<"SpellMessage"> | string | null
    failToVictim?: StringNullableFilter<"SpellMessage"> | string | null
    failToRoom?: StringNullableFilter<"SpellMessage"> | string | null
    wearoffToTarget?: StringNullableFilter<"SpellMessage"> | string | null
    wearoffToRoom?: StringNullableFilter<"SpellMessage"> | string | null
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }, "id" | "spellId">

  export type SpellMessageOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    startToCaster?: SortOrderInput | SortOrder
    startToVictim?: SortOrderInput | SortOrder
    startToRoom?: SortOrderInput | SortOrder
    successToCaster?: SortOrderInput | SortOrder
    successToVictim?: SortOrderInput | SortOrder
    successToRoom?: SortOrderInput | SortOrder
    failToCaster?: SortOrderInput | SortOrder
    failToVictim?: SortOrderInput | SortOrder
    failToRoom?: SortOrderInput | SortOrder
    wearoffToTarget?: SortOrderInput | SortOrder
    wearoffToRoom?: SortOrderInput | SortOrder
    _count?: SpellMessageCountOrderByAggregateInput
    _avg?: SpellMessageAvgOrderByAggregateInput
    _max?: SpellMessageMaxOrderByAggregateInput
    _min?: SpellMessageMinOrderByAggregateInput
    _sum?: SpellMessageSumOrderByAggregateInput
  }

  export type SpellMessageScalarWhereWithAggregatesInput = {
    AND?: SpellMessageScalarWhereWithAggregatesInput | SpellMessageScalarWhereWithAggregatesInput[]
    OR?: SpellMessageScalarWhereWithAggregatesInput[]
    NOT?: SpellMessageScalarWhereWithAggregatesInput | SpellMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellMessage"> | number
    spellId?: IntWithAggregatesFilter<"SpellMessage"> | number
    startToCaster?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
    startToVictim?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
    startToRoom?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
    successToCaster?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
    successToVictim?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
    successToRoom?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
    failToCaster?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
    failToVictim?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
    failToRoom?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
    wearoffToTarget?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
    wearoffToRoom?: StringNullableWithAggregatesFilter<"SpellMessage"> | string | null
  }

  export type SpellComponentWhereInput = {
    AND?: SpellComponentWhereInput | SpellComponentWhereInput[]
    OR?: SpellComponentWhereInput[]
    NOT?: SpellComponentWhereInput | SpellComponentWhereInput[]
    id?: IntFilter<"SpellComponent"> | number
    spellId?: IntFilter<"SpellComponent"> | number
    objectId?: IntFilter<"SpellComponent"> | number
    consumed?: BoolFilter<"SpellComponent"> | boolean
    required?: BoolFilter<"SpellComponent"> | boolean
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }

  export type SpellComponentOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    objectId?: SortOrder
    consumed?: SortOrder
    required?: SortOrder
    spell?: SpellOrderByWithRelationInput
  }

  export type SpellComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellComponentWhereInput | SpellComponentWhereInput[]
    OR?: SpellComponentWhereInput[]
    NOT?: SpellComponentWhereInput | SpellComponentWhereInput[]
    spellId?: IntFilter<"SpellComponent"> | number
    objectId?: IntFilter<"SpellComponent"> | number
    consumed?: BoolFilter<"SpellComponent"> | boolean
    required?: BoolFilter<"SpellComponent"> | boolean
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }, "id">

  export type SpellComponentOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    objectId?: SortOrder
    consumed?: SortOrder
    required?: SortOrder
    _count?: SpellComponentCountOrderByAggregateInput
    _avg?: SpellComponentAvgOrderByAggregateInput
    _max?: SpellComponentMaxOrderByAggregateInput
    _min?: SpellComponentMinOrderByAggregateInput
    _sum?: SpellComponentSumOrderByAggregateInput
  }

  export type SpellComponentScalarWhereWithAggregatesInput = {
    AND?: SpellComponentScalarWhereWithAggregatesInput | SpellComponentScalarWhereWithAggregatesInput[]
    OR?: SpellComponentScalarWhereWithAggregatesInput[]
    NOT?: SpellComponentScalarWhereWithAggregatesInput | SpellComponentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellComponent"> | number
    spellId?: IntWithAggregatesFilter<"SpellComponent"> | number
    objectId?: IntWithAggregatesFilter<"SpellComponent"> | number
    consumed?: BoolWithAggregatesFilter<"SpellComponent"> | boolean
    required?: BoolWithAggregatesFilter<"SpellComponent"> | boolean
  }

  export type SpellRestrictionWhereInput = {
    AND?: SpellRestrictionWhereInput | SpellRestrictionWhereInput[]
    OR?: SpellRestrictionWhereInput[]
    NOT?: SpellRestrictionWhereInput | SpellRestrictionWhereInput[]
    id?: IntFilter<"SpellRestriction"> | number
    spellId?: IntFilter<"SpellRestriction"> | number
    indoorsOnly?: BoolFilter<"SpellRestriction"> | boolean
    outdoorsOnly?: BoolFilter<"SpellRestriction"> | boolean
    noSafeRooms?: BoolFilter<"SpellRestriction"> | boolean
    noTeleportFlagsMask?: IntNullableFilter<"SpellRestriction"> | number | null
    terrainMask?: IntNullableFilter<"SpellRestriction"> | number | null
    disallowStatesMask?: IntNullableFilter<"SpellRestriction"> | number | null
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }

  export type SpellRestrictionOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    indoorsOnly?: SortOrder
    outdoorsOnly?: SortOrder
    noSafeRooms?: SortOrder
    noTeleportFlagsMask?: SortOrderInput | SortOrder
    terrainMask?: SortOrderInput | SortOrder
    disallowStatesMask?: SortOrderInput | SortOrder
    spell?: SpellOrderByWithRelationInput
  }

  export type SpellRestrictionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    spellId?: number
    AND?: SpellRestrictionWhereInput | SpellRestrictionWhereInput[]
    OR?: SpellRestrictionWhereInput[]
    NOT?: SpellRestrictionWhereInput | SpellRestrictionWhereInput[]
    indoorsOnly?: BoolFilter<"SpellRestriction"> | boolean
    outdoorsOnly?: BoolFilter<"SpellRestriction"> | boolean
    noSafeRooms?: BoolFilter<"SpellRestriction"> | boolean
    noTeleportFlagsMask?: IntNullableFilter<"SpellRestriction"> | number | null
    terrainMask?: IntNullableFilter<"SpellRestriction"> | number | null
    disallowStatesMask?: IntNullableFilter<"SpellRestriction"> | number | null
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }, "id" | "spellId">

  export type SpellRestrictionOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    indoorsOnly?: SortOrder
    outdoorsOnly?: SortOrder
    noSafeRooms?: SortOrder
    noTeleportFlagsMask?: SortOrderInput | SortOrder
    terrainMask?: SortOrderInput | SortOrder
    disallowStatesMask?: SortOrderInput | SortOrder
    _count?: SpellRestrictionCountOrderByAggregateInput
    _avg?: SpellRestrictionAvgOrderByAggregateInput
    _max?: SpellRestrictionMaxOrderByAggregateInput
    _min?: SpellRestrictionMinOrderByAggregateInput
    _sum?: SpellRestrictionSumOrderByAggregateInput
  }

  export type SpellRestrictionScalarWhereWithAggregatesInput = {
    AND?: SpellRestrictionScalarWhereWithAggregatesInput | SpellRestrictionScalarWhereWithAggregatesInput[]
    OR?: SpellRestrictionScalarWhereWithAggregatesInput[]
    NOT?: SpellRestrictionScalarWhereWithAggregatesInput | SpellRestrictionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellRestriction"> | number
    spellId?: IntWithAggregatesFilter<"SpellRestriction"> | number
    indoorsOnly?: BoolWithAggregatesFilter<"SpellRestriction"> | boolean
    outdoorsOnly?: BoolWithAggregatesFilter<"SpellRestriction"> | boolean
    noSafeRooms?: BoolWithAggregatesFilter<"SpellRestriction"> | boolean
    noTeleportFlagsMask?: IntNullableWithAggregatesFilter<"SpellRestriction"> | number | null
    terrainMask?: IntNullableWithAggregatesFilter<"SpellRestriction"> | number | null
    disallowStatesMask?: IntNullableWithAggregatesFilter<"SpellRestriction"> | number | null
  }

  export type SpellEffectWhereInput = {
    AND?: SpellEffectWhereInput | SpellEffectWhereInput[]
    OR?: SpellEffectWhereInput[]
    NOT?: SpellEffectWhereInput | SpellEffectWhereInput[]
    id?: IntFilter<"SpellEffect"> | number
    spellId?: IntFilter<"SpellEffect"> | number
    effectType?: EnumEffectTypeFilter<"SpellEffect"> | $Enums.EffectType
    order?: IntFilter<"SpellEffect"> | number
    chancePct?: IntFilter<"SpellEffect"> | number
    trigger?: EnumEffectTriggerNullableFilter<"SpellEffect"> | $Enums.EffectTrigger | null
    durationFormula?: StringNullableFilter<"SpellEffect"> | string | null
    stackingRule?: EnumStackingRuleFilter<"SpellEffect"> | $Enums.StackingRule
    conditionFilter?: JsonNullableFilter<"SpellEffect">
    params?: JsonFilter<"SpellEffect">
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }

  export type SpellEffectOrderByWithRelationInput = {
    id?: SortOrder
    spellId?: SortOrder
    effectType?: SortOrder
    order?: SortOrder
    chancePct?: SortOrder
    trigger?: SortOrderInput | SortOrder
    durationFormula?: SortOrderInput | SortOrder
    stackingRule?: SortOrder
    conditionFilter?: SortOrderInput | SortOrder
    params?: SortOrder
    spell?: SpellOrderByWithRelationInput
  }

  export type SpellEffectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpellEffectWhereInput | SpellEffectWhereInput[]
    OR?: SpellEffectWhereInput[]
    NOT?: SpellEffectWhereInput | SpellEffectWhereInput[]
    spellId?: IntFilter<"SpellEffect"> | number
    effectType?: EnumEffectTypeFilter<"SpellEffect"> | $Enums.EffectType
    order?: IntFilter<"SpellEffect"> | number
    chancePct?: IntFilter<"SpellEffect"> | number
    trigger?: EnumEffectTriggerNullableFilter<"SpellEffect"> | $Enums.EffectTrigger | null
    durationFormula?: StringNullableFilter<"SpellEffect"> | string | null
    stackingRule?: EnumStackingRuleFilter<"SpellEffect"> | $Enums.StackingRule
    conditionFilter?: JsonNullableFilter<"SpellEffect">
    params?: JsonFilter<"SpellEffect">
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }, "id">

  export type SpellEffectOrderByWithAggregationInput = {
    id?: SortOrder
    spellId?: SortOrder
    effectType?: SortOrder
    order?: SortOrder
    chancePct?: SortOrder
    trigger?: SortOrderInput | SortOrder
    durationFormula?: SortOrderInput | SortOrder
    stackingRule?: SortOrder
    conditionFilter?: SortOrderInput | SortOrder
    params?: SortOrder
    _count?: SpellEffectCountOrderByAggregateInput
    _avg?: SpellEffectAvgOrderByAggregateInput
    _max?: SpellEffectMaxOrderByAggregateInput
    _min?: SpellEffectMinOrderByAggregateInput
    _sum?: SpellEffectSumOrderByAggregateInput
  }

  export type SpellEffectScalarWhereWithAggregatesInput = {
    AND?: SpellEffectScalarWhereWithAggregatesInput | SpellEffectScalarWhereWithAggregatesInput[]
    OR?: SpellEffectScalarWhereWithAggregatesInput[]
    NOT?: SpellEffectScalarWhereWithAggregatesInput | SpellEffectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpellEffect"> | number
    spellId?: IntWithAggregatesFilter<"SpellEffect"> | number
    effectType?: EnumEffectTypeWithAggregatesFilter<"SpellEffect"> | $Enums.EffectType
    order?: IntWithAggregatesFilter<"SpellEffect"> | number
    chancePct?: IntWithAggregatesFilter<"SpellEffect"> | number
    trigger?: EnumEffectTriggerNullableWithAggregatesFilter<"SpellEffect"> | $Enums.EffectTrigger | null
    durationFormula?: StringNullableWithAggregatesFilter<"SpellEffect"> | string | null
    stackingRule?: EnumStackingRuleWithAggregatesFilter<"SpellEffect"> | $Enums.StackingRule
    conditionFilter?: JsonNullableWithAggregatesFilter<"SpellEffect">
    params?: JsonWithAggregatesFilter<"SpellEffect">
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: IntFilter<"Skill"> | number
    name?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    type?: EnumSkillTypeFilter<"Skill"> | $Enums.SkillType
    category?: EnumSkillCategoryFilter<"Skill"> | $Enums.SkillCategory
    maxLevel?: IntFilter<"Skill"> | number
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    characterSkills?: CharacterSkillListRelationFilter
    classSkills?: ClassSkillListRelationFilter
    mobSkills?: MobSkillListRelationFilter
    raceSkills?: RaceSkillListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    maxLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characterSkills?: CharacterSkillOrderByRelationAggregateInput
    classSkills?: ClassSkillOrderByRelationAggregateInput
    mobSkills?: MobSkillOrderByRelationAggregateInput
    raceSkills?: RaceSkillOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    description?: StringNullableFilter<"Skill"> | string | null
    type?: EnumSkillTypeFilter<"Skill"> | $Enums.SkillType
    category?: EnumSkillCategoryFilter<"Skill"> | $Enums.SkillCategory
    maxLevel?: IntFilter<"Skill"> | number
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    characterSkills?: CharacterSkillListRelationFilter
    classSkills?: ClassSkillListRelationFilter
    mobSkills?: MobSkillListRelationFilter
    raceSkills?: RaceSkillListRelationFilter
  }, "id" | "name">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    maxLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _avg?: SkillAvgOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
    _sum?: SkillSumOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Skill"> | number
    name?: StringWithAggregatesFilter<"Skill"> | string
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    type?: EnumSkillTypeWithAggregatesFilter<"Skill"> | $Enums.SkillType
    category?: EnumSkillCategoryWithAggregatesFilter<"Skill"> | $Enums.SkillCategory
    maxLevel?: IntWithAggregatesFilter<"Skill"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
  }

  export type ClassSkillWhereInput = {
    AND?: ClassSkillWhereInput | ClassSkillWhereInput[]
    OR?: ClassSkillWhereInput[]
    NOT?: ClassSkillWhereInput | ClassSkillWhereInput[]
    id?: IntFilter<"ClassSkill"> | number
    classId?: IntFilter<"ClassSkill"> | number
    skillId?: IntFilter<"ClassSkill"> | number
    category?: EnumSkillCategoryFilter<"ClassSkill"> | $Enums.SkillCategory
    minLevel?: IntFilter<"ClassSkill"> | number
    maxLevel?: IntFilter<"ClassSkill"> | number
    gameClass?: XOR<GameClassRelationFilter, GameClassWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type ClassSkillOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
    category?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
    gameClass?: GameClassOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type ClassSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    classId_skillId?: ClassSkillClassIdSkillIdCompoundUniqueInput
    AND?: ClassSkillWhereInput | ClassSkillWhereInput[]
    OR?: ClassSkillWhereInput[]
    NOT?: ClassSkillWhereInput | ClassSkillWhereInput[]
    classId?: IntFilter<"ClassSkill"> | number
    skillId?: IntFilter<"ClassSkill"> | number
    category?: EnumSkillCategoryFilter<"ClassSkill"> | $Enums.SkillCategory
    minLevel?: IntFilter<"ClassSkill"> | number
    maxLevel?: IntFilter<"ClassSkill"> | number
    gameClass?: XOR<GameClassRelationFilter, GameClassWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "id" | "classId_skillId">

  export type ClassSkillOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
    category?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
    _count?: ClassSkillCountOrderByAggregateInput
    _avg?: ClassSkillAvgOrderByAggregateInput
    _max?: ClassSkillMaxOrderByAggregateInput
    _min?: ClassSkillMinOrderByAggregateInput
    _sum?: ClassSkillSumOrderByAggregateInput
  }

  export type ClassSkillScalarWhereWithAggregatesInput = {
    AND?: ClassSkillScalarWhereWithAggregatesInput | ClassSkillScalarWhereWithAggregatesInput[]
    OR?: ClassSkillScalarWhereWithAggregatesInput[]
    NOT?: ClassSkillScalarWhereWithAggregatesInput | ClassSkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassSkill"> | number
    classId?: IntWithAggregatesFilter<"ClassSkill"> | number
    skillId?: IntWithAggregatesFilter<"ClassSkill"> | number
    category?: EnumSkillCategoryWithAggregatesFilter<"ClassSkill"> | $Enums.SkillCategory
    minLevel?: IntWithAggregatesFilter<"ClassSkill"> | number
    maxLevel?: IntWithAggregatesFilter<"ClassSkill"> | number
  }

  export type RaceSkillWhereInput = {
    AND?: RaceSkillWhereInput | RaceSkillWhereInput[]
    OR?: RaceSkillWhereInput[]
    NOT?: RaceSkillWhereInput | RaceSkillWhereInput[]
    id?: IntFilter<"RaceSkill"> | number
    race?: EnumRaceFilter<"RaceSkill"> | $Enums.Race
    skillId?: IntFilter<"RaceSkill"> | number
    category?: EnumSkillCategoryFilter<"RaceSkill"> | $Enums.SkillCategory
    bonus?: IntFilter<"RaceSkill"> | number
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type RaceSkillOrderByWithRelationInput = {
    id?: SortOrder
    race?: SortOrder
    skillId?: SortOrder
    category?: SortOrder
    bonus?: SortOrder
    skill?: SkillOrderByWithRelationInput
  }

  export type RaceSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    race_skillId?: RaceSkillRaceSkillIdCompoundUniqueInput
    AND?: RaceSkillWhereInput | RaceSkillWhereInput[]
    OR?: RaceSkillWhereInput[]
    NOT?: RaceSkillWhereInput | RaceSkillWhereInput[]
    race?: EnumRaceFilter<"RaceSkill"> | $Enums.Race
    skillId?: IntFilter<"RaceSkill"> | number
    category?: EnumSkillCategoryFilter<"RaceSkill"> | $Enums.SkillCategory
    bonus?: IntFilter<"RaceSkill"> | number
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "id" | "race_skillId">

  export type RaceSkillOrderByWithAggregationInput = {
    id?: SortOrder
    race?: SortOrder
    skillId?: SortOrder
    category?: SortOrder
    bonus?: SortOrder
    _count?: RaceSkillCountOrderByAggregateInput
    _avg?: RaceSkillAvgOrderByAggregateInput
    _max?: RaceSkillMaxOrderByAggregateInput
    _min?: RaceSkillMinOrderByAggregateInput
    _sum?: RaceSkillSumOrderByAggregateInput
  }

  export type RaceSkillScalarWhereWithAggregatesInput = {
    AND?: RaceSkillScalarWhereWithAggregatesInput | RaceSkillScalarWhereWithAggregatesInput[]
    OR?: RaceSkillScalarWhereWithAggregatesInput[]
    NOT?: RaceSkillScalarWhereWithAggregatesInput | RaceSkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RaceSkill"> | number
    race?: EnumRaceWithAggregatesFilter<"RaceSkill"> | $Enums.Race
    skillId?: IntWithAggregatesFilter<"RaceSkill"> | number
    category?: EnumSkillCategoryWithAggregatesFilter<"RaceSkill"> | $Enums.SkillCategory
    bonus?: IntWithAggregatesFilter<"RaceSkill"> | number
  }

  export type CharacterSkillWhereInput = {
    AND?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    OR?: CharacterSkillWhereInput[]
    NOT?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    id?: StringFilter<"CharacterSkill"> | string
    characterId?: StringFilter<"CharacterSkill"> | string
    skillId?: IntFilter<"CharacterSkill"> | number
    level?: IntFilter<"CharacterSkill"> | number
    experience?: IntFilter<"CharacterSkill"> | number
    lastUsed?: DateTimeNullableFilter<"CharacterSkill"> | Date | string | null
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type CharacterSkillOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    character?: CharacterOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type CharacterSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characterId_skillId?: CharacterSkillCharacterIdSkillIdCompoundUniqueInput
    AND?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    OR?: CharacterSkillWhereInput[]
    NOT?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    characterId?: StringFilter<"CharacterSkill"> | string
    skillId?: IntFilter<"CharacterSkill"> | number
    level?: IntFilter<"CharacterSkill"> | number
    experience?: IntFilter<"CharacterSkill"> | number
    lastUsed?: DateTimeNullableFilter<"CharacterSkill"> | Date | string | null
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "id" | "characterId_skillId">

  export type CharacterSkillOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    _count?: CharacterSkillCountOrderByAggregateInput
    _avg?: CharacterSkillAvgOrderByAggregateInput
    _max?: CharacterSkillMaxOrderByAggregateInput
    _min?: CharacterSkillMinOrderByAggregateInput
    _sum?: CharacterSkillSumOrderByAggregateInput
  }

  export type CharacterSkillScalarWhereWithAggregatesInput = {
    AND?: CharacterSkillScalarWhereWithAggregatesInput | CharacterSkillScalarWhereWithAggregatesInput[]
    OR?: CharacterSkillScalarWhereWithAggregatesInput[]
    NOT?: CharacterSkillScalarWhereWithAggregatesInput | CharacterSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterSkill"> | string
    characterId?: StringWithAggregatesFilter<"CharacterSkill"> | string
    skillId?: IntWithAggregatesFilter<"CharacterSkill"> | number
    level?: IntWithAggregatesFilter<"CharacterSkill"> | number
    experience?: IntWithAggregatesFilter<"CharacterSkill"> | number
    lastUsed?: DateTimeNullableWithAggregatesFilter<"CharacterSkill"> | Date | string | null
  }

  export type CharacterSpellWhereInput = {
    AND?: CharacterSpellWhereInput | CharacterSpellWhereInput[]
    OR?: CharacterSpellWhereInput[]
    NOT?: CharacterSpellWhereInput | CharacterSpellWhereInput[]
    id?: StringFilter<"CharacterSpell"> | string
    characterId?: StringFilter<"CharacterSpell"> | string
    spellId?: IntFilter<"CharacterSpell"> | number
    known?: BoolFilter<"CharacterSpell"> | boolean
    proficiency?: IntFilter<"CharacterSpell"> | number
    lastCast?: DateTimeNullableFilter<"CharacterSpell"> | Date | string | null
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }

  export type CharacterSpellOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    spellId?: SortOrder
    known?: SortOrder
    proficiency?: SortOrder
    lastCast?: SortOrderInput | SortOrder
    character?: CharacterOrderByWithRelationInput
    spell?: SpellOrderByWithRelationInput
  }

  export type CharacterSpellWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characterId_spellId?: CharacterSpellCharacterIdSpellIdCompoundUniqueInput
    AND?: CharacterSpellWhereInput | CharacterSpellWhereInput[]
    OR?: CharacterSpellWhereInput[]
    NOT?: CharacterSpellWhereInput | CharacterSpellWhereInput[]
    characterId?: StringFilter<"CharacterSpell"> | string
    spellId?: IntFilter<"CharacterSpell"> | number
    known?: BoolFilter<"CharacterSpell"> | boolean
    proficiency?: IntFilter<"CharacterSpell"> | number
    lastCast?: DateTimeNullableFilter<"CharacterSpell"> | Date | string | null
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
    spell?: XOR<SpellRelationFilter, SpellWhereInput>
  }, "id" | "characterId_spellId">

  export type CharacterSpellOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    spellId?: SortOrder
    known?: SortOrder
    proficiency?: SortOrder
    lastCast?: SortOrderInput | SortOrder
    _count?: CharacterSpellCountOrderByAggregateInput
    _avg?: CharacterSpellAvgOrderByAggregateInput
    _max?: CharacterSpellMaxOrderByAggregateInput
    _min?: CharacterSpellMinOrderByAggregateInput
    _sum?: CharacterSpellSumOrderByAggregateInput
  }

  export type CharacterSpellScalarWhereWithAggregatesInput = {
    AND?: CharacterSpellScalarWhereWithAggregatesInput | CharacterSpellScalarWhereWithAggregatesInput[]
    OR?: CharacterSpellScalarWhereWithAggregatesInput[]
    NOT?: CharacterSpellScalarWhereWithAggregatesInput | CharacterSpellScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterSpell"> | string
    characterId?: StringWithAggregatesFilter<"CharacterSpell"> | string
    spellId?: IntWithAggregatesFilter<"CharacterSpell"> | number
    known?: BoolWithAggregatesFilter<"CharacterSpell"> | boolean
    proficiency?: IntWithAggregatesFilter<"CharacterSpell"> | number
    lastCast?: DateTimeNullableWithAggregatesFilter<"CharacterSpell"> | Date | string | null
  }

  export type ChangeLogWhereInput = {
    AND?: ChangeLogWhereInput | ChangeLogWhereInput[]
    OR?: ChangeLogWhereInput[]
    NOT?: ChangeLogWhereInput | ChangeLogWhereInput[]
    id?: StringFilter<"ChangeLog"> | string
    entityType?: StringFilter<"ChangeLog"> | string
    entityId?: StringFilter<"ChangeLog"> | string
    action?: StringFilter<"ChangeLog"> | string
    changes?: JsonFilter<"ChangeLog">
    userId?: StringFilter<"ChangeLog"> | string
    timestamp?: DateTimeFilter<"ChangeLog"> | Date | string
    description?: StringNullableFilter<"ChangeLog"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChangeLogWhereInput | ChangeLogWhereInput[]
    OR?: ChangeLogWhereInput[]
    NOT?: ChangeLogWhereInput | ChangeLogWhereInput[]
    entityType?: StringFilter<"ChangeLog"> | string
    entityId?: StringFilter<"ChangeLog"> | string
    action?: StringFilter<"ChangeLog"> | string
    changes?: JsonFilter<"ChangeLog">
    userId?: StringFilter<"ChangeLog"> | string
    timestamp?: DateTimeFilter<"ChangeLog"> | Date | string
    description?: StringNullableFilter<"ChangeLog"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ChangeLogCountOrderByAggregateInput
    _max?: ChangeLogMaxOrderByAggregateInput
    _min?: ChangeLogMinOrderByAggregateInput
  }

  export type ChangeLogScalarWhereWithAggregatesInput = {
    AND?: ChangeLogScalarWhereWithAggregatesInput | ChangeLogScalarWhereWithAggregatesInput[]
    OR?: ChangeLogScalarWhereWithAggregatesInput[]
    NOT?: ChangeLogScalarWhereWithAggregatesInput | ChangeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChangeLog"> | string
    entityType?: StringWithAggregatesFilter<"ChangeLog"> | string
    entityId?: StringWithAggregatesFilter<"ChangeLog"> | string
    action?: StringWithAggregatesFilter<"ChangeLog"> | string
    changes?: JsonWithAggregatesFilter<"ChangeLog">
    userId?: StringWithAggregatesFilter<"ChangeLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ChangeLog"> | Date | string
    description?: StringNullableWithAggregatesFilter<"ChangeLog"> | string | null
  }

  export type BanRecordWhereInput = {
    AND?: BanRecordWhereInput | BanRecordWhereInput[]
    OR?: BanRecordWhereInput[]
    NOT?: BanRecordWhereInput | BanRecordWhereInput[]
    id?: StringFilter<"BanRecord"> | string
    userId?: StringFilter<"BanRecord"> | string
    bannedBy?: StringFilter<"BanRecord"> | string
    reason?: StringFilter<"BanRecord"> | string
    bannedAt?: DateTimeFilter<"BanRecord"> | Date | string
    expiresAt?: DateTimeNullableFilter<"BanRecord"> | Date | string | null
    unbannedAt?: DateTimeNullableFilter<"BanRecord"> | Date | string | null
    unbannedBy?: StringNullableFilter<"BanRecord"> | string | null
    active?: BoolFilter<"BanRecord"> | boolean
    admin?: XOR<UserRelationFilter, UserWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BanRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bannedBy?: SortOrder
    reason?: SortOrder
    bannedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    unbannedAt?: SortOrderInput | SortOrder
    unbannedBy?: SortOrderInput | SortOrder
    active?: SortOrder
    admin?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BanRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BanRecordWhereInput | BanRecordWhereInput[]
    OR?: BanRecordWhereInput[]
    NOT?: BanRecordWhereInput | BanRecordWhereInput[]
    userId?: StringFilter<"BanRecord"> | string
    bannedBy?: StringFilter<"BanRecord"> | string
    reason?: StringFilter<"BanRecord"> | string
    bannedAt?: DateTimeFilter<"BanRecord"> | Date | string
    expiresAt?: DateTimeNullableFilter<"BanRecord"> | Date | string | null
    unbannedAt?: DateTimeNullableFilter<"BanRecord"> | Date | string | null
    unbannedBy?: StringNullableFilter<"BanRecord"> | string | null
    active?: BoolFilter<"BanRecord"> | boolean
    admin?: XOR<UserRelationFilter, UserWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type BanRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bannedBy?: SortOrder
    reason?: SortOrder
    bannedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    unbannedAt?: SortOrderInput | SortOrder
    unbannedBy?: SortOrderInput | SortOrder
    active?: SortOrder
    _count?: BanRecordCountOrderByAggregateInput
    _max?: BanRecordMaxOrderByAggregateInput
    _min?: BanRecordMinOrderByAggregateInput
  }

  export type BanRecordScalarWhereWithAggregatesInput = {
    AND?: BanRecordScalarWhereWithAggregatesInput | BanRecordScalarWhereWithAggregatesInput[]
    OR?: BanRecordScalarWhereWithAggregatesInput[]
    NOT?: BanRecordScalarWhereWithAggregatesInput | BanRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BanRecord"> | string
    userId?: StringWithAggregatesFilter<"BanRecord"> | string
    bannedBy?: StringWithAggregatesFilter<"BanRecord"> | string
    reason?: StringWithAggregatesFilter<"BanRecord"> | string
    bannedAt?: DateTimeWithAggregatesFilter<"BanRecord"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"BanRecord"> | Date | string | null
    unbannedAt?: DateTimeNullableWithAggregatesFilter<"BanRecord"> | Date | string | null
    unbannedBy?: StringNullableWithAggregatesFilter<"BanRecord"> | string | null
    active?: BoolWithAggregatesFilter<"BanRecord"> | boolean
  }

  export type CharacterItemWhereInput = {
    AND?: CharacterItemWhereInput | CharacterItemWhereInput[]
    OR?: CharacterItemWhereInput[]
    NOT?: CharacterItemWhereInput | CharacterItemWhereInput[]
    id?: StringFilter<"CharacterItem"> | string
    characterId?: StringFilter<"CharacterItem"> | string
    object_zone_id?: IntFilter<"CharacterItem"> | number
    object_id?: IntFilter<"CharacterItem"> | number
    containerId?: StringNullableFilter<"CharacterItem"> | string | null
    equippedLocation?: StringNullableFilter<"CharacterItem"> | string | null
    condition?: IntFilter<"CharacterItem"> | number
    charges?: IntFilter<"CharacterItem"> | number
    instanceFlags?: StringNullableListFilter<"CharacterItem">
    customShortDesc?: StringNullableFilter<"CharacterItem"> | string | null
    customLongDesc?: StringNullableFilter<"CharacterItem"> | string | null
    customValues?: JsonFilter<"CharacterItem">
    createdAt?: DateTimeFilter<"CharacterItem"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterItem"> | Date | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
    container?: XOR<CharacterItemNullableRelationFilter, CharacterItemWhereInput> | null
    containedItems?: CharacterItemListRelationFilter
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }

  export type CharacterItemOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    object_zone_id?: SortOrder
    object_id?: SortOrder
    containerId?: SortOrderInput | SortOrder
    equippedLocation?: SortOrderInput | SortOrder
    condition?: SortOrder
    charges?: SortOrder
    instanceFlags?: SortOrder
    customShortDesc?: SortOrderInput | SortOrder
    customLongDesc?: SortOrderInput | SortOrder
    customValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    character?: CharacterOrderByWithRelationInput
    container?: CharacterItemOrderByWithRelationInput
    containedItems?: CharacterItemOrderByRelationAggregateInput
    object?: ObjectOrderByWithRelationInput
  }

  export type CharacterItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacterItemWhereInput | CharacterItemWhereInput[]
    OR?: CharacterItemWhereInput[]
    NOT?: CharacterItemWhereInput | CharacterItemWhereInput[]
    characterId?: StringFilter<"CharacterItem"> | string
    object_zone_id?: IntFilter<"CharacterItem"> | number
    object_id?: IntFilter<"CharacterItem"> | number
    containerId?: StringNullableFilter<"CharacterItem"> | string | null
    equippedLocation?: StringNullableFilter<"CharacterItem"> | string | null
    condition?: IntFilter<"CharacterItem"> | number
    charges?: IntFilter<"CharacterItem"> | number
    instanceFlags?: StringNullableListFilter<"CharacterItem">
    customShortDesc?: StringNullableFilter<"CharacterItem"> | string | null
    customLongDesc?: StringNullableFilter<"CharacterItem"> | string | null
    customValues?: JsonFilter<"CharacterItem">
    createdAt?: DateTimeFilter<"CharacterItem"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterItem"> | Date | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
    container?: XOR<CharacterItemNullableRelationFilter, CharacterItemWhereInput> | null
    containedItems?: CharacterItemListRelationFilter
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }, "id">

  export type CharacterItemOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    object_zone_id?: SortOrder
    object_id?: SortOrder
    containerId?: SortOrderInput | SortOrder
    equippedLocation?: SortOrderInput | SortOrder
    condition?: SortOrder
    charges?: SortOrder
    instanceFlags?: SortOrder
    customShortDesc?: SortOrderInput | SortOrder
    customLongDesc?: SortOrderInput | SortOrder
    customValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CharacterItemCountOrderByAggregateInput
    _avg?: CharacterItemAvgOrderByAggregateInput
    _max?: CharacterItemMaxOrderByAggregateInput
    _min?: CharacterItemMinOrderByAggregateInput
    _sum?: CharacterItemSumOrderByAggregateInput
  }

  export type CharacterItemScalarWhereWithAggregatesInput = {
    AND?: CharacterItemScalarWhereWithAggregatesInput | CharacterItemScalarWhereWithAggregatesInput[]
    OR?: CharacterItemScalarWhereWithAggregatesInput[]
    NOT?: CharacterItemScalarWhereWithAggregatesInput | CharacterItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterItem"> | string
    characterId?: StringWithAggregatesFilter<"CharacterItem"> | string
    object_zone_id?: IntWithAggregatesFilter<"CharacterItem"> | number
    object_id?: IntWithAggregatesFilter<"CharacterItem"> | number
    containerId?: StringNullableWithAggregatesFilter<"CharacterItem"> | string | null
    equippedLocation?: StringNullableWithAggregatesFilter<"CharacterItem"> | string | null
    condition?: IntWithAggregatesFilter<"CharacterItem"> | number
    charges?: IntWithAggregatesFilter<"CharacterItem"> | number
    instanceFlags?: StringNullableListFilter<"CharacterItem">
    customShortDesc?: StringNullableWithAggregatesFilter<"CharacterItem"> | string | null
    customLongDesc?: StringNullableWithAggregatesFilter<"CharacterItem"> | string | null
    customValues?: JsonWithAggregatesFilter<"CharacterItem">
    createdAt?: DateTimeWithAggregatesFilter<"CharacterItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CharacterItem"> | Date | string
  }

  export type CharacterEffectWhereInput = {
    AND?: CharacterEffectWhereInput | CharacterEffectWhereInput[]
    OR?: CharacterEffectWhereInput[]
    NOT?: CharacterEffectWhereInput | CharacterEffectWhereInput[]
    id?: StringFilter<"CharacterEffect"> | string
    characterId?: StringFilter<"CharacterEffect"> | string
    effectName?: StringFilter<"CharacterEffect"> | string
    effectType?: StringNullableFilter<"CharacterEffect"> | string | null
    duration?: IntNullableFilter<"CharacterEffect"> | number | null
    strength?: IntFilter<"CharacterEffect"> | number
    modifierData?: JsonFilter<"CharacterEffect">
    sourceType?: StringNullableFilter<"CharacterEffect"> | string | null
    sourceId?: IntNullableFilter<"CharacterEffect"> | number | null
    appliedAt?: DateTimeFilter<"CharacterEffect"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CharacterEffect"> | Date | string | null
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
  }

  export type CharacterEffectOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    effectName?: SortOrder
    effectType?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    strength?: SortOrder
    modifierData?: SortOrder
    sourceType?: SortOrderInput | SortOrder
    sourceId?: SortOrderInput | SortOrder
    appliedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    character?: CharacterOrderByWithRelationInput
  }

  export type CharacterEffectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacterEffectWhereInput | CharacterEffectWhereInput[]
    OR?: CharacterEffectWhereInput[]
    NOT?: CharacterEffectWhereInput | CharacterEffectWhereInput[]
    characterId?: StringFilter<"CharacterEffect"> | string
    effectName?: StringFilter<"CharacterEffect"> | string
    effectType?: StringNullableFilter<"CharacterEffect"> | string | null
    duration?: IntNullableFilter<"CharacterEffect"> | number | null
    strength?: IntFilter<"CharacterEffect"> | number
    modifierData?: JsonFilter<"CharacterEffect">
    sourceType?: StringNullableFilter<"CharacterEffect"> | string | null
    sourceId?: IntNullableFilter<"CharacterEffect"> | number | null
    appliedAt?: DateTimeFilter<"CharacterEffect"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CharacterEffect"> | Date | string | null
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
  }, "id">

  export type CharacterEffectOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    effectName?: SortOrder
    effectType?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    strength?: SortOrder
    modifierData?: SortOrder
    sourceType?: SortOrderInput | SortOrder
    sourceId?: SortOrderInput | SortOrder
    appliedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: CharacterEffectCountOrderByAggregateInput
    _avg?: CharacterEffectAvgOrderByAggregateInput
    _max?: CharacterEffectMaxOrderByAggregateInput
    _min?: CharacterEffectMinOrderByAggregateInput
    _sum?: CharacterEffectSumOrderByAggregateInput
  }

  export type CharacterEffectScalarWhereWithAggregatesInput = {
    AND?: CharacterEffectScalarWhereWithAggregatesInput | CharacterEffectScalarWhereWithAggregatesInput[]
    OR?: CharacterEffectScalarWhereWithAggregatesInput[]
    NOT?: CharacterEffectScalarWhereWithAggregatesInput | CharacterEffectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterEffect"> | string
    characterId?: StringWithAggregatesFilter<"CharacterEffect"> | string
    effectName?: StringWithAggregatesFilter<"CharacterEffect"> | string
    effectType?: StringNullableWithAggregatesFilter<"CharacterEffect"> | string | null
    duration?: IntNullableWithAggregatesFilter<"CharacterEffect"> | number | null
    strength?: IntWithAggregatesFilter<"CharacterEffect"> | number
    modifierData?: JsonWithAggregatesFilter<"CharacterEffect">
    sourceType?: StringNullableWithAggregatesFilter<"CharacterEffect"> | string | null
    sourceId?: IntNullableWithAggregatesFilter<"CharacterEffect"> | number | null
    appliedAt?: DateTimeWithAggregatesFilter<"CharacterEffect"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"CharacterEffect"> | Date | string | null
  }

  export type EquipmentSetItemWhereInput = {
    AND?: EquipmentSetItemWhereInput | EquipmentSetItemWhereInput[]
    OR?: EquipmentSetItemWhereInput[]
    NOT?: EquipmentSetItemWhereInput | EquipmentSetItemWhereInput[]
    id?: StringFilter<"EquipmentSetItem"> | string
    equipmentSetId?: StringFilter<"EquipmentSetItem"> | string
    objectZoneId?: IntFilter<"EquipmentSetItem"> | number
    objectId?: IntFilter<"EquipmentSetItem"> | number
    slot?: StringNullableFilter<"EquipmentSetItem"> | string | null
    quantity?: IntFilter<"EquipmentSetItem"> | number
    probability?: FloatFilter<"EquipmentSetItem"> | number
    equipmentSet?: XOR<EquipmentSetRelationFilter, EquipmentSetWhereInput>
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }

  export type EquipmentSetItemOrderByWithRelationInput = {
    id?: SortOrder
    equipmentSetId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    slot?: SortOrderInput | SortOrder
    quantity?: SortOrder
    probability?: SortOrder
    equipmentSet?: EquipmentSetOrderByWithRelationInput
    object?: ObjectOrderByWithRelationInput
  }

  export type EquipmentSetItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EquipmentSetItemWhereInput | EquipmentSetItemWhereInput[]
    OR?: EquipmentSetItemWhereInput[]
    NOT?: EquipmentSetItemWhereInput | EquipmentSetItemWhereInput[]
    equipmentSetId?: StringFilter<"EquipmentSetItem"> | string
    objectZoneId?: IntFilter<"EquipmentSetItem"> | number
    objectId?: IntFilter<"EquipmentSetItem"> | number
    slot?: StringNullableFilter<"EquipmentSetItem"> | string | null
    quantity?: IntFilter<"EquipmentSetItem"> | number
    probability?: FloatFilter<"EquipmentSetItem"> | number
    equipmentSet?: XOR<EquipmentSetRelationFilter, EquipmentSetWhereInput>
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
  }, "id">

  export type EquipmentSetItemOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentSetId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    slot?: SortOrderInput | SortOrder
    quantity?: SortOrder
    probability?: SortOrder
    _count?: EquipmentSetItemCountOrderByAggregateInput
    _avg?: EquipmentSetItemAvgOrderByAggregateInput
    _max?: EquipmentSetItemMaxOrderByAggregateInput
    _min?: EquipmentSetItemMinOrderByAggregateInput
    _sum?: EquipmentSetItemSumOrderByAggregateInput
  }

  export type EquipmentSetItemScalarWhereWithAggregatesInput = {
    AND?: EquipmentSetItemScalarWhereWithAggregatesInput | EquipmentSetItemScalarWhereWithAggregatesInput[]
    OR?: EquipmentSetItemScalarWhereWithAggregatesInput[]
    NOT?: EquipmentSetItemScalarWhereWithAggregatesInput | EquipmentSetItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentSetItem"> | string
    equipmentSetId?: StringWithAggregatesFilter<"EquipmentSetItem"> | string
    objectZoneId?: IntWithAggregatesFilter<"EquipmentSetItem"> | number
    objectId?: IntWithAggregatesFilter<"EquipmentSetItem"> | number
    slot?: StringNullableWithAggregatesFilter<"EquipmentSetItem"> | string | null
    quantity?: IntWithAggregatesFilter<"EquipmentSetItem"> | number
    probability?: FloatWithAggregatesFilter<"EquipmentSetItem"> | number
  }

  export type EquipmentSetWhereInput = {
    AND?: EquipmentSetWhereInput | EquipmentSetWhereInput[]
    OR?: EquipmentSetWhereInput[]
    NOT?: EquipmentSetWhereInput | EquipmentSetWhereInput[]
    id?: StringFilter<"EquipmentSet"> | string
    name?: StringFilter<"EquipmentSet"> | string
    description?: StringNullableFilter<"EquipmentSet"> | string | null
    createdAt?: DateTimeFilter<"EquipmentSet"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentSet"> | Date | string
    items?: EquipmentSetItemListRelationFilter
    mobEquipmentSets?: MobEquipmentSetListRelationFilter
  }

  export type EquipmentSetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: EquipmentSetItemOrderByRelationAggregateInput
    mobEquipmentSets?: MobEquipmentSetOrderByRelationAggregateInput
  }

  export type EquipmentSetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EquipmentSetWhereInput | EquipmentSetWhereInput[]
    OR?: EquipmentSetWhereInput[]
    NOT?: EquipmentSetWhereInput | EquipmentSetWhereInput[]
    name?: StringFilter<"EquipmentSet"> | string
    description?: StringNullableFilter<"EquipmentSet"> | string | null
    createdAt?: DateTimeFilter<"EquipmentSet"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentSet"> | Date | string
    items?: EquipmentSetItemListRelationFilter
    mobEquipmentSets?: MobEquipmentSetListRelationFilter
  }, "id">

  export type EquipmentSetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentSetCountOrderByAggregateInput
    _max?: EquipmentSetMaxOrderByAggregateInput
    _min?: EquipmentSetMinOrderByAggregateInput
  }

  export type EquipmentSetScalarWhereWithAggregatesInput = {
    AND?: EquipmentSetScalarWhereWithAggregatesInput | EquipmentSetScalarWhereWithAggregatesInput[]
    OR?: EquipmentSetScalarWhereWithAggregatesInput[]
    NOT?: EquipmentSetScalarWhereWithAggregatesInput | EquipmentSetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentSet"> | string
    name?: StringWithAggregatesFilter<"EquipmentSet"> | string
    description?: StringNullableWithAggregatesFilter<"EquipmentSet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentSet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EquipmentSet"> | Date | string
  }

  export type MobEquipmentSetWhereInput = {
    AND?: MobEquipmentSetWhereInput | MobEquipmentSetWhereInput[]
    OR?: MobEquipmentSetWhereInput[]
    NOT?: MobEquipmentSetWhereInput | MobEquipmentSetWhereInput[]
    id?: StringFilter<"MobEquipmentSet"> | string
    mobResetId?: StringFilter<"MobEquipmentSet"> | string
    equipmentSetId?: StringFilter<"MobEquipmentSet"> | string
    probability?: FloatFilter<"MobEquipmentSet"> | number
    equipmentSet?: XOR<EquipmentSetRelationFilter, EquipmentSetWhereInput>
    mobReset?: XOR<MobResetRelationFilter, MobResetWhereInput>
  }

  export type MobEquipmentSetOrderByWithRelationInput = {
    id?: SortOrder
    mobResetId?: SortOrder
    equipmentSetId?: SortOrder
    probability?: SortOrder
    equipmentSet?: EquipmentSetOrderByWithRelationInput
    mobReset?: MobResetOrderByWithRelationInput
  }

  export type MobEquipmentSetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mobResetId_equipmentSetId?: MobEquipmentSetMobResetIdEquipmentSetIdCompoundUniqueInput
    AND?: MobEquipmentSetWhereInput | MobEquipmentSetWhereInput[]
    OR?: MobEquipmentSetWhereInput[]
    NOT?: MobEquipmentSetWhereInput | MobEquipmentSetWhereInput[]
    mobResetId?: StringFilter<"MobEquipmentSet"> | string
    equipmentSetId?: StringFilter<"MobEquipmentSet"> | string
    probability?: FloatFilter<"MobEquipmentSet"> | number
    equipmentSet?: XOR<EquipmentSetRelationFilter, EquipmentSetWhereInput>
    mobReset?: XOR<MobResetRelationFilter, MobResetWhereInput>
  }, "id" | "mobResetId_equipmentSetId">

  export type MobEquipmentSetOrderByWithAggregationInput = {
    id?: SortOrder
    mobResetId?: SortOrder
    equipmentSetId?: SortOrder
    probability?: SortOrder
    _count?: MobEquipmentSetCountOrderByAggregateInput
    _avg?: MobEquipmentSetAvgOrderByAggregateInput
    _max?: MobEquipmentSetMaxOrderByAggregateInput
    _min?: MobEquipmentSetMinOrderByAggregateInput
    _sum?: MobEquipmentSetSumOrderByAggregateInput
  }

  export type MobEquipmentSetScalarWhereWithAggregatesInput = {
    AND?: MobEquipmentSetScalarWhereWithAggregatesInput | MobEquipmentSetScalarWhereWithAggregatesInput[]
    OR?: MobEquipmentSetScalarWhereWithAggregatesInput[]
    NOT?: MobEquipmentSetScalarWhereWithAggregatesInput | MobEquipmentSetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MobEquipmentSet"> | string
    mobResetId?: StringWithAggregatesFilter<"MobEquipmentSet"> | string
    equipmentSetId?: StringWithAggregatesFilter<"MobEquipmentSet"> | string
    probability?: FloatWithAggregatesFilter<"MobEquipmentSet"> | number
  }

  export type ObjectResetWhereInput = {
    AND?: ObjectResetWhereInput | ObjectResetWhereInput[]
    OR?: ObjectResetWhereInput[]
    NOT?: ObjectResetWhereInput | ObjectResetWhereInput[]
    id?: StringFilter<"ObjectReset"> | string
    max?: IntFilter<"ObjectReset"> | number
    name?: StringNullableFilter<"ObjectReset"> | string | null
    objectZoneId?: IntFilter<"ObjectReset"> | number
    objectId?: IntFilter<"ObjectReset"> | number
    roomZoneId?: IntFilter<"ObjectReset"> | number
    roomId?: IntFilter<"ObjectReset"> | number
    zoneId?: IntFilter<"ObjectReset"> | number
    probability?: FloatFilter<"ObjectReset"> | number
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    spawnConditions?: SpawnConditionListRelationFilter
  }

  export type ObjectResetOrderByWithRelationInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrderInput | SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
    object?: ObjectOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    spawnConditions?: SpawnConditionOrderByRelationAggregateInput
  }

  export type ObjectResetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObjectResetWhereInput | ObjectResetWhereInput[]
    OR?: ObjectResetWhereInput[]
    NOT?: ObjectResetWhereInput | ObjectResetWhereInput[]
    max?: IntFilter<"ObjectReset"> | number
    name?: StringNullableFilter<"ObjectReset"> | string | null
    objectZoneId?: IntFilter<"ObjectReset"> | number
    objectId?: IntFilter<"ObjectReset"> | number
    roomZoneId?: IntFilter<"ObjectReset"> | number
    roomId?: IntFilter<"ObjectReset"> | number
    zoneId?: IntFilter<"ObjectReset"> | number
    probability?: FloatFilter<"ObjectReset"> | number
    object?: XOR<ObjectRelationFilter, ObjectWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    spawnConditions?: SpawnConditionListRelationFilter
  }, "id">

  export type ObjectResetOrderByWithAggregationInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrderInput | SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
    _count?: ObjectResetCountOrderByAggregateInput
    _avg?: ObjectResetAvgOrderByAggregateInput
    _max?: ObjectResetMaxOrderByAggregateInput
    _min?: ObjectResetMinOrderByAggregateInput
    _sum?: ObjectResetSumOrderByAggregateInput
  }

  export type ObjectResetScalarWhereWithAggregatesInput = {
    AND?: ObjectResetScalarWhereWithAggregatesInput | ObjectResetScalarWhereWithAggregatesInput[]
    OR?: ObjectResetScalarWhereWithAggregatesInput[]
    NOT?: ObjectResetScalarWhereWithAggregatesInput | ObjectResetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ObjectReset"> | string
    max?: IntWithAggregatesFilter<"ObjectReset"> | number
    name?: StringNullableWithAggregatesFilter<"ObjectReset"> | string | null
    objectZoneId?: IntWithAggregatesFilter<"ObjectReset"> | number
    objectId?: IntWithAggregatesFilter<"ObjectReset"> | number
    roomZoneId?: IntWithAggregatesFilter<"ObjectReset"> | number
    roomId?: IntWithAggregatesFilter<"ObjectReset"> | number
    zoneId?: IntWithAggregatesFilter<"ObjectReset"> | number
    probability?: FloatWithAggregatesFilter<"ObjectReset"> | number
  }

  export type SpawnConditionWhereInput = {
    AND?: SpawnConditionWhereInput | SpawnConditionWhereInput[]
    OR?: SpawnConditionWhereInput[]
    NOT?: SpawnConditionWhereInput | SpawnConditionWhereInput[]
    id?: StringFilter<"SpawnCondition"> | string
    type?: StringFilter<"SpawnCondition"> | string
    parameters?: JsonFilter<"SpawnCondition">
    mobResetId?: StringNullableFilter<"SpawnCondition"> | string | null
    objectResetId?: StringNullableFilter<"SpawnCondition"> | string | null
    mobReset?: XOR<MobResetNullableRelationFilter, MobResetWhereInput> | null
    objectReset?: XOR<ObjectResetNullableRelationFilter, ObjectResetWhereInput> | null
  }

  export type SpawnConditionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    parameters?: SortOrder
    mobResetId?: SortOrderInput | SortOrder
    objectResetId?: SortOrderInput | SortOrder
    mobReset?: MobResetOrderByWithRelationInput
    objectReset?: ObjectResetOrderByWithRelationInput
  }

  export type SpawnConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpawnConditionWhereInput | SpawnConditionWhereInput[]
    OR?: SpawnConditionWhereInput[]
    NOT?: SpawnConditionWhereInput | SpawnConditionWhereInput[]
    type?: StringFilter<"SpawnCondition"> | string
    parameters?: JsonFilter<"SpawnCondition">
    mobResetId?: StringNullableFilter<"SpawnCondition"> | string | null
    objectResetId?: StringNullableFilter<"SpawnCondition"> | string | null
    mobReset?: XOR<MobResetNullableRelationFilter, MobResetWhereInput> | null
    objectReset?: XOR<ObjectResetNullableRelationFilter, ObjectResetWhereInput> | null
  }, "id">

  export type SpawnConditionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    parameters?: SortOrder
    mobResetId?: SortOrderInput | SortOrder
    objectResetId?: SortOrderInput | SortOrder
    _count?: SpawnConditionCountOrderByAggregateInput
    _max?: SpawnConditionMaxOrderByAggregateInput
    _min?: SpawnConditionMinOrderByAggregateInput
  }

  export type SpawnConditionScalarWhereWithAggregatesInput = {
    AND?: SpawnConditionScalarWhereWithAggregatesInput | SpawnConditionScalarWhereWithAggregatesInput[]
    OR?: SpawnConditionScalarWhereWithAggregatesInput[]
    NOT?: SpawnConditionScalarWhereWithAggregatesInput | SpawnConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpawnCondition"> | string
    type?: StringWithAggregatesFilter<"SpawnCondition"> | string
    parameters?: JsonWithAggregatesFilter<"SpawnCondition">
    mobResetId?: StringNullableWithAggregatesFilter<"SpawnCondition"> | string | null
    objectResetId?: StringNullableWithAggregatesFilter<"SpawnCondition"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    issuedBans?: BanRecordCreateNestedManyWithoutAdminInput
    banRecords?: BanRecordCreateNestedManyWithoutUserInput
    changeLogs?: ChangeLogCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    issuedBans?: BanRecordUncheckedCreateNestedManyWithoutAdminInput
    banRecords?: BanRecordUncheckedCreateNestedManyWithoutUserInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    issuedBans?: BanRecordUpdateManyWithoutAdminNestedInput
    banRecords?: BanRecordUpdateManyWithoutUserNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    issuedBans?: BanRecordUncheckedUpdateManyWithoutAdminNestedInput
    banRecords?: BanRecordUncheckedUpdateManyWithoutUserNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterCreateInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectCreateNestedManyWithoutCharacterInput
    items?: CharacterItemCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellCreateNestedManyWithoutCharacterInput
    gameClass?: GameClassCreateNestedOneWithoutCharactersInput
    user: UserCreateNestedOneWithoutCharactersInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: number | null
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectUncheckedCreateNestedManyWithoutCharacterInput
    items?: CharacterItemUncheckedCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUpdateManyWithoutCharacterNestedInput
    items?: CharacterItemUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUpdateManyWithoutCharacterNestedInput
    gameClass?: GameClassUpdateOneWithoutCharactersNestedInput
    user?: UserUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUncheckedUpdateManyWithoutCharacterNestedInput
    items?: CharacterItemUncheckedUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateManyInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: number | null
    experience?: number
    skillPoints?: number
  }

  export type CharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
  }

  export type ZoneCreateInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetCreateNestedManyWithoutZoneInput
    mobs?: MobCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetCreateNestedManyWithoutZoneInput
    objects?: ObjectCreateNestedManyWithoutZoneInput
    rooms?: RoomCreateNestedManyWithoutZoneInput
    shops?: ShopCreateNestedManyWithoutZoneInput
    triggers?: TriggerCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutZoneInput
    mobs?: MobUncheckedCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutZoneInput
    objects?: ObjectUncheckedCreateNestedManyWithoutZoneInput
    rooms?: RoomUncheckedCreateNestedManyWithoutZoneInput
    shops?: ShopUncheckedCreateNestedManyWithoutZoneInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUpdateManyWithoutZoneNestedInput
    mobs?: MobUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUpdateManyWithoutZoneNestedInput
    objects?: ObjectUpdateManyWithoutZoneNestedInput
    rooms?: RoomUpdateManyWithoutZoneNestedInput
    shops?: ShopUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUncheckedUpdateManyWithoutZoneNestedInput
    mobs?: MobUncheckedUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutZoneNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutZoneNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutZoneNestedInput
    shops?: ShopUncheckedUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type ZoneUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomCreateInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    mobResets?: MobResetCreateNestedManyWithoutRoomInput
    objectResets?: ObjectResetCreateNestedManyWithoutRoomInput
    exits?: RoomExitCreateNestedManyWithoutRoomInput
    extraDescs?: RoomExtraDescriptionCreateNestedManyWithoutRoomInput
    zone: ZoneCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutRoomInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutRoomInput
    exits?: RoomExitUncheckedCreateNestedManyWithoutRoomInput
    extraDescs?: RoomExtraDescriptionUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    mobResets?: MobResetUpdateManyWithoutRoomNestedInput
    objectResets?: ObjectResetUpdateManyWithoutRoomNestedInput
    exits?: RoomExitUpdateManyWithoutRoomNestedInput
    extraDescs?: RoomExtraDescriptionUpdateManyWithoutRoomNestedInput
    zone?: ZoneUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    mobResets?: MobResetUncheckedUpdateManyWithoutRoomNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutRoomNestedInput
    exits?: RoomExitUncheckedUpdateManyWithoutRoomNestedInput
    extraDescs?: RoomExtraDescriptionUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
  }

  export type RoomUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomExitCreateInput = {
    id?: string
    direction: $Enums.Direction
    description?: string | null
    keyword?: string | null
    key?: string | null
    destination?: number | null
    flags?: RoomExitCreateflagsInput | $Enums.ExitFlag[]
    room: RoomCreateNestedOneWithoutExitsInput
  }

  export type RoomExitUncheckedCreateInput = {
    id?: string
    direction: $Enums.Direction
    description?: string | null
    keyword?: string | null
    key?: string | null
    destination?: number | null
    roomZoneId: number
    roomId: number
    flags?: RoomExitCreateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: RoomExitUpdateflagsInput | $Enums.ExitFlag[]
    room?: RoomUpdateOneRequiredWithoutExitsNestedInput
  }

  export type RoomExitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableIntFieldUpdateOperationsInput | number | null
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    flags?: RoomExitUpdateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExitCreateManyInput = {
    id?: string
    direction: $Enums.Direction
    description?: string | null
    keyword?: string | null
    key?: string | null
    destination?: number | null
    roomZoneId: number
    roomId: number
    flags?: RoomExitCreateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: RoomExitUpdateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableIntFieldUpdateOperationsInput | number | null
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    flags?: RoomExitUpdateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExtraDescriptionCreateInput = {
    id?: string
    keyword: string
    description: string
    room: RoomCreateNestedOneWithoutExtraDescsInput
  }

  export type RoomExtraDescriptionUncheckedCreateInput = {
    id?: string
    keyword: string
    description: string
    roomZoneId: number
    roomId: number
  }

  export type RoomExtraDescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneRequiredWithoutExtraDescsNestedInput
  }

  export type RoomExtraDescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
  }

  export type RoomExtraDescriptionCreateManyInput = {
    id?: string
    keyword: string
    description: string
    roomZoneId: number
    roomId: number
  }

  export type RoomExtraDescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RoomExtraDescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
  }

  export type MobCreateInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetCreateNestedManyWithoutMobInput
    skills?: MobSkillCreateNestedManyWithoutMobInput
    spells?: MobSpellCreateNestedManyWithoutMobInput
    gameClass?: GameClassCreateNestedOneWithoutMobsInput
    zone: ZoneCreateNestedOneWithoutMobsInput
    shops?: ShopCreateNestedManyWithoutKeeperInput
    triggers?: TriggerCreateNestedManyWithoutMobInput
  }

  export type MobUncheckedCreateInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    classId?: number | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetUncheckedCreateNestedManyWithoutMobInput
    skills?: MobSkillUncheckedCreateNestedManyWithoutMobInput
    spells?: MobSpellUncheckedCreateNestedManyWithoutMobInput
    shops?: ShopUncheckedCreateNestedManyWithoutKeeperInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutMobInput
  }

  export type MobUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUpdateManyWithoutMobNestedInput
    skills?: MobSkillUpdateManyWithoutMobNestedInput
    spells?: MobSpellUpdateManyWithoutMobNestedInput
    gameClass?: GameClassUpdateOneWithoutMobsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobsNestedInput
    shops?: ShopUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUpdateManyWithoutMobNestedInput
  }

  export type MobUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUncheckedUpdateManyWithoutMobNestedInput
    skills?: MobSkillUncheckedUpdateManyWithoutMobNestedInput
    spells?: MobSpellUncheckedUpdateManyWithoutMobNestedInput
    shops?: ShopUncheckedUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutMobNestedInput
  }

  export type MobCreateManyInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    classId?: number | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
  }

  export type MobUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
  }

  export type MobUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
  }

  export type MobSkillCreateInput = {
    level?: number
    mob: MobCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutMobSkillsInput
  }

  export type MobSkillUncheckedCreateInput = {
    id?: number
    mobZoneId: number
    mobId: number
    skillId: number
    level?: number
  }

  export type MobSkillUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    mob?: MobUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutMobSkillsNestedInput
  }

  export type MobSkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type MobSkillCreateManyInput = {
    id?: number
    mobZoneId: number
    mobId: number
    skillId: number
    level?: number
  }

  export type MobSkillUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
  }

  export type MobSkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type MobSpellCreateInput = {
    circle?: number
    known?: boolean
    mob: MobCreateNestedOneWithoutSpellsInput
    spell: SpellCreateNestedOneWithoutMobSpellsInput
  }

  export type MobSpellUncheckedCreateInput = {
    id?: number
    mobZoneId: number
    mobId: number
    spellId: number
    circle?: number
    known?: boolean
  }

  export type MobSpellUpdateInput = {
    circle?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
    mob?: MobUpdateOneRequiredWithoutSpellsNestedInput
    spell?: SpellUpdateOneRequiredWithoutMobSpellsNestedInput
  }

  export type MobSpellUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MobSpellCreateManyInput = {
    id?: number
    mobZoneId: number
    mobId: number
    spellId: number
    circle?: number
    known?: boolean
  }

  export type MobSpellUpdateManyMutationInput = {
    circle?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MobSpellUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MobResetCreateInput = {
    id?: string
    max?: number
    name?: string | null
    probability?: number
    carrying?: MobCarryingCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedCreateNestedManyWithoutResetInput
    mob: MobCreateNestedOneWithoutResetsInput
    room: RoomCreateNestedOneWithoutMobResetsInput
    zone: ZoneCreateNestedOneWithoutMobResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutMobResetInput
  }

  export type MobResetUncheckedCreateInput = {
    id?: string
    max?: number
    name?: string | null
    mobZoneId: number
    mobId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
    carrying?: MobCarryingUncheckedCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetUncheckedCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedUncheckedCreateNestedManyWithoutResetInput
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutMobResetInput
  }

  export type MobResetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUpdateManyWithoutResetNestedInput
    mob?: MobUpdateOneRequiredWithoutResetsNestedInput
    room?: RoomUpdateOneRequiredWithoutMobResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUncheckedUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUncheckedUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUncheckedUpdateManyWithoutResetNestedInput
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetCreateManyInput = {
    id?: string
    max?: number
    name?: string | null
    mobZoneId: number
    mobId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
  }

  export type MobResetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobResetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobCarryingCreateInput = {
    id?: string
    max?: number
    name?: string | null
    object: ObjectCreateNestedOneWithoutMobCarryingInput
    reset: MobResetCreateNestedOneWithoutCarryingInput
  }

  export type MobCarryingUncheckedCreateInput = {
    id?: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
    resetId: string
  }

  export type MobCarryingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    object?: ObjectUpdateOneRequiredWithoutMobCarryingNestedInput
    reset?: MobResetUpdateOneRequiredWithoutCarryingNestedInput
  }

  export type MobCarryingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    resetId?: StringFieldUpdateOperationsInput | string
  }

  export type MobCarryingCreateManyInput = {
    id?: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
    resetId: string
  }

  export type MobCarryingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MobCarryingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    resetId?: StringFieldUpdateOperationsInput | string
  }

  export type MobEquippedCreateInput = {
    id?: string
    max?: number
    location: string
    name?: string | null
    object: ObjectCreateNestedOneWithoutMobEquippedInput
    reset: MobResetCreateNestedOneWithoutEquippedInput
  }

  export type MobEquippedUncheckedCreateInput = {
    id?: string
    max?: number
    location: string
    name?: string | null
    objectZoneId: number
    objectId: number
    resetId: string
  }

  export type MobEquippedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    object?: ObjectUpdateOneRequiredWithoutMobEquippedNestedInput
    reset?: MobResetUpdateOneRequiredWithoutEquippedNestedInput
  }

  export type MobEquippedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    resetId?: StringFieldUpdateOperationsInput | string
  }

  export type MobEquippedCreateManyInput = {
    id?: string
    max?: number
    location: string
    name?: string | null
    objectZoneId: number
    objectId: number
    resetId: string
  }

  export type MobEquippedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MobEquippedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    resetId?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ObjectCreateManyInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
  }

  export type ObjectUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
  }

  export type ObjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
  }

  export type ObjectExtraDescriptionCreateInput = {
    id?: string
    keyword: string
    description: string
    object: ObjectCreateNestedOneWithoutExtraDescsInput
  }

  export type ObjectExtraDescriptionUncheckedCreateInput = {
    id?: string
    keyword: string
    description: string
    objectZoneId: number
    objectId: number
  }

  export type ObjectExtraDescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateOneRequiredWithoutExtraDescsNestedInput
  }

  export type ObjectExtraDescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectExtraDescriptionCreateManyInput = {
    id?: string
    keyword: string
    description: string
    objectZoneId: number
    objectId: number
  }

  export type ObjectExtraDescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectExtraDescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectAffectCreateInput = {
    id?: string
    location: string
    modifier: number
    object: ObjectCreateNestedOneWithoutAffectsInput
  }

  export type ObjectAffectUncheckedCreateInput = {
    id?: string
    location: string
    modifier: number
    objectZoneId: number
    objectId: number
  }

  export type ObjectAffectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    object?: ObjectUpdateOneRequiredWithoutAffectsNestedInput
  }

  export type ObjectAffectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectAffectCreateManyInput = {
    id?: string
    location: string
    modifier: number
    objectZoneId: number
    objectId: number
  }

  export type ObjectAffectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectAffectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectSpellCreateInput = {
    id?: string
    spell: string
    level?: number
    object: ObjectCreateNestedOneWithoutSpellsInput
  }

  export type ObjectSpellUncheckedCreateInput = {
    id?: string
    spell: string
    level?: number
    objectZoneId: number
    objectId: number
  }

  export type ObjectSpellUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spell?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    object?: ObjectUpdateOneRequiredWithoutSpellsNestedInput
  }

  export type ObjectSpellUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spell?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectSpellCreateManyInput = {
    id?: string
    spell: string
    level?: number
    objectZoneId: number
    objectId: number
  }

  export type ObjectSpellUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    spell?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectSpellUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    spell?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopCreateInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptCreateNestedManyWithoutShopInput
    hours?: ShopHourCreateNestedManyWithoutShopInput
    items?: ShopItemCreateNestedManyWithoutShopInput
    rooms?: ShopRoomCreateNestedManyWithoutShopInput
    keeper?: MobCreateNestedOneWithoutShopsInput
    zone: ZoneCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    keeperZoneId?: number | null
    keeperId?: number | null
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedCreateNestedManyWithoutShopInput
    hours?: ShopHourUncheckedCreateNestedManyWithoutShopInput
    items?: ShopItemUncheckedCreateNestedManyWithoutShopInput
    rooms?: ShopRoomUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUpdateManyWithoutShopNestedInput
    hours?: ShopHourUpdateManyWithoutShopNestedInput
    items?: ShopItemUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUpdateManyWithoutShopNestedInput
    keeper?: MobUpdateOneWithoutShopsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    keeperZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    keeperId?: NullableIntFieldUpdateOperationsInput | number | null
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedUpdateManyWithoutShopNestedInput
    hours?: ShopHourUncheckedUpdateManyWithoutShopNestedInput
    items?: ShopItemUncheckedUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateManyInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    keeperZoneId?: number | null
    keeperId?: number | null
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
  }

  export type ShopUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
  }

  export type ShopUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    keeperZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    keeperId?: NullableIntFieldUpdateOperationsInput | number | null
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
  }

  export type ShopItemCreateInput = {
    id?: string
    amount?: number
    object: ObjectCreateNestedOneWithoutShopItemsInput
    shop: ShopCreateNestedOneWithoutItemsInput
  }

  export type ShopItemUncheckedCreateInput = {
    id?: string
    amount?: number
    shopZoneId: number
    shopId: number
    objectZoneId: number
    objectId: number
  }

  export type ShopItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    object?: ObjectUpdateOneRequiredWithoutShopItemsNestedInput
    shop?: ShopUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ShopItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    shopZoneId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopItemCreateManyInput = {
    id?: string
    amount?: number
    shopZoneId: number
    shopId: number
    objectZoneId: number
    objectId: number
  }

  export type ShopItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type ShopItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    shopZoneId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopAcceptCreateInput = {
    id?: string
    type: string
    keywords?: ShopAcceptCreatekeywordsInput | string[]
    shop: ShopCreateNestedOneWithoutAcceptsInput
  }

  export type ShopAcceptUncheckedCreateInput = {
    id?: string
    type: string
    keywords?: ShopAcceptCreatekeywordsInput | string[]
    shopZoneId: number
    shopId: number
  }

  export type ShopAcceptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ShopAcceptUpdatekeywordsInput | string[]
    shop?: ShopUpdateOneRequiredWithoutAcceptsNestedInput
  }

  export type ShopAcceptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ShopAcceptUpdatekeywordsInput | string[]
    shopZoneId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopAcceptCreateManyInput = {
    id?: string
    type: string
    keywords?: ShopAcceptCreatekeywordsInput | string[]
    shopZoneId: number
    shopId: number
  }

  export type ShopAcceptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ShopAcceptUpdatekeywordsInput | string[]
  }

  export type ShopAcceptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ShopAcceptUpdatekeywordsInput | string[]
    shopZoneId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopRoomCreateInput = {
    id?: string
    roomId: number
    shop: ShopCreateNestedOneWithoutRoomsInput
  }

  export type ShopRoomUncheckedCreateInput = {
    id?: string
    roomId: number
    shopZoneId: number
    shopId: number
  }

  export type ShopRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type ShopRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    shopZoneId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopRoomCreateManyInput = {
    id?: string
    roomId: number
    shopZoneId: number
    shopId: number
  }

  export type ShopRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    shopZoneId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopHourCreateInput = {
    id?: string
    open: number
    close: number
    shop: ShopCreateNestedOneWithoutHoursInput
  }

  export type ShopHourUncheckedCreateInput = {
    id?: string
    open: number
    close: number
    shopZoneId: number
    shopId: number
  }

  export type ShopHourUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    open?: IntFieldUpdateOperationsInput | number
    close?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutHoursNestedInput
  }

  export type ShopHourUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    open?: IntFieldUpdateOperationsInput | number
    close?: IntFieldUpdateOperationsInput | number
    shopZoneId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopHourCreateManyInput = {
    id?: string
    open: number
    close: number
    shopZoneId: number
    shopId: number
  }

  export type ShopHourUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    open?: IntFieldUpdateOperationsInput | number
    close?: IntFieldUpdateOperationsInput | number
  }

  export type ShopHourUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    open?: IntFieldUpdateOperationsInput | number
    close?: IntFieldUpdateOperationsInput | number
    shopZoneId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type TriggerCreateInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
    mob?: MobCreateNestedOneWithoutTriggersInput
    object?: ObjectCreateNestedOneWithoutTriggersInput
    zone?: ZoneCreateNestedOneWithoutTriggersInput
  }

  export type TriggerUncheckedCreateInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    zoneId?: number | null
    mobZoneId?: number | null
    mobId?: number | null
    objectZoneId?: number | null
    objectId?: number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
  }

  export type TriggerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
    mob?: MobUpdateOneWithoutTriggersNestedInput
    object?: ObjectUpdateOneWithoutTriggersNestedInput
    zone?: ZoneUpdateOneWithoutTriggersNestedInput
  }

  export type TriggerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableIntFieldUpdateOperationsInput | number | null
    mobZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    mobId?: NullableIntFieldUpdateOperationsInput | number | null
    objectZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
  }

  export type TriggerCreateManyInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    zoneId?: number | null
    mobZoneId?: number | null
    mobId?: number | null
    objectZoneId?: number | null
    objectId?: number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
  }

  export type TriggerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
  }

  export type TriggerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableIntFieldUpdateOperationsInput | number | null
    mobZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    mobId?: NullableIntFieldUpdateOperationsInput | number | null
    objectZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameClassCreateInput = {
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutGameClassInput
    skillAccess?: ClassSkillCreateNestedManyWithoutGameClassInput
    mobs?: MobCreateNestedManyWithoutGameClassInput
    spellCircles?: SpellClassCircleCreateNestedManyWithoutGameClassInput
  }

  export type GameClassUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutGameClassInput
    skillAccess?: ClassSkillUncheckedCreateNestedManyWithoutGameClassInput
    mobs?: MobUncheckedCreateNestedManyWithoutGameClassInput
    spellCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutGameClassInput
  }

  export type GameClassUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutGameClassNestedInput
    skillAccess?: ClassSkillUpdateManyWithoutGameClassNestedInput
    mobs?: MobUpdateManyWithoutGameClassNestedInput
    spellCircles?: SpellClassCircleUpdateManyWithoutGameClassNestedInput
  }

  export type GameClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutGameClassNestedInput
    skillAccess?: ClassSkillUncheckedUpdateManyWithoutGameClassNestedInput
    mobs?: MobUncheckedUpdateManyWithoutGameClassNestedInput
    spellCircles?: SpellClassCircleUncheckedUpdateManyWithoutGameClassNestedInput
  }

  export type GameClassCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameClassUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpellCreateInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleCreateNestedManyWithoutSpellInput
    components?: SpellComponentCreateNestedManyWithoutSpellInput
    effects?: SpellEffectCreateNestedManyWithoutSpellInput
    messages?: SpellMessageCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingCreateNestedOneWithoutSpellInput
    school?: SpellSchoolCreateNestedOneWithoutSpellsInput
  }

  export type SpellUncheckedCreateInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellUncheckedCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellUncheckedCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput
    components?: SpellComponentUncheckedCreateNestedManyWithoutSpellInput
    effects?: SpellEffectUncheckedCreateNestedManyWithoutSpellInput
    messages?: SpellMessageUncheckedCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingUncheckedCreateNestedOneWithoutSpellInput
  }

  export type SpellUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUpdateOneWithoutSpellNestedInput
    school?: SpellSchoolUpdateOneWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUncheckedUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUncheckedUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUncheckedUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUncheckedUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput
  }

  export type SpellCreateManyInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpellUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpellUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpellSchoolCreateInput = {
    name: string
    description?: string | null
    spells?: SpellCreateNestedManyWithoutSchoolInput
  }

  export type SpellSchoolUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    spells?: SpellUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SpellSchoolUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spells?: SpellUpdateManyWithoutSchoolNestedInput
  }

  export type SpellSchoolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spells?: SpellUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SpellSchoolCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type SpellSchoolUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellSchoolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellClassCircleCreateInput = {
    circle: number
    minLevel?: number | null
    proficiencyGain?: number | null
    gameClass: GameClassCreateNestedOneWithoutSpellCirclesInput
    spell: SpellCreateNestedOneWithoutClassCirclesInput
  }

  export type SpellClassCircleUncheckedCreateInput = {
    id?: number
    spellId: number
    classId: number
    circle: number
    minLevel?: number | null
    proficiencyGain?: number | null
  }

  export type SpellClassCircleUpdateInput = {
    circle?: IntFieldUpdateOperationsInput | number
    minLevel?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyGain?: NullableIntFieldUpdateOperationsInput | number | null
    gameClass?: GameClassUpdateOneRequiredWithoutSpellCirclesNestedInput
    spell?: SpellUpdateOneRequiredWithoutClassCirclesNestedInput
  }

  export type SpellClassCircleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    minLevel?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyGain?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellClassCircleCreateManyInput = {
    id?: number
    spellId: number
    classId: number
    circle: number
    minLevel?: number | null
    proficiencyGain?: number | null
  }

  export type SpellClassCircleUpdateManyMutationInput = {
    circle?: IntFieldUpdateOperationsInput | number
    minLevel?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyGain?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellClassCircleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    minLevel?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyGain?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellTargetingCreateInput = {
    allowedTargetsMask: number
    targetScope?: $Enums.TargetScope
    maxTargets?: number
    range?: $Enums.SpellRange
    requireLos?: boolean
    filtersMask?: number | null
    spell: SpellCreateNestedOneWithoutTargetingInput
  }

  export type SpellTargetingUncheckedCreateInput = {
    id?: number
    spellId: number
    allowedTargetsMask: number
    targetScope?: $Enums.TargetScope
    maxTargets?: number
    range?: $Enums.SpellRange
    requireLos?: boolean
    filtersMask?: number | null
  }

  export type SpellTargetingUpdateInput = {
    allowedTargetsMask?: IntFieldUpdateOperationsInput | number
    targetScope?: EnumTargetScopeFieldUpdateOperationsInput | $Enums.TargetScope
    maxTargets?: IntFieldUpdateOperationsInput | number
    range?: EnumSpellRangeFieldUpdateOperationsInput | $Enums.SpellRange
    requireLos?: BoolFieldUpdateOperationsInput | boolean
    filtersMask?: NullableIntFieldUpdateOperationsInput | number | null
    spell?: SpellUpdateOneRequiredWithoutTargetingNestedInput
  }

  export type SpellTargetingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    allowedTargetsMask?: IntFieldUpdateOperationsInput | number
    targetScope?: EnumTargetScopeFieldUpdateOperationsInput | $Enums.TargetScope
    maxTargets?: IntFieldUpdateOperationsInput | number
    range?: EnumSpellRangeFieldUpdateOperationsInput | $Enums.SpellRange
    requireLos?: BoolFieldUpdateOperationsInput | boolean
    filtersMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellTargetingCreateManyInput = {
    id?: number
    spellId: number
    allowedTargetsMask: number
    targetScope?: $Enums.TargetScope
    maxTargets?: number
    range?: $Enums.SpellRange
    requireLos?: boolean
    filtersMask?: number | null
  }

  export type SpellTargetingUpdateManyMutationInput = {
    allowedTargetsMask?: IntFieldUpdateOperationsInput | number
    targetScope?: EnumTargetScopeFieldUpdateOperationsInput | $Enums.TargetScope
    maxTargets?: IntFieldUpdateOperationsInput | number
    range?: EnumSpellRangeFieldUpdateOperationsInput | $Enums.SpellRange
    requireLos?: BoolFieldUpdateOperationsInput | boolean
    filtersMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellTargetingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    allowedTargetsMask?: IntFieldUpdateOperationsInput | number
    targetScope?: EnumTargetScopeFieldUpdateOperationsInput | $Enums.TargetScope
    maxTargets?: IntFieldUpdateOperationsInput | number
    range?: EnumSpellRangeFieldUpdateOperationsInput | $Enums.SpellRange
    requireLos?: BoolFieldUpdateOperationsInput | boolean
    filtersMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSavingThrowCreateInput = {
    saveType?: $Enums.SaveType
    onSave?: $Enums.SaveResult
    dcFormula: string
    saveModifierMask?: number | null
    spell: SpellCreateNestedOneWithoutSavingThrowsInput
  }

  export type SpellSavingThrowUncheckedCreateInput = {
    id?: number
    spellId: number
    saveType?: $Enums.SaveType
    onSave?: $Enums.SaveResult
    dcFormula: string
    saveModifierMask?: number | null
  }

  export type SpellSavingThrowUpdateInput = {
    saveType?: EnumSaveTypeFieldUpdateOperationsInput | $Enums.SaveType
    onSave?: EnumSaveResultFieldUpdateOperationsInput | $Enums.SaveResult
    dcFormula?: StringFieldUpdateOperationsInput | string
    saveModifierMask?: NullableIntFieldUpdateOperationsInput | number | null
    spell?: SpellUpdateOneRequiredWithoutSavingThrowsNestedInput
  }

  export type SpellSavingThrowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    saveType?: EnumSaveTypeFieldUpdateOperationsInput | $Enums.SaveType
    onSave?: EnumSaveResultFieldUpdateOperationsInput | $Enums.SaveResult
    dcFormula?: StringFieldUpdateOperationsInput | string
    saveModifierMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSavingThrowCreateManyInput = {
    id?: number
    spellId: number
    saveType?: $Enums.SaveType
    onSave?: $Enums.SaveResult
    dcFormula: string
    saveModifierMask?: number | null
  }

  export type SpellSavingThrowUpdateManyMutationInput = {
    saveType?: EnumSaveTypeFieldUpdateOperationsInput | $Enums.SaveType
    onSave?: EnumSaveResultFieldUpdateOperationsInput | $Enums.SaveResult
    dcFormula?: StringFieldUpdateOperationsInput | string
    saveModifierMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSavingThrowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    saveType?: EnumSaveTypeFieldUpdateOperationsInput | $Enums.SaveType
    onSave?: EnumSaveResultFieldUpdateOperationsInput | $Enums.SaveResult
    dcFormula?: StringFieldUpdateOperationsInput | string
    saveModifierMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellMessageCreateInput = {
    startToCaster?: string | null
    startToVictim?: string | null
    startToRoom?: string | null
    successToCaster?: string | null
    successToVictim?: string | null
    successToRoom?: string | null
    failToCaster?: string | null
    failToVictim?: string | null
    failToRoom?: string | null
    wearoffToTarget?: string | null
    wearoffToRoom?: string | null
    spell: SpellCreateNestedOneWithoutMessagesInput
  }

  export type SpellMessageUncheckedCreateInput = {
    id?: number
    spellId: number
    startToCaster?: string | null
    startToVictim?: string | null
    startToRoom?: string | null
    successToCaster?: string | null
    successToVictim?: string | null
    successToRoom?: string | null
    failToCaster?: string | null
    failToVictim?: string | null
    failToRoom?: string | null
    wearoffToTarget?: string | null
    wearoffToRoom?: string | null
  }

  export type SpellMessageUpdateInput = {
    startToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    startToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    startToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    successToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    successToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    successToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    failToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    failToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    failToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToTarget?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    spell?: SpellUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type SpellMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    startToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    startToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    startToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    successToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    successToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    successToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    failToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    failToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    failToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToTarget?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToRoom?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellMessageCreateManyInput = {
    id?: number
    spellId: number
    startToCaster?: string | null
    startToVictim?: string | null
    startToRoom?: string | null
    successToCaster?: string | null
    successToVictim?: string | null
    successToRoom?: string | null
    failToCaster?: string | null
    failToVictim?: string | null
    failToRoom?: string | null
    wearoffToTarget?: string | null
    wearoffToRoom?: string | null
  }

  export type SpellMessageUpdateManyMutationInput = {
    startToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    startToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    startToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    successToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    successToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    successToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    failToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    failToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    failToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToTarget?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToRoom?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    startToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    startToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    startToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    successToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    successToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    successToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    failToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    failToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    failToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToTarget?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToRoom?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellComponentCreateInput = {
    objectId: number
    consumed?: boolean
    required?: boolean
    spell: SpellCreateNestedOneWithoutComponentsInput
  }

  export type SpellComponentUncheckedCreateInput = {
    id?: number
    spellId: number
    objectId: number
    consumed?: boolean
    required?: boolean
  }

  export type SpellComponentUpdateInput = {
    objectId?: IntFieldUpdateOperationsInput | number
    consumed?: BoolFieldUpdateOperationsInput | boolean
    required?: BoolFieldUpdateOperationsInput | boolean
    spell?: SpellUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type SpellComponentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    consumed?: BoolFieldUpdateOperationsInput | boolean
    required?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellComponentCreateManyInput = {
    id?: number
    spellId: number
    objectId: number
    consumed?: boolean
    required?: boolean
  }

  export type SpellComponentUpdateManyMutationInput = {
    objectId?: IntFieldUpdateOperationsInput | number
    consumed?: BoolFieldUpdateOperationsInput | boolean
    required?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellComponentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    consumed?: BoolFieldUpdateOperationsInput | boolean
    required?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellRestrictionCreateInput = {
    indoorsOnly?: boolean
    outdoorsOnly?: boolean
    noSafeRooms?: boolean
    noTeleportFlagsMask?: number | null
    terrainMask?: number | null
    disallowStatesMask?: number | null
    spell: SpellCreateNestedOneWithoutRestrictionsInput
  }

  export type SpellRestrictionUncheckedCreateInput = {
    id?: number
    spellId: number
    indoorsOnly?: boolean
    outdoorsOnly?: boolean
    noSafeRooms?: boolean
    noTeleportFlagsMask?: number | null
    terrainMask?: number | null
    disallowStatesMask?: number | null
  }

  export type SpellRestrictionUpdateInput = {
    indoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    outdoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    noSafeRooms?: BoolFieldUpdateOperationsInput | boolean
    noTeleportFlagsMask?: NullableIntFieldUpdateOperationsInput | number | null
    terrainMask?: NullableIntFieldUpdateOperationsInput | number | null
    disallowStatesMask?: NullableIntFieldUpdateOperationsInput | number | null
    spell?: SpellUpdateOneRequiredWithoutRestrictionsNestedInput
  }

  export type SpellRestrictionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    indoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    outdoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    noSafeRooms?: BoolFieldUpdateOperationsInput | boolean
    noTeleportFlagsMask?: NullableIntFieldUpdateOperationsInput | number | null
    terrainMask?: NullableIntFieldUpdateOperationsInput | number | null
    disallowStatesMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellRestrictionCreateManyInput = {
    id?: number
    spellId: number
    indoorsOnly?: boolean
    outdoorsOnly?: boolean
    noSafeRooms?: boolean
    noTeleportFlagsMask?: number | null
    terrainMask?: number | null
    disallowStatesMask?: number | null
  }

  export type SpellRestrictionUpdateManyMutationInput = {
    indoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    outdoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    noSafeRooms?: BoolFieldUpdateOperationsInput | boolean
    noTeleportFlagsMask?: NullableIntFieldUpdateOperationsInput | number | null
    terrainMask?: NullableIntFieldUpdateOperationsInput | number | null
    disallowStatesMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellRestrictionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    indoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    outdoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    noSafeRooms?: BoolFieldUpdateOperationsInput | boolean
    noTeleportFlagsMask?: NullableIntFieldUpdateOperationsInput | number | null
    terrainMask?: NullableIntFieldUpdateOperationsInput | number | null
    disallowStatesMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellEffectCreateInput = {
    effectType: $Enums.EffectType
    order?: number
    chancePct?: number
    trigger?: $Enums.EffectTrigger | null
    durationFormula?: string | null
    stackingRule?: $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params: JsonNullValueInput | InputJsonValue
    spell: SpellCreateNestedOneWithoutEffectsInput
  }

  export type SpellEffectUncheckedCreateInput = {
    id?: number
    spellId: number
    effectType: $Enums.EffectType
    order?: number
    chancePct?: number
    trigger?: $Enums.EffectTrigger | null
    durationFormula?: string | null
    stackingRule?: $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params: JsonNullValueInput | InputJsonValue
  }

  export type SpellEffectUpdateInput = {
    effectType?: EnumEffectTypeFieldUpdateOperationsInput | $Enums.EffectType
    order?: IntFieldUpdateOperationsInput | number
    chancePct?: IntFieldUpdateOperationsInput | number
    trigger?: NullableEnumEffectTriggerFieldUpdateOperationsInput | $Enums.EffectTrigger | null
    durationFormula?: NullableStringFieldUpdateOperationsInput | string | null
    stackingRule?: EnumStackingRuleFieldUpdateOperationsInput | $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params?: JsonNullValueInput | InputJsonValue
    spell?: SpellUpdateOneRequiredWithoutEffectsNestedInput
  }

  export type SpellEffectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    effectType?: EnumEffectTypeFieldUpdateOperationsInput | $Enums.EffectType
    order?: IntFieldUpdateOperationsInput | number
    chancePct?: IntFieldUpdateOperationsInput | number
    trigger?: NullableEnumEffectTriggerFieldUpdateOperationsInput | $Enums.EffectTrigger | null
    durationFormula?: NullableStringFieldUpdateOperationsInput | string | null
    stackingRule?: EnumStackingRuleFieldUpdateOperationsInput | $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params?: JsonNullValueInput | InputJsonValue
  }

  export type SpellEffectCreateManyInput = {
    id?: number
    spellId: number
    effectType: $Enums.EffectType
    order?: number
    chancePct?: number
    trigger?: $Enums.EffectTrigger | null
    durationFormula?: string | null
    stackingRule?: $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params: JsonNullValueInput | InputJsonValue
  }

  export type SpellEffectUpdateManyMutationInput = {
    effectType?: EnumEffectTypeFieldUpdateOperationsInput | $Enums.EffectType
    order?: IntFieldUpdateOperationsInput | number
    chancePct?: IntFieldUpdateOperationsInput | number
    trigger?: NullableEnumEffectTriggerFieldUpdateOperationsInput | $Enums.EffectTrigger | null
    durationFormula?: NullableStringFieldUpdateOperationsInput | string | null
    stackingRule?: EnumStackingRuleFieldUpdateOperationsInput | $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params?: JsonNullValueInput | InputJsonValue
  }

  export type SpellEffectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    effectType?: EnumEffectTypeFieldUpdateOperationsInput | $Enums.EffectType
    order?: IntFieldUpdateOperationsInput | number
    chancePct?: IntFieldUpdateOperationsInput | number
    trigger?: NullableEnumEffectTriggerFieldUpdateOperationsInput | $Enums.EffectTrigger | null
    durationFormula?: NullableStringFieldUpdateOperationsInput | string | null
    stackingRule?: EnumStackingRuleFieldUpdateOperationsInput | $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params?: JsonNullValueInput | InputJsonValue
  }

  export type SkillCreateInput = {
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSkills?: CharacterSkillCreateNestedManyWithoutSkillInput
    classSkills?: ClassSkillCreateNestedManyWithoutSkillInput
    mobSkills?: MobSkillCreateNestedManyWithoutSkillInput
    raceSkills?: RaceSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutSkillInput
    classSkills?: ClassSkillUncheckedCreateNestedManyWithoutSkillInput
    mobSkills?: MobSkillUncheckedCreateNestedManyWithoutSkillInput
    raceSkills?: RaceSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSkills?: CharacterSkillUpdateManyWithoutSkillNestedInput
    classSkills?: ClassSkillUpdateManyWithoutSkillNestedInput
    mobSkills?: MobSkillUpdateManyWithoutSkillNestedInput
    raceSkills?: RaceSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutSkillNestedInput
    classSkills?: ClassSkillUncheckedUpdateManyWithoutSkillNestedInput
    mobSkills?: MobSkillUncheckedUpdateManyWithoutSkillNestedInput
    raceSkills?: RaceSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSkillCreateInput = {
    category?: $Enums.SkillCategory
    minLevel?: number
    maxLevel?: number
    gameClass: GameClassCreateNestedOneWithoutSkillAccessInput
    skill: SkillCreateNestedOneWithoutClassSkillsInput
  }

  export type ClassSkillUncheckedCreateInput = {
    id?: number
    classId: number
    skillId: number
    category?: $Enums.SkillCategory
    minLevel?: number
    maxLevel?: number
  }

  export type ClassSkillUpdateInput = {
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    gameClass?: GameClassUpdateOneRequiredWithoutSkillAccessNestedInput
    skill?: SkillUpdateOneRequiredWithoutClassSkillsNestedInput
  }

  export type ClassSkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillCreateManyInput = {
    id?: number
    classId: number
    skillId: number
    category?: $Enums.SkillCategory
    minLevel?: number
    maxLevel?: number
  }

  export type ClassSkillUpdateManyMutationInput = {
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
  }

  export type RaceSkillCreateInput = {
    race: $Enums.Race
    category?: $Enums.SkillCategory
    bonus?: number
    skill: SkillCreateNestedOneWithoutRaceSkillsInput
  }

  export type RaceSkillUncheckedCreateInput = {
    id?: number
    race: $Enums.Race
    skillId: number
    category?: $Enums.SkillCategory
    bonus?: number
  }

  export type RaceSkillUpdateInput = {
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    bonus?: IntFieldUpdateOperationsInput | number
    skill?: SkillUpdateOneRequiredWithoutRaceSkillsNestedInput
  }

  export type RaceSkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    skillId?: IntFieldUpdateOperationsInput | number
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    bonus?: IntFieldUpdateOperationsInput | number
  }

  export type RaceSkillCreateManyInput = {
    id?: number
    race: $Enums.Race
    skillId: number
    category?: $Enums.SkillCategory
    bonus?: number
  }

  export type RaceSkillUpdateManyMutationInput = {
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    bonus?: IntFieldUpdateOperationsInput | number
  }

  export type RaceSkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    skillId?: IntFieldUpdateOperationsInput | number
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    bonus?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterSkillCreateInput = {
    id?: string
    level?: number
    experience?: number
    lastUsed?: Date | string | null
    character: CharacterCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutCharacterSkillsInput
  }

  export type CharacterSkillUncheckedCreateInput = {
    id?: string
    characterId: string
    skillId: number
    level?: number
    experience?: number
    lastUsed?: Date | string | null
  }

  export type CharacterSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    character?: CharacterUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutCharacterSkillsNestedInput
  }

  export type CharacterSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterSkillCreateManyInput = {
    id?: string
    characterId: string
    skillId: number
    level?: number
    experience?: number
    lastUsed?: Date | string | null
  }

  export type CharacterSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterSpellCreateInput = {
    id?: string
    known?: boolean
    proficiency?: number
    lastCast?: Date | string | null
    character: CharacterCreateNestedOneWithoutSpellsInput
    spell: SpellCreateNestedOneWithoutCharacterSpellsInput
  }

  export type CharacterSpellUncheckedCreateInput = {
    id?: string
    characterId: string
    spellId: number
    known?: boolean
    proficiency?: number
    lastCast?: Date | string | null
  }

  export type CharacterSpellUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    known?: BoolFieldUpdateOperationsInput | boolean
    proficiency?: IntFieldUpdateOperationsInput | number
    lastCast?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    character?: CharacterUpdateOneRequiredWithoutSpellsNestedInput
    spell?: SpellUpdateOneRequiredWithoutCharacterSpellsNestedInput
  }

  export type CharacterSpellUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    spellId?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
    proficiency?: IntFieldUpdateOperationsInput | number
    lastCast?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterSpellCreateManyInput = {
    id?: string
    characterId: string
    spellId: number
    known?: boolean
    proficiency?: number
    lastCast?: Date | string | null
  }

  export type CharacterSpellUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    known?: BoolFieldUpdateOperationsInput | boolean
    proficiency?: IntFieldUpdateOperationsInput | number
    lastCast?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterSpellUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    spellId?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
    proficiency?: IntFieldUpdateOperationsInput | number
    lastCast?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeLogCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    description?: string | null
    user: UserCreateNestedOneWithoutChangeLogsInput
  }

  export type ChangeLogUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes?: JsonNullValueInput | InputJsonValue
    userId: string
    timestamp?: Date | string
    description?: string | null
  }

  export type ChangeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutChangeLogsNestedInput
  }

  export type ChangeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeLogCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes?: JsonNullValueInput | InputJsonValue
    userId: string
    timestamp?: Date | string
    description?: string | null
  }

  export type ChangeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BanRecordCreateInput = {
    id?: string
    reason: string
    bannedAt?: Date | string
    expiresAt?: Date | string | null
    unbannedAt?: Date | string | null
    unbannedBy?: string | null
    active?: boolean
    admin: UserCreateNestedOneWithoutIssuedBansInput
    user: UserCreateNestedOneWithoutBanRecordsInput
  }

  export type BanRecordUncheckedCreateInput = {
    id?: string
    userId: string
    bannedBy: string
    reason: string
    bannedAt?: Date | string
    expiresAt?: Date | string | null
    unbannedAt?: Date | string | null
    unbannedBy?: string | null
    active?: boolean
  }

  export type BanRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    bannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    admin?: UserUpdateOneRequiredWithoutIssuedBansNestedInput
    user?: UserUpdateOneRequiredWithoutBanRecordsNestedInput
  }

  export type BanRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bannedBy?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    bannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BanRecordCreateManyInput = {
    id?: string
    userId: string
    bannedBy: string
    reason: string
    bannedAt?: Date | string
    expiresAt?: Date | string | null
    unbannedAt?: Date | string | null
    unbannedBy?: string | null
    active?: boolean
  }

  export type BanRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    bannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BanRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bannedBy?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    bannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CharacterItemCreateInput = {
    id?: string
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    character: CharacterCreateNestedOneWithoutItemsInput
    container?: CharacterItemCreateNestedOneWithoutContainedItemsInput
    containedItems?: CharacterItemCreateNestedManyWithoutContainerInput
    object: ObjectCreateNestedOneWithoutCharacterItemsInput
  }

  export type CharacterItemUncheckedCreateInput = {
    id?: string
    characterId: string
    object_zone_id: number
    object_id: number
    containerId?: string | null
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    containedItems?: CharacterItemUncheckedCreateNestedManyWithoutContainerInput
  }

  export type CharacterItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutItemsNestedInput
    container?: CharacterItemUpdateOneWithoutContainedItemsNestedInput
    containedItems?: CharacterItemUpdateManyWithoutContainerNestedInput
    object?: ObjectUpdateOneRequiredWithoutCharacterItemsNestedInput
  }

  export type CharacterItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    object_zone_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containedItems?: CharacterItemUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type CharacterItemCreateManyInput = {
    id?: string
    characterId: string
    object_zone_id: number
    object_id: number
    containerId?: string | null
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    object_zone_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterEffectCreateInput = {
    id?: string
    effectName: string
    effectType?: string | null
    duration?: number | null
    strength?: number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: string | null
    sourceId?: number | null
    appliedAt?: Date | string
    expiresAt?: Date | string | null
    character: CharacterCreateNestedOneWithoutEffectsInput
  }

  export type CharacterEffectUncheckedCreateInput = {
    id?: string
    characterId: string
    effectName: string
    effectType?: string | null
    duration?: number | null
    strength?: number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: string | null
    sourceId?: number | null
    appliedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CharacterEffectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    effectName?: StringFieldUpdateOperationsInput | string
    effectType?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: IntFieldUpdateOperationsInput | number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    character?: CharacterUpdateOneRequiredWithoutEffectsNestedInput
  }

  export type CharacterEffectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    effectName?: StringFieldUpdateOperationsInput | string
    effectType?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: IntFieldUpdateOperationsInput | number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterEffectCreateManyInput = {
    id?: string
    characterId: string
    effectName: string
    effectType?: string | null
    duration?: number | null
    strength?: number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: string | null
    sourceId?: number | null
    appliedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CharacterEffectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    effectName?: StringFieldUpdateOperationsInput | string
    effectType?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: IntFieldUpdateOperationsInput | number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterEffectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    effectName?: StringFieldUpdateOperationsInput | string
    effectType?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: IntFieldUpdateOperationsInput | number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EquipmentSetItemCreateInput = {
    id: string
    slot?: string | null
    quantity?: number
    probability?: number
    equipmentSet: EquipmentSetCreateNestedOneWithoutItemsInput
    object: ObjectCreateNestedOneWithoutEquipmentSetItemsInput
  }

  export type EquipmentSetItemUncheckedCreateInput = {
    id: string
    equipmentSetId: string
    objectZoneId: number
    objectId: number
    slot?: string | null
    quantity?: number
    probability?: number
  }

  export type EquipmentSetItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    equipmentSet?: EquipmentSetUpdateOneRequiredWithoutItemsNestedInput
    object?: ObjectUpdateOneRequiredWithoutEquipmentSetItemsNestedInput
  }

  export type EquipmentSetItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentSetId?: StringFieldUpdateOperationsInput | string
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentSetItemCreateManyInput = {
    id: string
    equipmentSetId: string
    objectZoneId: number
    objectId: number
    slot?: string | null
    quantity?: number
    probability?: number
  }

  export type EquipmentSetItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentSetItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentSetId?: StringFieldUpdateOperationsInput | string
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentSetCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    items?: EquipmentSetItemCreateNestedManyWithoutEquipmentSetInput
    mobEquipmentSets?: MobEquipmentSetCreateNestedManyWithoutEquipmentSetInput
  }

  export type EquipmentSetUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    items?: EquipmentSetItemUncheckedCreateNestedManyWithoutEquipmentSetInput
    mobEquipmentSets?: MobEquipmentSetUncheckedCreateNestedManyWithoutEquipmentSetInput
  }

  export type EquipmentSetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: EquipmentSetItemUpdateManyWithoutEquipmentSetNestedInput
    mobEquipmentSets?: MobEquipmentSetUpdateManyWithoutEquipmentSetNestedInput
  }

  export type EquipmentSetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: EquipmentSetItemUncheckedUpdateManyWithoutEquipmentSetNestedInput
    mobEquipmentSets?: MobEquipmentSetUncheckedUpdateManyWithoutEquipmentSetNestedInput
  }

  export type EquipmentSetCreateManyInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type EquipmentSetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentSetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MobEquipmentSetCreateInput = {
    id: string
    probability?: number
    equipmentSet: EquipmentSetCreateNestedOneWithoutMobEquipmentSetsInput
    mobReset: MobResetCreateNestedOneWithoutEquipmentSetsInput
  }

  export type MobEquipmentSetUncheckedCreateInput = {
    id: string
    mobResetId: string
    equipmentSetId: string
    probability?: number
  }

  export type MobEquipmentSetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
    equipmentSet?: EquipmentSetUpdateOneRequiredWithoutMobEquipmentSetsNestedInput
    mobReset?: MobResetUpdateOneRequiredWithoutEquipmentSetsNestedInput
  }

  export type MobEquipmentSetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobResetId?: StringFieldUpdateOperationsInput | string
    equipmentSetId?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobEquipmentSetCreateManyInput = {
    id: string
    mobResetId: string
    equipmentSetId: string
    probability?: number
  }

  export type MobEquipmentSetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobEquipmentSetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobResetId?: StringFieldUpdateOperationsInput | string
    equipmentSetId?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectResetCreateInput = {
    id: string
    max?: number
    name?: string | null
    probability?: number
    object: ObjectCreateNestedOneWithoutResetsInput
    room: RoomCreateNestedOneWithoutObjectResetsInput
    zone: ZoneCreateNestedOneWithoutObjectResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutObjectResetInput
  }

  export type ObjectResetUncheckedCreateInput = {
    id: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutObjectResetInput
  }

  export type ObjectResetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    object?: ObjectUpdateOneRequiredWithoutResetsNestedInput
    room?: RoomUpdateOneRequiredWithoutObjectResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutObjectResetNestedInput
  }

  export type ObjectResetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutObjectResetNestedInput
  }

  export type ObjectResetCreateManyInput = {
    id: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
  }

  export type ObjectResetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectResetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type SpawnConditionCreateInput = {
    id: string
    type: string
    parameters?: JsonNullValueInput | InputJsonValue
    mobReset?: MobResetCreateNestedOneWithoutSpawnConditionsInput
    objectReset?: ObjectResetCreateNestedOneWithoutSpawnConditionsInput
  }

  export type SpawnConditionUncheckedCreateInput = {
    id: string
    type: string
    parameters?: JsonNullValueInput | InputJsonValue
    mobResetId?: string | null
    objectResetId?: string | null
  }

  export type SpawnConditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    mobReset?: MobResetUpdateOneWithoutSpawnConditionsNestedInput
    objectReset?: ObjectResetUpdateOneWithoutSpawnConditionsNestedInput
  }

  export type SpawnConditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    mobResetId?: NullableStringFieldUpdateOperationsInput | string | null
    objectResetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpawnConditionCreateManyInput = {
    id: string
    type: string
    parameters?: JsonNullValueInput | InputJsonValue
    mobResetId?: string | null
    objectResetId?: string | null
  }

  export type SpawnConditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
  }

  export type SpawnConditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    mobResetId?: NullableStringFieldUpdateOperationsInput | string | null
    objectResetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type BanRecordListRelationFilter = {
    every?: BanRecordWhereInput
    some?: BanRecordWhereInput
    none?: BanRecordWhereInput
  }

  export type ChangeLogListRelationFilter = {
    every?: ChangeLogWhereInput
    some?: ChangeLogWhereInput
    none?: ChangeLogWhereInput
  }

  export type CharacterListRelationFilter = {
    every?: CharacterWhereInput
    some?: CharacterWhereInput
    none?: CharacterWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BanRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    lastFailedLogin?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    lastFailedLogin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    lastFailedLogin?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumRaceFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    not?: NestedEnumRaceFilter<$PrismaModel> | $Enums.Race
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CharacterEffectListRelationFilter = {
    every?: CharacterEffectWhereInput
    some?: CharacterEffectWhereInput
    none?: CharacterEffectWhereInput
  }

  export type CharacterItemListRelationFilter = {
    every?: CharacterItemWhereInput
    some?: CharacterItemWhereInput
    none?: CharacterItemWhereInput
  }

  export type CharacterSkillListRelationFilter = {
    every?: CharacterSkillWhereInput
    some?: CharacterSkillWhereInput
    none?: CharacterSkillWhereInput
  }

  export type CharacterSpellListRelationFilter = {
    every?: CharacterSpellWhereInput
    some?: CharacterSpellWhereInput
    none?: CharacterSpellWhereInput
  }

  export type GameClassNullableRelationFilter = {
    is?: GameClassWhereInput | null
    isNot?: GameClassWhereInput | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CharacterEffectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterSpellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    alignment?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    luck?: SortOrder
    hitPoints?: SortOrder
    movement?: SortOrder
    hitPointsMax?: SortOrder
    movementMax?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    bankCopper?: SortOrder
    bankSilver?: SortOrder
    bankGold?: SortOrder
    bankPlatinum?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    passwordHash?: SortOrder
    raceType?: SortOrder
    race?: SortOrder
    gender?: SortOrder
    playerClass?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    baseSize?: SortOrder
    currentSize?: SortOrder
    hitRoll?: SortOrder
    damageRoll?: SortOrder
    armorClass?: SortOrder
    currentRoom?: SortOrder
    saveRoom?: SortOrder
    homeRoom?: SortOrder
    lastLogin?: SortOrder
    timePlayed?: SortOrder
    isOnline?: SortOrder
    hunger?: SortOrder
    thirst?: SortOrder
    description?: SortOrder
    title?: SortOrder
    prompt?: SortOrder
    pageLength?: SortOrder
    playerFlags?: SortOrder
    effectFlags?: SortOrder
    privilegeFlags?: SortOrder
    olcZones?: SortOrder
    invisLevel?: SortOrder
    birthTime?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classId?: SortOrder
    experience?: SortOrder
    skillPoints?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    level?: SortOrder
    alignment?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    luck?: SortOrder
    hitPoints?: SortOrder
    movement?: SortOrder
    hitPointsMax?: SortOrder
    movementMax?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    bankCopper?: SortOrder
    bankSilver?: SortOrder
    bankGold?: SortOrder
    bankPlatinum?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    baseSize?: SortOrder
    currentSize?: SortOrder
    hitRoll?: SortOrder
    damageRoll?: SortOrder
    armorClass?: SortOrder
    currentRoom?: SortOrder
    saveRoom?: SortOrder
    homeRoom?: SortOrder
    timePlayed?: SortOrder
    hunger?: SortOrder
    thirst?: SortOrder
    pageLength?: SortOrder
    olcZones?: SortOrder
    invisLevel?: SortOrder
    classId?: SortOrder
    experience?: SortOrder
    skillPoints?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    alignment?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    luck?: SortOrder
    hitPoints?: SortOrder
    movement?: SortOrder
    hitPointsMax?: SortOrder
    movementMax?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    bankCopper?: SortOrder
    bankSilver?: SortOrder
    bankGold?: SortOrder
    bankPlatinum?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    passwordHash?: SortOrder
    raceType?: SortOrder
    race?: SortOrder
    gender?: SortOrder
    playerClass?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    baseSize?: SortOrder
    currentSize?: SortOrder
    hitRoll?: SortOrder
    damageRoll?: SortOrder
    armorClass?: SortOrder
    currentRoom?: SortOrder
    saveRoom?: SortOrder
    homeRoom?: SortOrder
    lastLogin?: SortOrder
    timePlayed?: SortOrder
    isOnline?: SortOrder
    hunger?: SortOrder
    thirst?: SortOrder
    description?: SortOrder
    title?: SortOrder
    prompt?: SortOrder
    pageLength?: SortOrder
    invisLevel?: SortOrder
    birthTime?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classId?: SortOrder
    experience?: SortOrder
    skillPoints?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    alignment?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    luck?: SortOrder
    hitPoints?: SortOrder
    movement?: SortOrder
    hitPointsMax?: SortOrder
    movementMax?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    bankCopper?: SortOrder
    bankSilver?: SortOrder
    bankGold?: SortOrder
    bankPlatinum?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    passwordHash?: SortOrder
    raceType?: SortOrder
    race?: SortOrder
    gender?: SortOrder
    playerClass?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    baseSize?: SortOrder
    currentSize?: SortOrder
    hitRoll?: SortOrder
    damageRoll?: SortOrder
    armorClass?: SortOrder
    currentRoom?: SortOrder
    saveRoom?: SortOrder
    homeRoom?: SortOrder
    lastLogin?: SortOrder
    timePlayed?: SortOrder
    isOnline?: SortOrder
    hunger?: SortOrder
    thirst?: SortOrder
    description?: SortOrder
    title?: SortOrder
    prompt?: SortOrder
    pageLength?: SortOrder
    invisLevel?: SortOrder
    birthTime?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classId?: SortOrder
    experience?: SortOrder
    skillPoints?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    level?: SortOrder
    alignment?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    luck?: SortOrder
    hitPoints?: SortOrder
    movement?: SortOrder
    hitPointsMax?: SortOrder
    movementMax?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    bankCopper?: SortOrder
    bankSilver?: SortOrder
    bankGold?: SortOrder
    bankPlatinum?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    baseSize?: SortOrder
    currentSize?: SortOrder
    hitRoll?: SortOrder
    damageRoll?: SortOrder
    armorClass?: SortOrder
    currentRoom?: SortOrder
    saveRoom?: SortOrder
    homeRoom?: SortOrder
    timePlayed?: SortOrder
    hunger?: SortOrder
    thirst?: SortOrder
    pageLength?: SortOrder
    olcZones?: SortOrder
    invisLevel?: SortOrder
    classId?: SortOrder
    experience?: SortOrder
    skillPoints?: SortOrder
  }

  export type EnumRaceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    not?: NestedEnumRaceWithAggregatesFilter<$PrismaModel> | $Enums.Race
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRaceFilter<$PrismaModel>
    _max?: NestedEnumRaceFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumResetModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResetMode | EnumResetModeFieldRefInput<$PrismaModel>
    in?: $Enums.ResetMode[] | ListEnumResetModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResetMode[] | ListEnumResetModeFieldRefInput<$PrismaModel>
    not?: NestedEnumResetModeFilter<$PrismaModel> | $Enums.ResetMode
  }

  export type EnumHemisphereFilter<$PrismaModel = never> = {
    equals?: $Enums.Hemisphere | EnumHemisphereFieldRefInput<$PrismaModel>
    in?: $Enums.Hemisphere[] | ListEnumHemisphereFieldRefInput<$PrismaModel>
    notIn?: $Enums.Hemisphere[] | ListEnumHemisphereFieldRefInput<$PrismaModel>
    not?: NestedEnumHemisphereFilter<$PrismaModel> | $Enums.Hemisphere
  }

  export type EnumClimateFilter<$PrismaModel = never> = {
    equals?: $Enums.Climate | EnumClimateFieldRefInput<$PrismaModel>
    in?: $Enums.Climate[] | ListEnumClimateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Climate[] | ListEnumClimateFieldRefInput<$PrismaModel>
    not?: NestedEnumClimateFilter<$PrismaModel> | $Enums.Climate
  }

  export type MobResetListRelationFilter = {
    every?: MobResetWhereInput
    some?: MobResetWhereInput
    none?: MobResetWhereInput
  }

  export type MobListRelationFilter = {
    every?: MobWhereInput
    some?: MobWhereInput
    none?: MobWhereInput
  }

  export type ObjectResetListRelationFilter = {
    every?: ObjectResetWhereInput
    some?: ObjectResetWhereInput
    none?: ObjectResetWhereInput
  }

  export type ObjectListRelationFilter = {
    every?: ObjectWhereInput
    some?: ObjectWhereInput
    none?: ObjectWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type ShopListRelationFilter = {
    every?: ShopWhereInput
    some?: ShopWhereInput
    none?: ShopWhereInput
  }

  export type TriggerListRelationFilter = {
    every?: TriggerWhereInput
    some?: TriggerWhereInput
    none?: TriggerWhereInput
  }

  export type MobResetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectResetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TriggerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lifespan?: SortOrder
    resetMode?: SortOrder
    hemisphere?: SortOrder
    climate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ZoneAvgOrderByAggregateInput = {
    id?: SortOrder
    lifespan?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lifespan?: SortOrder
    resetMode?: SortOrder
    hemisphere?: SortOrder
    climate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lifespan?: SortOrder
    resetMode?: SortOrder
    hemisphere?: SortOrder
    climate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ZoneSumOrderByAggregateInput = {
    id?: SortOrder
    lifespan?: SortOrder
  }

  export type EnumResetModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResetMode | EnumResetModeFieldRefInput<$PrismaModel>
    in?: $Enums.ResetMode[] | ListEnumResetModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResetMode[] | ListEnumResetModeFieldRefInput<$PrismaModel>
    not?: NestedEnumResetModeWithAggregatesFilter<$PrismaModel> | $Enums.ResetMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResetModeFilter<$PrismaModel>
    _max?: NestedEnumResetModeFilter<$PrismaModel>
  }

  export type EnumHemisphereWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Hemisphere | EnumHemisphereFieldRefInput<$PrismaModel>
    in?: $Enums.Hemisphere[] | ListEnumHemisphereFieldRefInput<$PrismaModel>
    notIn?: $Enums.Hemisphere[] | ListEnumHemisphereFieldRefInput<$PrismaModel>
    not?: NestedEnumHemisphereWithAggregatesFilter<$PrismaModel> | $Enums.Hemisphere
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHemisphereFilter<$PrismaModel>
    _max?: NestedEnumHemisphereFilter<$PrismaModel>
  }

  export type EnumClimateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Climate | EnumClimateFieldRefInput<$PrismaModel>
    in?: $Enums.Climate[] | ListEnumClimateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Climate[] | ListEnumClimateFieldRefInput<$PrismaModel>
    not?: NestedEnumClimateWithAggregatesFilter<$PrismaModel> | $Enums.Climate
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClimateFilter<$PrismaModel>
    _max?: NestedEnumClimateFilter<$PrismaModel>
  }

  export type EnumSectorFilter<$PrismaModel = never> = {
    equals?: $Enums.Sector | EnumSectorFieldRefInput<$PrismaModel>
    in?: $Enums.Sector[] | ListEnumSectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sector[] | ListEnumSectorFieldRefInput<$PrismaModel>
    not?: NestedEnumSectorFilter<$PrismaModel> | $Enums.Sector
  }

  export type EnumRoomFlagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomFlag[] | ListEnumRoomFlagFieldRefInput<$PrismaModel> | null
    has?: $Enums.RoomFlag | EnumRoomFlagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.RoomFlag[] | ListEnumRoomFlagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.RoomFlag[] | ListEnumRoomFlagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type RoomExitListRelationFilter = {
    every?: RoomExitWhereInput
    some?: RoomExitWhereInput
    none?: RoomExitWhereInput
  }

  export type RoomExtraDescriptionListRelationFilter = {
    every?: RoomExtraDescriptionWhereInput
    some?: RoomExtraDescriptionWhereInput
    none?: RoomExtraDescriptionWhereInput
  }

  export type ZoneRelationFilter = {
    is?: ZoneWhereInput
    isNot?: ZoneWhereInput
  }

  export type RoomExitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomExtraDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomZoneIdIdCompoundUniqueInput = {
    zoneId: number
    id: number
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sector?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    flags?: SortOrder
    layoutX?: SortOrder
    layoutY?: SortOrder
    layoutZ?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    layoutX?: SortOrder
    layoutY?: SortOrder
    layoutZ?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sector?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    layoutX?: SortOrder
    layoutY?: SortOrder
    layoutZ?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sector?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    layoutX?: SortOrder
    layoutY?: SortOrder
    layoutZ?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    layoutX?: SortOrder
    layoutY?: SortOrder
    layoutZ?: SortOrder
  }

  export type EnumSectorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sector | EnumSectorFieldRefInput<$PrismaModel>
    in?: $Enums.Sector[] | ListEnumSectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sector[] | ListEnumSectorFieldRefInput<$PrismaModel>
    not?: NestedEnumSectorWithAggregatesFilter<$PrismaModel> | $Enums.Sector
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSectorFilter<$PrismaModel>
    _max?: NestedEnumSectorFilter<$PrismaModel>
  }

  export type EnumDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionFilter<$PrismaModel> | $Enums.Direction
  }

  export type EnumExitFlagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ExitFlag[] | ListEnumExitFlagFieldRefInput<$PrismaModel> | null
    has?: $Enums.ExitFlag | EnumExitFlagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ExitFlag[] | ListEnumExitFlagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ExitFlag[] | ListEnumExitFlagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type RoomExitRoomZoneIdRoomIdDirectionCompoundUniqueInput = {
    roomZoneId: number
    roomId: number
    direction: $Enums.Direction
  }

  export type RoomExitCountOrderByAggregateInput = {
    id?: SortOrder
    direction?: SortOrder
    description?: SortOrder
    keyword?: SortOrder
    key?: SortOrder
    destination?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    flags?: SortOrder
  }

  export type RoomExitAvgOrderByAggregateInput = {
    destination?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
  }

  export type RoomExitMaxOrderByAggregateInput = {
    id?: SortOrder
    direction?: SortOrder
    description?: SortOrder
    keyword?: SortOrder
    key?: SortOrder
    destination?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
  }

  export type RoomExitMinOrderByAggregateInput = {
    id?: SortOrder
    direction?: SortOrder
    description?: SortOrder
    keyword?: SortOrder
    key?: SortOrder
    destination?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
  }

  export type RoomExitSumOrderByAggregateInput = {
    destination?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
  }

  export type EnumDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionWithAggregatesFilter<$PrismaModel> | $Enums.Direction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectionFilter<$PrismaModel>
    _max?: NestedEnumDirectionFilter<$PrismaModel>
  }

  export type RoomExtraDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
  }

  export type RoomExtraDescriptionAvgOrderByAggregateInput = {
    roomZoneId?: SortOrder
    roomId?: SortOrder
  }

  export type RoomExtraDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
  }

  export type RoomExtraDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
  }

  export type RoomExtraDescriptionSumOrderByAggregateInput = {
    roomZoneId?: SortOrder
    roomId?: SortOrder
  }

  export type EnumMobFlagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.MobFlag[] | ListEnumMobFlagFieldRefInput<$PrismaModel> | null
    has?: $Enums.MobFlag | EnumMobFlagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.MobFlag[] | ListEnumMobFlagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.MobFlag[] | ListEnumMobFlagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumEffectFlagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.EffectFlag[] | ListEnumEffectFlagFieldRefInput<$PrismaModel> | null
    has?: $Enums.EffectFlag | EnumEffectFlagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.EffectFlag[] | ListEnumEffectFlagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.EffectFlag[] | ListEnumEffectFlagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionFilter<$PrismaModel> | $Enums.Position
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type EnumSizeFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel>
    in?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumSizeFilter<$PrismaModel> | $Enums.Size
  }

  export type EnumLifeForceFilter<$PrismaModel = never> = {
    equals?: $Enums.LifeForce | EnumLifeForceFieldRefInput<$PrismaModel>
    in?: $Enums.LifeForce[] | ListEnumLifeForceFieldRefInput<$PrismaModel>
    notIn?: $Enums.LifeForce[] | ListEnumLifeForceFieldRefInput<$PrismaModel>
    not?: NestedEnumLifeForceFilter<$PrismaModel> | $Enums.LifeForce
  }

  export type EnumCompositionFilter<$PrismaModel = never> = {
    equals?: $Enums.Composition | EnumCompositionFieldRefInput<$PrismaModel>
    in?: $Enums.Composition[] | ListEnumCompositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Composition[] | ListEnumCompositionFieldRefInput<$PrismaModel>
    not?: NestedEnumCompositionFilter<$PrismaModel> | $Enums.Composition
  }

  export type EnumStanceFilter<$PrismaModel = never> = {
    equals?: $Enums.Stance | EnumStanceFieldRefInput<$PrismaModel>
    in?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStanceFilter<$PrismaModel> | $Enums.Stance
  }

  export type EnumDamageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDamageTypeFilter<$PrismaModel> | $Enums.DamageType
  }

  export type MobSkillListRelationFilter = {
    every?: MobSkillWhereInput
    some?: MobSkillWhereInput
    none?: MobSkillWhereInput
  }

  export type MobSpellListRelationFilter = {
    every?: MobSpellWhereInput
    some?: MobSpellWhereInput
    none?: MobSpellWhereInput
  }

  export type MobSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MobSpellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MobZoneIdIdCompoundUniqueInput = {
    zoneId: number
    id: number
  }

  export type MobCountOrderByAggregateInput = {
    id?: SortOrder
    keywords?: SortOrder
    mobClass?: SortOrder
    shortDesc?: SortOrder
    longDesc?: SortOrder
    desc?: SortOrder
    alignment?: SortOrder
    level?: SortOrder
    armorClass?: SortOrder
    hitRoll?: SortOrder
    move?: SortOrder
    hpDiceNum?: SortOrder
    hpDiceSize?: SortOrder
    hpDiceBonus?: SortOrder
    damageDiceNum?: SortOrder
    damageDiceSize?: SortOrder
    damageDiceBonus?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    raceAlign?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    estimated_hp?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    perception?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    classId?: SortOrder
    race?: SortOrder
    mobFlags?: SortOrder
    effectFlags?: SortOrder
    position?: SortOrder
    defaultPosition?: SortOrder
    gender?: SortOrder
    size?: SortOrder
    lifeForce?: SortOrder
    composition?: SortOrder
    stance?: SortOrder
    damageType?: SortOrder
  }

  export type MobAvgOrderByAggregateInput = {
    id?: SortOrder
    alignment?: SortOrder
    level?: SortOrder
    armorClass?: SortOrder
    hitRoll?: SortOrder
    move?: SortOrder
    hpDiceNum?: SortOrder
    hpDiceSize?: SortOrder
    hpDiceBonus?: SortOrder
    damageDiceNum?: SortOrder
    damageDiceSize?: SortOrder
    damageDiceBonus?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    raceAlign?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    estimated_hp?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    perception?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
    classId?: SortOrder
  }

  export type MobMaxOrderByAggregateInput = {
    id?: SortOrder
    mobClass?: SortOrder
    shortDesc?: SortOrder
    longDesc?: SortOrder
    desc?: SortOrder
    alignment?: SortOrder
    level?: SortOrder
    armorClass?: SortOrder
    hitRoll?: SortOrder
    move?: SortOrder
    hpDiceNum?: SortOrder
    hpDiceSize?: SortOrder
    hpDiceBonus?: SortOrder
    damageDiceNum?: SortOrder
    damageDiceSize?: SortOrder
    damageDiceBonus?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    raceAlign?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    estimated_hp?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    perception?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    classId?: SortOrder
    race?: SortOrder
    position?: SortOrder
    defaultPosition?: SortOrder
    gender?: SortOrder
    size?: SortOrder
    lifeForce?: SortOrder
    composition?: SortOrder
    stance?: SortOrder
    damageType?: SortOrder
  }

  export type MobMinOrderByAggregateInput = {
    id?: SortOrder
    mobClass?: SortOrder
    shortDesc?: SortOrder
    longDesc?: SortOrder
    desc?: SortOrder
    alignment?: SortOrder
    level?: SortOrder
    armorClass?: SortOrder
    hitRoll?: SortOrder
    move?: SortOrder
    hpDiceNum?: SortOrder
    hpDiceSize?: SortOrder
    hpDiceBonus?: SortOrder
    damageDiceNum?: SortOrder
    damageDiceSize?: SortOrder
    damageDiceBonus?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    raceAlign?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    estimated_hp?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    perception?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    classId?: SortOrder
    race?: SortOrder
    position?: SortOrder
    defaultPosition?: SortOrder
    gender?: SortOrder
    size?: SortOrder
    lifeForce?: SortOrder
    composition?: SortOrder
    stance?: SortOrder
    damageType?: SortOrder
  }

  export type MobSumOrderByAggregateInput = {
    id?: SortOrder
    alignment?: SortOrder
    level?: SortOrder
    armorClass?: SortOrder
    hitRoll?: SortOrder
    move?: SortOrder
    hpDiceNum?: SortOrder
    hpDiceSize?: SortOrder
    hpDiceBonus?: SortOrder
    damageDiceNum?: SortOrder
    damageDiceSize?: SortOrder
    damageDiceBonus?: SortOrder
    copper?: SortOrder
    silver?: SortOrder
    gold?: SortOrder
    platinum?: SortOrder
    raceAlign?: SortOrder
    total_wealth?: SortOrder
    average_stats?: SortOrder
    estimated_hp?: SortOrder
    strength?: SortOrder
    intelligence?: SortOrder
    wisdom?: SortOrder
    dexterity?: SortOrder
    constitution?: SortOrder
    charisma?: SortOrder
    perception?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
    classId?: SortOrder
  }

  export type EnumPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionWithAggregatesFilter<$PrismaModel> | $Enums.Position
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPositionFilter<$PrismaModel>
    _max?: NestedEnumPositionFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumSizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel>
    in?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumSizeWithAggregatesFilter<$PrismaModel> | $Enums.Size
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSizeFilter<$PrismaModel>
    _max?: NestedEnumSizeFilter<$PrismaModel>
  }

  export type EnumLifeForceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LifeForce | EnumLifeForceFieldRefInput<$PrismaModel>
    in?: $Enums.LifeForce[] | ListEnumLifeForceFieldRefInput<$PrismaModel>
    notIn?: $Enums.LifeForce[] | ListEnumLifeForceFieldRefInput<$PrismaModel>
    not?: NestedEnumLifeForceWithAggregatesFilter<$PrismaModel> | $Enums.LifeForce
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLifeForceFilter<$PrismaModel>
    _max?: NestedEnumLifeForceFilter<$PrismaModel>
  }

  export type EnumCompositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Composition | EnumCompositionFieldRefInput<$PrismaModel>
    in?: $Enums.Composition[] | ListEnumCompositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Composition[] | ListEnumCompositionFieldRefInput<$PrismaModel>
    not?: NestedEnumCompositionWithAggregatesFilter<$PrismaModel> | $Enums.Composition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompositionFilter<$PrismaModel>
    _max?: NestedEnumCompositionFilter<$PrismaModel>
  }

  export type EnumStanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Stance | EnumStanceFieldRefInput<$PrismaModel>
    in?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStanceWithAggregatesFilter<$PrismaModel> | $Enums.Stance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStanceFilter<$PrismaModel>
    _max?: NestedEnumStanceFilter<$PrismaModel>
  }

  export type EnumDamageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDamageTypeWithAggregatesFilter<$PrismaModel> | $Enums.DamageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDamageTypeFilter<$PrismaModel>
    _max?: NestedEnumDamageTypeFilter<$PrismaModel>
  }

  export type MobRelationFilter = {
    is?: MobWhereInput
    isNot?: MobWhereInput
  }

  export type SkillRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type MobSkillMobZoneIdMobIdSkillIdCompoundUniqueInput = {
    mobZoneId: number
    mobId: number
    skillId: number
  }

  export type MobSkillCountOrderByAggregateInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
  }

  export type MobSkillAvgOrderByAggregateInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
  }

  export type MobSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
  }

  export type MobSkillMinOrderByAggregateInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
  }

  export type MobSkillSumOrderByAggregateInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
  }

  export type SpellRelationFilter = {
    is?: SpellWhereInput
    isNot?: SpellWhereInput
  }

  export type MobSpellMobZoneIdMobIdSpellIdCompoundUniqueInput = {
    mobZoneId: number
    mobId: number
    spellId: number
  }

  export type MobSpellCountOrderByAggregateInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    spellId?: SortOrder
    circle?: SortOrder
    known?: SortOrder
  }

  export type MobSpellAvgOrderByAggregateInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    spellId?: SortOrder
    circle?: SortOrder
  }

  export type MobSpellMaxOrderByAggregateInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    spellId?: SortOrder
    circle?: SortOrder
    known?: SortOrder
  }

  export type MobSpellMinOrderByAggregateInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    spellId?: SortOrder
    circle?: SortOrder
    known?: SortOrder
  }

  export type MobSpellSumOrderByAggregateInput = {
    id?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    spellId?: SortOrder
    circle?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MobCarryingListRelationFilter = {
    every?: MobCarryingWhereInput
    some?: MobCarryingWhereInput
    none?: MobCarryingWhereInput
  }

  export type MobEquipmentSetListRelationFilter = {
    every?: MobEquipmentSetWhereInput
    some?: MobEquipmentSetWhereInput
    none?: MobEquipmentSetWhereInput
  }

  export type MobEquippedListRelationFilter = {
    every?: MobEquippedWhereInput
    some?: MobEquippedWhereInput
    none?: MobEquippedWhereInput
  }

  export type SpawnConditionListRelationFilter = {
    every?: SpawnConditionWhereInput
    some?: SpawnConditionWhereInput
    none?: SpawnConditionWhereInput
  }

  export type MobCarryingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MobEquipmentSetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MobEquippedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpawnConditionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MobResetCountOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
  }

  export type MobResetAvgOrderByAggregateInput = {
    max?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
  }

  export type MobResetMaxOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
  }

  export type MobResetMinOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
  }

  export type MobResetSumOrderByAggregateInput = {
    max?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ObjectRelationFilter = {
    is?: ObjectWhereInput
    isNot?: ObjectWhereInput
  }

  export type MobResetRelationFilter = {
    is?: MobResetWhereInput
    isNot?: MobResetWhereInput
  }

  export type MobCarryingCountOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    resetId?: SortOrder
  }

  export type MobCarryingAvgOrderByAggregateInput = {
    max?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type MobCarryingMaxOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    resetId?: SortOrder
  }

  export type MobCarryingMinOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    resetId?: SortOrder
  }

  export type MobCarryingSumOrderByAggregateInput = {
    max?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type MobEquippedCountOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    location?: SortOrder
    name?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    resetId?: SortOrder
  }

  export type MobEquippedAvgOrderByAggregateInput = {
    max?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type MobEquippedMaxOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    location?: SortOrder
    name?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    resetId?: SortOrder
  }

  export type MobEquippedMinOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    location?: SortOrder
    name?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    resetId?: SortOrder
  }

  export type MobEquippedSumOrderByAggregateInput = {
    max?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type EnumObjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectType | EnumObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectType[] | ListEnumObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectType[] | ListEnumObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectTypeFilter<$PrismaModel> | $Enums.ObjectType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumObjectFlagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectFlag[] | ListEnumObjectFlagFieldRefInput<$PrismaModel> | null
    has?: $Enums.ObjectFlag | EnumObjectFlagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ObjectFlag[] | ListEnumObjectFlagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ObjectFlag[] | ListEnumObjectFlagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumWearFlagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.WearFlag[] | ListEnumWearFlagFieldRefInput<$PrismaModel> | null
    has?: $Enums.WearFlag | EnumWearFlagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.WearFlag[] | ListEnumWearFlagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.WearFlag[] | ListEnumWearFlagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EquipmentSetItemListRelationFilter = {
    every?: EquipmentSetItemWhereInput
    some?: EquipmentSetItemWhereInput
    none?: EquipmentSetItemWhereInput
  }

  export type ObjectAffectListRelationFilter = {
    every?: ObjectAffectWhereInput
    some?: ObjectAffectWhereInput
    none?: ObjectAffectWhereInput
  }

  export type ObjectExtraDescriptionListRelationFilter = {
    every?: ObjectExtraDescriptionWhereInput
    some?: ObjectExtraDescriptionWhereInput
    none?: ObjectExtraDescriptionWhereInput
  }

  export type ObjectSpellListRelationFilter = {
    every?: ObjectSpellWhereInput
    some?: ObjectSpellWhereInput
    none?: ObjectSpellWhereInput
  }

  export type ShopItemListRelationFilter = {
    every?: ShopItemWhereInput
    some?: ShopItemWhereInput
    none?: ShopItemWhereInput
  }

  export type EquipmentSetItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectAffectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectExtraDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectSpellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectZoneIdIdCompoundUniqueInput = {
    zoneId: number
    id: number
  }

  export type ObjectCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    keywords?: SortOrder
    shortDesc?: SortOrder
    description?: SortOrder
    actionDesc?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    timer?: SortOrder
    decomposeTimer?: SortOrder
    level?: SortOrder
    concealment?: SortOrder
    values?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    flags?: SortOrder
    effectFlags?: SortOrder
    wearFlags?: SortOrder
  }

  export type ObjectAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    timer?: SortOrder
    decomposeTimer?: SortOrder
    level?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
  }

  export type ObjectMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    shortDesc?: SortOrder
    description?: SortOrder
    actionDesc?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    timer?: SortOrder
    decomposeTimer?: SortOrder
    level?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ObjectMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    shortDesc?: SortOrder
    description?: SortOrder
    actionDesc?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    timer?: SortOrder
    decomposeTimer?: SortOrder
    level?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ObjectSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    timer?: SortOrder
    decomposeTimer?: SortOrder
    level?: SortOrder
    concealment?: SortOrder
    zoneId?: SortOrder
  }

  export type EnumObjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectType | EnumObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectType[] | ListEnumObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectType[] | ListEnumObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.ObjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObjectTypeFilter<$PrismaModel>
    _max?: NestedEnumObjectTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ObjectExtraDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectExtraDescriptionAvgOrderByAggregateInput = {
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectExtraDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectExtraDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectExtraDescriptionSumOrderByAggregateInput = {
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectAffectCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    modifier?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectAffectAvgOrderByAggregateInput = {
    modifier?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectAffectMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    modifier?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectAffectMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    modifier?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectAffectSumOrderByAggregateInput = {
    modifier?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectSpellCountOrderByAggregateInput = {
    id?: SortOrder
    spell?: SortOrder
    level?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectSpellAvgOrderByAggregateInput = {
    level?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectSpellMaxOrderByAggregateInput = {
    id?: SortOrder
    spell?: SortOrder
    level?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectSpellMinOrderByAggregateInput = {
    id?: SortOrder
    spell?: SortOrder
    level?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ObjectSpellSumOrderByAggregateInput = {
    level?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type EnumShopFlagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopFlag[] | ListEnumShopFlagFieldRefInput<$PrismaModel> | null
    has?: $Enums.ShopFlag | EnumShopFlagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ShopFlag[] | ListEnumShopFlagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ShopFlag[] | ListEnumShopFlagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumShopTradesWithNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ShopTradesWith[] | ListEnumShopTradesWithFieldRefInput<$PrismaModel> | null
    has?: $Enums.ShopTradesWith | EnumShopTradesWithFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ShopTradesWith[] | ListEnumShopTradesWithFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ShopTradesWith[] | ListEnumShopTradesWithFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ShopAcceptListRelationFilter = {
    every?: ShopAcceptWhereInput
    some?: ShopAcceptWhereInput
    none?: ShopAcceptWhereInput
  }

  export type ShopHourListRelationFilter = {
    every?: ShopHourWhereInput
    some?: ShopHourWhereInput
    none?: ShopHourWhereInput
  }

  export type ShopRoomListRelationFilter = {
    every?: ShopRoomWhereInput
    some?: ShopRoomWhereInput
    none?: ShopRoomWhereInput
  }

  export type MobNullableRelationFilter = {
    is?: MobWhereInput | null
    isNot?: MobWhereInput | null
  }

  export type ShopAcceptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopHourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopZoneIdIdCompoundUniqueInput = {
    zoneId: number
    id: number
  }

  export type ShopCountOrderByAggregateInput = {
    id?: SortOrder
    buyProfit?: SortOrder
    sellProfit?: SortOrder
    temper1?: SortOrder
    noSuchItem1?: SortOrder
    noSuchItem2?: SortOrder
    doNotBuy?: SortOrder
    missingCash1?: SortOrder
    missingCash2?: SortOrder
    messageBuy?: SortOrder
    messageSell?: SortOrder
    keeperZoneId?: SortOrder
    keeperId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    flags?: SortOrder
    tradesWithFlags?: SortOrder
  }

  export type ShopAvgOrderByAggregateInput = {
    id?: SortOrder
    buyProfit?: SortOrder
    sellProfit?: SortOrder
    temper1?: SortOrder
    keeperZoneId?: SortOrder
    keeperId?: SortOrder
    zoneId?: SortOrder
  }

  export type ShopMaxOrderByAggregateInput = {
    id?: SortOrder
    buyProfit?: SortOrder
    sellProfit?: SortOrder
    temper1?: SortOrder
    noSuchItem1?: SortOrder
    noSuchItem2?: SortOrder
    doNotBuy?: SortOrder
    missingCash1?: SortOrder
    missingCash2?: SortOrder
    messageBuy?: SortOrder
    messageSell?: SortOrder
    keeperZoneId?: SortOrder
    keeperId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ShopMinOrderByAggregateInput = {
    id?: SortOrder
    buyProfit?: SortOrder
    sellProfit?: SortOrder
    temper1?: SortOrder
    noSuchItem1?: SortOrder
    noSuchItem2?: SortOrder
    doNotBuy?: SortOrder
    missingCash1?: SortOrder
    missingCash2?: SortOrder
    messageBuy?: SortOrder
    messageSell?: SortOrder
    keeperZoneId?: SortOrder
    keeperId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type ShopSumOrderByAggregateInput = {
    id?: SortOrder
    buyProfit?: SortOrder
    sellProfit?: SortOrder
    temper1?: SortOrder
    keeperZoneId?: SortOrder
    keeperId?: SortOrder
    zoneId?: SortOrder
  }

  export type ShopRelationFilter = {
    is?: ShopWhereInput
    isNot?: ShopWhereInput
  }

  export type ShopItemShopZoneIdShopIdObjectZoneIdObjectIdCompoundUniqueInput = {
    shopZoneId: number
    shopId: number
    objectZoneId: number
    objectId: number
  }

  export type ShopItemCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ShopItemAvgOrderByAggregateInput = {
    amount?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ShopItemMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ShopItemMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ShopItemSumOrderByAggregateInput = {
    amount?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type ShopAcceptCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    keywords?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopAcceptAvgOrderByAggregateInput = {
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopAcceptMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopAcceptMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopAcceptSumOrderByAggregateInput = {
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopRoomShopZoneIdShopIdRoomIdCompoundUniqueInput = {
    shopZoneId: number
    shopId: number
    roomId: number
  }

  export type ShopRoomCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopRoomAvgOrderByAggregateInput = {
    roomId?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopRoomMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopRoomSumOrderByAggregateInput = {
    roomId?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopHourCountOrderByAggregateInput = {
    id?: SortOrder
    open?: SortOrder
    close?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopHourAvgOrderByAggregateInput = {
    open?: SortOrder
    close?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopHourMaxOrderByAggregateInput = {
    id?: SortOrder
    open?: SortOrder
    close?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopHourMinOrderByAggregateInput = {
    id?: SortOrder
    open?: SortOrder
    close?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type ShopHourSumOrderByAggregateInput = {
    open?: SortOrder
    close?: SortOrder
    shopZoneId?: SortOrder
    shopId?: SortOrder
  }

  export type EnumScriptTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScriptType | EnumScriptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScriptType[] | ListEnumScriptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScriptType[] | ListEnumScriptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScriptTypeFilter<$PrismaModel> | $Enums.ScriptType
  }

  export type EnumTriggerFlagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerFlag[] | ListEnumTriggerFlagFieldRefInput<$PrismaModel> | null
    has?: $Enums.TriggerFlag | EnumTriggerFlagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.TriggerFlag[] | ListEnumTriggerFlagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.TriggerFlag[] | ListEnumTriggerFlagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ObjectNullableRelationFilter = {
    is?: ObjectWhereInput | null
    isNot?: ObjectWhereInput | null
  }

  export type ZoneNullableRelationFilter = {
    is?: ZoneWhereInput | null
    isNot?: ZoneWhereInput | null
  }

  export type TriggerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    attachType?: SortOrder
    numArgs?: SortOrder
    argList?: SortOrder
    commands?: SortOrder
    zoneId?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    variables?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    flags?: SortOrder
  }

  export type TriggerAvgOrderByAggregateInput = {
    numArgs?: SortOrder
    zoneId?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type TriggerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    attachType?: SortOrder
    numArgs?: SortOrder
    argList?: SortOrder
    commands?: SortOrder
    zoneId?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type TriggerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    attachType?: SortOrder
    numArgs?: SortOrder
    argList?: SortOrder
    commands?: SortOrder
    zoneId?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type TriggerSumOrderByAggregateInput = {
    numArgs?: SortOrder
    zoneId?: SortOrder
    mobZoneId?: SortOrder
    mobId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
  }

  export type EnumScriptTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScriptType | EnumScriptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScriptType[] | ListEnumScriptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScriptType[] | ListEnumScriptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScriptTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScriptType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScriptTypeFilter<$PrismaModel>
    _max?: NestedEnumScriptTypeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ClassSkillListRelationFilter = {
    every?: ClassSkillWhereInput
    some?: ClassSkillWhereInput
    none?: ClassSkillWhereInput
  }

  export type SpellClassCircleListRelationFilter = {
    every?: SpellClassCircleWhereInput
    some?: SpellClassCircleWhereInput
    none?: SpellClassCircleWhereInput
  }

  export type ClassSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellClassCircleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    hitDice?: SortOrder
    primaryStat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameClassAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GameClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    hitDice?: SortOrder
    primaryStat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    hitDice?: SortOrder
    primaryStat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameClassSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpellComponentListRelationFilter = {
    every?: SpellComponentWhereInput
    some?: SpellComponentWhereInput
    none?: SpellComponentWhereInput
  }

  export type SpellEffectListRelationFilter = {
    every?: SpellEffectWhereInput
    some?: SpellEffectWhereInput
    none?: SpellEffectWhereInput
  }

  export type SpellMessageNullableRelationFilter = {
    is?: SpellMessageWhereInput | null
    isNot?: SpellMessageWhereInput | null
  }

  export type SpellRestrictionNullableRelationFilter = {
    is?: SpellRestrictionWhereInput | null
    isNot?: SpellRestrictionWhereInput | null
  }

  export type SpellSavingThrowListRelationFilter = {
    every?: SpellSavingThrowWhereInput
    some?: SpellSavingThrowWhereInput
    none?: SpellSavingThrowWhereInput
  }

  export type SpellTargetingNullableRelationFilter = {
    is?: SpellTargetingWhereInput | null
    isNot?: SpellTargetingWhereInput | null
  }

  export type SpellSchoolNullableRelationFilter = {
    is?: SpellSchoolWhereInput | null
    isNot?: SpellSchoolWhereInput | null
  }

  export type SpellComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellEffectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellSavingThrowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    minPosition?: SortOrder
    violent?: SortOrder
    castTimeRounds?: SortOrder
    cooldownMs?: SortOrder
    inCombatOnly?: SortOrder
    isArea?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpellAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    castTimeRounds?: SortOrder
    cooldownMs?: SortOrder
  }

  export type SpellMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    minPosition?: SortOrder
    violent?: SortOrder
    castTimeRounds?: SortOrder
    cooldownMs?: SortOrder
    inCombatOnly?: SortOrder
    isArea?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpellMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    minPosition?: SortOrder
    violent?: SortOrder
    castTimeRounds?: SortOrder
    cooldownMs?: SortOrder
    inCombatOnly?: SortOrder
    isArea?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpellSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    castTimeRounds?: SortOrder
    cooldownMs?: SortOrder
  }

  export type SpellListRelationFilter = {
    every?: SpellWhereInput
    some?: SpellWhereInput
    none?: SpellWhereInput
  }

  export type SpellOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpellSchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SpellSchoolAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpellSchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SpellSchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SpellSchoolSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GameClassRelationFilter = {
    is?: GameClassWhereInput
    isNot?: GameClassWhereInput
  }

  export type SpellClassCircleSpellIdClassIdCompoundUniqueInput = {
    spellId: number
    classId: number
  }

  export type SpellClassCircleCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    classId?: SortOrder
    circle?: SortOrder
    minLevel?: SortOrder
    proficiencyGain?: SortOrder
  }

  export type SpellClassCircleAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    classId?: SortOrder
    circle?: SortOrder
    minLevel?: SortOrder
    proficiencyGain?: SortOrder
  }

  export type SpellClassCircleMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    classId?: SortOrder
    circle?: SortOrder
    minLevel?: SortOrder
    proficiencyGain?: SortOrder
  }

  export type SpellClassCircleMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    classId?: SortOrder
    circle?: SortOrder
    minLevel?: SortOrder
    proficiencyGain?: SortOrder
  }

  export type SpellClassCircleSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    classId?: SortOrder
    circle?: SortOrder
    minLevel?: SortOrder
    proficiencyGain?: SortOrder
  }

  export type EnumTargetScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetScope | EnumTargetScopeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetScope[] | ListEnumTargetScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetScope[] | ListEnumTargetScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetScopeFilter<$PrismaModel> | $Enums.TargetScope
  }

  export type EnumSpellRangeFilter<$PrismaModel = never> = {
    equals?: $Enums.SpellRange | EnumSpellRangeFieldRefInput<$PrismaModel>
    in?: $Enums.SpellRange[] | ListEnumSpellRangeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpellRange[] | ListEnumSpellRangeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpellRangeFilter<$PrismaModel> | $Enums.SpellRange
  }

  export type SpellTargetingCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    allowedTargetsMask?: SortOrder
    targetScope?: SortOrder
    maxTargets?: SortOrder
    range?: SortOrder
    requireLos?: SortOrder
    filtersMask?: SortOrder
  }

  export type SpellTargetingAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    allowedTargetsMask?: SortOrder
    maxTargets?: SortOrder
    filtersMask?: SortOrder
  }

  export type SpellTargetingMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    allowedTargetsMask?: SortOrder
    targetScope?: SortOrder
    maxTargets?: SortOrder
    range?: SortOrder
    requireLos?: SortOrder
    filtersMask?: SortOrder
  }

  export type SpellTargetingMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    allowedTargetsMask?: SortOrder
    targetScope?: SortOrder
    maxTargets?: SortOrder
    range?: SortOrder
    requireLos?: SortOrder
    filtersMask?: SortOrder
  }

  export type SpellTargetingSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    allowedTargetsMask?: SortOrder
    maxTargets?: SortOrder
    filtersMask?: SortOrder
  }

  export type EnumTargetScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetScope | EnumTargetScopeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetScope[] | ListEnumTargetScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetScope[] | ListEnumTargetScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetScopeWithAggregatesFilter<$PrismaModel> | $Enums.TargetScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTargetScopeFilter<$PrismaModel>
    _max?: NestedEnumTargetScopeFilter<$PrismaModel>
  }

  export type EnumSpellRangeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpellRange | EnumSpellRangeFieldRefInput<$PrismaModel>
    in?: $Enums.SpellRange[] | ListEnumSpellRangeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpellRange[] | ListEnumSpellRangeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpellRangeWithAggregatesFilter<$PrismaModel> | $Enums.SpellRange
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpellRangeFilter<$PrismaModel>
    _max?: NestedEnumSpellRangeFilter<$PrismaModel>
  }

  export type EnumSaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SaveType | EnumSaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SaveType[] | ListEnumSaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaveType[] | ListEnumSaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSaveTypeFilter<$PrismaModel> | $Enums.SaveType
  }

  export type EnumSaveResultFilter<$PrismaModel = never> = {
    equals?: $Enums.SaveResult | EnumSaveResultFieldRefInput<$PrismaModel>
    in?: $Enums.SaveResult[] | ListEnumSaveResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaveResult[] | ListEnumSaveResultFieldRefInput<$PrismaModel>
    not?: NestedEnumSaveResultFilter<$PrismaModel> | $Enums.SaveResult
  }

  export type SpellSavingThrowCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    saveType?: SortOrder
    onSave?: SortOrder
    dcFormula?: SortOrder
    saveModifierMask?: SortOrder
  }

  export type SpellSavingThrowAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    saveModifierMask?: SortOrder
  }

  export type SpellSavingThrowMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    saveType?: SortOrder
    onSave?: SortOrder
    dcFormula?: SortOrder
    saveModifierMask?: SortOrder
  }

  export type SpellSavingThrowMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    saveType?: SortOrder
    onSave?: SortOrder
    dcFormula?: SortOrder
    saveModifierMask?: SortOrder
  }

  export type SpellSavingThrowSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    saveModifierMask?: SortOrder
  }

  export type EnumSaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaveType | EnumSaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SaveType[] | ListEnumSaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaveType[] | ListEnumSaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.SaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaveTypeFilter<$PrismaModel>
    _max?: NestedEnumSaveTypeFilter<$PrismaModel>
  }

  export type EnumSaveResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaveResult | EnumSaveResultFieldRefInput<$PrismaModel>
    in?: $Enums.SaveResult[] | ListEnumSaveResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaveResult[] | ListEnumSaveResultFieldRefInput<$PrismaModel>
    not?: NestedEnumSaveResultWithAggregatesFilter<$PrismaModel> | $Enums.SaveResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaveResultFilter<$PrismaModel>
    _max?: NestedEnumSaveResultFilter<$PrismaModel>
  }

  export type SpellMessageCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    startToCaster?: SortOrder
    startToVictim?: SortOrder
    startToRoom?: SortOrder
    successToCaster?: SortOrder
    successToVictim?: SortOrder
    successToRoom?: SortOrder
    failToCaster?: SortOrder
    failToVictim?: SortOrder
    failToRoom?: SortOrder
    wearoffToTarget?: SortOrder
    wearoffToRoom?: SortOrder
  }

  export type SpellMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
  }

  export type SpellMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    startToCaster?: SortOrder
    startToVictim?: SortOrder
    startToRoom?: SortOrder
    successToCaster?: SortOrder
    successToVictim?: SortOrder
    successToRoom?: SortOrder
    failToCaster?: SortOrder
    failToVictim?: SortOrder
    failToRoom?: SortOrder
    wearoffToTarget?: SortOrder
    wearoffToRoom?: SortOrder
  }

  export type SpellMessageMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    startToCaster?: SortOrder
    startToVictim?: SortOrder
    startToRoom?: SortOrder
    successToCaster?: SortOrder
    successToVictim?: SortOrder
    successToRoom?: SortOrder
    failToCaster?: SortOrder
    failToVictim?: SortOrder
    failToRoom?: SortOrder
    wearoffToTarget?: SortOrder
    wearoffToRoom?: SortOrder
  }

  export type SpellMessageSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
  }

  export type SpellComponentCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    objectId?: SortOrder
    consumed?: SortOrder
    required?: SortOrder
  }

  export type SpellComponentAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    objectId?: SortOrder
  }

  export type SpellComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    objectId?: SortOrder
    consumed?: SortOrder
    required?: SortOrder
  }

  export type SpellComponentMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    objectId?: SortOrder
    consumed?: SortOrder
    required?: SortOrder
  }

  export type SpellComponentSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    objectId?: SortOrder
  }

  export type SpellRestrictionCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    indoorsOnly?: SortOrder
    outdoorsOnly?: SortOrder
    noSafeRooms?: SortOrder
    noTeleportFlagsMask?: SortOrder
    terrainMask?: SortOrder
    disallowStatesMask?: SortOrder
  }

  export type SpellRestrictionAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    noTeleportFlagsMask?: SortOrder
    terrainMask?: SortOrder
    disallowStatesMask?: SortOrder
  }

  export type SpellRestrictionMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    indoorsOnly?: SortOrder
    outdoorsOnly?: SortOrder
    noSafeRooms?: SortOrder
    noTeleportFlagsMask?: SortOrder
    terrainMask?: SortOrder
    disallowStatesMask?: SortOrder
  }

  export type SpellRestrictionMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    indoorsOnly?: SortOrder
    outdoorsOnly?: SortOrder
    noSafeRooms?: SortOrder
    noTeleportFlagsMask?: SortOrder
    terrainMask?: SortOrder
    disallowStatesMask?: SortOrder
  }

  export type SpellRestrictionSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    noTeleportFlagsMask?: SortOrder
    terrainMask?: SortOrder
    disallowStatesMask?: SortOrder
  }

  export type EnumEffectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EffectType | EnumEffectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EffectType[] | ListEnumEffectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EffectType[] | ListEnumEffectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEffectTypeFilter<$PrismaModel> | $Enums.EffectType
  }

  export type EnumEffectTriggerNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EffectTrigger | EnumEffectTriggerFieldRefInput<$PrismaModel> | null
    in?: $Enums.EffectTrigger[] | ListEnumEffectTriggerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EffectTrigger[] | ListEnumEffectTriggerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEffectTriggerNullableFilter<$PrismaModel> | $Enums.EffectTrigger | null
  }

  export type EnumStackingRuleFilter<$PrismaModel = never> = {
    equals?: $Enums.StackingRule | EnumStackingRuleFieldRefInput<$PrismaModel>
    in?: $Enums.StackingRule[] | ListEnumStackingRuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StackingRule[] | ListEnumStackingRuleFieldRefInput<$PrismaModel>
    not?: NestedEnumStackingRuleFilter<$PrismaModel> | $Enums.StackingRule
  }

  export type SpellEffectCountOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    effectType?: SortOrder
    order?: SortOrder
    chancePct?: SortOrder
    trigger?: SortOrder
    durationFormula?: SortOrder
    stackingRule?: SortOrder
    conditionFilter?: SortOrder
    params?: SortOrder
  }

  export type SpellEffectAvgOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    order?: SortOrder
    chancePct?: SortOrder
  }

  export type SpellEffectMaxOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    effectType?: SortOrder
    order?: SortOrder
    chancePct?: SortOrder
    trigger?: SortOrder
    durationFormula?: SortOrder
    stackingRule?: SortOrder
  }

  export type SpellEffectMinOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    effectType?: SortOrder
    order?: SortOrder
    chancePct?: SortOrder
    trigger?: SortOrder
    durationFormula?: SortOrder
    stackingRule?: SortOrder
  }

  export type SpellEffectSumOrderByAggregateInput = {
    id?: SortOrder
    spellId?: SortOrder
    order?: SortOrder
    chancePct?: SortOrder
  }

  export type EnumEffectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EffectType | EnumEffectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EffectType[] | ListEnumEffectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EffectType[] | ListEnumEffectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEffectTypeWithAggregatesFilter<$PrismaModel> | $Enums.EffectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEffectTypeFilter<$PrismaModel>
    _max?: NestedEnumEffectTypeFilter<$PrismaModel>
  }

  export type EnumEffectTriggerNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EffectTrigger | EnumEffectTriggerFieldRefInput<$PrismaModel> | null
    in?: $Enums.EffectTrigger[] | ListEnumEffectTriggerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EffectTrigger[] | ListEnumEffectTriggerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEffectTriggerNullableWithAggregatesFilter<$PrismaModel> | $Enums.EffectTrigger | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEffectTriggerNullableFilter<$PrismaModel>
    _max?: NestedEnumEffectTriggerNullableFilter<$PrismaModel>
  }

  export type EnumStackingRuleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StackingRule | EnumStackingRuleFieldRefInput<$PrismaModel>
    in?: $Enums.StackingRule[] | ListEnumStackingRuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StackingRule[] | ListEnumStackingRuleFieldRefInput<$PrismaModel>
    not?: NestedEnumStackingRuleWithAggregatesFilter<$PrismaModel> | $Enums.StackingRule
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStackingRuleFilter<$PrismaModel>
    _max?: NestedEnumStackingRuleFilter<$PrismaModel>
  }

  export type EnumSkillTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillType | EnumSkillTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillTypeFilter<$PrismaModel> | $Enums.SkillType
  }

  export type EnumSkillCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryFilter<$PrismaModel> | $Enums.SkillCategory
  }

  export type RaceSkillListRelationFilter = {
    every?: RaceSkillWhereInput
    some?: RaceSkillWhereInput
    none?: RaceSkillWhereInput
  }

  export type RaceSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    maxLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillAvgOrderByAggregateInput = {
    id?: SortOrder
    maxLevel?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    maxLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    maxLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillSumOrderByAggregateInput = {
    id?: SortOrder
    maxLevel?: SortOrder
  }

  export type EnumSkillTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillType | EnumSkillTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillTypeWithAggregatesFilter<$PrismaModel> | $Enums.SkillType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillTypeFilter<$PrismaModel>
    _max?: NestedEnumSkillTypeFilter<$PrismaModel>
  }

  export type EnumSkillCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SkillCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillCategoryFilter<$PrismaModel>
    _max?: NestedEnumSkillCategoryFilter<$PrismaModel>
  }

  export type ClassSkillClassIdSkillIdCompoundUniqueInput = {
    classId: number
    skillId: number
  }

  export type ClassSkillCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
    category?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
  }

  export type ClassSkillAvgOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
  }

  export type ClassSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
    category?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
  }

  export type ClassSkillMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
    category?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
  }

  export type ClassSkillSumOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    skillId?: SortOrder
    minLevel?: SortOrder
    maxLevel?: SortOrder
  }

  export type RaceSkillRaceSkillIdCompoundUniqueInput = {
    race: $Enums.Race
    skillId: number
  }

  export type RaceSkillCountOrderByAggregateInput = {
    id?: SortOrder
    race?: SortOrder
    skillId?: SortOrder
    category?: SortOrder
    bonus?: SortOrder
  }

  export type RaceSkillAvgOrderByAggregateInput = {
    id?: SortOrder
    skillId?: SortOrder
    bonus?: SortOrder
  }

  export type RaceSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    race?: SortOrder
    skillId?: SortOrder
    category?: SortOrder
    bonus?: SortOrder
  }

  export type RaceSkillMinOrderByAggregateInput = {
    id?: SortOrder
    race?: SortOrder
    skillId?: SortOrder
    category?: SortOrder
    bonus?: SortOrder
  }

  export type RaceSkillSumOrderByAggregateInput = {
    id?: SortOrder
    skillId?: SortOrder
    bonus?: SortOrder
  }

  export type CharacterRelationFilter = {
    is?: CharacterWhereInput
    isNot?: CharacterWhereInput
  }

  export type CharacterSkillCharacterIdSkillIdCompoundUniqueInput = {
    characterId: string
    skillId: number
  }

  export type CharacterSkillCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    lastUsed?: SortOrder
  }

  export type CharacterSkillAvgOrderByAggregateInput = {
    skillId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
  }

  export type CharacterSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    lastUsed?: SortOrder
  }

  export type CharacterSkillMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    lastUsed?: SortOrder
  }

  export type CharacterSkillSumOrderByAggregateInput = {
    skillId?: SortOrder
    level?: SortOrder
    experience?: SortOrder
  }

  export type CharacterSpellCharacterIdSpellIdCompoundUniqueInput = {
    characterId: string
    spellId: number
  }

  export type CharacterSpellCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    spellId?: SortOrder
    known?: SortOrder
    proficiency?: SortOrder
    lastCast?: SortOrder
  }

  export type CharacterSpellAvgOrderByAggregateInput = {
    spellId?: SortOrder
    proficiency?: SortOrder
  }

  export type CharacterSpellMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    spellId?: SortOrder
    known?: SortOrder
    proficiency?: SortOrder
    lastCast?: SortOrder
  }

  export type CharacterSpellMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    spellId?: SortOrder
    known?: SortOrder
    proficiency?: SortOrder
    lastCast?: SortOrder
  }

  export type CharacterSpellSumOrderByAggregateInput = {
    spellId?: SortOrder
    proficiency?: SortOrder
  }

  export type ChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
  }

  export type ChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
  }

  export type ChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
  }

  export type BanRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bannedBy?: SortOrder
    reason?: SortOrder
    bannedAt?: SortOrder
    expiresAt?: SortOrder
    unbannedAt?: SortOrder
    unbannedBy?: SortOrder
    active?: SortOrder
  }

  export type BanRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bannedBy?: SortOrder
    reason?: SortOrder
    bannedAt?: SortOrder
    expiresAt?: SortOrder
    unbannedAt?: SortOrder
    unbannedBy?: SortOrder
    active?: SortOrder
  }

  export type BanRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bannedBy?: SortOrder
    reason?: SortOrder
    bannedAt?: SortOrder
    expiresAt?: SortOrder
    unbannedAt?: SortOrder
    unbannedBy?: SortOrder
    active?: SortOrder
  }

  export type CharacterItemNullableRelationFilter = {
    is?: CharacterItemWhereInput | null
    isNot?: CharacterItemWhereInput | null
  }

  export type CharacterItemCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    object_zone_id?: SortOrder
    object_id?: SortOrder
    containerId?: SortOrder
    equippedLocation?: SortOrder
    condition?: SortOrder
    charges?: SortOrder
    instanceFlags?: SortOrder
    customShortDesc?: SortOrder
    customLongDesc?: SortOrder
    customValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterItemAvgOrderByAggregateInput = {
    object_zone_id?: SortOrder
    object_id?: SortOrder
    condition?: SortOrder
    charges?: SortOrder
  }

  export type CharacterItemMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    object_zone_id?: SortOrder
    object_id?: SortOrder
    containerId?: SortOrder
    equippedLocation?: SortOrder
    condition?: SortOrder
    charges?: SortOrder
    customShortDesc?: SortOrder
    customLongDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterItemMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    object_zone_id?: SortOrder
    object_id?: SortOrder
    containerId?: SortOrder
    equippedLocation?: SortOrder
    condition?: SortOrder
    charges?: SortOrder
    customShortDesc?: SortOrder
    customLongDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterItemSumOrderByAggregateInput = {
    object_zone_id?: SortOrder
    object_id?: SortOrder
    condition?: SortOrder
    charges?: SortOrder
  }

  export type CharacterEffectCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    effectName?: SortOrder
    effectType?: SortOrder
    duration?: SortOrder
    strength?: SortOrder
    modifierData?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    appliedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CharacterEffectAvgOrderByAggregateInput = {
    duration?: SortOrder
    strength?: SortOrder
    sourceId?: SortOrder
  }

  export type CharacterEffectMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    effectName?: SortOrder
    effectType?: SortOrder
    duration?: SortOrder
    strength?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    appliedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CharacterEffectMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    effectName?: SortOrder
    effectType?: SortOrder
    duration?: SortOrder
    strength?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    appliedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CharacterEffectSumOrderByAggregateInput = {
    duration?: SortOrder
    strength?: SortOrder
    sourceId?: SortOrder
  }

  export type EquipmentSetRelationFilter = {
    is?: EquipmentSetWhereInput
    isNot?: EquipmentSetWhereInput
  }

  export type EquipmentSetItemCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentSetId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    slot?: SortOrder
    quantity?: SortOrder
    probability?: SortOrder
  }

  export type EquipmentSetItemAvgOrderByAggregateInput = {
    objectZoneId?: SortOrder
    objectId?: SortOrder
    quantity?: SortOrder
    probability?: SortOrder
  }

  export type EquipmentSetItemMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentSetId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    slot?: SortOrder
    quantity?: SortOrder
    probability?: SortOrder
  }

  export type EquipmentSetItemMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentSetId?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    slot?: SortOrder
    quantity?: SortOrder
    probability?: SortOrder
  }

  export type EquipmentSetItemSumOrderByAggregateInput = {
    objectZoneId?: SortOrder
    objectId?: SortOrder
    quantity?: SortOrder
    probability?: SortOrder
  }

  export type EquipmentSetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentSetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentSetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MobEquipmentSetMobResetIdEquipmentSetIdCompoundUniqueInput = {
    mobResetId: string
    equipmentSetId: string
  }

  export type MobEquipmentSetCountOrderByAggregateInput = {
    id?: SortOrder
    mobResetId?: SortOrder
    equipmentSetId?: SortOrder
    probability?: SortOrder
  }

  export type MobEquipmentSetAvgOrderByAggregateInput = {
    probability?: SortOrder
  }

  export type MobEquipmentSetMaxOrderByAggregateInput = {
    id?: SortOrder
    mobResetId?: SortOrder
    equipmentSetId?: SortOrder
    probability?: SortOrder
  }

  export type MobEquipmentSetMinOrderByAggregateInput = {
    id?: SortOrder
    mobResetId?: SortOrder
    equipmentSetId?: SortOrder
    probability?: SortOrder
  }

  export type MobEquipmentSetSumOrderByAggregateInput = {
    probability?: SortOrder
  }

  export type ObjectResetCountOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
  }

  export type ObjectResetAvgOrderByAggregateInput = {
    max?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
  }

  export type ObjectResetMaxOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
  }

  export type ObjectResetMinOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    name?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
  }

  export type ObjectResetSumOrderByAggregateInput = {
    max?: SortOrder
    objectZoneId?: SortOrder
    objectId?: SortOrder
    roomZoneId?: SortOrder
    roomId?: SortOrder
    zoneId?: SortOrder
    probability?: SortOrder
  }

  export type MobResetNullableRelationFilter = {
    is?: MobResetWhereInput | null
    isNot?: MobResetWhereInput | null
  }

  export type ObjectResetNullableRelationFilter = {
    is?: ObjectResetWhereInput | null
    isNot?: ObjectResetWhereInput | null
  }

  export type SpawnConditionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    parameters?: SortOrder
    mobResetId?: SortOrder
    objectResetId?: SortOrder
  }

  export type SpawnConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    mobResetId?: SortOrder
    objectResetId?: SortOrder
  }

  export type SpawnConditionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    mobResetId?: SortOrder
    objectResetId?: SortOrder
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BanRecordCreateNestedManyWithoutAdminInput = {
    create?: XOR<BanRecordCreateWithoutAdminInput, BanRecordUncheckedCreateWithoutAdminInput> | BanRecordCreateWithoutAdminInput[] | BanRecordUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BanRecordCreateOrConnectWithoutAdminInput | BanRecordCreateOrConnectWithoutAdminInput[]
    createMany?: BanRecordCreateManyAdminInputEnvelope
    connect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
  }

  export type BanRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<BanRecordCreateWithoutUserInput, BanRecordUncheckedCreateWithoutUserInput> | BanRecordCreateWithoutUserInput[] | BanRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BanRecordCreateOrConnectWithoutUserInput | BanRecordCreateOrConnectWithoutUserInput[]
    createMany?: BanRecordCreateManyUserInputEnvelope
    connect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
  }

  export type ChangeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput> | ChangeLogCreateWithoutUserInput[] | ChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutUserInput | ChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: ChangeLogCreateManyUserInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type CharacterCreateNestedManyWithoutUserInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput> | CharacterCreateWithoutUserInput[] | CharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput | CharacterCreateOrConnectWithoutUserInput[]
    createMany?: CharacterCreateManyUserInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BanRecordUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<BanRecordCreateWithoutAdminInput, BanRecordUncheckedCreateWithoutAdminInput> | BanRecordCreateWithoutAdminInput[] | BanRecordUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BanRecordCreateOrConnectWithoutAdminInput | BanRecordCreateOrConnectWithoutAdminInput[]
    createMany?: BanRecordCreateManyAdminInputEnvelope
    connect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
  }

  export type BanRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BanRecordCreateWithoutUserInput, BanRecordUncheckedCreateWithoutUserInput> | BanRecordCreateWithoutUserInput[] | BanRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BanRecordCreateOrConnectWithoutUserInput | BanRecordCreateOrConnectWithoutUserInput[]
    createMany?: BanRecordCreateManyUserInputEnvelope
    connect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
  }

  export type ChangeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput> | ChangeLogCreateWithoutUserInput[] | ChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutUserInput | ChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: ChangeLogCreateManyUserInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput> | CharacterCreateWithoutUserInput[] | CharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput | CharacterCreateOrConnectWithoutUserInput[]
    createMany?: CharacterCreateManyUserInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BanRecordUpdateManyWithoutAdminNestedInput = {
    create?: XOR<BanRecordCreateWithoutAdminInput, BanRecordUncheckedCreateWithoutAdminInput> | BanRecordCreateWithoutAdminInput[] | BanRecordUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BanRecordCreateOrConnectWithoutAdminInput | BanRecordCreateOrConnectWithoutAdminInput[]
    upsert?: BanRecordUpsertWithWhereUniqueWithoutAdminInput | BanRecordUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: BanRecordCreateManyAdminInputEnvelope
    set?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    disconnect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    delete?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    connect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    update?: BanRecordUpdateWithWhereUniqueWithoutAdminInput | BanRecordUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: BanRecordUpdateManyWithWhereWithoutAdminInput | BanRecordUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: BanRecordScalarWhereInput | BanRecordScalarWhereInput[]
  }

  export type BanRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<BanRecordCreateWithoutUserInput, BanRecordUncheckedCreateWithoutUserInput> | BanRecordCreateWithoutUserInput[] | BanRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BanRecordCreateOrConnectWithoutUserInput | BanRecordCreateOrConnectWithoutUserInput[]
    upsert?: BanRecordUpsertWithWhereUniqueWithoutUserInput | BanRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BanRecordCreateManyUserInputEnvelope
    set?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    disconnect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    delete?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    connect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    update?: BanRecordUpdateWithWhereUniqueWithoutUserInput | BanRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BanRecordUpdateManyWithWhereWithoutUserInput | BanRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BanRecordScalarWhereInput | BanRecordScalarWhereInput[]
  }

  export type ChangeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput> | ChangeLogCreateWithoutUserInput[] | ChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutUserInput | ChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutUserInput | ChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChangeLogCreateManyUserInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutUserInput | ChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutUserInput | ChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type CharacterUpdateManyWithoutUserNestedInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput> | CharacterCreateWithoutUserInput[] | CharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput | CharacterCreateOrConnectWithoutUserInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutUserInput | CharacterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CharacterCreateManyUserInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutUserInput | CharacterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutUserInput | CharacterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BanRecordUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<BanRecordCreateWithoutAdminInput, BanRecordUncheckedCreateWithoutAdminInput> | BanRecordCreateWithoutAdminInput[] | BanRecordUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BanRecordCreateOrConnectWithoutAdminInput | BanRecordCreateOrConnectWithoutAdminInput[]
    upsert?: BanRecordUpsertWithWhereUniqueWithoutAdminInput | BanRecordUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: BanRecordCreateManyAdminInputEnvelope
    set?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    disconnect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    delete?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    connect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    update?: BanRecordUpdateWithWhereUniqueWithoutAdminInput | BanRecordUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: BanRecordUpdateManyWithWhereWithoutAdminInput | BanRecordUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: BanRecordScalarWhereInput | BanRecordScalarWhereInput[]
  }

  export type BanRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BanRecordCreateWithoutUserInput, BanRecordUncheckedCreateWithoutUserInput> | BanRecordCreateWithoutUserInput[] | BanRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BanRecordCreateOrConnectWithoutUserInput | BanRecordCreateOrConnectWithoutUserInput[]
    upsert?: BanRecordUpsertWithWhereUniqueWithoutUserInput | BanRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BanRecordCreateManyUserInputEnvelope
    set?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    disconnect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    delete?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    connect?: BanRecordWhereUniqueInput | BanRecordWhereUniqueInput[]
    update?: BanRecordUpdateWithWhereUniqueWithoutUserInput | BanRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BanRecordUpdateManyWithWhereWithoutUserInput | BanRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BanRecordScalarWhereInput | BanRecordScalarWhereInput[]
  }

  export type ChangeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput> | ChangeLogCreateWithoutUserInput[] | ChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutUserInput | ChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutUserInput | ChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChangeLogCreateManyUserInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutUserInput | ChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutUserInput | ChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput> | CharacterCreateWithoutUserInput[] | CharacterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput | CharacterCreateOrConnectWithoutUserInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutUserInput | CharacterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CharacterCreateManyUserInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutUserInput | CharacterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutUserInput | CharacterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterCreateplayerFlagsInput = {
    set: string[]
  }

  export type CharacterCreateeffectFlagsInput = {
    set: string[]
  }

  export type CharacterCreateprivilegeFlagsInput = {
    set: string[]
  }

  export type CharacterCreateolcZonesInput = {
    set: number[]
  }

  export type CharacterEffectCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterEffectCreateWithoutCharacterInput, CharacterEffectUncheckedCreateWithoutCharacterInput> | CharacterEffectCreateWithoutCharacterInput[] | CharacterEffectUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterEffectCreateOrConnectWithoutCharacterInput | CharacterEffectCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterEffectCreateManyCharacterInputEnvelope
    connect?: CharacterEffectWhereUniqueInput | CharacterEffectWhereUniqueInput[]
  }

  export type CharacterItemCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterItemCreateWithoutCharacterInput, CharacterItemUncheckedCreateWithoutCharacterInput> | CharacterItemCreateWithoutCharacterInput[] | CharacterItemUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutCharacterInput | CharacterItemCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterItemCreateManyCharacterInputEnvelope
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
  }

  export type CharacterSkillCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterSkillCreateManyCharacterInputEnvelope
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
  }

  export type CharacterSpellCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterSpellCreateWithoutCharacterInput, CharacterSpellUncheckedCreateWithoutCharacterInput> | CharacterSpellCreateWithoutCharacterInput[] | CharacterSpellUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSpellCreateOrConnectWithoutCharacterInput | CharacterSpellCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterSpellCreateManyCharacterInputEnvelope
    connect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
  }

  export type GameClassCreateNestedOneWithoutCharactersInput = {
    create?: XOR<GameClassCreateWithoutCharactersInput, GameClassUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: GameClassCreateOrConnectWithoutCharactersInput
    connect?: GameClassWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCharactersInput = {
    create?: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharactersInput
    connect?: UserWhereUniqueInput
  }

  export type CharacterEffectUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterEffectCreateWithoutCharacterInput, CharacterEffectUncheckedCreateWithoutCharacterInput> | CharacterEffectCreateWithoutCharacterInput[] | CharacterEffectUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterEffectCreateOrConnectWithoutCharacterInput | CharacterEffectCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterEffectCreateManyCharacterInputEnvelope
    connect?: CharacterEffectWhereUniqueInput | CharacterEffectWhereUniqueInput[]
  }

  export type CharacterItemUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterItemCreateWithoutCharacterInput, CharacterItemUncheckedCreateWithoutCharacterInput> | CharacterItemCreateWithoutCharacterInput[] | CharacterItemUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutCharacterInput | CharacterItemCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterItemCreateManyCharacterInputEnvelope
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
  }

  export type CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterSkillCreateManyCharacterInputEnvelope
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
  }

  export type CharacterSpellUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterSpellCreateWithoutCharacterInput, CharacterSpellUncheckedCreateWithoutCharacterInput> | CharacterSpellCreateWithoutCharacterInput[] | CharacterSpellUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSpellCreateOrConnectWithoutCharacterInput | CharacterSpellCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterSpellCreateManyCharacterInputEnvelope
    connect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
  }

  export type EnumRaceFieldUpdateOperationsInput = {
    set?: $Enums.Race
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CharacterUpdateplayerFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CharacterUpdateeffectFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CharacterUpdateprivilegeFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CharacterUpdateolcZonesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type CharacterEffectUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterEffectCreateWithoutCharacterInput, CharacterEffectUncheckedCreateWithoutCharacterInput> | CharacterEffectCreateWithoutCharacterInput[] | CharacterEffectUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterEffectCreateOrConnectWithoutCharacterInput | CharacterEffectCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterEffectUpsertWithWhereUniqueWithoutCharacterInput | CharacterEffectUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterEffectCreateManyCharacterInputEnvelope
    set?: CharacterEffectWhereUniqueInput | CharacterEffectWhereUniqueInput[]
    disconnect?: CharacterEffectWhereUniqueInput | CharacterEffectWhereUniqueInput[]
    delete?: CharacterEffectWhereUniqueInput | CharacterEffectWhereUniqueInput[]
    connect?: CharacterEffectWhereUniqueInput | CharacterEffectWhereUniqueInput[]
    update?: CharacterEffectUpdateWithWhereUniqueWithoutCharacterInput | CharacterEffectUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterEffectUpdateManyWithWhereWithoutCharacterInput | CharacterEffectUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterEffectScalarWhereInput | CharacterEffectScalarWhereInput[]
  }

  export type CharacterItemUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterItemCreateWithoutCharacterInput, CharacterItemUncheckedCreateWithoutCharacterInput> | CharacterItemCreateWithoutCharacterInput[] | CharacterItemUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutCharacterInput | CharacterItemCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterItemUpsertWithWhereUniqueWithoutCharacterInput | CharacterItemUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterItemCreateManyCharacterInputEnvelope
    set?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    disconnect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    delete?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    update?: CharacterItemUpdateWithWhereUniqueWithoutCharacterInput | CharacterItemUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterItemUpdateManyWithWhereWithoutCharacterInput | CharacterItemUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterItemScalarWhereInput | CharacterItemScalarWhereInput[]
  }

  export type CharacterSkillUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput | CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterSkillCreateManyCharacterInputEnvelope
    set?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    disconnect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    delete?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    update?: CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput | CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterSkillUpdateManyWithWhereWithoutCharacterInput | CharacterSkillUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
  }

  export type CharacterSpellUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterSpellCreateWithoutCharacterInput, CharacterSpellUncheckedCreateWithoutCharacterInput> | CharacterSpellCreateWithoutCharacterInput[] | CharacterSpellUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSpellCreateOrConnectWithoutCharacterInput | CharacterSpellCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterSpellUpsertWithWhereUniqueWithoutCharacterInput | CharacterSpellUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterSpellCreateManyCharacterInputEnvelope
    set?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    disconnect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    delete?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    connect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    update?: CharacterSpellUpdateWithWhereUniqueWithoutCharacterInput | CharacterSpellUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterSpellUpdateManyWithWhereWithoutCharacterInput | CharacterSpellUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterSpellScalarWhereInput | CharacterSpellScalarWhereInput[]
  }

  export type GameClassUpdateOneWithoutCharactersNestedInput = {
    create?: XOR<GameClassCreateWithoutCharactersInput, GameClassUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: GameClassCreateOrConnectWithoutCharactersInput
    upsert?: GameClassUpsertWithoutCharactersInput
    disconnect?: GameClassWhereInput | boolean
    delete?: GameClassWhereInput | boolean
    connect?: GameClassWhereUniqueInput
    update?: XOR<XOR<GameClassUpdateToOneWithWhereWithoutCharactersInput, GameClassUpdateWithoutCharactersInput>, GameClassUncheckedUpdateWithoutCharactersInput>
  }

  export type UserUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharactersInput
    upsert?: UserUpsertWithoutCharactersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCharactersInput, UserUpdateWithoutCharactersInput>, UserUncheckedUpdateWithoutCharactersInput>
  }

  export type CharacterEffectUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterEffectCreateWithoutCharacterInput, CharacterEffectUncheckedCreateWithoutCharacterInput> | CharacterEffectCreateWithoutCharacterInput[] | CharacterEffectUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterEffectCreateOrConnectWithoutCharacterInput | CharacterEffectCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterEffectUpsertWithWhereUniqueWithoutCharacterInput | CharacterEffectUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterEffectCreateManyCharacterInputEnvelope
    set?: CharacterEffectWhereUniqueInput | CharacterEffectWhereUniqueInput[]
    disconnect?: CharacterEffectWhereUniqueInput | CharacterEffectWhereUniqueInput[]
    delete?: CharacterEffectWhereUniqueInput | CharacterEffectWhereUniqueInput[]
    connect?: CharacterEffectWhereUniqueInput | CharacterEffectWhereUniqueInput[]
    update?: CharacterEffectUpdateWithWhereUniqueWithoutCharacterInput | CharacterEffectUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterEffectUpdateManyWithWhereWithoutCharacterInput | CharacterEffectUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterEffectScalarWhereInput | CharacterEffectScalarWhereInput[]
  }

  export type CharacterItemUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterItemCreateWithoutCharacterInput, CharacterItemUncheckedCreateWithoutCharacterInput> | CharacterItemCreateWithoutCharacterInput[] | CharacterItemUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutCharacterInput | CharacterItemCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterItemUpsertWithWhereUniqueWithoutCharacterInput | CharacterItemUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterItemCreateManyCharacterInputEnvelope
    set?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    disconnect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    delete?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    update?: CharacterItemUpdateWithWhereUniqueWithoutCharacterInput | CharacterItemUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterItemUpdateManyWithWhereWithoutCharacterInput | CharacterItemUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterItemScalarWhereInput | CharacterItemScalarWhereInput[]
  }

  export type CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput | CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterSkillCreateManyCharacterInputEnvelope
    set?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    disconnect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    delete?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    update?: CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput | CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterSkillUpdateManyWithWhereWithoutCharacterInput | CharacterSkillUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
  }

  export type CharacterSpellUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterSpellCreateWithoutCharacterInput, CharacterSpellUncheckedCreateWithoutCharacterInput> | CharacterSpellCreateWithoutCharacterInput[] | CharacterSpellUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSpellCreateOrConnectWithoutCharacterInput | CharacterSpellCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterSpellUpsertWithWhereUniqueWithoutCharacterInput | CharacterSpellUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterSpellCreateManyCharacterInputEnvelope
    set?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    disconnect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    delete?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    connect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    update?: CharacterSpellUpdateWithWhereUniqueWithoutCharacterInput | CharacterSpellUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterSpellUpdateManyWithWhereWithoutCharacterInput | CharacterSpellUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterSpellScalarWhereInput | CharacterSpellScalarWhereInput[]
  }

  export type MobResetCreateNestedManyWithoutZoneInput = {
    create?: XOR<MobResetCreateWithoutZoneInput, MobResetUncheckedCreateWithoutZoneInput> | MobResetCreateWithoutZoneInput[] | MobResetUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutZoneInput | MobResetCreateOrConnectWithoutZoneInput[]
    createMany?: MobResetCreateManyZoneInputEnvelope
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
  }

  export type MobCreateNestedManyWithoutZoneInput = {
    create?: XOR<MobCreateWithoutZoneInput, MobUncheckedCreateWithoutZoneInput> | MobCreateWithoutZoneInput[] | MobUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: MobCreateOrConnectWithoutZoneInput | MobCreateOrConnectWithoutZoneInput[]
    createMany?: MobCreateManyZoneInputEnvelope
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
  }

  export type ObjectResetCreateNestedManyWithoutZoneInput = {
    create?: XOR<ObjectResetCreateWithoutZoneInput, ObjectResetUncheckedCreateWithoutZoneInput> | ObjectResetCreateWithoutZoneInput[] | ObjectResetUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutZoneInput | ObjectResetCreateOrConnectWithoutZoneInput[]
    createMany?: ObjectResetCreateManyZoneInputEnvelope
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
  }

  export type ObjectCreateNestedManyWithoutZoneInput = {
    create?: XOR<ObjectCreateWithoutZoneInput, ObjectUncheckedCreateWithoutZoneInput> | ObjectCreateWithoutZoneInput[] | ObjectUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutZoneInput | ObjectCreateOrConnectWithoutZoneInput[]
    createMany?: ObjectCreateManyZoneInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutZoneInput = {
    create?: XOR<RoomCreateWithoutZoneInput, RoomUncheckedCreateWithoutZoneInput> | RoomCreateWithoutZoneInput[] | RoomUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutZoneInput | RoomCreateOrConnectWithoutZoneInput[]
    createMany?: RoomCreateManyZoneInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ShopCreateNestedManyWithoutZoneInput = {
    create?: XOR<ShopCreateWithoutZoneInput, ShopUncheckedCreateWithoutZoneInput> | ShopCreateWithoutZoneInput[] | ShopUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutZoneInput | ShopCreateOrConnectWithoutZoneInput[]
    createMany?: ShopCreateManyZoneInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type TriggerCreateNestedManyWithoutZoneInput = {
    create?: XOR<TriggerCreateWithoutZoneInput, TriggerUncheckedCreateWithoutZoneInput> | TriggerCreateWithoutZoneInput[] | TriggerUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutZoneInput | TriggerCreateOrConnectWithoutZoneInput[]
    createMany?: TriggerCreateManyZoneInputEnvelope
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
  }

  export type MobResetUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<MobResetCreateWithoutZoneInput, MobResetUncheckedCreateWithoutZoneInput> | MobResetCreateWithoutZoneInput[] | MobResetUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutZoneInput | MobResetCreateOrConnectWithoutZoneInput[]
    createMany?: MobResetCreateManyZoneInputEnvelope
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
  }

  export type MobUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<MobCreateWithoutZoneInput, MobUncheckedCreateWithoutZoneInput> | MobCreateWithoutZoneInput[] | MobUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: MobCreateOrConnectWithoutZoneInput | MobCreateOrConnectWithoutZoneInput[]
    createMany?: MobCreateManyZoneInputEnvelope
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
  }

  export type ObjectResetUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<ObjectResetCreateWithoutZoneInput, ObjectResetUncheckedCreateWithoutZoneInput> | ObjectResetCreateWithoutZoneInput[] | ObjectResetUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutZoneInput | ObjectResetCreateOrConnectWithoutZoneInput[]
    createMany?: ObjectResetCreateManyZoneInputEnvelope
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<ObjectCreateWithoutZoneInput, ObjectUncheckedCreateWithoutZoneInput> | ObjectCreateWithoutZoneInput[] | ObjectUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutZoneInput | ObjectCreateOrConnectWithoutZoneInput[]
    createMany?: ObjectCreateManyZoneInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<RoomCreateWithoutZoneInput, RoomUncheckedCreateWithoutZoneInput> | RoomCreateWithoutZoneInput[] | RoomUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutZoneInput | RoomCreateOrConnectWithoutZoneInput[]
    createMany?: RoomCreateManyZoneInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ShopUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<ShopCreateWithoutZoneInput, ShopUncheckedCreateWithoutZoneInput> | ShopCreateWithoutZoneInput[] | ShopUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutZoneInput | ShopCreateOrConnectWithoutZoneInput[]
    createMany?: ShopCreateManyZoneInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type TriggerUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<TriggerCreateWithoutZoneInput, TriggerUncheckedCreateWithoutZoneInput> | TriggerCreateWithoutZoneInput[] | TriggerUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutZoneInput | TriggerCreateOrConnectWithoutZoneInput[]
    createMany?: TriggerCreateManyZoneInputEnvelope
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
  }

  export type EnumResetModeFieldUpdateOperationsInput = {
    set?: $Enums.ResetMode
  }

  export type EnumHemisphereFieldUpdateOperationsInput = {
    set?: $Enums.Hemisphere
  }

  export type EnumClimateFieldUpdateOperationsInput = {
    set?: $Enums.Climate
  }

  export type MobResetUpdateManyWithoutZoneNestedInput = {
    create?: XOR<MobResetCreateWithoutZoneInput, MobResetUncheckedCreateWithoutZoneInput> | MobResetCreateWithoutZoneInput[] | MobResetUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutZoneInput | MobResetCreateOrConnectWithoutZoneInput[]
    upsert?: MobResetUpsertWithWhereUniqueWithoutZoneInput | MobResetUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: MobResetCreateManyZoneInputEnvelope
    set?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    disconnect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    delete?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    update?: MobResetUpdateWithWhereUniqueWithoutZoneInput | MobResetUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: MobResetUpdateManyWithWhereWithoutZoneInput | MobResetUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: MobResetScalarWhereInput | MobResetScalarWhereInput[]
  }

  export type MobUpdateManyWithoutZoneNestedInput = {
    create?: XOR<MobCreateWithoutZoneInput, MobUncheckedCreateWithoutZoneInput> | MobCreateWithoutZoneInput[] | MobUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: MobCreateOrConnectWithoutZoneInput | MobCreateOrConnectWithoutZoneInput[]
    upsert?: MobUpsertWithWhereUniqueWithoutZoneInput | MobUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: MobCreateManyZoneInputEnvelope
    set?: MobWhereUniqueInput | MobWhereUniqueInput[]
    disconnect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    delete?: MobWhereUniqueInput | MobWhereUniqueInput[]
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    update?: MobUpdateWithWhereUniqueWithoutZoneInput | MobUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: MobUpdateManyWithWhereWithoutZoneInput | MobUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: MobScalarWhereInput | MobScalarWhereInput[]
  }

  export type ObjectResetUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ObjectResetCreateWithoutZoneInput, ObjectResetUncheckedCreateWithoutZoneInput> | ObjectResetCreateWithoutZoneInput[] | ObjectResetUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutZoneInput | ObjectResetCreateOrConnectWithoutZoneInput[]
    upsert?: ObjectResetUpsertWithWhereUniqueWithoutZoneInput | ObjectResetUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ObjectResetCreateManyZoneInputEnvelope
    set?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    disconnect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    delete?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    update?: ObjectResetUpdateWithWhereUniqueWithoutZoneInput | ObjectResetUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ObjectResetUpdateManyWithWhereWithoutZoneInput | ObjectResetUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ObjectResetScalarWhereInput | ObjectResetScalarWhereInput[]
  }

  export type ObjectUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ObjectCreateWithoutZoneInput, ObjectUncheckedCreateWithoutZoneInput> | ObjectCreateWithoutZoneInput[] | ObjectUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutZoneInput | ObjectCreateOrConnectWithoutZoneInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutZoneInput | ObjectUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ObjectCreateManyZoneInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutZoneInput | ObjectUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutZoneInput | ObjectUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutZoneNestedInput = {
    create?: XOR<RoomCreateWithoutZoneInput, RoomUncheckedCreateWithoutZoneInput> | RoomCreateWithoutZoneInput[] | RoomUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutZoneInput | RoomCreateOrConnectWithoutZoneInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutZoneInput | RoomUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: RoomCreateManyZoneInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutZoneInput | RoomUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutZoneInput | RoomUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ShopUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ShopCreateWithoutZoneInput, ShopUncheckedCreateWithoutZoneInput> | ShopCreateWithoutZoneInput[] | ShopUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutZoneInput | ShopCreateOrConnectWithoutZoneInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutZoneInput | ShopUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ShopCreateManyZoneInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutZoneInput | ShopUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutZoneInput | ShopUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type TriggerUpdateManyWithoutZoneNestedInput = {
    create?: XOR<TriggerCreateWithoutZoneInput, TriggerUncheckedCreateWithoutZoneInput> | TriggerCreateWithoutZoneInput[] | TriggerUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutZoneInput | TriggerCreateOrConnectWithoutZoneInput[]
    upsert?: TriggerUpsertWithWhereUniqueWithoutZoneInput | TriggerUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: TriggerCreateManyZoneInputEnvelope
    set?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    disconnect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    delete?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    update?: TriggerUpdateWithWhereUniqueWithoutZoneInput | TriggerUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: TriggerUpdateManyWithWhereWithoutZoneInput | TriggerUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
  }

  export type MobResetUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<MobResetCreateWithoutZoneInput, MobResetUncheckedCreateWithoutZoneInput> | MobResetCreateWithoutZoneInput[] | MobResetUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutZoneInput | MobResetCreateOrConnectWithoutZoneInput[]
    upsert?: MobResetUpsertWithWhereUniqueWithoutZoneInput | MobResetUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: MobResetCreateManyZoneInputEnvelope
    set?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    disconnect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    delete?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    update?: MobResetUpdateWithWhereUniqueWithoutZoneInput | MobResetUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: MobResetUpdateManyWithWhereWithoutZoneInput | MobResetUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: MobResetScalarWhereInput | MobResetScalarWhereInput[]
  }

  export type MobUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<MobCreateWithoutZoneInput, MobUncheckedCreateWithoutZoneInput> | MobCreateWithoutZoneInput[] | MobUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: MobCreateOrConnectWithoutZoneInput | MobCreateOrConnectWithoutZoneInput[]
    upsert?: MobUpsertWithWhereUniqueWithoutZoneInput | MobUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: MobCreateManyZoneInputEnvelope
    set?: MobWhereUniqueInput | MobWhereUniqueInput[]
    disconnect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    delete?: MobWhereUniqueInput | MobWhereUniqueInput[]
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    update?: MobUpdateWithWhereUniqueWithoutZoneInput | MobUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: MobUpdateManyWithWhereWithoutZoneInput | MobUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: MobScalarWhereInput | MobScalarWhereInput[]
  }

  export type ObjectResetUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ObjectResetCreateWithoutZoneInput, ObjectResetUncheckedCreateWithoutZoneInput> | ObjectResetCreateWithoutZoneInput[] | ObjectResetUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutZoneInput | ObjectResetCreateOrConnectWithoutZoneInput[]
    upsert?: ObjectResetUpsertWithWhereUniqueWithoutZoneInput | ObjectResetUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ObjectResetCreateManyZoneInputEnvelope
    set?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    disconnect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    delete?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    update?: ObjectResetUpdateWithWhereUniqueWithoutZoneInput | ObjectResetUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ObjectResetUpdateManyWithWhereWithoutZoneInput | ObjectResetUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ObjectResetScalarWhereInput | ObjectResetScalarWhereInput[]
  }

  export type ObjectUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ObjectCreateWithoutZoneInput, ObjectUncheckedCreateWithoutZoneInput> | ObjectCreateWithoutZoneInput[] | ObjectUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutZoneInput | ObjectCreateOrConnectWithoutZoneInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutZoneInput | ObjectUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ObjectCreateManyZoneInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutZoneInput | ObjectUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutZoneInput | ObjectUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<RoomCreateWithoutZoneInput, RoomUncheckedCreateWithoutZoneInput> | RoomCreateWithoutZoneInput[] | RoomUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutZoneInput | RoomCreateOrConnectWithoutZoneInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutZoneInput | RoomUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: RoomCreateManyZoneInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutZoneInput | RoomUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutZoneInput | RoomUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ShopUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ShopCreateWithoutZoneInput, ShopUncheckedCreateWithoutZoneInput> | ShopCreateWithoutZoneInput[] | ShopUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutZoneInput | ShopCreateOrConnectWithoutZoneInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutZoneInput | ShopUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ShopCreateManyZoneInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutZoneInput | ShopUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutZoneInput | ShopUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type TriggerUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<TriggerCreateWithoutZoneInput, TriggerUncheckedCreateWithoutZoneInput> | TriggerCreateWithoutZoneInput[] | TriggerUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutZoneInput | TriggerCreateOrConnectWithoutZoneInput[]
    upsert?: TriggerUpsertWithWhereUniqueWithoutZoneInput | TriggerUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: TriggerCreateManyZoneInputEnvelope
    set?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    disconnect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    delete?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    update?: TriggerUpdateWithWhereUniqueWithoutZoneInput | TriggerUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: TriggerUpdateManyWithWhereWithoutZoneInput | TriggerUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
  }

  export type RoomCreateflagsInput = {
    set: $Enums.RoomFlag[]
  }

  export type MobResetCreateNestedManyWithoutRoomInput = {
    create?: XOR<MobResetCreateWithoutRoomInput, MobResetUncheckedCreateWithoutRoomInput> | MobResetCreateWithoutRoomInput[] | MobResetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutRoomInput | MobResetCreateOrConnectWithoutRoomInput[]
    createMany?: MobResetCreateManyRoomInputEnvelope
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
  }

  export type ObjectResetCreateNestedManyWithoutRoomInput = {
    create?: XOR<ObjectResetCreateWithoutRoomInput, ObjectResetUncheckedCreateWithoutRoomInput> | ObjectResetCreateWithoutRoomInput[] | ObjectResetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutRoomInput | ObjectResetCreateOrConnectWithoutRoomInput[]
    createMany?: ObjectResetCreateManyRoomInputEnvelope
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
  }

  export type RoomExitCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomExitCreateWithoutRoomInput, RoomExitUncheckedCreateWithoutRoomInput> | RoomExitCreateWithoutRoomInput[] | RoomExitUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomExitCreateOrConnectWithoutRoomInput | RoomExitCreateOrConnectWithoutRoomInput[]
    createMany?: RoomExitCreateManyRoomInputEnvelope
    connect?: RoomExitWhereUniqueInput | RoomExitWhereUniqueInput[]
  }

  export type RoomExtraDescriptionCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomExtraDescriptionCreateWithoutRoomInput, RoomExtraDescriptionUncheckedCreateWithoutRoomInput> | RoomExtraDescriptionCreateWithoutRoomInput[] | RoomExtraDescriptionUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomExtraDescriptionCreateOrConnectWithoutRoomInput | RoomExtraDescriptionCreateOrConnectWithoutRoomInput[]
    createMany?: RoomExtraDescriptionCreateManyRoomInputEnvelope
    connect?: RoomExtraDescriptionWhereUniqueInput | RoomExtraDescriptionWhereUniqueInput[]
  }

  export type ZoneCreateNestedOneWithoutRoomsInput = {
    create?: XOR<ZoneCreateWithoutRoomsInput, ZoneUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutRoomsInput
    connect?: ZoneWhereUniqueInput
  }

  export type MobResetUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<MobResetCreateWithoutRoomInput, MobResetUncheckedCreateWithoutRoomInput> | MobResetCreateWithoutRoomInput[] | MobResetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutRoomInput | MobResetCreateOrConnectWithoutRoomInput[]
    createMany?: MobResetCreateManyRoomInputEnvelope
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
  }

  export type ObjectResetUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<ObjectResetCreateWithoutRoomInput, ObjectResetUncheckedCreateWithoutRoomInput> | ObjectResetCreateWithoutRoomInput[] | ObjectResetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutRoomInput | ObjectResetCreateOrConnectWithoutRoomInput[]
    createMany?: ObjectResetCreateManyRoomInputEnvelope
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
  }

  export type RoomExitUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomExitCreateWithoutRoomInput, RoomExitUncheckedCreateWithoutRoomInput> | RoomExitCreateWithoutRoomInput[] | RoomExitUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomExitCreateOrConnectWithoutRoomInput | RoomExitCreateOrConnectWithoutRoomInput[]
    createMany?: RoomExitCreateManyRoomInputEnvelope
    connect?: RoomExitWhereUniqueInput | RoomExitWhereUniqueInput[]
  }

  export type RoomExtraDescriptionUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomExtraDescriptionCreateWithoutRoomInput, RoomExtraDescriptionUncheckedCreateWithoutRoomInput> | RoomExtraDescriptionCreateWithoutRoomInput[] | RoomExtraDescriptionUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomExtraDescriptionCreateOrConnectWithoutRoomInput | RoomExtraDescriptionCreateOrConnectWithoutRoomInput[]
    createMany?: RoomExtraDescriptionCreateManyRoomInputEnvelope
    connect?: RoomExtraDescriptionWhereUniqueInput | RoomExtraDescriptionWhereUniqueInput[]
  }

  export type EnumSectorFieldUpdateOperationsInput = {
    set?: $Enums.Sector
  }

  export type RoomUpdateflagsInput = {
    set?: $Enums.RoomFlag[]
    push?: $Enums.RoomFlag | $Enums.RoomFlag[]
  }

  export type MobResetUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MobResetCreateWithoutRoomInput, MobResetUncheckedCreateWithoutRoomInput> | MobResetCreateWithoutRoomInput[] | MobResetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutRoomInput | MobResetCreateOrConnectWithoutRoomInput[]
    upsert?: MobResetUpsertWithWhereUniqueWithoutRoomInput | MobResetUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MobResetCreateManyRoomInputEnvelope
    set?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    disconnect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    delete?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    update?: MobResetUpdateWithWhereUniqueWithoutRoomInput | MobResetUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MobResetUpdateManyWithWhereWithoutRoomInput | MobResetUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MobResetScalarWhereInput | MobResetScalarWhereInput[]
  }

  export type ObjectResetUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ObjectResetCreateWithoutRoomInput, ObjectResetUncheckedCreateWithoutRoomInput> | ObjectResetCreateWithoutRoomInput[] | ObjectResetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutRoomInput | ObjectResetCreateOrConnectWithoutRoomInput[]
    upsert?: ObjectResetUpsertWithWhereUniqueWithoutRoomInput | ObjectResetUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ObjectResetCreateManyRoomInputEnvelope
    set?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    disconnect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    delete?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    update?: ObjectResetUpdateWithWhereUniqueWithoutRoomInput | ObjectResetUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ObjectResetUpdateManyWithWhereWithoutRoomInput | ObjectResetUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ObjectResetScalarWhereInput | ObjectResetScalarWhereInput[]
  }

  export type RoomExitUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomExitCreateWithoutRoomInput, RoomExitUncheckedCreateWithoutRoomInput> | RoomExitCreateWithoutRoomInput[] | RoomExitUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomExitCreateOrConnectWithoutRoomInput | RoomExitCreateOrConnectWithoutRoomInput[]
    upsert?: RoomExitUpsertWithWhereUniqueWithoutRoomInput | RoomExitUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomExitCreateManyRoomInputEnvelope
    set?: RoomExitWhereUniqueInput | RoomExitWhereUniqueInput[]
    disconnect?: RoomExitWhereUniqueInput | RoomExitWhereUniqueInput[]
    delete?: RoomExitWhereUniqueInput | RoomExitWhereUniqueInput[]
    connect?: RoomExitWhereUniqueInput | RoomExitWhereUniqueInput[]
    update?: RoomExitUpdateWithWhereUniqueWithoutRoomInput | RoomExitUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomExitUpdateManyWithWhereWithoutRoomInput | RoomExitUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomExitScalarWhereInput | RoomExitScalarWhereInput[]
  }

  export type RoomExtraDescriptionUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomExtraDescriptionCreateWithoutRoomInput, RoomExtraDescriptionUncheckedCreateWithoutRoomInput> | RoomExtraDescriptionCreateWithoutRoomInput[] | RoomExtraDescriptionUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomExtraDescriptionCreateOrConnectWithoutRoomInput | RoomExtraDescriptionCreateOrConnectWithoutRoomInput[]
    upsert?: RoomExtraDescriptionUpsertWithWhereUniqueWithoutRoomInput | RoomExtraDescriptionUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomExtraDescriptionCreateManyRoomInputEnvelope
    set?: RoomExtraDescriptionWhereUniqueInput | RoomExtraDescriptionWhereUniqueInput[]
    disconnect?: RoomExtraDescriptionWhereUniqueInput | RoomExtraDescriptionWhereUniqueInput[]
    delete?: RoomExtraDescriptionWhereUniqueInput | RoomExtraDescriptionWhereUniqueInput[]
    connect?: RoomExtraDescriptionWhereUniqueInput | RoomExtraDescriptionWhereUniqueInput[]
    update?: RoomExtraDescriptionUpdateWithWhereUniqueWithoutRoomInput | RoomExtraDescriptionUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomExtraDescriptionUpdateManyWithWhereWithoutRoomInput | RoomExtraDescriptionUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomExtraDescriptionScalarWhereInput | RoomExtraDescriptionScalarWhereInput[]
  }

  export type ZoneUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<ZoneCreateWithoutRoomsInput, ZoneUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutRoomsInput
    upsert?: ZoneUpsertWithoutRoomsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutRoomsInput, ZoneUpdateWithoutRoomsInput>, ZoneUncheckedUpdateWithoutRoomsInput>
  }

  export type MobResetUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MobResetCreateWithoutRoomInput, MobResetUncheckedCreateWithoutRoomInput> | MobResetCreateWithoutRoomInput[] | MobResetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutRoomInput | MobResetCreateOrConnectWithoutRoomInput[]
    upsert?: MobResetUpsertWithWhereUniqueWithoutRoomInput | MobResetUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MobResetCreateManyRoomInputEnvelope
    set?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    disconnect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    delete?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    update?: MobResetUpdateWithWhereUniqueWithoutRoomInput | MobResetUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MobResetUpdateManyWithWhereWithoutRoomInput | MobResetUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MobResetScalarWhereInput | MobResetScalarWhereInput[]
  }

  export type ObjectResetUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ObjectResetCreateWithoutRoomInput, ObjectResetUncheckedCreateWithoutRoomInput> | ObjectResetCreateWithoutRoomInput[] | ObjectResetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutRoomInput | ObjectResetCreateOrConnectWithoutRoomInput[]
    upsert?: ObjectResetUpsertWithWhereUniqueWithoutRoomInput | ObjectResetUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ObjectResetCreateManyRoomInputEnvelope
    set?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    disconnect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    delete?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    update?: ObjectResetUpdateWithWhereUniqueWithoutRoomInput | ObjectResetUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ObjectResetUpdateManyWithWhereWithoutRoomInput | ObjectResetUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ObjectResetScalarWhereInput | ObjectResetScalarWhereInput[]
  }

  export type RoomExitUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomExitCreateWithoutRoomInput, RoomExitUncheckedCreateWithoutRoomInput> | RoomExitCreateWithoutRoomInput[] | RoomExitUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomExitCreateOrConnectWithoutRoomInput | RoomExitCreateOrConnectWithoutRoomInput[]
    upsert?: RoomExitUpsertWithWhereUniqueWithoutRoomInput | RoomExitUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomExitCreateManyRoomInputEnvelope
    set?: RoomExitWhereUniqueInput | RoomExitWhereUniqueInput[]
    disconnect?: RoomExitWhereUniqueInput | RoomExitWhereUniqueInput[]
    delete?: RoomExitWhereUniqueInput | RoomExitWhereUniqueInput[]
    connect?: RoomExitWhereUniqueInput | RoomExitWhereUniqueInput[]
    update?: RoomExitUpdateWithWhereUniqueWithoutRoomInput | RoomExitUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomExitUpdateManyWithWhereWithoutRoomInput | RoomExitUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomExitScalarWhereInput | RoomExitScalarWhereInput[]
  }

  export type RoomExtraDescriptionUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomExtraDescriptionCreateWithoutRoomInput, RoomExtraDescriptionUncheckedCreateWithoutRoomInput> | RoomExtraDescriptionCreateWithoutRoomInput[] | RoomExtraDescriptionUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomExtraDescriptionCreateOrConnectWithoutRoomInput | RoomExtraDescriptionCreateOrConnectWithoutRoomInput[]
    upsert?: RoomExtraDescriptionUpsertWithWhereUniqueWithoutRoomInput | RoomExtraDescriptionUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomExtraDescriptionCreateManyRoomInputEnvelope
    set?: RoomExtraDescriptionWhereUniqueInput | RoomExtraDescriptionWhereUniqueInput[]
    disconnect?: RoomExtraDescriptionWhereUniqueInput | RoomExtraDescriptionWhereUniqueInput[]
    delete?: RoomExtraDescriptionWhereUniqueInput | RoomExtraDescriptionWhereUniqueInput[]
    connect?: RoomExtraDescriptionWhereUniqueInput | RoomExtraDescriptionWhereUniqueInput[]
    update?: RoomExtraDescriptionUpdateWithWhereUniqueWithoutRoomInput | RoomExtraDescriptionUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomExtraDescriptionUpdateManyWithWhereWithoutRoomInput | RoomExtraDescriptionUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomExtraDescriptionScalarWhereInput | RoomExtraDescriptionScalarWhereInput[]
  }

  export type RoomExitCreateflagsInput = {
    set: $Enums.ExitFlag[]
  }

  export type RoomCreateNestedOneWithoutExitsInput = {
    create?: XOR<RoomCreateWithoutExitsInput, RoomUncheckedCreateWithoutExitsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutExitsInput
    connect?: RoomWhereUniqueInput
  }

  export type EnumDirectionFieldUpdateOperationsInput = {
    set?: $Enums.Direction
  }

  export type RoomExitUpdateflagsInput = {
    set?: $Enums.ExitFlag[]
    push?: $Enums.ExitFlag | $Enums.ExitFlag[]
  }

  export type RoomUpdateOneRequiredWithoutExitsNestedInput = {
    create?: XOR<RoomCreateWithoutExitsInput, RoomUncheckedCreateWithoutExitsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutExitsInput
    upsert?: RoomUpsertWithoutExitsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutExitsInput, RoomUpdateWithoutExitsInput>, RoomUncheckedUpdateWithoutExitsInput>
  }

  export type RoomCreateNestedOneWithoutExtraDescsInput = {
    create?: XOR<RoomCreateWithoutExtraDescsInput, RoomUncheckedCreateWithoutExtraDescsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutExtraDescsInput
    connect?: RoomWhereUniqueInput
  }

  export type RoomUpdateOneRequiredWithoutExtraDescsNestedInput = {
    create?: XOR<RoomCreateWithoutExtraDescsInput, RoomUncheckedCreateWithoutExtraDescsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutExtraDescsInput
    upsert?: RoomUpsertWithoutExtraDescsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutExtraDescsInput, RoomUpdateWithoutExtraDescsInput>, RoomUncheckedUpdateWithoutExtraDescsInput>
  }

  export type MobCreatekeywordsInput = {
    set: string[]
  }

  export type MobCreatemobFlagsInput = {
    set: $Enums.MobFlag[]
  }

  export type MobCreateeffectFlagsInput = {
    set: $Enums.EffectFlag[]
  }

  export type MobResetCreateNestedManyWithoutMobInput = {
    create?: XOR<MobResetCreateWithoutMobInput, MobResetUncheckedCreateWithoutMobInput> | MobResetCreateWithoutMobInput[] | MobResetUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutMobInput | MobResetCreateOrConnectWithoutMobInput[]
    createMany?: MobResetCreateManyMobInputEnvelope
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
  }

  export type MobSkillCreateNestedManyWithoutMobInput = {
    create?: XOR<MobSkillCreateWithoutMobInput, MobSkillUncheckedCreateWithoutMobInput> | MobSkillCreateWithoutMobInput[] | MobSkillUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobSkillCreateOrConnectWithoutMobInput | MobSkillCreateOrConnectWithoutMobInput[]
    createMany?: MobSkillCreateManyMobInputEnvelope
    connect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
  }

  export type MobSpellCreateNestedManyWithoutMobInput = {
    create?: XOR<MobSpellCreateWithoutMobInput, MobSpellUncheckedCreateWithoutMobInput> | MobSpellCreateWithoutMobInput[] | MobSpellUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobSpellCreateOrConnectWithoutMobInput | MobSpellCreateOrConnectWithoutMobInput[]
    createMany?: MobSpellCreateManyMobInputEnvelope
    connect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
  }

  export type GameClassCreateNestedOneWithoutMobsInput = {
    create?: XOR<GameClassCreateWithoutMobsInput, GameClassUncheckedCreateWithoutMobsInput>
    connectOrCreate?: GameClassCreateOrConnectWithoutMobsInput
    connect?: GameClassWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutMobsInput = {
    create?: XOR<ZoneCreateWithoutMobsInput, ZoneUncheckedCreateWithoutMobsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutMobsInput
    connect?: ZoneWhereUniqueInput
  }

  export type ShopCreateNestedManyWithoutKeeperInput = {
    create?: XOR<ShopCreateWithoutKeeperInput, ShopUncheckedCreateWithoutKeeperInput> | ShopCreateWithoutKeeperInput[] | ShopUncheckedCreateWithoutKeeperInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutKeeperInput | ShopCreateOrConnectWithoutKeeperInput[]
    createMany?: ShopCreateManyKeeperInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type TriggerCreateNestedManyWithoutMobInput = {
    create?: XOR<TriggerCreateWithoutMobInput, TriggerUncheckedCreateWithoutMobInput> | TriggerCreateWithoutMobInput[] | TriggerUncheckedCreateWithoutMobInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutMobInput | TriggerCreateOrConnectWithoutMobInput[]
    createMany?: TriggerCreateManyMobInputEnvelope
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
  }

  export type MobResetUncheckedCreateNestedManyWithoutMobInput = {
    create?: XOR<MobResetCreateWithoutMobInput, MobResetUncheckedCreateWithoutMobInput> | MobResetCreateWithoutMobInput[] | MobResetUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutMobInput | MobResetCreateOrConnectWithoutMobInput[]
    createMany?: MobResetCreateManyMobInputEnvelope
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
  }

  export type MobSkillUncheckedCreateNestedManyWithoutMobInput = {
    create?: XOR<MobSkillCreateWithoutMobInput, MobSkillUncheckedCreateWithoutMobInput> | MobSkillCreateWithoutMobInput[] | MobSkillUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobSkillCreateOrConnectWithoutMobInput | MobSkillCreateOrConnectWithoutMobInput[]
    createMany?: MobSkillCreateManyMobInputEnvelope
    connect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
  }

  export type MobSpellUncheckedCreateNestedManyWithoutMobInput = {
    create?: XOR<MobSpellCreateWithoutMobInput, MobSpellUncheckedCreateWithoutMobInput> | MobSpellCreateWithoutMobInput[] | MobSpellUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobSpellCreateOrConnectWithoutMobInput | MobSpellCreateOrConnectWithoutMobInput[]
    createMany?: MobSpellCreateManyMobInputEnvelope
    connect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
  }

  export type ShopUncheckedCreateNestedManyWithoutKeeperInput = {
    create?: XOR<ShopCreateWithoutKeeperInput, ShopUncheckedCreateWithoutKeeperInput> | ShopCreateWithoutKeeperInput[] | ShopUncheckedCreateWithoutKeeperInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutKeeperInput | ShopCreateOrConnectWithoutKeeperInput[]
    createMany?: ShopCreateManyKeeperInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type TriggerUncheckedCreateNestedManyWithoutMobInput = {
    create?: XOR<TriggerCreateWithoutMobInput, TriggerUncheckedCreateWithoutMobInput> | TriggerCreateWithoutMobInput[] | TriggerUncheckedCreateWithoutMobInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutMobInput | TriggerCreateOrConnectWithoutMobInput[]
    createMany?: TriggerCreateManyMobInputEnvelope
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
  }

  export type MobUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MobUpdatemobFlagsInput = {
    set?: $Enums.MobFlag[]
    push?: $Enums.MobFlag | $Enums.MobFlag[]
  }

  export type MobUpdateeffectFlagsInput = {
    set?: $Enums.EffectFlag[]
    push?: $Enums.EffectFlag | $Enums.EffectFlag[]
  }

  export type EnumPositionFieldUpdateOperationsInput = {
    set?: $Enums.Position
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type EnumSizeFieldUpdateOperationsInput = {
    set?: $Enums.Size
  }

  export type EnumLifeForceFieldUpdateOperationsInput = {
    set?: $Enums.LifeForce
  }

  export type EnumCompositionFieldUpdateOperationsInput = {
    set?: $Enums.Composition
  }

  export type EnumStanceFieldUpdateOperationsInput = {
    set?: $Enums.Stance
  }

  export type EnumDamageTypeFieldUpdateOperationsInput = {
    set?: $Enums.DamageType
  }

  export type MobResetUpdateManyWithoutMobNestedInput = {
    create?: XOR<MobResetCreateWithoutMobInput, MobResetUncheckedCreateWithoutMobInput> | MobResetCreateWithoutMobInput[] | MobResetUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutMobInput | MobResetCreateOrConnectWithoutMobInput[]
    upsert?: MobResetUpsertWithWhereUniqueWithoutMobInput | MobResetUpsertWithWhereUniqueWithoutMobInput[]
    createMany?: MobResetCreateManyMobInputEnvelope
    set?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    disconnect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    delete?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    update?: MobResetUpdateWithWhereUniqueWithoutMobInput | MobResetUpdateWithWhereUniqueWithoutMobInput[]
    updateMany?: MobResetUpdateManyWithWhereWithoutMobInput | MobResetUpdateManyWithWhereWithoutMobInput[]
    deleteMany?: MobResetScalarWhereInput | MobResetScalarWhereInput[]
  }

  export type MobSkillUpdateManyWithoutMobNestedInput = {
    create?: XOR<MobSkillCreateWithoutMobInput, MobSkillUncheckedCreateWithoutMobInput> | MobSkillCreateWithoutMobInput[] | MobSkillUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobSkillCreateOrConnectWithoutMobInput | MobSkillCreateOrConnectWithoutMobInput[]
    upsert?: MobSkillUpsertWithWhereUniqueWithoutMobInput | MobSkillUpsertWithWhereUniqueWithoutMobInput[]
    createMany?: MobSkillCreateManyMobInputEnvelope
    set?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    disconnect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    delete?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    connect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    update?: MobSkillUpdateWithWhereUniqueWithoutMobInput | MobSkillUpdateWithWhereUniqueWithoutMobInput[]
    updateMany?: MobSkillUpdateManyWithWhereWithoutMobInput | MobSkillUpdateManyWithWhereWithoutMobInput[]
    deleteMany?: MobSkillScalarWhereInput | MobSkillScalarWhereInput[]
  }

  export type MobSpellUpdateManyWithoutMobNestedInput = {
    create?: XOR<MobSpellCreateWithoutMobInput, MobSpellUncheckedCreateWithoutMobInput> | MobSpellCreateWithoutMobInput[] | MobSpellUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobSpellCreateOrConnectWithoutMobInput | MobSpellCreateOrConnectWithoutMobInput[]
    upsert?: MobSpellUpsertWithWhereUniqueWithoutMobInput | MobSpellUpsertWithWhereUniqueWithoutMobInput[]
    createMany?: MobSpellCreateManyMobInputEnvelope
    set?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    disconnect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    delete?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    connect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    update?: MobSpellUpdateWithWhereUniqueWithoutMobInput | MobSpellUpdateWithWhereUniqueWithoutMobInput[]
    updateMany?: MobSpellUpdateManyWithWhereWithoutMobInput | MobSpellUpdateManyWithWhereWithoutMobInput[]
    deleteMany?: MobSpellScalarWhereInput | MobSpellScalarWhereInput[]
  }

  export type GameClassUpdateOneWithoutMobsNestedInput = {
    create?: XOR<GameClassCreateWithoutMobsInput, GameClassUncheckedCreateWithoutMobsInput>
    connectOrCreate?: GameClassCreateOrConnectWithoutMobsInput
    upsert?: GameClassUpsertWithoutMobsInput
    disconnect?: GameClassWhereInput | boolean
    delete?: GameClassWhereInput | boolean
    connect?: GameClassWhereUniqueInput
    update?: XOR<XOR<GameClassUpdateToOneWithWhereWithoutMobsInput, GameClassUpdateWithoutMobsInput>, GameClassUncheckedUpdateWithoutMobsInput>
  }

  export type ZoneUpdateOneRequiredWithoutMobsNestedInput = {
    create?: XOR<ZoneCreateWithoutMobsInput, ZoneUncheckedCreateWithoutMobsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutMobsInput
    upsert?: ZoneUpsertWithoutMobsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutMobsInput, ZoneUpdateWithoutMobsInput>, ZoneUncheckedUpdateWithoutMobsInput>
  }

  export type ShopUpdateManyWithoutKeeperNestedInput = {
    create?: XOR<ShopCreateWithoutKeeperInput, ShopUncheckedCreateWithoutKeeperInput> | ShopCreateWithoutKeeperInput[] | ShopUncheckedCreateWithoutKeeperInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutKeeperInput | ShopCreateOrConnectWithoutKeeperInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutKeeperInput | ShopUpsertWithWhereUniqueWithoutKeeperInput[]
    createMany?: ShopCreateManyKeeperInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutKeeperInput | ShopUpdateWithWhereUniqueWithoutKeeperInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutKeeperInput | ShopUpdateManyWithWhereWithoutKeeperInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type TriggerUpdateManyWithoutMobNestedInput = {
    create?: XOR<TriggerCreateWithoutMobInput, TriggerUncheckedCreateWithoutMobInput> | TriggerCreateWithoutMobInput[] | TriggerUncheckedCreateWithoutMobInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutMobInput | TriggerCreateOrConnectWithoutMobInput[]
    upsert?: TriggerUpsertWithWhereUniqueWithoutMobInput | TriggerUpsertWithWhereUniqueWithoutMobInput[]
    createMany?: TriggerCreateManyMobInputEnvelope
    set?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    disconnect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    delete?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    update?: TriggerUpdateWithWhereUniqueWithoutMobInput | TriggerUpdateWithWhereUniqueWithoutMobInput[]
    updateMany?: TriggerUpdateManyWithWhereWithoutMobInput | TriggerUpdateManyWithWhereWithoutMobInput[]
    deleteMany?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
  }

  export type MobResetUncheckedUpdateManyWithoutMobNestedInput = {
    create?: XOR<MobResetCreateWithoutMobInput, MobResetUncheckedCreateWithoutMobInput> | MobResetCreateWithoutMobInput[] | MobResetUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobResetCreateOrConnectWithoutMobInput | MobResetCreateOrConnectWithoutMobInput[]
    upsert?: MobResetUpsertWithWhereUniqueWithoutMobInput | MobResetUpsertWithWhereUniqueWithoutMobInput[]
    createMany?: MobResetCreateManyMobInputEnvelope
    set?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    disconnect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    delete?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    connect?: MobResetWhereUniqueInput | MobResetWhereUniqueInput[]
    update?: MobResetUpdateWithWhereUniqueWithoutMobInput | MobResetUpdateWithWhereUniqueWithoutMobInput[]
    updateMany?: MobResetUpdateManyWithWhereWithoutMobInput | MobResetUpdateManyWithWhereWithoutMobInput[]
    deleteMany?: MobResetScalarWhereInput | MobResetScalarWhereInput[]
  }

  export type MobSkillUncheckedUpdateManyWithoutMobNestedInput = {
    create?: XOR<MobSkillCreateWithoutMobInput, MobSkillUncheckedCreateWithoutMobInput> | MobSkillCreateWithoutMobInput[] | MobSkillUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobSkillCreateOrConnectWithoutMobInput | MobSkillCreateOrConnectWithoutMobInput[]
    upsert?: MobSkillUpsertWithWhereUniqueWithoutMobInput | MobSkillUpsertWithWhereUniqueWithoutMobInput[]
    createMany?: MobSkillCreateManyMobInputEnvelope
    set?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    disconnect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    delete?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    connect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    update?: MobSkillUpdateWithWhereUniqueWithoutMobInput | MobSkillUpdateWithWhereUniqueWithoutMobInput[]
    updateMany?: MobSkillUpdateManyWithWhereWithoutMobInput | MobSkillUpdateManyWithWhereWithoutMobInput[]
    deleteMany?: MobSkillScalarWhereInput | MobSkillScalarWhereInput[]
  }

  export type MobSpellUncheckedUpdateManyWithoutMobNestedInput = {
    create?: XOR<MobSpellCreateWithoutMobInput, MobSpellUncheckedCreateWithoutMobInput> | MobSpellCreateWithoutMobInput[] | MobSpellUncheckedCreateWithoutMobInput[]
    connectOrCreate?: MobSpellCreateOrConnectWithoutMobInput | MobSpellCreateOrConnectWithoutMobInput[]
    upsert?: MobSpellUpsertWithWhereUniqueWithoutMobInput | MobSpellUpsertWithWhereUniqueWithoutMobInput[]
    createMany?: MobSpellCreateManyMobInputEnvelope
    set?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    disconnect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    delete?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    connect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    update?: MobSpellUpdateWithWhereUniqueWithoutMobInput | MobSpellUpdateWithWhereUniqueWithoutMobInput[]
    updateMany?: MobSpellUpdateManyWithWhereWithoutMobInput | MobSpellUpdateManyWithWhereWithoutMobInput[]
    deleteMany?: MobSpellScalarWhereInput | MobSpellScalarWhereInput[]
  }

  export type ShopUncheckedUpdateManyWithoutKeeperNestedInput = {
    create?: XOR<ShopCreateWithoutKeeperInput, ShopUncheckedCreateWithoutKeeperInput> | ShopCreateWithoutKeeperInput[] | ShopUncheckedCreateWithoutKeeperInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutKeeperInput | ShopCreateOrConnectWithoutKeeperInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutKeeperInput | ShopUpsertWithWhereUniqueWithoutKeeperInput[]
    createMany?: ShopCreateManyKeeperInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutKeeperInput | ShopUpdateWithWhereUniqueWithoutKeeperInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutKeeperInput | ShopUpdateManyWithWhereWithoutKeeperInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type TriggerUncheckedUpdateManyWithoutMobNestedInput = {
    create?: XOR<TriggerCreateWithoutMobInput, TriggerUncheckedCreateWithoutMobInput> | TriggerCreateWithoutMobInput[] | TriggerUncheckedCreateWithoutMobInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutMobInput | TriggerCreateOrConnectWithoutMobInput[]
    upsert?: TriggerUpsertWithWhereUniqueWithoutMobInput | TriggerUpsertWithWhereUniqueWithoutMobInput[]
    createMany?: TriggerCreateManyMobInputEnvelope
    set?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    disconnect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    delete?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    update?: TriggerUpdateWithWhereUniqueWithoutMobInput | TriggerUpdateWithWhereUniqueWithoutMobInput[]
    updateMany?: TriggerUpdateManyWithWhereWithoutMobInput | TriggerUpdateManyWithWhereWithoutMobInput[]
    deleteMany?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
  }

  export type MobCreateNestedOneWithoutSkillsInput = {
    create?: XOR<MobCreateWithoutSkillsInput, MobUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: MobCreateOrConnectWithoutSkillsInput
    connect?: MobWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutMobSkillsInput = {
    create?: XOR<SkillCreateWithoutMobSkillsInput, SkillUncheckedCreateWithoutMobSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutMobSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type MobUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<MobCreateWithoutSkillsInput, MobUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: MobCreateOrConnectWithoutSkillsInput
    upsert?: MobUpsertWithoutSkillsInput
    connect?: MobWhereUniqueInput
    update?: XOR<XOR<MobUpdateToOneWithWhereWithoutSkillsInput, MobUpdateWithoutSkillsInput>, MobUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutMobSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutMobSkillsInput, SkillUncheckedCreateWithoutMobSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutMobSkillsInput
    upsert?: SkillUpsertWithoutMobSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutMobSkillsInput, SkillUpdateWithoutMobSkillsInput>, SkillUncheckedUpdateWithoutMobSkillsInput>
  }

  export type MobCreateNestedOneWithoutSpellsInput = {
    create?: XOR<MobCreateWithoutSpellsInput, MobUncheckedCreateWithoutSpellsInput>
    connectOrCreate?: MobCreateOrConnectWithoutSpellsInput
    connect?: MobWhereUniqueInput
  }

  export type SpellCreateNestedOneWithoutMobSpellsInput = {
    create?: XOR<SpellCreateWithoutMobSpellsInput, SpellUncheckedCreateWithoutMobSpellsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutMobSpellsInput
    connect?: SpellWhereUniqueInput
  }

  export type MobUpdateOneRequiredWithoutSpellsNestedInput = {
    create?: XOR<MobCreateWithoutSpellsInput, MobUncheckedCreateWithoutSpellsInput>
    connectOrCreate?: MobCreateOrConnectWithoutSpellsInput
    upsert?: MobUpsertWithoutSpellsInput
    connect?: MobWhereUniqueInput
    update?: XOR<XOR<MobUpdateToOneWithWhereWithoutSpellsInput, MobUpdateWithoutSpellsInput>, MobUncheckedUpdateWithoutSpellsInput>
  }

  export type SpellUpdateOneRequiredWithoutMobSpellsNestedInput = {
    create?: XOR<SpellCreateWithoutMobSpellsInput, SpellUncheckedCreateWithoutMobSpellsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutMobSpellsInput
    upsert?: SpellUpsertWithoutMobSpellsInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutMobSpellsInput, SpellUpdateWithoutMobSpellsInput>, SpellUncheckedUpdateWithoutMobSpellsInput>
  }

  export type MobCarryingCreateNestedManyWithoutResetInput = {
    create?: XOR<MobCarryingCreateWithoutResetInput, MobCarryingUncheckedCreateWithoutResetInput> | MobCarryingCreateWithoutResetInput[] | MobCarryingUncheckedCreateWithoutResetInput[]
    connectOrCreate?: MobCarryingCreateOrConnectWithoutResetInput | MobCarryingCreateOrConnectWithoutResetInput[]
    createMany?: MobCarryingCreateManyResetInputEnvelope
    connect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
  }

  export type MobEquipmentSetCreateNestedManyWithoutMobResetInput = {
    create?: XOR<MobEquipmentSetCreateWithoutMobResetInput, MobEquipmentSetUncheckedCreateWithoutMobResetInput> | MobEquipmentSetCreateWithoutMobResetInput[] | MobEquipmentSetUncheckedCreateWithoutMobResetInput[]
    connectOrCreate?: MobEquipmentSetCreateOrConnectWithoutMobResetInput | MobEquipmentSetCreateOrConnectWithoutMobResetInput[]
    createMany?: MobEquipmentSetCreateManyMobResetInputEnvelope
    connect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
  }

  export type MobEquippedCreateNestedManyWithoutResetInput = {
    create?: XOR<MobEquippedCreateWithoutResetInput, MobEquippedUncheckedCreateWithoutResetInput> | MobEquippedCreateWithoutResetInput[] | MobEquippedUncheckedCreateWithoutResetInput[]
    connectOrCreate?: MobEquippedCreateOrConnectWithoutResetInput | MobEquippedCreateOrConnectWithoutResetInput[]
    createMany?: MobEquippedCreateManyResetInputEnvelope
    connect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
  }

  export type MobCreateNestedOneWithoutResetsInput = {
    create?: XOR<MobCreateWithoutResetsInput, MobUncheckedCreateWithoutResetsInput>
    connectOrCreate?: MobCreateOrConnectWithoutResetsInput
    connect?: MobWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutMobResetsInput = {
    create?: XOR<RoomCreateWithoutMobResetsInput, RoomUncheckedCreateWithoutMobResetsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutMobResetsInput
    connect?: RoomWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutMobResetsInput = {
    create?: XOR<ZoneCreateWithoutMobResetsInput, ZoneUncheckedCreateWithoutMobResetsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutMobResetsInput
    connect?: ZoneWhereUniqueInput
  }

  export type SpawnConditionCreateNestedManyWithoutMobResetInput = {
    create?: XOR<SpawnConditionCreateWithoutMobResetInput, SpawnConditionUncheckedCreateWithoutMobResetInput> | SpawnConditionCreateWithoutMobResetInput[] | SpawnConditionUncheckedCreateWithoutMobResetInput[]
    connectOrCreate?: SpawnConditionCreateOrConnectWithoutMobResetInput | SpawnConditionCreateOrConnectWithoutMobResetInput[]
    createMany?: SpawnConditionCreateManyMobResetInputEnvelope
    connect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
  }

  export type MobCarryingUncheckedCreateNestedManyWithoutResetInput = {
    create?: XOR<MobCarryingCreateWithoutResetInput, MobCarryingUncheckedCreateWithoutResetInput> | MobCarryingCreateWithoutResetInput[] | MobCarryingUncheckedCreateWithoutResetInput[]
    connectOrCreate?: MobCarryingCreateOrConnectWithoutResetInput | MobCarryingCreateOrConnectWithoutResetInput[]
    createMany?: MobCarryingCreateManyResetInputEnvelope
    connect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
  }

  export type MobEquipmentSetUncheckedCreateNestedManyWithoutMobResetInput = {
    create?: XOR<MobEquipmentSetCreateWithoutMobResetInput, MobEquipmentSetUncheckedCreateWithoutMobResetInput> | MobEquipmentSetCreateWithoutMobResetInput[] | MobEquipmentSetUncheckedCreateWithoutMobResetInput[]
    connectOrCreate?: MobEquipmentSetCreateOrConnectWithoutMobResetInput | MobEquipmentSetCreateOrConnectWithoutMobResetInput[]
    createMany?: MobEquipmentSetCreateManyMobResetInputEnvelope
    connect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
  }

  export type MobEquippedUncheckedCreateNestedManyWithoutResetInput = {
    create?: XOR<MobEquippedCreateWithoutResetInput, MobEquippedUncheckedCreateWithoutResetInput> | MobEquippedCreateWithoutResetInput[] | MobEquippedUncheckedCreateWithoutResetInput[]
    connectOrCreate?: MobEquippedCreateOrConnectWithoutResetInput | MobEquippedCreateOrConnectWithoutResetInput[]
    createMany?: MobEquippedCreateManyResetInputEnvelope
    connect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
  }

  export type SpawnConditionUncheckedCreateNestedManyWithoutMobResetInput = {
    create?: XOR<SpawnConditionCreateWithoutMobResetInput, SpawnConditionUncheckedCreateWithoutMobResetInput> | SpawnConditionCreateWithoutMobResetInput[] | SpawnConditionUncheckedCreateWithoutMobResetInput[]
    connectOrCreate?: SpawnConditionCreateOrConnectWithoutMobResetInput | SpawnConditionCreateOrConnectWithoutMobResetInput[]
    createMany?: SpawnConditionCreateManyMobResetInputEnvelope
    connect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MobCarryingUpdateManyWithoutResetNestedInput = {
    create?: XOR<MobCarryingCreateWithoutResetInput, MobCarryingUncheckedCreateWithoutResetInput> | MobCarryingCreateWithoutResetInput[] | MobCarryingUncheckedCreateWithoutResetInput[]
    connectOrCreate?: MobCarryingCreateOrConnectWithoutResetInput | MobCarryingCreateOrConnectWithoutResetInput[]
    upsert?: MobCarryingUpsertWithWhereUniqueWithoutResetInput | MobCarryingUpsertWithWhereUniqueWithoutResetInput[]
    createMany?: MobCarryingCreateManyResetInputEnvelope
    set?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    disconnect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    delete?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    connect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    update?: MobCarryingUpdateWithWhereUniqueWithoutResetInput | MobCarryingUpdateWithWhereUniqueWithoutResetInput[]
    updateMany?: MobCarryingUpdateManyWithWhereWithoutResetInput | MobCarryingUpdateManyWithWhereWithoutResetInput[]
    deleteMany?: MobCarryingScalarWhereInput | MobCarryingScalarWhereInput[]
  }

  export type MobEquipmentSetUpdateManyWithoutMobResetNestedInput = {
    create?: XOR<MobEquipmentSetCreateWithoutMobResetInput, MobEquipmentSetUncheckedCreateWithoutMobResetInput> | MobEquipmentSetCreateWithoutMobResetInput[] | MobEquipmentSetUncheckedCreateWithoutMobResetInput[]
    connectOrCreate?: MobEquipmentSetCreateOrConnectWithoutMobResetInput | MobEquipmentSetCreateOrConnectWithoutMobResetInput[]
    upsert?: MobEquipmentSetUpsertWithWhereUniqueWithoutMobResetInput | MobEquipmentSetUpsertWithWhereUniqueWithoutMobResetInput[]
    createMany?: MobEquipmentSetCreateManyMobResetInputEnvelope
    set?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    disconnect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    delete?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    connect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    update?: MobEquipmentSetUpdateWithWhereUniqueWithoutMobResetInput | MobEquipmentSetUpdateWithWhereUniqueWithoutMobResetInput[]
    updateMany?: MobEquipmentSetUpdateManyWithWhereWithoutMobResetInput | MobEquipmentSetUpdateManyWithWhereWithoutMobResetInput[]
    deleteMany?: MobEquipmentSetScalarWhereInput | MobEquipmentSetScalarWhereInput[]
  }

  export type MobEquippedUpdateManyWithoutResetNestedInput = {
    create?: XOR<MobEquippedCreateWithoutResetInput, MobEquippedUncheckedCreateWithoutResetInput> | MobEquippedCreateWithoutResetInput[] | MobEquippedUncheckedCreateWithoutResetInput[]
    connectOrCreate?: MobEquippedCreateOrConnectWithoutResetInput | MobEquippedCreateOrConnectWithoutResetInput[]
    upsert?: MobEquippedUpsertWithWhereUniqueWithoutResetInput | MobEquippedUpsertWithWhereUniqueWithoutResetInput[]
    createMany?: MobEquippedCreateManyResetInputEnvelope
    set?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    disconnect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    delete?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    connect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    update?: MobEquippedUpdateWithWhereUniqueWithoutResetInput | MobEquippedUpdateWithWhereUniqueWithoutResetInput[]
    updateMany?: MobEquippedUpdateManyWithWhereWithoutResetInput | MobEquippedUpdateManyWithWhereWithoutResetInput[]
    deleteMany?: MobEquippedScalarWhereInput | MobEquippedScalarWhereInput[]
  }

  export type MobUpdateOneRequiredWithoutResetsNestedInput = {
    create?: XOR<MobCreateWithoutResetsInput, MobUncheckedCreateWithoutResetsInput>
    connectOrCreate?: MobCreateOrConnectWithoutResetsInput
    upsert?: MobUpsertWithoutResetsInput
    connect?: MobWhereUniqueInput
    update?: XOR<XOR<MobUpdateToOneWithWhereWithoutResetsInput, MobUpdateWithoutResetsInput>, MobUncheckedUpdateWithoutResetsInput>
  }

  export type RoomUpdateOneRequiredWithoutMobResetsNestedInput = {
    create?: XOR<RoomCreateWithoutMobResetsInput, RoomUncheckedCreateWithoutMobResetsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutMobResetsInput
    upsert?: RoomUpsertWithoutMobResetsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutMobResetsInput, RoomUpdateWithoutMobResetsInput>, RoomUncheckedUpdateWithoutMobResetsInput>
  }

  export type ZoneUpdateOneRequiredWithoutMobResetsNestedInput = {
    create?: XOR<ZoneCreateWithoutMobResetsInput, ZoneUncheckedCreateWithoutMobResetsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutMobResetsInput
    upsert?: ZoneUpsertWithoutMobResetsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutMobResetsInput, ZoneUpdateWithoutMobResetsInput>, ZoneUncheckedUpdateWithoutMobResetsInput>
  }

  export type SpawnConditionUpdateManyWithoutMobResetNestedInput = {
    create?: XOR<SpawnConditionCreateWithoutMobResetInput, SpawnConditionUncheckedCreateWithoutMobResetInput> | SpawnConditionCreateWithoutMobResetInput[] | SpawnConditionUncheckedCreateWithoutMobResetInput[]
    connectOrCreate?: SpawnConditionCreateOrConnectWithoutMobResetInput | SpawnConditionCreateOrConnectWithoutMobResetInput[]
    upsert?: SpawnConditionUpsertWithWhereUniqueWithoutMobResetInput | SpawnConditionUpsertWithWhereUniqueWithoutMobResetInput[]
    createMany?: SpawnConditionCreateManyMobResetInputEnvelope
    set?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    disconnect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    delete?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    connect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    update?: SpawnConditionUpdateWithWhereUniqueWithoutMobResetInput | SpawnConditionUpdateWithWhereUniqueWithoutMobResetInput[]
    updateMany?: SpawnConditionUpdateManyWithWhereWithoutMobResetInput | SpawnConditionUpdateManyWithWhereWithoutMobResetInput[]
    deleteMany?: SpawnConditionScalarWhereInput | SpawnConditionScalarWhereInput[]
  }

  export type MobCarryingUncheckedUpdateManyWithoutResetNestedInput = {
    create?: XOR<MobCarryingCreateWithoutResetInput, MobCarryingUncheckedCreateWithoutResetInput> | MobCarryingCreateWithoutResetInput[] | MobCarryingUncheckedCreateWithoutResetInput[]
    connectOrCreate?: MobCarryingCreateOrConnectWithoutResetInput | MobCarryingCreateOrConnectWithoutResetInput[]
    upsert?: MobCarryingUpsertWithWhereUniqueWithoutResetInput | MobCarryingUpsertWithWhereUniqueWithoutResetInput[]
    createMany?: MobCarryingCreateManyResetInputEnvelope
    set?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    disconnect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    delete?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    connect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    update?: MobCarryingUpdateWithWhereUniqueWithoutResetInput | MobCarryingUpdateWithWhereUniqueWithoutResetInput[]
    updateMany?: MobCarryingUpdateManyWithWhereWithoutResetInput | MobCarryingUpdateManyWithWhereWithoutResetInput[]
    deleteMany?: MobCarryingScalarWhereInput | MobCarryingScalarWhereInput[]
  }

  export type MobEquipmentSetUncheckedUpdateManyWithoutMobResetNestedInput = {
    create?: XOR<MobEquipmentSetCreateWithoutMobResetInput, MobEquipmentSetUncheckedCreateWithoutMobResetInput> | MobEquipmentSetCreateWithoutMobResetInput[] | MobEquipmentSetUncheckedCreateWithoutMobResetInput[]
    connectOrCreate?: MobEquipmentSetCreateOrConnectWithoutMobResetInput | MobEquipmentSetCreateOrConnectWithoutMobResetInput[]
    upsert?: MobEquipmentSetUpsertWithWhereUniqueWithoutMobResetInput | MobEquipmentSetUpsertWithWhereUniqueWithoutMobResetInput[]
    createMany?: MobEquipmentSetCreateManyMobResetInputEnvelope
    set?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    disconnect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    delete?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    connect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    update?: MobEquipmentSetUpdateWithWhereUniqueWithoutMobResetInput | MobEquipmentSetUpdateWithWhereUniqueWithoutMobResetInput[]
    updateMany?: MobEquipmentSetUpdateManyWithWhereWithoutMobResetInput | MobEquipmentSetUpdateManyWithWhereWithoutMobResetInput[]
    deleteMany?: MobEquipmentSetScalarWhereInput | MobEquipmentSetScalarWhereInput[]
  }

  export type MobEquippedUncheckedUpdateManyWithoutResetNestedInput = {
    create?: XOR<MobEquippedCreateWithoutResetInput, MobEquippedUncheckedCreateWithoutResetInput> | MobEquippedCreateWithoutResetInput[] | MobEquippedUncheckedCreateWithoutResetInput[]
    connectOrCreate?: MobEquippedCreateOrConnectWithoutResetInput | MobEquippedCreateOrConnectWithoutResetInput[]
    upsert?: MobEquippedUpsertWithWhereUniqueWithoutResetInput | MobEquippedUpsertWithWhereUniqueWithoutResetInput[]
    createMany?: MobEquippedCreateManyResetInputEnvelope
    set?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    disconnect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    delete?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    connect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    update?: MobEquippedUpdateWithWhereUniqueWithoutResetInput | MobEquippedUpdateWithWhereUniqueWithoutResetInput[]
    updateMany?: MobEquippedUpdateManyWithWhereWithoutResetInput | MobEquippedUpdateManyWithWhereWithoutResetInput[]
    deleteMany?: MobEquippedScalarWhereInput | MobEquippedScalarWhereInput[]
  }

  export type SpawnConditionUncheckedUpdateManyWithoutMobResetNestedInput = {
    create?: XOR<SpawnConditionCreateWithoutMobResetInput, SpawnConditionUncheckedCreateWithoutMobResetInput> | SpawnConditionCreateWithoutMobResetInput[] | SpawnConditionUncheckedCreateWithoutMobResetInput[]
    connectOrCreate?: SpawnConditionCreateOrConnectWithoutMobResetInput | SpawnConditionCreateOrConnectWithoutMobResetInput[]
    upsert?: SpawnConditionUpsertWithWhereUniqueWithoutMobResetInput | SpawnConditionUpsertWithWhereUniqueWithoutMobResetInput[]
    createMany?: SpawnConditionCreateManyMobResetInputEnvelope
    set?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    disconnect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    delete?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    connect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    update?: SpawnConditionUpdateWithWhereUniqueWithoutMobResetInput | SpawnConditionUpdateWithWhereUniqueWithoutMobResetInput[]
    updateMany?: SpawnConditionUpdateManyWithWhereWithoutMobResetInput | SpawnConditionUpdateManyWithWhereWithoutMobResetInput[]
    deleteMany?: SpawnConditionScalarWhereInput | SpawnConditionScalarWhereInput[]
  }

  export type ObjectCreateNestedOneWithoutMobCarryingInput = {
    create?: XOR<ObjectCreateWithoutMobCarryingInput, ObjectUncheckedCreateWithoutMobCarryingInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutMobCarryingInput
    connect?: ObjectWhereUniqueInput
  }

  export type MobResetCreateNestedOneWithoutCarryingInput = {
    create?: XOR<MobResetCreateWithoutCarryingInput, MobResetUncheckedCreateWithoutCarryingInput>
    connectOrCreate?: MobResetCreateOrConnectWithoutCarryingInput
    connect?: MobResetWhereUniqueInput
  }

  export type ObjectUpdateOneRequiredWithoutMobCarryingNestedInput = {
    create?: XOR<ObjectCreateWithoutMobCarryingInput, ObjectUncheckedCreateWithoutMobCarryingInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutMobCarryingInput
    upsert?: ObjectUpsertWithoutMobCarryingInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutMobCarryingInput, ObjectUpdateWithoutMobCarryingInput>, ObjectUncheckedUpdateWithoutMobCarryingInput>
  }

  export type MobResetUpdateOneRequiredWithoutCarryingNestedInput = {
    create?: XOR<MobResetCreateWithoutCarryingInput, MobResetUncheckedCreateWithoutCarryingInput>
    connectOrCreate?: MobResetCreateOrConnectWithoutCarryingInput
    upsert?: MobResetUpsertWithoutCarryingInput
    connect?: MobResetWhereUniqueInput
    update?: XOR<XOR<MobResetUpdateToOneWithWhereWithoutCarryingInput, MobResetUpdateWithoutCarryingInput>, MobResetUncheckedUpdateWithoutCarryingInput>
  }

  export type ObjectCreateNestedOneWithoutMobEquippedInput = {
    create?: XOR<ObjectCreateWithoutMobEquippedInput, ObjectUncheckedCreateWithoutMobEquippedInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutMobEquippedInput
    connect?: ObjectWhereUniqueInput
  }

  export type MobResetCreateNestedOneWithoutEquippedInput = {
    create?: XOR<MobResetCreateWithoutEquippedInput, MobResetUncheckedCreateWithoutEquippedInput>
    connectOrCreate?: MobResetCreateOrConnectWithoutEquippedInput
    connect?: MobResetWhereUniqueInput
  }

  export type ObjectUpdateOneRequiredWithoutMobEquippedNestedInput = {
    create?: XOR<ObjectCreateWithoutMobEquippedInput, ObjectUncheckedCreateWithoutMobEquippedInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutMobEquippedInput
    upsert?: ObjectUpsertWithoutMobEquippedInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutMobEquippedInput, ObjectUpdateWithoutMobEquippedInput>, ObjectUncheckedUpdateWithoutMobEquippedInput>
  }

  export type MobResetUpdateOneRequiredWithoutEquippedNestedInput = {
    create?: XOR<MobResetCreateWithoutEquippedInput, MobResetUncheckedCreateWithoutEquippedInput>
    connectOrCreate?: MobResetCreateOrConnectWithoutEquippedInput
    upsert?: MobResetUpsertWithoutEquippedInput
    connect?: MobResetWhereUniqueInput
    update?: XOR<XOR<MobResetUpdateToOneWithWhereWithoutEquippedInput, MobResetUpdateWithoutEquippedInput>, MobResetUncheckedUpdateWithoutEquippedInput>
  }

  export type ObjectCreatekeywordsInput = {
    set: string[]
  }

  export type ObjectCreateflagsInput = {
    set: $Enums.ObjectFlag[]
  }

  export type ObjectCreateeffectFlagsInput = {
    set: $Enums.EffectFlag[]
  }

  export type ObjectCreatewearFlagsInput = {
    set: $Enums.WearFlag[]
  }

  export type CharacterItemCreateNestedManyWithoutObjectInput = {
    create?: XOR<CharacterItemCreateWithoutObjectInput, CharacterItemUncheckedCreateWithoutObjectInput> | CharacterItemCreateWithoutObjectInput[] | CharacterItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutObjectInput | CharacterItemCreateOrConnectWithoutObjectInput[]
    createMany?: CharacterItemCreateManyObjectInputEnvelope
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
  }

  export type EquipmentSetItemCreateNestedManyWithoutObjectInput = {
    create?: XOR<EquipmentSetItemCreateWithoutObjectInput, EquipmentSetItemUncheckedCreateWithoutObjectInput> | EquipmentSetItemCreateWithoutObjectInput[] | EquipmentSetItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: EquipmentSetItemCreateOrConnectWithoutObjectInput | EquipmentSetItemCreateOrConnectWithoutObjectInput[]
    createMany?: EquipmentSetItemCreateManyObjectInputEnvelope
    connect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
  }

  export type MobCarryingCreateNestedManyWithoutObjectInput = {
    create?: XOR<MobCarryingCreateWithoutObjectInput, MobCarryingUncheckedCreateWithoutObjectInput> | MobCarryingCreateWithoutObjectInput[] | MobCarryingUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: MobCarryingCreateOrConnectWithoutObjectInput | MobCarryingCreateOrConnectWithoutObjectInput[]
    createMany?: MobCarryingCreateManyObjectInputEnvelope
    connect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
  }

  export type MobEquippedCreateNestedManyWithoutObjectInput = {
    create?: XOR<MobEquippedCreateWithoutObjectInput, MobEquippedUncheckedCreateWithoutObjectInput> | MobEquippedCreateWithoutObjectInput[] | MobEquippedUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: MobEquippedCreateOrConnectWithoutObjectInput | MobEquippedCreateOrConnectWithoutObjectInput[]
    createMany?: MobEquippedCreateManyObjectInputEnvelope
    connect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
  }

  export type ObjectAffectCreateNestedManyWithoutObjectInput = {
    create?: XOR<ObjectAffectCreateWithoutObjectInput, ObjectAffectUncheckedCreateWithoutObjectInput> | ObjectAffectCreateWithoutObjectInput[] | ObjectAffectUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectAffectCreateOrConnectWithoutObjectInput | ObjectAffectCreateOrConnectWithoutObjectInput[]
    createMany?: ObjectAffectCreateManyObjectInputEnvelope
    connect?: ObjectAffectWhereUniqueInput | ObjectAffectWhereUniqueInput[]
  }

  export type ObjectExtraDescriptionCreateNestedManyWithoutObjectInput = {
    create?: XOR<ObjectExtraDescriptionCreateWithoutObjectInput, ObjectExtraDescriptionUncheckedCreateWithoutObjectInput> | ObjectExtraDescriptionCreateWithoutObjectInput[] | ObjectExtraDescriptionUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectExtraDescriptionCreateOrConnectWithoutObjectInput | ObjectExtraDescriptionCreateOrConnectWithoutObjectInput[]
    createMany?: ObjectExtraDescriptionCreateManyObjectInputEnvelope
    connect?: ObjectExtraDescriptionWhereUniqueInput | ObjectExtraDescriptionWhereUniqueInput[]
  }

  export type ObjectResetCreateNestedManyWithoutObjectInput = {
    create?: XOR<ObjectResetCreateWithoutObjectInput, ObjectResetUncheckedCreateWithoutObjectInput> | ObjectResetCreateWithoutObjectInput[] | ObjectResetUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutObjectInput | ObjectResetCreateOrConnectWithoutObjectInput[]
    createMany?: ObjectResetCreateManyObjectInputEnvelope
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
  }

  export type ObjectSpellCreateNestedManyWithoutObjectInput = {
    create?: XOR<ObjectSpellCreateWithoutObjectInput, ObjectSpellUncheckedCreateWithoutObjectInput> | ObjectSpellCreateWithoutObjectInput[] | ObjectSpellUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectSpellCreateOrConnectWithoutObjectInput | ObjectSpellCreateOrConnectWithoutObjectInput[]
    createMany?: ObjectSpellCreateManyObjectInputEnvelope
    connect?: ObjectSpellWhereUniqueInput | ObjectSpellWhereUniqueInput[]
  }

  export type ZoneCreateNestedOneWithoutObjectsInput = {
    create?: XOR<ZoneCreateWithoutObjectsInput, ZoneUncheckedCreateWithoutObjectsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutObjectsInput
    connect?: ZoneWhereUniqueInput
  }

  export type ShopItemCreateNestedManyWithoutObjectInput = {
    create?: XOR<ShopItemCreateWithoutObjectInput, ShopItemUncheckedCreateWithoutObjectInput> | ShopItemCreateWithoutObjectInput[] | ShopItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutObjectInput | ShopItemCreateOrConnectWithoutObjectInput[]
    createMany?: ShopItemCreateManyObjectInputEnvelope
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
  }

  export type TriggerCreateNestedManyWithoutObjectInput = {
    create?: XOR<TriggerCreateWithoutObjectInput, TriggerUncheckedCreateWithoutObjectInput> | TriggerCreateWithoutObjectInput[] | TriggerUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutObjectInput | TriggerCreateOrConnectWithoutObjectInput[]
    createMany?: TriggerCreateManyObjectInputEnvelope
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
  }

  export type CharacterItemUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<CharacterItemCreateWithoutObjectInput, CharacterItemUncheckedCreateWithoutObjectInput> | CharacterItemCreateWithoutObjectInput[] | CharacterItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutObjectInput | CharacterItemCreateOrConnectWithoutObjectInput[]
    createMany?: CharacterItemCreateManyObjectInputEnvelope
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
  }

  export type EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<EquipmentSetItemCreateWithoutObjectInput, EquipmentSetItemUncheckedCreateWithoutObjectInput> | EquipmentSetItemCreateWithoutObjectInput[] | EquipmentSetItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: EquipmentSetItemCreateOrConnectWithoutObjectInput | EquipmentSetItemCreateOrConnectWithoutObjectInput[]
    createMany?: EquipmentSetItemCreateManyObjectInputEnvelope
    connect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
  }

  export type MobCarryingUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<MobCarryingCreateWithoutObjectInput, MobCarryingUncheckedCreateWithoutObjectInput> | MobCarryingCreateWithoutObjectInput[] | MobCarryingUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: MobCarryingCreateOrConnectWithoutObjectInput | MobCarryingCreateOrConnectWithoutObjectInput[]
    createMany?: MobCarryingCreateManyObjectInputEnvelope
    connect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
  }

  export type MobEquippedUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<MobEquippedCreateWithoutObjectInput, MobEquippedUncheckedCreateWithoutObjectInput> | MobEquippedCreateWithoutObjectInput[] | MobEquippedUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: MobEquippedCreateOrConnectWithoutObjectInput | MobEquippedCreateOrConnectWithoutObjectInput[]
    createMany?: MobEquippedCreateManyObjectInputEnvelope
    connect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
  }

  export type ObjectAffectUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<ObjectAffectCreateWithoutObjectInput, ObjectAffectUncheckedCreateWithoutObjectInput> | ObjectAffectCreateWithoutObjectInput[] | ObjectAffectUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectAffectCreateOrConnectWithoutObjectInput | ObjectAffectCreateOrConnectWithoutObjectInput[]
    createMany?: ObjectAffectCreateManyObjectInputEnvelope
    connect?: ObjectAffectWhereUniqueInput | ObjectAffectWhereUniqueInput[]
  }

  export type ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<ObjectExtraDescriptionCreateWithoutObjectInput, ObjectExtraDescriptionUncheckedCreateWithoutObjectInput> | ObjectExtraDescriptionCreateWithoutObjectInput[] | ObjectExtraDescriptionUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectExtraDescriptionCreateOrConnectWithoutObjectInput | ObjectExtraDescriptionCreateOrConnectWithoutObjectInput[]
    createMany?: ObjectExtraDescriptionCreateManyObjectInputEnvelope
    connect?: ObjectExtraDescriptionWhereUniqueInput | ObjectExtraDescriptionWhereUniqueInput[]
  }

  export type ObjectResetUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<ObjectResetCreateWithoutObjectInput, ObjectResetUncheckedCreateWithoutObjectInput> | ObjectResetCreateWithoutObjectInput[] | ObjectResetUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutObjectInput | ObjectResetCreateOrConnectWithoutObjectInput[]
    createMany?: ObjectResetCreateManyObjectInputEnvelope
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
  }

  export type ObjectSpellUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<ObjectSpellCreateWithoutObjectInput, ObjectSpellUncheckedCreateWithoutObjectInput> | ObjectSpellCreateWithoutObjectInput[] | ObjectSpellUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectSpellCreateOrConnectWithoutObjectInput | ObjectSpellCreateOrConnectWithoutObjectInput[]
    createMany?: ObjectSpellCreateManyObjectInputEnvelope
    connect?: ObjectSpellWhereUniqueInput | ObjectSpellWhereUniqueInput[]
  }

  export type ShopItemUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<ShopItemCreateWithoutObjectInput, ShopItemUncheckedCreateWithoutObjectInput> | ShopItemCreateWithoutObjectInput[] | ShopItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutObjectInput | ShopItemCreateOrConnectWithoutObjectInput[]
    createMany?: ShopItemCreateManyObjectInputEnvelope
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
  }

  export type TriggerUncheckedCreateNestedManyWithoutObjectInput = {
    create?: XOR<TriggerCreateWithoutObjectInput, TriggerUncheckedCreateWithoutObjectInput> | TriggerCreateWithoutObjectInput[] | TriggerUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutObjectInput | TriggerCreateOrConnectWithoutObjectInput[]
    createMany?: TriggerCreateManyObjectInputEnvelope
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
  }

  export type EnumObjectTypeFieldUpdateOperationsInput = {
    set?: $Enums.ObjectType
  }

  export type ObjectUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ObjectUpdateflagsInput = {
    set?: $Enums.ObjectFlag[]
    push?: $Enums.ObjectFlag | $Enums.ObjectFlag[]
  }

  export type ObjectUpdateeffectFlagsInput = {
    set?: $Enums.EffectFlag[]
    push?: $Enums.EffectFlag | $Enums.EffectFlag[]
  }

  export type ObjectUpdatewearFlagsInput = {
    set?: $Enums.WearFlag[]
    push?: $Enums.WearFlag | $Enums.WearFlag[]
  }

  export type CharacterItemUpdateManyWithoutObjectNestedInput = {
    create?: XOR<CharacterItemCreateWithoutObjectInput, CharacterItemUncheckedCreateWithoutObjectInput> | CharacterItemCreateWithoutObjectInput[] | CharacterItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutObjectInput | CharacterItemCreateOrConnectWithoutObjectInput[]
    upsert?: CharacterItemUpsertWithWhereUniqueWithoutObjectInput | CharacterItemUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: CharacterItemCreateManyObjectInputEnvelope
    set?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    disconnect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    delete?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    update?: CharacterItemUpdateWithWhereUniqueWithoutObjectInput | CharacterItemUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: CharacterItemUpdateManyWithWhereWithoutObjectInput | CharacterItemUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: CharacterItemScalarWhereInput | CharacterItemScalarWhereInput[]
  }

  export type EquipmentSetItemUpdateManyWithoutObjectNestedInput = {
    create?: XOR<EquipmentSetItemCreateWithoutObjectInput, EquipmentSetItemUncheckedCreateWithoutObjectInput> | EquipmentSetItemCreateWithoutObjectInput[] | EquipmentSetItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: EquipmentSetItemCreateOrConnectWithoutObjectInput | EquipmentSetItemCreateOrConnectWithoutObjectInput[]
    upsert?: EquipmentSetItemUpsertWithWhereUniqueWithoutObjectInput | EquipmentSetItemUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: EquipmentSetItemCreateManyObjectInputEnvelope
    set?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    disconnect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    delete?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    connect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    update?: EquipmentSetItemUpdateWithWhereUniqueWithoutObjectInput | EquipmentSetItemUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: EquipmentSetItemUpdateManyWithWhereWithoutObjectInput | EquipmentSetItemUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: EquipmentSetItemScalarWhereInput | EquipmentSetItemScalarWhereInput[]
  }

  export type MobCarryingUpdateManyWithoutObjectNestedInput = {
    create?: XOR<MobCarryingCreateWithoutObjectInput, MobCarryingUncheckedCreateWithoutObjectInput> | MobCarryingCreateWithoutObjectInput[] | MobCarryingUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: MobCarryingCreateOrConnectWithoutObjectInput | MobCarryingCreateOrConnectWithoutObjectInput[]
    upsert?: MobCarryingUpsertWithWhereUniqueWithoutObjectInput | MobCarryingUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: MobCarryingCreateManyObjectInputEnvelope
    set?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    disconnect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    delete?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    connect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    update?: MobCarryingUpdateWithWhereUniqueWithoutObjectInput | MobCarryingUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: MobCarryingUpdateManyWithWhereWithoutObjectInput | MobCarryingUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: MobCarryingScalarWhereInput | MobCarryingScalarWhereInput[]
  }

  export type MobEquippedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<MobEquippedCreateWithoutObjectInput, MobEquippedUncheckedCreateWithoutObjectInput> | MobEquippedCreateWithoutObjectInput[] | MobEquippedUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: MobEquippedCreateOrConnectWithoutObjectInput | MobEquippedCreateOrConnectWithoutObjectInput[]
    upsert?: MobEquippedUpsertWithWhereUniqueWithoutObjectInput | MobEquippedUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: MobEquippedCreateManyObjectInputEnvelope
    set?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    disconnect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    delete?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    connect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    update?: MobEquippedUpdateWithWhereUniqueWithoutObjectInput | MobEquippedUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: MobEquippedUpdateManyWithWhereWithoutObjectInput | MobEquippedUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: MobEquippedScalarWhereInput | MobEquippedScalarWhereInput[]
  }

  export type ObjectAffectUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ObjectAffectCreateWithoutObjectInput, ObjectAffectUncheckedCreateWithoutObjectInput> | ObjectAffectCreateWithoutObjectInput[] | ObjectAffectUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectAffectCreateOrConnectWithoutObjectInput | ObjectAffectCreateOrConnectWithoutObjectInput[]
    upsert?: ObjectAffectUpsertWithWhereUniqueWithoutObjectInput | ObjectAffectUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ObjectAffectCreateManyObjectInputEnvelope
    set?: ObjectAffectWhereUniqueInput | ObjectAffectWhereUniqueInput[]
    disconnect?: ObjectAffectWhereUniqueInput | ObjectAffectWhereUniqueInput[]
    delete?: ObjectAffectWhereUniqueInput | ObjectAffectWhereUniqueInput[]
    connect?: ObjectAffectWhereUniqueInput | ObjectAffectWhereUniqueInput[]
    update?: ObjectAffectUpdateWithWhereUniqueWithoutObjectInput | ObjectAffectUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ObjectAffectUpdateManyWithWhereWithoutObjectInput | ObjectAffectUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ObjectAffectScalarWhereInput | ObjectAffectScalarWhereInput[]
  }

  export type ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ObjectExtraDescriptionCreateWithoutObjectInput, ObjectExtraDescriptionUncheckedCreateWithoutObjectInput> | ObjectExtraDescriptionCreateWithoutObjectInput[] | ObjectExtraDescriptionUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectExtraDescriptionCreateOrConnectWithoutObjectInput | ObjectExtraDescriptionCreateOrConnectWithoutObjectInput[]
    upsert?: ObjectExtraDescriptionUpsertWithWhereUniqueWithoutObjectInput | ObjectExtraDescriptionUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ObjectExtraDescriptionCreateManyObjectInputEnvelope
    set?: ObjectExtraDescriptionWhereUniqueInput | ObjectExtraDescriptionWhereUniqueInput[]
    disconnect?: ObjectExtraDescriptionWhereUniqueInput | ObjectExtraDescriptionWhereUniqueInput[]
    delete?: ObjectExtraDescriptionWhereUniqueInput | ObjectExtraDescriptionWhereUniqueInput[]
    connect?: ObjectExtraDescriptionWhereUniqueInput | ObjectExtraDescriptionWhereUniqueInput[]
    update?: ObjectExtraDescriptionUpdateWithWhereUniqueWithoutObjectInput | ObjectExtraDescriptionUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ObjectExtraDescriptionUpdateManyWithWhereWithoutObjectInput | ObjectExtraDescriptionUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ObjectExtraDescriptionScalarWhereInput | ObjectExtraDescriptionScalarWhereInput[]
  }

  export type ObjectResetUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ObjectResetCreateWithoutObjectInput, ObjectResetUncheckedCreateWithoutObjectInput> | ObjectResetCreateWithoutObjectInput[] | ObjectResetUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutObjectInput | ObjectResetCreateOrConnectWithoutObjectInput[]
    upsert?: ObjectResetUpsertWithWhereUniqueWithoutObjectInput | ObjectResetUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ObjectResetCreateManyObjectInputEnvelope
    set?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    disconnect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    delete?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    update?: ObjectResetUpdateWithWhereUniqueWithoutObjectInput | ObjectResetUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ObjectResetUpdateManyWithWhereWithoutObjectInput | ObjectResetUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ObjectResetScalarWhereInput | ObjectResetScalarWhereInput[]
  }

  export type ObjectSpellUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ObjectSpellCreateWithoutObjectInput, ObjectSpellUncheckedCreateWithoutObjectInput> | ObjectSpellCreateWithoutObjectInput[] | ObjectSpellUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectSpellCreateOrConnectWithoutObjectInput | ObjectSpellCreateOrConnectWithoutObjectInput[]
    upsert?: ObjectSpellUpsertWithWhereUniqueWithoutObjectInput | ObjectSpellUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ObjectSpellCreateManyObjectInputEnvelope
    set?: ObjectSpellWhereUniqueInput | ObjectSpellWhereUniqueInput[]
    disconnect?: ObjectSpellWhereUniqueInput | ObjectSpellWhereUniqueInput[]
    delete?: ObjectSpellWhereUniqueInput | ObjectSpellWhereUniqueInput[]
    connect?: ObjectSpellWhereUniqueInput | ObjectSpellWhereUniqueInput[]
    update?: ObjectSpellUpdateWithWhereUniqueWithoutObjectInput | ObjectSpellUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ObjectSpellUpdateManyWithWhereWithoutObjectInput | ObjectSpellUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ObjectSpellScalarWhereInput | ObjectSpellScalarWhereInput[]
  }

  export type ZoneUpdateOneRequiredWithoutObjectsNestedInput = {
    create?: XOR<ZoneCreateWithoutObjectsInput, ZoneUncheckedCreateWithoutObjectsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutObjectsInput
    upsert?: ZoneUpsertWithoutObjectsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutObjectsInput, ZoneUpdateWithoutObjectsInput>, ZoneUncheckedUpdateWithoutObjectsInput>
  }

  export type ShopItemUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ShopItemCreateWithoutObjectInput, ShopItemUncheckedCreateWithoutObjectInput> | ShopItemCreateWithoutObjectInput[] | ShopItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutObjectInput | ShopItemCreateOrConnectWithoutObjectInput[]
    upsert?: ShopItemUpsertWithWhereUniqueWithoutObjectInput | ShopItemUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ShopItemCreateManyObjectInputEnvelope
    set?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    disconnect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    delete?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    update?: ShopItemUpdateWithWhereUniqueWithoutObjectInput | ShopItemUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ShopItemUpdateManyWithWhereWithoutObjectInput | ShopItemUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
  }

  export type TriggerUpdateManyWithoutObjectNestedInput = {
    create?: XOR<TriggerCreateWithoutObjectInput, TriggerUncheckedCreateWithoutObjectInput> | TriggerCreateWithoutObjectInput[] | TriggerUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutObjectInput | TriggerCreateOrConnectWithoutObjectInput[]
    upsert?: TriggerUpsertWithWhereUniqueWithoutObjectInput | TriggerUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: TriggerCreateManyObjectInputEnvelope
    set?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    disconnect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    delete?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    update?: TriggerUpdateWithWhereUniqueWithoutObjectInput | TriggerUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: TriggerUpdateManyWithWhereWithoutObjectInput | TriggerUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
  }

  export type CharacterItemUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<CharacterItemCreateWithoutObjectInput, CharacterItemUncheckedCreateWithoutObjectInput> | CharacterItemCreateWithoutObjectInput[] | CharacterItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutObjectInput | CharacterItemCreateOrConnectWithoutObjectInput[]
    upsert?: CharacterItemUpsertWithWhereUniqueWithoutObjectInput | CharacterItemUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: CharacterItemCreateManyObjectInputEnvelope
    set?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    disconnect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    delete?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    update?: CharacterItemUpdateWithWhereUniqueWithoutObjectInput | CharacterItemUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: CharacterItemUpdateManyWithWhereWithoutObjectInput | CharacterItemUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: CharacterItemScalarWhereInput | CharacterItemScalarWhereInput[]
  }

  export type EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<EquipmentSetItemCreateWithoutObjectInput, EquipmentSetItemUncheckedCreateWithoutObjectInput> | EquipmentSetItemCreateWithoutObjectInput[] | EquipmentSetItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: EquipmentSetItemCreateOrConnectWithoutObjectInput | EquipmentSetItemCreateOrConnectWithoutObjectInput[]
    upsert?: EquipmentSetItemUpsertWithWhereUniqueWithoutObjectInput | EquipmentSetItemUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: EquipmentSetItemCreateManyObjectInputEnvelope
    set?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    disconnect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    delete?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    connect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    update?: EquipmentSetItemUpdateWithWhereUniqueWithoutObjectInput | EquipmentSetItemUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: EquipmentSetItemUpdateManyWithWhereWithoutObjectInput | EquipmentSetItemUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: EquipmentSetItemScalarWhereInput | EquipmentSetItemScalarWhereInput[]
  }

  export type MobCarryingUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<MobCarryingCreateWithoutObjectInput, MobCarryingUncheckedCreateWithoutObjectInput> | MobCarryingCreateWithoutObjectInput[] | MobCarryingUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: MobCarryingCreateOrConnectWithoutObjectInput | MobCarryingCreateOrConnectWithoutObjectInput[]
    upsert?: MobCarryingUpsertWithWhereUniqueWithoutObjectInput | MobCarryingUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: MobCarryingCreateManyObjectInputEnvelope
    set?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    disconnect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    delete?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    connect?: MobCarryingWhereUniqueInput | MobCarryingWhereUniqueInput[]
    update?: MobCarryingUpdateWithWhereUniqueWithoutObjectInput | MobCarryingUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: MobCarryingUpdateManyWithWhereWithoutObjectInput | MobCarryingUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: MobCarryingScalarWhereInput | MobCarryingScalarWhereInput[]
  }

  export type MobEquippedUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<MobEquippedCreateWithoutObjectInput, MobEquippedUncheckedCreateWithoutObjectInput> | MobEquippedCreateWithoutObjectInput[] | MobEquippedUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: MobEquippedCreateOrConnectWithoutObjectInput | MobEquippedCreateOrConnectWithoutObjectInput[]
    upsert?: MobEquippedUpsertWithWhereUniqueWithoutObjectInput | MobEquippedUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: MobEquippedCreateManyObjectInputEnvelope
    set?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    disconnect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    delete?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    connect?: MobEquippedWhereUniqueInput | MobEquippedWhereUniqueInput[]
    update?: MobEquippedUpdateWithWhereUniqueWithoutObjectInput | MobEquippedUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: MobEquippedUpdateManyWithWhereWithoutObjectInput | MobEquippedUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: MobEquippedScalarWhereInput | MobEquippedScalarWhereInput[]
  }

  export type ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ObjectAffectCreateWithoutObjectInput, ObjectAffectUncheckedCreateWithoutObjectInput> | ObjectAffectCreateWithoutObjectInput[] | ObjectAffectUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectAffectCreateOrConnectWithoutObjectInput | ObjectAffectCreateOrConnectWithoutObjectInput[]
    upsert?: ObjectAffectUpsertWithWhereUniqueWithoutObjectInput | ObjectAffectUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ObjectAffectCreateManyObjectInputEnvelope
    set?: ObjectAffectWhereUniqueInput | ObjectAffectWhereUniqueInput[]
    disconnect?: ObjectAffectWhereUniqueInput | ObjectAffectWhereUniqueInput[]
    delete?: ObjectAffectWhereUniqueInput | ObjectAffectWhereUniqueInput[]
    connect?: ObjectAffectWhereUniqueInput | ObjectAffectWhereUniqueInput[]
    update?: ObjectAffectUpdateWithWhereUniqueWithoutObjectInput | ObjectAffectUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ObjectAffectUpdateManyWithWhereWithoutObjectInput | ObjectAffectUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ObjectAffectScalarWhereInput | ObjectAffectScalarWhereInput[]
  }

  export type ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ObjectExtraDescriptionCreateWithoutObjectInput, ObjectExtraDescriptionUncheckedCreateWithoutObjectInput> | ObjectExtraDescriptionCreateWithoutObjectInput[] | ObjectExtraDescriptionUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectExtraDescriptionCreateOrConnectWithoutObjectInput | ObjectExtraDescriptionCreateOrConnectWithoutObjectInput[]
    upsert?: ObjectExtraDescriptionUpsertWithWhereUniqueWithoutObjectInput | ObjectExtraDescriptionUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ObjectExtraDescriptionCreateManyObjectInputEnvelope
    set?: ObjectExtraDescriptionWhereUniqueInput | ObjectExtraDescriptionWhereUniqueInput[]
    disconnect?: ObjectExtraDescriptionWhereUniqueInput | ObjectExtraDescriptionWhereUniqueInput[]
    delete?: ObjectExtraDescriptionWhereUniqueInput | ObjectExtraDescriptionWhereUniqueInput[]
    connect?: ObjectExtraDescriptionWhereUniqueInput | ObjectExtraDescriptionWhereUniqueInput[]
    update?: ObjectExtraDescriptionUpdateWithWhereUniqueWithoutObjectInput | ObjectExtraDescriptionUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ObjectExtraDescriptionUpdateManyWithWhereWithoutObjectInput | ObjectExtraDescriptionUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ObjectExtraDescriptionScalarWhereInput | ObjectExtraDescriptionScalarWhereInput[]
  }

  export type ObjectResetUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ObjectResetCreateWithoutObjectInput, ObjectResetUncheckedCreateWithoutObjectInput> | ObjectResetCreateWithoutObjectInput[] | ObjectResetUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectResetCreateOrConnectWithoutObjectInput | ObjectResetCreateOrConnectWithoutObjectInput[]
    upsert?: ObjectResetUpsertWithWhereUniqueWithoutObjectInput | ObjectResetUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ObjectResetCreateManyObjectInputEnvelope
    set?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    disconnect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    delete?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    connect?: ObjectResetWhereUniqueInput | ObjectResetWhereUniqueInput[]
    update?: ObjectResetUpdateWithWhereUniqueWithoutObjectInput | ObjectResetUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ObjectResetUpdateManyWithWhereWithoutObjectInput | ObjectResetUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ObjectResetScalarWhereInput | ObjectResetScalarWhereInput[]
  }

  export type ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ObjectSpellCreateWithoutObjectInput, ObjectSpellUncheckedCreateWithoutObjectInput> | ObjectSpellCreateWithoutObjectInput[] | ObjectSpellUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ObjectSpellCreateOrConnectWithoutObjectInput | ObjectSpellCreateOrConnectWithoutObjectInput[]
    upsert?: ObjectSpellUpsertWithWhereUniqueWithoutObjectInput | ObjectSpellUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ObjectSpellCreateManyObjectInputEnvelope
    set?: ObjectSpellWhereUniqueInput | ObjectSpellWhereUniqueInput[]
    disconnect?: ObjectSpellWhereUniqueInput | ObjectSpellWhereUniqueInput[]
    delete?: ObjectSpellWhereUniqueInput | ObjectSpellWhereUniqueInput[]
    connect?: ObjectSpellWhereUniqueInput | ObjectSpellWhereUniqueInput[]
    update?: ObjectSpellUpdateWithWhereUniqueWithoutObjectInput | ObjectSpellUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ObjectSpellUpdateManyWithWhereWithoutObjectInput | ObjectSpellUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ObjectSpellScalarWhereInput | ObjectSpellScalarWhereInput[]
  }

  export type ShopItemUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<ShopItemCreateWithoutObjectInput, ShopItemUncheckedCreateWithoutObjectInput> | ShopItemCreateWithoutObjectInput[] | ShopItemUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutObjectInput | ShopItemCreateOrConnectWithoutObjectInput[]
    upsert?: ShopItemUpsertWithWhereUniqueWithoutObjectInput | ShopItemUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: ShopItemCreateManyObjectInputEnvelope
    set?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    disconnect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    delete?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    update?: ShopItemUpdateWithWhereUniqueWithoutObjectInput | ShopItemUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: ShopItemUpdateManyWithWhereWithoutObjectInput | ShopItemUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
  }

  export type TriggerUncheckedUpdateManyWithoutObjectNestedInput = {
    create?: XOR<TriggerCreateWithoutObjectInput, TriggerUncheckedCreateWithoutObjectInput> | TriggerCreateWithoutObjectInput[] | TriggerUncheckedCreateWithoutObjectInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutObjectInput | TriggerCreateOrConnectWithoutObjectInput[]
    upsert?: TriggerUpsertWithWhereUniqueWithoutObjectInput | TriggerUpsertWithWhereUniqueWithoutObjectInput[]
    createMany?: TriggerCreateManyObjectInputEnvelope
    set?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    disconnect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    delete?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    update?: TriggerUpdateWithWhereUniqueWithoutObjectInput | TriggerUpdateWithWhereUniqueWithoutObjectInput[]
    updateMany?: TriggerUpdateManyWithWhereWithoutObjectInput | TriggerUpdateManyWithWhereWithoutObjectInput[]
    deleteMany?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
  }

  export type ObjectCreateNestedOneWithoutExtraDescsInput = {
    create?: XOR<ObjectCreateWithoutExtraDescsInput, ObjectUncheckedCreateWithoutExtraDescsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutExtraDescsInput
    connect?: ObjectWhereUniqueInput
  }

  export type ObjectUpdateOneRequiredWithoutExtraDescsNestedInput = {
    create?: XOR<ObjectCreateWithoutExtraDescsInput, ObjectUncheckedCreateWithoutExtraDescsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutExtraDescsInput
    upsert?: ObjectUpsertWithoutExtraDescsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutExtraDescsInput, ObjectUpdateWithoutExtraDescsInput>, ObjectUncheckedUpdateWithoutExtraDescsInput>
  }

  export type ObjectCreateNestedOneWithoutAffectsInput = {
    create?: XOR<ObjectCreateWithoutAffectsInput, ObjectUncheckedCreateWithoutAffectsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutAffectsInput
    connect?: ObjectWhereUniqueInput
  }

  export type ObjectUpdateOneRequiredWithoutAffectsNestedInput = {
    create?: XOR<ObjectCreateWithoutAffectsInput, ObjectUncheckedCreateWithoutAffectsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutAffectsInput
    upsert?: ObjectUpsertWithoutAffectsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutAffectsInput, ObjectUpdateWithoutAffectsInput>, ObjectUncheckedUpdateWithoutAffectsInput>
  }

  export type ObjectCreateNestedOneWithoutSpellsInput = {
    create?: XOR<ObjectCreateWithoutSpellsInput, ObjectUncheckedCreateWithoutSpellsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutSpellsInput
    connect?: ObjectWhereUniqueInput
  }

  export type ObjectUpdateOneRequiredWithoutSpellsNestedInput = {
    create?: XOR<ObjectCreateWithoutSpellsInput, ObjectUncheckedCreateWithoutSpellsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutSpellsInput
    upsert?: ObjectUpsertWithoutSpellsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutSpellsInput, ObjectUpdateWithoutSpellsInput>, ObjectUncheckedUpdateWithoutSpellsInput>
  }

  export type ShopCreateflagsInput = {
    set: $Enums.ShopFlag[]
  }

  export type ShopCreatetradesWithFlagsInput = {
    set: $Enums.ShopTradesWith[]
  }

  export type ShopAcceptCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopAcceptCreateWithoutShopInput, ShopAcceptUncheckedCreateWithoutShopInput> | ShopAcceptCreateWithoutShopInput[] | ShopAcceptUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopAcceptCreateOrConnectWithoutShopInput | ShopAcceptCreateOrConnectWithoutShopInput[]
    createMany?: ShopAcceptCreateManyShopInputEnvelope
    connect?: ShopAcceptWhereUniqueInput | ShopAcceptWhereUniqueInput[]
  }

  export type ShopHourCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopHourCreateWithoutShopInput, ShopHourUncheckedCreateWithoutShopInput> | ShopHourCreateWithoutShopInput[] | ShopHourUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopHourCreateOrConnectWithoutShopInput | ShopHourCreateOrConnectWithoutShopInput[]
    createMany?: ShopHourCreateManyShopInputEnvelope
    connect?: ShopHourWhereUniqueInput | ShopHourWhereUniqueInput[]
  }

  export type ShopItemCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput> | ShopItemCreateWithoutShopInput[] | ShopItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutShopInput | ShopItemCreateOrConnectWithoutShopInput[]
    createMany?: ShopItemCreateManyShopInputEnvelope
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
  }

  export type ShopRoomCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopRoomCreateWithoutShopInput, ShopRoomUncheckedCreateWithoutShopInput> | ShopRoomCreateWithoutShopInput[] | ShopRoomUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopRoomCreateOrConnectWithoutShopInput | ShopRoomCreateOrConnectWithoutShopInput[]
    createMany?: ShopRoomCreateManyShopInputEnvelope
    connect?: ShopRoomWhereUniqueInput | ShopRoomWhereUniqueInput[]
  }

  export type MobCreateNestedOneWithoutShopsInput = {
    create?: XOR<MobCreateWithoutShopsInput, MobUncheckedCreateWithoutShopsInput>
    connectOrCreate?: MobCreateOrConnectWithoutShopsInput
    connect?: MobWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutShopsInput = {
    create?: XOR<ZoneCreateWithoutShopsInput, ZoneUncheckedCreateWithoutShopsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutShopsInput
    connect?: ZoneWhereUniqueInput
  }

  export type ShopAcceptUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopAcceptCreateWithoutShopInput, ShopAcceptUncheckedCreateWithoutShopInput> | ShopAcceptCreateWithoutShopInput[] | ShopAcceptUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopAcceptCreateOrConnectWithoutShopInput | ShopAcceptCreateOrConnectWithoutShopInput[]
    createMany?: ShopAcceptCreateManyShopInputEnvelope
    connect?: ShopAcceptWhereUniqueInput | ShopAcceptWhereUniqueInput[]
  }

  export type ShopHourUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopHourCreateWithoutShopInput, ShopHourUncheckedCreateWithoutShopInput> | ShopHourCreateWithoutShopInput[] | ShopHourUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopHourCreateOrConnectWithoutShopInput | ShopHourCreateOrConnectWithoutShopInput[]
    createMany?: ShopHourCreateManyShopInputEnvelope
    connect?: ShopHourWhereUniqueInput | ShopHourWhereUniqueInput[]
  }

  export type ShopItemUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput> | ShopItemCreateWithoutShopInput[] | ShopItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutShopInput | ShopItemCreateOrConnectWithoutShopInput[]
    createMany?: ShopItemCreateManyShopInputEnvelope
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
  }

  export type ShopRoomUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopRoomCreateWithoutShopInput, ShopRoomUncheckedCreateWithoutShopInput> | ShopRoomCreateWithoutShopInput[] | ShopRoomUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopRoomCreateOrConnectWithoutShopInput | ShopRoomCreateOrConnectWithoutShopInput[]
    createMany?: ShopRoomCreateManyShopInputEnvelope
    connect?: ShopRoomWhereUniqueInput | ShopRoomWhereUniqueInput[]
  }

  export type ShopUpdateflagsInput = {
    set?: $Enums.ShopFlag[]
    push?: $Enums.ShopFlag | $Enums.ShopFlag[]
  }

  export type ShopUpdatetradesWithFlagsInput = {
    set?: $Enums.ShopTradesWith[]
    push?: $Enums.ShopTradesWith | $Enums.ShopTradesWith[]
  }

  export type ShopAcceptUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopAcceptCreateWithoutShopInput, ShopAcceptUncheckedCreateWithoutShopInput> | ShopAcceptCreateWithoutShopInput[] | ShopAcceptUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopAcceptCreateOrConnectWithoutShopInput | ShopAcceptCreateOrConnectWithoutShopInput[]
    upsert?: ShopAcceptUpsertWithWhereUniqueWithoutShopInput | ShopAcceptUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopAcceptCreateManyShopInputEnvelope
    set?: ShopAcceptWhereUniqueInput | ShopAcceptWhereUniqueInput[]
    disconnect?: ShopAcceptWhereUniqueInput | ShopAcceptWhereUniqueInput[]
    delete?: ShopAcceptWhereUniqueInput | ShopAcceptWhereUniqueInput[]
    connect?: ShopAcceptWhereUniqueInput | ShopAcceptWhereUniqueInput[]
    update?: ShopAcceptUpdateWithWhereUniqueWithoutShopInput | ShopAcceptUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopAcceptUpdateManyWithWhereWithoutShopInput | ShopAcceptUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopAcceptScalarWhereInput | ShopAcceptScalarWhereInput[]
  }

  export type ShopHourUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopHourCreateWithoutShopInput, ShopHourUncheckedCreateWithoutShopInput> | ShopHourCreateWithoutShopInput[] | ShopHourUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopHourCreateOrConnectWithoutShopInput | ShopHourCreateOrConnectWithoutShopInput[]
    upsert?: ShopHourUpsertWithWhereUniqueWithoutShopInput | ShopHourUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopHourCreateManyShopInputEnvelope
    set?: ShopHourWhereUniqueInput | ShopHourWhereUniqueInput[]
    disconnect?: ShopHourWhereUniqueInput | ShopHourWhereUniqueInput[]
    delete?: ShopHourWhereUniqueInput | ShopHourWhereUniqueInput[]
    connect?: ShopHourWhereUniqueInput | ShopHourWhereUniqueInput[]
    update?: ShopHourUpdateWithWhereUniqueWithoutShopInput | ShopHourUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopHourUpdateManyWithWhereWithoutShopInput | ShopHourUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopHourScalarWhereInput | ShopHourScalarWhereInput[]
  }

  export type ShopItemUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput> | ShopItemCreateWithoutShopInput[] | ShopItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutShopInput | ShopItemCreateOrConnectWithoutShopInput[]
    upsert?: ShopItemUpsertWithWhereUniqueWithoutShopInput | ShopItemUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopItemCreateManyShopInputEnvelope
    set?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    disconnect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    delete?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    update?: ShopItemUpdateWithWhereUniqueWithoutShopInput | ShopItemUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopItemUpdateManyWithWhereWithoutShopInput | ShopItemUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
  }

  export type ShopRoomUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopRoomCreateWithoutShopInput, ShopRoomUncheckedCreateWithoutShopInput> | ShopRoomCreateWithoutShopInput[] | ShopRoomUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopRoomCreateOrConnectWithoutShopInput | ShopRoomCreateOrConnectWithoutShopInput[]
    upsert?: ShopRoomUpsertWithWhereUniqueWithoutShopInput | ShopRoomUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopRoomCreateManyShopInputEnvelope
    set?: ShopRoomWhereUniqueInput | ShopRoomWhereUniqueInput[]
    disconnect?: ShopRoomWhereUniqueInput | ShopRoomWhereUniqueInput[]
    delete?: ShopRoomWhereUniqueInput | ShopRoomWhereUniqueInput[]
    connect?: ShopRoomWhereUniqueInput | ShopRoomWhereUniqueInput[]
    update?: ShopRoomUpdateWithWhereUniqueWithoutShopInput | ShopRoomUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopRoomUpdateManyWithWhereWithoutShopInput | ShopRoomUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopRoomScalarWhereInput | ShopRoomScalarWhereInput[]
  }

  export type MobUpdateOneWithoutShopsNestedInput = {
    create?: XOR<MobCreateWithoutShopsInput, MobUncheckedCreateWithoutShopsInput>
    connectOrCreate?: MobCreateOrConnectWithoutShopsInput
    upsert?: MobUpsertWithoutShopsInput
    disconnect?: MobWhereInput | boolean
    delete?: MobWhereInput | boolean
    connect?: MobWhereUniqueInput
    update?: XOR<XOR<MobUpdateToOneWithWhereWithoutShopsInput, MobUpdateWithoutShopsInput>, MobUncheckedUpdateWithoutShopsInput>
  }

  export type ZoneUpdateOneRequiredWithoutShopsNestedInput = {
    create?: XOR<ZoneCreateWithoutShopsInput, ZoneUncheckedCreateWithoutShopsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutShopsInput
    upsert?: ZoneUpsertWithoutShopsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutShopsInput, ZoneUpdateWithoutShopsInput>, ZoneUncheckedUpdateWithoutShopsInput>
  }

  export type ShopAcceptUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopAcceptCreateWithoutShopInput, ShopAcceptUncheckedCreateWithoutShopInput> | ShopAcceptCreateWithoutShopInput[] | ShopAcceptUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopAcceptCreateOrConnectWithoutShopInput | ShopAcceptCreateOrConnectWithoutShopInput[]
    upsert?: ShopAcceptUpsertWithWhereUniqueWithoutShopInput | ShopAcceptUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopAcceptCreateManyShopInputEnvelope
    set?: ShopAcceptWhereUniqueInput | ShopAcceptWhereUniqueInput[]
    disconnect?: ShopAcceptWhereUniqueInput | ShopAcceptWhereUniqueInput[]
    delete?: ShopAcceptWhereUniqueInput | ShopAcceptWhereUniqueInput[]
    connect?: ShopAcceptWhereUniqueInput | ShopAcceptWhereUniqueInput[]
    update?: ShopAcceptUpdateWithWhereUniqueWithoutShopInput | ShopAcceptUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopAcceptUpdateManyWithWhereWithoutShopInput | ShopAcceptUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopAcceptScalarWhereInput | ShopAcceptScalarWhereInput[]
  }

  export type ShopHourUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopHourCreateWithoutShopInput, ShopHourUncheckedCreateWithoutShopInput> | ShopHourCreateWithoutShopInput[] | ShopHourUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopHourCreateOrConnectWithoutShopInput | ShopHourCreateOrConnectWithoutShopInput[]
    upsert?: ShopHourUpsertWithWhereUniqueWithoutShopInput | ShopHourUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopHourCreateManyShopInputEnvelope
    set?: ShopHourWhereUniqueInput | ShopHourWhereUniqueInput[]
    disconnect?: ShopHourWhereUniqueInput | ShopHourWhereUniqueInput[]
    delete?: ShopHourWhereUniqueInput | ShopHourWhereUniqueInput[]
    connect?: ShopHourWhereUniqueInput | ShopHourWhereUniqueInput[]
    update?: ShopHourUpdateWithWhereUniqueWithoutShopInput | ShopHourUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopHourUpdateManyWithWhereWithoutShopInput | ShopHourUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopHourScalarWhereInput | ShopHourScalarWhereInput[]
  }

  export type ShopItemUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput> | ShopItemCreateWithoutShopInput[] | ShopItemUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutShopInput | ShopItemCreateOrConnectWithoutShopInput[]
    upsert?: ShopItemUpsertWithWhereUniqueWithoutShopInput | ShopItemUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopItemCreateManyShopInputEnvelope
    set?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    disconnect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    delete?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    update?: ShopItemUpdateWithWhereUniqueWithoutShopInput | ShopItemUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopItemUpdateManyWithWhereWithoutShopInput | ShopItemUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
  }

  export type ShopRoomUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopRoomCreateWithoutShopInput, ShopRoomUncheckedCreateWithoutShopInput> | ShopRoomCreateWithoutShopInput[] | ShopRoomUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopRoomCreateOrConnectWithoutShopInput | ShopRoomCreateOrConnectWithoutShopInput[]
    upsert?: ShopRoomUpsertWithWhereUniqueWithoutShopInput | ShopRoomUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopRoomCreateManyShopInputEnvelope
    set?: ShopRoomWhereUniqueInput | ShopRoomWhereUniqueInput[]
    disconnect?: ShopRoomWhereUniqueInput | ShopRoomWhereUniqueInput[]
    delete?: ShopRoomWhereUniqueInput | ShopRoomWhereUniqueInput[]
    connect?: ShopRoomWhereUniqueInput | ShopRoomWhereUniqueInput[]
    update?: ShopRoomUpdateWithWhereUniqueWithoutShopInput | ShopRoomUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopRoomUpdateManyWithWhereWithoutShopInput | ShopRoomUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopRoomScalarWhereInput | ShopRoomScalarWhereInput[]
  }

  export type ObjectCreateNestedOneWithoutShopItemsInput = {
    create?: XOR<ObjectCreateWithoutShopItemsInput, ObjectUncheckedCreateWithoutShopItemsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutShopItemsInput
    connect?: ObjectWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutItemsInput = {
    create?: XOR<ShopCreateWithoutItemsInput, ShopUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutItemsInput
    connect?: ShopWhereUniqueInput
  }

  export type ObjectUpdateOneRequiredWithoutShopItemsNestedInput = {
    create?: XOR<ObjectCreateWithoutShopItemsInput, ObjectUncheckedCreateWithoutShopItemsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutShopItemsInput
    upsert?: ObjectUpsertWithoutShopItemsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutShopItemsInput, ObjectUpdateWithoutShopItemsInput>, ObjectUncheckedUpdateWithoutShopItemsInput>
  }

  export type ShopUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ShopCreateWithoutItemsInput, ShopUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutItemsInput
    upsert?: ShopUpsertWithoutItemsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutItemsInput, ShopUpdateWithoutItemsInput>, ShopUncheckedUpdateWithoutItemsInput>
  }

  export type ShopAcceptCreatekeywordsInput = {
    set: string[]
  }

  export type ShopCreateNestedOneWithoutAcceptsInput = {
    create?: XOR<ShopCreateWithoutAcceptsInput, ShopUncheckedCreateWithoutAcceptsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutAcceptsInput
    connect?: ShopWhereUniqueInput
  }

  export type ShopAcceptUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ShopUpdateOneRequiredWithoutAcceptsNestedInput = {
    create?: XOR<ShopCreateWithoutAcceptsInput, ShopUncheckedCreateWithoutAcceptsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutAcceptsInput
    upsert?: ShopUpsertWithoutAcceptsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutAcceptsInput, ShopUpdateWithoutAcceptsInput>, ShopUncheckedUpdateWithoutAcceptsInput>
  }

  export type ShopCreateNestedOneWithoutRoomsInput = {
    create?: XOR<ShopCreateWithoutRoomsInput, ShopUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutRoomsInput
    connect?: ShopWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<ShopCreateWithoutRoomsInput, ShopUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutRoomsInput
    upsert?: ShopUpsertWithoutRoomsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutRoomsInput, ShopUpdateWithoutRoomsInput>, ShopUncheckedUpdateWithoutRoomsInput>
  }

  export type ShopCreateNestedOneWithoutHoursInput = {
    create?: XOR<ShopCreateWithoutHoursInput, ShopUncheckedCreateWithoutHoursInput>
    connectOrCreate?: ShopCreateOrConnectWithoutHoursInput
    connect?: ShopWhereUniqueInput
  }

  export type ShopUpdateOneRequiredWithoutHoursNestedInput = {
    create?: XOR<ShopCreateWithoutHoursInput, ShopUncheckedCreateWithoutHoursInput>
    connectOrCreate?: ShopCreateOrConnectWithoutHoursInput
    upsert?: ShopUpsertWithoutHoursInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutHoursInput, ShopUpdateWithoutHoursInput>, ShopUncheckedUpdateWithoutHoursInput>
  }

  export type TriggerCreateflagsInput = {
    set: $Enums.TriggerFlag[]
  }

  export type MobCreateNestedOneWithoutTriggersInput = {
    create?: XOR<MobCreateWithoutTriggersInput, MobUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: MobCreateOrConnectWithoutTriggersInput
    connect?: MobWhereUniqueInput
  }

  export type ObjectCreateNestedOneWithoutTriggersInput = {
    create?: XOR<ObjectCreateWithoutTriggersInput, ObjectUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutTriggersInput
    connect?: ObjectWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutTriggersInput = {
    create?: XOR<ZoneCreateWithoutTriggersInput, ZoneUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutTriggersInput
    connect?: ZoneWhereUniqueInput
  }

  export type EnumScriptTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScriptType
  }

  export type TriggerUpdateflagsInput = {
    set?: $Enums.TriggerFlag[]
    push?: $Enums.TriggerFlag | $Enums.TriggerFlag[]
  }

  export type MobUpdateOneWithoutTriggersNestedInput = {
    create?: XOR<MobCreateWithoutTriggersInput, MobUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: MobCreateOrConnectWithoutTriggersInput
    upsert?: MobUpsertWithoutTriggersInput
    disconnect?: MobWhereInput | boolean
    delete?: MobWhereInput | boolean
    connect?: MobWhereUniqueInput
    update?: XOR<XOR<MobUpdateToOneWithWhereWithoutTriggersInput, MobUpdateWithoutTriggersInput>, MobUncheckedUpdateWithoutTriggersInput>
  }

  export type ObjectUpdateOneWithoutTriggersNestedInput = {
    create?: XOR<ObjectCreateWithoutTriggersInput, ObjectUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutTriggersInput
    upsert?: ObjectUpsertWithoutTriggersInput
    disconnect?: ObjectWhereInput | boolean
    delete?: ObjectWhereInput | boolean
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutTriggersInput, ObjectUpdateWithoutTriggersInput>, ObjectUncheckedUpdateWithoutTriggersInput>
  }

  export type ZoneUpdateOneWithoutTriggersNestedInput = {
    create?: XOR<ZoneCreateWithoutTriggersInput, ZoneUncheckedCreateWithoutTriggersInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutTriggersInput
    upsert?: ZoneUpsertWithoutTriggersInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutTriggersInput, ZoneUpdateWithoutTriggersInput>, ZoneUncheckedUpdateWithoutTriggersInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CharacterCreateNestedManyWithoutGameClassInput = {
    create?: XOR<CharacterCreateWithoutGameClassInput, CharacterUncheckedCreateWithoutGameClassInput> | CharacterCreateWithoutGameClassInput[] | CharacterUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutGameClassInput | CharacterCreateOrConnectWithoutGameClassInput[]
    createMany?: CharacterCreateManyGameClassInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type ClassSkillCreateNestedManyWithoutGameClassInput = {
    create?: XOR<ClassSkillCreateWithoutGameClassInput, ClassSkillUncheckedCreateWithoutGameClassInput> | ClassSkillCreateWithoutGameClassInput[] | ClassSkillUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: ClassSkillCreateOrConnectWithoutGameClassInput | ClassSkillCreateOrConnectWithoutGameClassInput[]
    createMany?: ClassSkillCreateManyGameClassInputEnvelope
    connect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
  }

  export type MobCreateNestedManyWithoutGameClassInput = {
    create?: XOR<MobCreateWithoutGameClassInput, MobUncheckedCreateWithoutGameClassInput> | MobCreateWithoutGameClassInput[] | MobUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: MobCreateOrConnectWithoutGameClassInput | MobCreateOrConnectWithoutGameClassInput[]
    createMany?: MobCreateManyGameClassInputEnvelope
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
  }

  export type SpellClassCircleCreateNestedManyWithoutGameClassInput = {
    create?: XOR<SpellClassCircleCreateWithoutGameClassInput, SpellClassCircleUncheckedCreateWithoutGameClassInput> | SpellClassCircleCreateWithoutGameClassInput[] | SpellClassCircleUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: SpellClassCircleCreateOrConnectWithoutGameClassInput | SpellClassCircleCreateOrConnectWithoutGameClassInput[]
    createMany?: SpellClassCircleCreateManyGameClassInputEnvelope
    connect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutGameClassInput = {
    create?: XOR<CharacterCreateWithoutGameClassInput, CharacterUncheckedCreateWithoutGameClassInput> | CharacterCreateWithoutGameClassInput[] | CharacterUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutGameClassInput | CharacterCreateOrConnectWithoutGameClassInput[]
    createMany?: CharacterCreateManyGameClassInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type ClassSkillUncheckedCreateNestedManyWithoutGameClassInput = {
    create?: XOR<ClassSkillCreateWithoutGameClassInput, ClassSkillUncheckedCreateWithoutGameClassInput> | ClassSkillCreateWithoutGameClassInput[] | ClassSkillUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: ClassSkillCreateOrConnectWithoutGameClassInput | ClassSkillCreateOrConnectWithoutGameClassInput[]
    createMany?: ClassSkillCreateManyGameClassInputEnvelope
    connect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
  }

  export type MobUncheckedCreateNestedManyWithoutGameClassInput = {
    create?: XOR<MobCreateWithoutGameClassInput, MobUncheckedCreateWithoutGameClassInput> | MobCreateWithoutGameClassInput[] | MobUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: MobCreateOrConnectWithoutGameClassInput | MobCreateOrConnectWithoutGameClassInput[]
    createMany?: MobCreateManyGameClassInputEnvelope
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
  }

  export type SpellClassCircleUncheckedCreateNestedManyWithoutGameClassInput = {
    create?: XOR<SpellClassCircleCreateWithoutGameClassInput, SpellClassCircleUncheckedCreateWithoutGameClassInput> | SpellClassCircleCreateWithoutGameClassInput[] | SpellClassCircleUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: SpellClassCircleCreateOrConnectWithoutGameClassInput | SpellClassCircleCreateOrConnectWithoutGameClassInput[]
    createMany?: SpellClassCircleCreateManyGameClassInputEnvelope
    connect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
  }

  export type CharacterUpdateManyWithoutGameClassNestedInput = {
    create?: XOR<CharacterCreateWithoutGameClassInput, CharacterUncheckedCreateWithoutGameClassInput> | CharacterCreateWithoutGameClassInput[] | CharacterUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutGameClassInput | CharacterCreateOrConnectWithoutGameClassInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutGameClassInput | CharacterUpsertWithWhereUniqueWithoutGameClassInput[]
    createMany?: CharacterCreateManyGameClassInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutGameClassInput | CharacterUpdateWithWhereUniqueWithoutGameClassInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutGameClassInput | CharacterUpdateManyWithWhereWithoutGameClassInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type ClassSkillUpdateManyWithoutGameClassNestedInput = {
    create?: XOR<ClassSkillCreateWithoutGameClassInput, ClassSkillUncheckedCreateWithoutGameClassInput> | ClassSkillCreateWithoutGameClassInput[] | ClassSkillUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: ClassSkillCreateOrConnectWithoutGameClassInput | ClassSkillCreateOrConnectWithoutGameClassInput[]
    upsert?: ClassSkillUpsertWithWhereUniqueWithoutGameClassInput | ClassSkillUpsertWithWhereUniqueWithoutGameClassInput[]
    createMany?: ClassSkillCreateManyGameClassInputEnvelope
    set?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    disconnect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    delete?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    connect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    update?: ClassSkillUpdateWithWhereUniqueWithoutGameClassInput | ClassSkillUpdateWithWhereUniqueWithoutGameClassInput[]
    updateMany?: ClassSkillUpdateManyWithWhereWithoutGameClassInput | ClassSkillUpdateManyWithWhereWithoutGameClassInput[]
    deleteMany?: ClassSkillScalarWhereInput | ClassSkillScalarWhereInput[]
  }

  export type MobUpdateManyWithoutGameClassNestedInput = {
    create?: XOR<MobCreateWithoutGameClassInput, MobUncheckedCreateWithoutGameClassInput> | MobCreateWithoutGameClassInput[] | MobUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: MobCreateOrConnectWithoutGameClassInput | MobCreateOrConnectWithoutGameClassInput[]
    upsert?: MobUpsertWithWhereUniqueWithoutGameClassInput | MobUpsertWithWhereUniqueWithoutGameClassInput[]
    createMany?: MobCreateManyGameClassInputEnvelope
    set?: MobWhereUniqueInput | MobWhereUniqueInput[]
    disconnect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    delete?: MobWhereUniqueInput | MobWhereUniqueInput[]
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    update?: MobUpdateWithWhereUniqueWithoutGameClassInput | MobUpdateWithWhereUniqueWithoutGameClassInput[]
    updateMany?: MobUpdateManyWithWhereWithoutGameClassInput | MobUpdateManyWithWhereWithoutGameClassInput[]
    deleteMany?: MobScalarWhereInput | MobScalarWhereInput[]
  }

  export type SpellClassCircleUpdateManyWithoutGameClassNestedInput = {
    create?: XOR<SpellClassCircleCreateWithoutGameClassInput, SpellClassCircleUncheckedCreateWithoutGameClassInput> | SpellClassCircleCreateWithoutGameClassInput[] | SpellClassCircleUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: SpellClassCircleCreateOrConnectWithoutGameClassInput | SpellClassCircleCreateOrConnectWithoutGameClassInput[]
    upsert?: SpellClassCircleUpsertWithWhereUniqueWithoutGameClassInput | SpellClassCircleUpsertWithWhereUniqueWithoutGameClassInput[]
    createMany?: SpellClassCircleCreateManyGameClassInputEnvelope
    set?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    disconnect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    delete?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    connect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    update?: SpellClassCircleUpdateWithWhereUniqueWithoutGameClassInput | SpellClassCircleUpdateWithWhereUniqueWithoutGameClassInput[]
    updateMany?: SpellClassCircleUpdateManyWithWhereWithoutGameClassInput | SpellClassCircleUpdateManyWithWhereWithoutGameClassInput[]
    deleteMany?: SpellClassCircleScalarWhereInput | SpellClassCircleScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutGameClassNestedInput = {
    create?: XOR<CharacterCreateWithoutGameClassInput, CharacterUncheckedCreateWithoutGameClassInput> | CharacterCreateWithoutGameClassInput[] | CharacterUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutGameClassInput | CharacterCreateOrConnectWithoutGameClassInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutGameClassInput | CharacterUpsertWithWhereUniqueWithoutGameClassInput[]
    createMany?: CharacterCreateManyGameClassInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutGameClassInput | CharacterUpdateWithWhereUniqueWithoutGameClassInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutGameClassInput | CharacterUpdateManyWithWhereWithoutGameClassInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type ClassSkillUncheckedUpdateManyWithoutGameClassNestedInput = {
    create?: XOR<ClassSkillCreateWithoutGameClassInput, ClassSkillUncheckedCreateWithoutGameClassInput> | ClassSkillCreateWithoutGameClassInput[] | ClassSkillUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: ClassSkillCreateOrConnectWithoutGameClassInput | ClassSkillCreateOrConnectWithoutGameClassInput[]
    upsert?: ClassSkillUpsertWithWhereUniqueWithoutGameClassInput | ClassSkillUpsertWithWhereUniqueWithoutGameClassInput[]
    createMany?: ClassSkillCreateManyGameClassInputEnvelope
    set?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    disconnect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    delete?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    connect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    update?: ClassSkillUpdateWithWhereUniqueWithoutGameClassInput | ClassSkillUpdateWithWhereUniqueWithoutGameClassInput[]
    updateMany?: ClassSkillUpdateManyWithWhereWithoutGameClassInput | ClassSkillUpdateManyWithWhereWithoutGameClassInput[]
    deleteMany?: ClassSkillScalarWhereInput | ClassSkillScalarWhereInput[]
  }

  export type MobUncheckedUpdateManyWithoutGameClassNestedInput = {
    create?: XOR<MobCreateWithoutGameClassInput, MobUncheckedCreateWithoutGameClassInput> | MobCreateWithoutGameClassInput[] | MobUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: MobCreateOrConnectWithoutGameClassInput | MobCreateOrConnectWithoutGameClassInput[]
    upsert?: MobUpsertWithWhereUniqueWithoutGameClassInput | MobUpsertWithWhereUniqueWithoutGameClassInput[]
    createMany?: MobCreateManyGameClassInputEnvelope
    set?: MobWhereUniqueInput | MobWhereUniqueInput[]
    disconnect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    delete?: MobWhereUniqueInput | MobWhereUniqueInput[]
    connect?: MobWhereUniqueInput | MobWhereUniqueInput[]
    update?: MobUpdateWithWhereUniqueWithoutGameClassInput | MobUpdateWithWhereUniqueWithoutGameClassInput[]
    updateMany?: MobUpdateManyWithWhereWithoutGameClassInput | MobUpdateManyWithWhereWithoutGameClassInput[]
    deleteMany?: MobScalarWhereInput | MobScalarWhereInput[]
  }

  export type SpellClassCircleUncheckedUpdateManyWithoutGameClassNestedInput = {
    create?: XOR<SpellClassCircleCreateWithoutGameClassInput, SpellClassCircleUncheckedCreateWithoutGameClassInput> | SpellClassCircleCreateWithoutGameClassInput[] | SpellClassCircleUncheckedCreateWithoutGameClassInput[]
    connectOrCreate?: SpellClassCircleCreateOrConnectWithoutGameClassInput | SpellClassCircleCreateOrConnectWithoutGameClassInput[]
    upsert?: SpellClassCircleUpsertWithWhereUniqueWithoutGameClassInput | SpellClassCircleUpsertWithWhereUniqueWithoutGameClassInput[]
    createMany?: SpellClassCircleCreateManyGameClassInputEnvelope
    set?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    disconnect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    delete?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    connect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    update?: SpellClassCircleUpdateWithWhereUniqueWithoutGameClassInput | SpellClassCircleUpdateWithWhereUniqueWithoutGameClassInput[]
    updateMany?: SpellClassCircleUpdateManyWithWhereWithoutGameClassInput | SpellClassCircleUpdateManyWithWhereWithoutGameClassInput[]
    deleteMany?: SpellClassCircleScalarWhereInput | SpellClassCircleScalarWhereInput[]
  }

  export type CharacterSpellCreateNestedManyWithoutSpellInput = {
    create?: XOR<CharacterSpellCreateWithoutSpellInput, CharacterSpellUncheckedCreateWithoutSpellInput> | CharacterSpellCreateWithoutSpellInput[] | CharacterSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: CharacterSpellCreateOrConnectWithoutSpellInput | CharacterSpellCreateOrConnectWithoutSpellInput[]
    createMany?: CharacterSpellCreateManySpellInputEnvelope
    connect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
  }

  export type MobSpellCreateNestedManyWithoutSpellInput = {
    create?: XOR<MobSpellCreateWithoutSpellInput, MobSpellUncheckedCreateWithoutSpellInput> | MobSpellCreateWithoutSpellInput[] | MobSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: MobSpellCreateOrConnectWithoutSpellInput | MobSpellCreateOrConnectWithoutSpellInput[]
    createMany?: MobSpellCreateManySpellInputEnvelope
    connect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
  }

  export type SpellClassCircleCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellClassCircleCreateWithoutSpellInput, SpellClassCircleUncheckedCreateWithoutSpellInput> | SpellClassCircleCreateWithoutSpellInput[] | SpellClassCircleUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellClassCircleCreateOrConnectWithoutSpellInput | SpellClassCircleCreateOrConnectWithoutSpellInput[]
    createMany?: SpellClassCircleCreateManySpellInputEnvelope
    connect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
  }

  export type SpellComponentCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellComponentCreateWithoutSpellInput, SpellComponentUncheckedCreateWithoutSpellInput> | SpellComponentCreateWithoutSpellInput[] | SpellComponentUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellComponentCreateOrConnectWithoutSpellInput | SpellComponentCreateOrConnectWithoutSpellInput[]
    createMany?: SpellComponentCreateManySpellInputEnvelope
    connect?: SpellComponentWhereUniqueInput | SpellComponentWhereUniqueInput[]
  }

  export type SpellEffectCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellEffectCreateWithoutSpellInput, SpellEffectUncheckedCreateWithoutSpellInput> | SpellEffectCreateWithoutSpellInput[] | SpellEffectUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellEffectCreateOrConnectWithoutSpellInput | SpellEffectCreateOrConnectWithoutSpellInput[]
    createMany?: SpellEffectCreateManySpellInputEnvelope
    connect?: SpellEffectWhereUniqueInput | SpellEffectWhereUniqueInput[]
  }

  export type SpellMessageCreateNestedOneWithoutSpellInput = {
    create?: XOR<SpellMessageCreateWithoutSpellInput, SpellMessageUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellMessageCreateOrConnectWithoutSpellInput
    connect?: SpellMessageWhereUniqueInput
  }

  export type SpellRestrictionCreateNestedOneWithoutSpellInput = {
    create?: XOR<SpellRestrictionCreateWithoutSpellInput, SpellRestrictionUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellRestrictionCreateOrConnectWithoutSpellInput
    connect?: SpellRestrictionWhereUniqueInput
  }

  export type SpellSavingThrowCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellSavingThrowCreateWithoutSpellInput, SpellSavingThrowUncheckedCreateWithoutSpellInput> | SpellSavingThrowCreateWithoutSpellInput[] | SpellSavingThrowUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSavingThrowCreateOrConnectWithoutSpellInput | SpellSavingThrowCreateOrConnectWithoutSpellInput[]
    createMany?: SpellSavingThrowCreateManySpellInputEnvelope
    connect?: SpellSavingThrowWhereUniqueInput | SpellSavingThrowWhereUniqueInput[]
  }

  export type SpellTargetingCreateNestedOneWithoutSpellInput = {
    create?: XOR<SpellTargetingCreateWithoutSpellInput, SpellTargetingUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellTargetingCreateOrConnectWithoutSpellInput
    connect?: SpellTargetingWhereUniqueInput
  }

  export type SpellSchoolCreateNestedOneWithoutSpellsInput = {
    create?: XOR<SpellSchoolCreateWithoutSpellsInput, SpellSchoolUncheckedCreateWithoutSpellsInput>
    connectOrCreate?: SpellSchoolCreateOrConnectWithoutSpellsInput
    connect?: SpellSchoolWhereUniqueInput
  }

  export type CharacterSpellUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<CharacterSpellCreateWithoutSpellInput, CharacterSpellUncheckedCreateWithoutSpellInput> | CharacterSpellCreateWithoutSpellInput[] | CharacterSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: CharacterSpellCreateOrConnectWithoutSpellInput | CharacterSpellCreateOrConnectWithoutSpellInput[]
    createMany?: CharacterSpellCreateManySpellInputEnvelope
    connect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
  }

  export type MobSpellUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<MobSpellCreateWithoutSpellInput, MobSpellUncheckedCreateWithoutSpellInput> | MobSpellCreateWithoutSpellInput[] | MobSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: MobSpellCreateOrConnectWithoutSpellInput | MobSpellCreateOrConnectWithoutSpellInput[]
    createMany?: MobSpellCreateManySpellInputEnvelope
    connect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
  }

  export type SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellClassCircleCreateWithoutSpellInput, SpellClassCircleUncheckedCreateWithoutSpellInput> | SpellClassCircleCreateWithoutSpellInput[] | SpellClassCircleUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellClassCircleCreateOrConnectWithoutSpellInput | SpellClassCircleCreateOrConnectWithoutSpellInput[]
    createMany?: SpellClassCircleCreateManySpellInputEnvelope
    connect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
  }

  export type SpellComponentUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellComponentCreateWithoutSpellInput, SpellComponentUncheckedCreateWithoutSpellInput> | SpellComponentCreateWithoutSpellInput[] | SpellComponentUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellComponentCreateOrConnectWithoutSpellInput | SpellComponentCreateOrConnectWithoutSpellInput[]
    createMany?: SpellComponentCreateManySpellInputEnvelope
    connect?: SpellComponentWhereUniqueInput | SpellComponentWhereUniqueInput[]
  }

  export type SpellEffectUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellEffectCreateWithoutSpellInput, SpellEffectUncheckedCreateWithoutSpellInput> | SpellEffectCreateWithoutSpellInput[] | SpellEffectUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellEffectCreateOrConnectWithoutSpellInput | SpellEffectCreateOrConnectWithoutSpellInput[]
    createMany?: SpellEffectCreateManySpellInputEnvelope
    connect?: SpellEffectWhereUniqueInput | SpellEffectWhereUniqueInput[]
  }

  export type SpellMessageUncheckedCreateNestedOneWithoutSpellInput = {
    create?: XOR<SpellMessageCreateWithoutSpellInput, SpellMessageUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellMessageCreateOrConnectWithoutSpellInput
    connect?: SpellMessageWhereUniqueInput
  }

  export type SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput = {
    create?: XOR<SpellRestrictionCreateWithoutSpellInput, SpellRestrictionUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellRestrictionCreateOrConnectWithoutSpellInput
    connect?: SpellRestrictionWhereUniqueInput
  }

  export type SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput = {
    create?: XOR<SpellSavingThrowCreateWithoutSpellInput, SpellSavingThrowUncheckedCreateWithoutSpellInput> | SpellSavingThrowCreateWithoutSpellInput[] | SpellSavingThrowUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSavingThrowCreateOrConnectWithoutSpellInput | SpellSavingThrowCreateOrConnectWithoutSpellInput[]
    createMany?: SpellSavingThrowCreateManySpellInputEnvelope
    connect?: SpellSavingThrowWhereUniqueInput | SpellSavingThrowWhereUniqueInput[]
  }

  export type SpellTargetingUncheckedCreateNestedOneWithoutSpellInput = {
    create?: XOR<SpellTargetingCreateWithoutSpellInput, SpellTargetingUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellTargetingCreateOrConnectWithoutSpellInput
    connect?: SpellTargetingWhereUniqueInput
  }

  export type CharacterSpellUpdateManyWithoutSpellNestedInput = {
    create?: XOR<CharacterSpellCreateWithoutSpellInput, CharacterSpellUncheckedCreateWithoutSpellInput> | CharacterSpellCreateWithoutSpellInput[] | CharacterSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: CharacterSpellCreateOrConnectWithoutSpellInput | CharacterSpellCreateOrConnectWithoutSpellInput[]
    upsert?: CharacterSpellUpsertWithWhereUniqueWithoutSpellInput | CharacterSpellUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: CharacterSpellCreateManySpellInputEnvelope
    set?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    disconnect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    delete?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    connect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    update?: CharacterSpellUpdateWithWhereUniqueWithoutSpellInput | CharacterSpellUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: CharacterSpellUpdateManyWithWhereWithoutSpellInput | CharacterSpellUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: CharacterSpellScalarWhereInput | CharacterSpellScalarWhereInput[]
  }

  export type MobSpellUpdateManyWithoutSpellNestedInput = {
    create?: XOR<MobSpellCreateWithoutSpellInput, MobSpellUncheckedCreateWithoutSpellInput> | MobSpellCreateWithoutSpellInput[] | MobSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: MobSpellCreateOrConnectWithoutSpellInput | MobSpellCreateOrConnectWithoutSpellInput[]
    upsert?: MobSpellUpsertWithWhereUniqueWithoutSpellInput | MobSpellUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: MobSpellCreateManySpellInputEnvelope
    set?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    disconnect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    delete?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    connect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    update?: MobSpellUpdateWithWhereUniqueWithoutSpellInput | MobSpellUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: MobSpellUpdateManyWithWhereWithoutSpellInput | MobSpellUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: MobSpellScalarWhereInput | MobSpellScalarWhereInput[]
  }

  export type SpellClassCircleUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellClassCircleCreateWithoutSpellInput, SpellClassCircleUncheckedCreateWithoutSpellInput> | SpellClassCircleCreateWithoutSpellInput[] | SpellClassCircleUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellClassCircleCreateOrConnectWithoutSpellInput | SpellClassCircleCreateOrConnectWithoutSpellInput[]
    upsert?: SpellClassCircleUpsertWithWhereUniqueWithoutSpellInput | SpellClassCircleUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellClassCircleCreateManySpellInputEnvelope
    set?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    disconnect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    delete?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    connect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    update?: SpellClassCircleUpdateWithWhereUniqueWithoutSpellInput | SpellClassCircleUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellClassCircleUpdateManyWithWhereWithoutSpellInput | SpellClassCircleUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellClassCircleScalarWhereInput | SpellClassCircleScalarWhereInput[]
  }

  export type SpellComponentUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellComponentCreateWithoutSpellInput, SpellComponentUncheckedCreateWithoutSpellInput> | SpellComponentCreateWithoutSpellInput[] | SpellComponentUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellComponentCreateOrConnectWithoutSpellInput | SpellComponentCreateOrConnectWithoutSpellInput[]
    upsert?: SpellComponentUpsertWithWhereUniqueWithoutSpellInput | SpellComponentUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellComponentCreateManySpellInputEnvelope
    set?: SpellComponentWhereUniqueInput | SpellComponentWhereUniqueInput[]
    disconnect?: SpellComponentWhereUniqueInput | SpellComponentWhereUniqueInput[]
    delete?: SpellComponentWhereUniqueInput | SpellComponentWhereUniqueInput[]
    connect?: SpellComponentWhereUniqueInput | SpellComponentWhereUniqueInput[]
    update?: SpellComponentUpdateWithWhereUniqueWithoutSpellInput | SpellComponentUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellComponentUpdateManyWithWhereWithoutSpellInput | SpellComponentUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellComponentScalarWhereInput | SpellComponentScalarWhereInput[]
  }

  export type SpellEffectUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellEffectCreateWithoutSpellInput, SpellEffectUncheckedCreateWithoutSpellInput> | SpellEffectCreateWithoutSpellInput[] | SpellEffectUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellEffectCreateOrConnectWithoutSpellInput | SpellEffectCreateOrConnectWithoutSpellInput[]
    upsert?: SpellEffectUpsertWithWhereUniqueWithoutSpellInput | SpellEffectUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellEffectCreateManySpellInputEnvelope
    set?: SpellEffectWhereUniqueInput | SpellEffectWhereUniqueInput[]
    disconnect?: SpellEffectWhereUniqueInput | SpellEffectWhereUniqueInput[]
    delete?: SpellEffectWhereUniqueInput | SpellEffectWhereUniqueInput[]
    connect?: SpellEffectWhereUniqueInput | SpellEffectWhereUniqueInput[]
    update?: SpellEffectUpdateWithWhereUniqueWithoutSpellInput | SpellEffectUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellEffectUpdateManyWithWhereWithoutSpellInput | SpellEffectUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellEffectScalarWhereInput | SpellEffectScalarWhereInput[]
  }

  export type SpellMessageUpdateOneWithoutSpellNestedInput = {
    create?: XOR<SpellMessageCreateWithoutSpellInput, SpellMessageUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellMessageCreateOrConnectWithoutSpellInput
    upsert?: SpellMessageUpsertWithoutSpellInput
    disconnect?: SpellMessageWhereInput | boolean
    delete?: SpellMessageWhereInput | boolean
    connect?: SpellMessageWhereUniqueInput
    update?: XOR<XOR<SpellMessageUpdateToOneWithWhereWithoutSpellInput, SpellMessageUpdateWithoutSpellInput>, SpellMessageUncheckedUpdateWithoutSpellInput>
  }

  export type SpellRestrictionUpdateOneWithoutSpellNestedInput = {
    create?: XOR<SpellRestrictionCreateWithoutSpellInput, SpellRestrictionUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellRestrictionCreateOrConnectWithoutSpellInput
    upsert?: SpellRestrictionUpsertWithoutSpellInput
    disconnect?: SpellRestrictionWhereInput | boolean
    delete?: SpellRestrictionWhereInput | boolean
    connect?: SpellRestrictionWhereUniqueInput
    update?: XOR<XOR<SpellRestrictionUpdateToOneWithWhereWithoutSpellInput, SpellRestrictionUpdateWithoutSpellInput>, SpellRestrictionUncheckedUpdateWithoutSpellInput>
  }

  export type SpellSavingThrowUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellSavingThrowCreateWithoutSpellInput, SpellSavingThrowUncheckedCreateWithoutSpellInput> | SpellSavingThrowCreateWithoutSpellInput[] | SpellSavingThrowUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSavingThrowCreateOrConnectWithoutSpellInput | SpellSavingThrowCreateOrConnectWithoutSpellInput[]
    upsert?: SpellSavingThrowUpsertWithWhereUniqueWithoutSpellInput | SpellSavingThrowUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellSavingThrowCreateManySpellInputEnvelope
    set?: SpellSavingThrowWhereUniqueInput | SpellSavingThrowWhereUniqueInput[]
    disconnect?: SpellSavingThrowWhereUniqueInput | SpellSavingThrowWhereUniqueInput[]
    delete?: SpellSavingThrowWhereUniqueInput | SpellSavingThrowWhereUniqueInput[]
    connect?: SpellSavingThrowWhereUniqueInput | SpellSavingThrowWhereUniqueInput[]
    update?: SpellSavingThrowUpdateWithWhereUniqueWithoutSpellInput | SpellSavingThrowUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellSavingThrowUpdateManyWithWhereWithoutSpellInput | SpellSavingThrowUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellSavingThrowScalarWhereInput | SpellSavingThrowScalarWhereInput[]
  }

  export type SpellTargetingUpdateOneWithoutSpellNestedInput = {
    create?: XOR<SpellTargetingCreateWithoutSpellInput, SpellTargetingUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellTargetingCreateOrConnectWithoutSpellInput
    upsert?: SpellTargetingUpsertWithoutSpellInput
    disconnect?: SpellTargetingWhereInput | boolean
    delete?: SpellTargetingWhereInput | boolean
    connect?: SpellTargetingWhereUniqueInput
    update?: XOR<XOR<SpellTargetingUpdateToOneWithWhereWithoutSpellInput, SpellTargetingUpdateWithoutSpellInput>, SpellTargetingUncheckedUpdateWithoutSpellInput>
  }

  export type SpellSchoolUpdateOneWithoutSpellsNestedInput = {
    create?: XOR<SpellSchoolCreateWithoutSpellsInput, SpellSchoolUncheckedCreateWithoutSpellsInput>
    connectOrCreate?: SpellSchoolCreateOrConnectWithoutSpellsInput
    upsert?: SpellSchoolUpsertWithoutSpellsInput
    disconnect?: SpellSchoolWhereInput | boolean
    delete?: SpellSchoolWhereInput | boolean
    connect?: SpellSchoolWhereUniqueInput
    update?: XOR<XOR<SpellSchoolUpdateToOneWithWhereWithoutSpellsInput, SpellSchoolUpdateWithoutSpellsInput>, SpellSchoolUncheckedUpdateWithoutSpellsInput>
  }

  export type CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<CharacterSpellCreateWithoutSpellInput, CharacterSpellUncheckedCreateWithoutSpellInput> | CharacterSpellCreateWithoutSpellInput[] | CharacterSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: CharacterSpellCreateOrConnectWithoutSpellInput | CharacterSpellCreateOrConnectWithoutSpellInput[]
    upsert?: CharacterSpellUpsertWithWhereUniqueWithoutSpellInput | CharacterSpellUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: CharacterSpellCreateManySpellInputEnvelope
    set?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    disconnect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    delete?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    connect?: CharacterSpellWhereUniqueInput | CharacterSpellWhereUniqueInput[]
    update?: CharacterSpellUpdateWithWhereUniqueWithoutSpellInput | CharacterSpellUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: CharacterSpellUpdateManyWithWhereWithoutSpellInput | CharacterSpellUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: CharacterSpellScalarWhereInput | CharacterSpellScalarWhereInput[]
  }

  export type MobSpellUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<MobSpellCreateWithoutSpellInput, MobSpellUncheckedCreateWithoutSpellInput> | MobSpellCreateWithoutSpellInput[] | MobSpellUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: MobSpellCreateOrConnectWithoutSpellInput | MobSpellCreateOrConnectWithoutSpellInput[]
    upsert?: MobSpellUpsertWithWhereUniqueWithoutSpellInput | MobSpellUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: MobSpellCreateManySpellInputEnvelope
    set?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    disconnect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    delete?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    connect?: MobSpellWhereUniqueInput | MobSpellWhereUniqueInput[]
    update?: MobSpellUpdateWithWhereUniqueWithoutSpellInput | MobSpellUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: MobSpellUpdateManyWithWhereWithoutSpellInput | MobSpellUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: MobSpellScalarWhereInput | MobSpellScalarWhereInput[]
  }

  export type SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellClassCircleCreateWithoutSpellInput, SpellClassCircleUncheckedCreateWithoutSpellInput> | SpellClassCircleCreateWithoutSpellInput[] | SpellClassCircleUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellClassCircleCreateOrConnectWithoutSpellInput | SpellClassCircleCreateOrConnectWithoutSpellInput[]
    upsert?: SpellClassCircleUpsertWithWhereUniqueWithoutSpellInput | SpellClassCircleUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellClassCircleCreateManySpellInputEnvelope
    set?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    disconnect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    delete?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    connect?: SpellClassCircleWhereUniqueInput | SpellClassCircleWhereUniqueInput[]
    update?: SpellClassCircleUpdateWithWhereUniqueWithoutSpellInput | SpellClassCircleUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellClassCircleUpdateManyWithWhereWithoutSpellInput | SpellClassCircleUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellClassCircleScalarWhereInput | SpellClassCircleScalarWhereInput[]
  }

  export type SpellComponentUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellComponentCreateWithoutSpellInput, SpellComponentUncheckedCreateWithoutSpellInput> | SpellComponentCreateWithoutSpellInput[] | SpellComponentUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellComponentCreateOrConnectWithoutSpellInput | SpellComponentCreateOrConnectWithoutSpellInput[]
    upsert?: SpellComponentUpsertWithWhereUniqueWithoutSpellInput | SpellComponentUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellComponentCreateManySpellInputEnvelope
    set?: SpellComponentWhereUniqueInput | SpellComponentWhereUniqueInput[]
    disconnect?: SpellComponentWhereUniqueInput | SpellComponentWhereUniqueInput[]
    delete?: SpellComponentWhereUniqueInput | SpellComponentWhereUniqueInput[]
    connect?: SpellComponentWhereUniqueInput | SpellComponentWhereUniqueInput[]
    update?: SpellComponentUpdateWithWhereUniqueWithoutSpellInput | SpellComponentUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellComponentUpdateManyWithWhereWithoutSpellInput | SpellComponentUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellComponentScalarWhereInput | SpellComponentScalarWhereInput[]
  }

  export type SpellEffectUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellEffectCreateWithoutSpellInput, SpellEffectUncheckedCreateWithoutSpellInput> | SpellEffectCreateWithoutSpellInput[] | SpellEffectUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellEffectCreateOrConnectWithoutSpellInput | SpellEffectCreateOrConnectWithoutSpellInput[]
    upsert?: SpellEffectUpsertWithWhereUniqueWithoutSpellInput | SpellEffectUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellEffectCreateManySpellInputEnvelope
    set?: SpellEffectWhereUniqueInput | SpellEffectWhereUniqueInput[]
    disconnect?: SpellEffectWhereUniqueInput | SpellEffectWhereUniqueInput[]
    delete?: SpellEffectWhereUniqueInput | SpellEffectWhereUniqueInput[]
    connect?: SpellEffectWhereUniqueInput | SpellEffectWhereUniqueInput[]
    update?: SpellEffectUpdateWithWhereUniqueWithoutSpellInput | SpellEffectUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellEffectUpdateManyWithWhereWithoutSpellInput | SpellEffectUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellEffectScalarWhereInput | SpellEffectScalarWhereInput[]
  }

  export type SpellMessageUncheckedUpdateOneWithoutSpellNestedInput = {
    create?: XOR<SpellMessageCreateWithoutSpellInput, SpellMessageUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellMessageCreateOrConnectWithoutSpellInput
    upsert?: SpellMessageUpsertWithoutSpellInput
    disconnect?: SpellMessageWhereInput | boolean
    delete?: SpellMessageWhereInput | boolean
    connect?: SpellMessageWhereUniqueInput
    update?: XOR<XOR<SpellMessageUpdateToOneWithWhereWithoutSpellInput, SpellMessageUpdateWithoutSpellInput>, SpellMessageUncheckedUpdateWithoutSpellInput>
  }

  export type SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput = {
    create?: XOR<SpellRestrictionCreateWithoutSpellInput, SpellRestrictionUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellRestrictionCreateOrConnectWithoutSpellInput
    upsert?: SpellRestrictionUpsertWithoutSpellInput
    disconnect?: SpellRestrictionWhereInput | boolean
    delete?: SpellRestrictionWhereInput | boolean
    connect?: SpellRestrictionWhereUniqueInput
    update?: XOR<XOR<SpellRestrictionUpdateToOneWithWhereWithoutSpellInput, SpellRestrictionUpdateWithoutSpellInput>, SpellRestrictionUncheckedUpdateWithoutSpellInput>
  }

  export type SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput = {
    create?: XOR<SpellSavingThrowCreateWithoutSpellInput, SpellSavingThrowUncheckedCreateWithoutSpellInput> | SpellSavingThrowCreateWithoutSpellInput[] | SpellSavingThrowUncheckedCreateWithoutSpellInput[]
    connectOrCreate?: SpellSavingThrowCreateOrConnectWithoutSpellInput | SpellSavingThrowCreateOrConnectWithoutSpellInput[]
    upsert?: SpellSavingThrowUpsertWithWhereUniqueWithoutSpellInput | SpellSavingThrowUpsertWithWhereUniqueWithoutSpellInput[]
    createMany?: SpellSavingThrowCreateManySpellInputEnvelope
    set?: SpellSavingThrowWhereUniqueInput | SpellSavingThrowWhereUniqueInput[]
    disconnect?: SpellSavingThrowWhereUniqueInput | SpellSavingThrowWhereUniqueInput[]
    delete?: SpellSavingThrowWhereUniqueInput | SpellSavingThrowWhereUniqueInput[]
    connect?: SpellSavingThrowWhereUniqueInput | SpellSavingThrowWhereUniqueInput[]
    update?: SpellSavingThrowUpdateWithWhereUniqueWithoutSpellInput | SpellSavingThrowUpdateWithWhereUniqueWithoutSpellInput[]
    updateMany?: SpellSavingThrowUpdateManyWithWhereWithoutSpellInput | SpellSavingThrowUpdateManyWithWhereWithoutSpellInput[]
    deleteMany?: SpellSavingThrowScalarWhereInput | SpellSavingThrowScalarWhereInput[]
  }

  export type SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput = {
    create?: XOR<SpellTargetingCreateWithoutSpellInput, SpellTargetingUncheckedCreateWithoutSpellInput>
    connectOrCreate?: SpellTargetingCreateOrConnectWithoutSpellInput
    upsert?: SpellTargetingUpsertWithoutSpellInput
    disconnect?: SpellTargetingWhereInput | boolean
    delete?: SpellTargetingWhereInput | boolean
    connect?: SpellTargetingWhereUniqueInput
    update?: XOR<XOR<SpellTargetingUpdateToOneWithWhereWithoutSpellInput, SpellTargetingUpdateWithoutSpellInput>, SpellTargetingUncheckedUpdateWithoutSpellInput>
  }

  export type SpellCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SpellCreateWithoutSchoolInput, SpellUncheckedCreateWithoutSchoolInput> | SpellCreateWithoutSchoolInput[] | SpellUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutSchoolInput | SpellCreateOrConnectWithoutSchoolInput[]
    createMany?: SpellCreateManySchoolInputEnvelope
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type SpellUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SpellCreateWithoutSchoolInput, SpellUncheckedCreateWithoutSchoolInput> | SpellCreateWithoutSchoolInput[] | SpellUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutSchoolInput | SpellCreateOrConnectWithoutSchoolInput[]
    createMany?: SpellCreateManySchoolInputEnvelope
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
  }

  export type SpellUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SpellCreateWithoutSchoolInput, SpellUncheckedCreateWithoutSchoolInput> | SpellCreateWithoutSchoolInput[] | SpellUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutSchoolInput | SpellCreateOrConnectWithoutSchoolInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutSchoolInput | SpellUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SpellCreateManySchoolInputEnvelope
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutSchoolInput | SpellUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutSchoolInput | SpellUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type SpellUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SpellCreateWithoutSchoolInput, SpellUncheckedCreateWithoutSchoolInput> | SpellCreateWithoutSchoolInput[] | SpellUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SpellCreateOrConnectWithoutSchoolInput | SpellCreateOrConnectWithoutSchoolInput[]
    upsert?: SpellUpsertWithWhereUniqueWithoutSchoolInput | SpellUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SpellCreateManySchoolInputEnvelope
    set?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    disconnect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    delete?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    connect?: SpellWhereUniqueInput | SpellWhereUniqueInput[]
    update?: SpellUpdateWithWhereUniqueWithoutSchoolInput | SpellUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SpellUpdateManyWithWhereWithoutSchoolInput | SpellUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SpellScalarWhereInput | SpellScalarWhereInput[]
  }

  export type GameClassCreateNestedOneWithoutSpellCirclesInput = {
    create?: XOR<GameClassCreateWithoutSpellCirclesInput, GameClassUncheckedCreateWithoutSpellCirclesInput>
    connectOrCreate?: GameClassCreateOrConnectWithoutSpellCirclesInput
    connect?: GameClassWhereUniqueInput
  }

  export type SpellCreateNestedOneWithoutClassCirclesInput = {
    create?: XOR<SpellCreateWithoutClassCirclesInput, SpellUncheckedCreateWithoutClassCirclesInput>
    connectOrCreate?: SpellCreateOrConnectWithoutClassCirclesInput
    connect?: SpellWhereUniqueInput
  }

  export type GameClassUpdateOneRequiredWithoutSpellCirclesNestedInput = {
    create?: XOR<GameClassCreateWithoutSpellCirclesInput, GameClassUncheckedCreateWithoutSpellCirclesInput>
    connectOrCreate?: GameClassCreateOrConnectWithoutSpellCirclesInput
    upsert?: GameClassUpsertWithoutSpellCirclesInput
    connect?: GameClassWhereUniqueInput
    update?: XOR<XOR<GameClassUpdateToOneWithWhereWithoutSpellCirclesInput, GameClassUpdateWithoutSpellCirclesInput>, GameClassUncheckedUpdateWithoutSpellCirclesInput>
  }

  export type SpellUpdateOneRequiredWithoutClassCirclesNestedInput = {
    create?: XOR<SpellCreateWithoutClassCirclesInput, SpellUncheckedCreateWithoutClassCirclesInput>
    connectOrCreate?: SpellCreateOrConnectWithoutClassCirclesInput
    upsert?: SpellUpsertWithoutClassCirclesInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutClassCirclesInput, SpellUpdateWithoutClassCirclesInput>, SpellUncheckedUpdateWithoutClassCirclesInput>
  }

  export type SpellCreateNestedOneWithoutTargetingInput = {
    create?: XOR<SpellCreateWithoutTargetingInput, SpellUncheckedCreateWithoutTargetingInput>
    connectOrCreate?: SpellCreateOrConnectWithoutTargetingInput
    connect?: SpellWhereUniqueInput
  }

  export type EnumTargetScopeFieldUpdateOperationsInput = {
    set?: $Enums.TargetScope
  }

  export type EnumSpellRangeFieldUpdateOperationsInput = {
    set?: $Enums.SpellRange
  }

  export type SpellUpdateOneRequiredWithoutTargetingNestedInput = {
    create?: XOR<SpellCreateWithoutTargetingInput, SpellUncheckedCreateWithoutTargetingInput>
    connectOrCreate?: SpellCreateOrConnectWithoutTargetingInput
    upsert?: SpellUpsertWithoutTargetingInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutTargetingInput, SpellUpdateWithoutTargetingInput>, SpellUncheckedUpdateWithoutTargetingInput>
  }

  export type SpellCreateNestedOneWithoutSavingThrowsInput = {
    create?: XOR<SpellCreateWithoutSavingThrowsInput, SpellUncheckedCreateWithoutSavingThrowsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSavingThrowsInput
    connect?: SpellWhereUniqueInput
  }

  export type EnumSaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.SaveType
  }

  export type EnumSaveResultFieldUpdateOperationsInput = {
    set?: $Enums.SaveResult
  }

  export type SpellUpdateOneRequiredWithoutSavingThrowsNestedInput = {
    create?: XOR<SpellCreateWithoutSavingThrowsInput, SpellUncheckedCreateWithoutSavingThrowsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutSavingThrowsInput
    upsert?: SpellUpsertWithoutSavingThrowsInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutSavingThrowsInput, SpellUpdateWithoutSavingThrowsInput>, SpellUncheckedUpdateWithoutSavingThrowsInput>
  }

  export type SpellCreateNestedOneWithoutMessagesInput = {
    create?: XOR<SpellCreateWithoutMessagesInput, SpellUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SpellCreateOrConnectWithoutMessagesInput
    connect?: SpellWhereUniqueInput
  }

  export type SpellUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<SpellCreateWithoutMessagesInput, SpellUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SpellCreateOrConnectWithoutMessagesInput
    upsert?: SpellUpsertWithoutMessagesInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutMessagesInput, SpellUpdateWithoutMessagesInput>, SpellUncheckedUpdateWithoutMessagesInput>
  }

  export type SpellCreateNestedOneWithoutComponentsInput = {
    create?: XOR<SpellCreateWithoutComponentsInput, SpellUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutComponentsInput
    connect?: SpellWhereUniqueInput
  }

  export type SpellUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<SpellCreateWithoutComponentsInput, SpellUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutComponentsInput
    upsert?: SpellUpsertWithoutComponentsInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutComponentsInput, SpellUpdateWithoutComponentsInput>, SpellUncheckedUpdateWithoutComponentsInput>
  }

  export type SpellCreateNestedOneWithoutRestrictionsInput = {
    create?: XOR<SpellCreateWithoutRestrictionsInput, SpellUncheckedCreateWithoutRestrictionsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutRestrictionsInput
    connect?: SpellWhereUniqueInput
  }

  export type SpellUpdateOneRequiredWithoutRestrictionsNestedInput = {
    create?: XOR<SpellCreateWithoutRestrictionsInput, SpellUncheckedCreateWithoutRestrictionsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutRestrictionsInput
    upsert?: SpellUpsertWithoutRestrictionsInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutRestrictionsInput, SpellUpdateWithoutRestrictionsInput>, SpellUncheckedUpdateWithoutRestrictionsInput>
  }

  export type SpellCreateNestedOneWithoutEffectsInput = {
    create?: XOR<SpellCreateWithoutEffectsInput, SpellUncheckedCreateWithoutEffectsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutEffectsInput
    connect?: SpellWhereUniqueInput
  }

  export type EnumEffectTypeFieldUpdateOperationsInput = {
    set?: $Enums.EffectType
  }

  export type NullableEnumEffectTriggerFieldUpdateOperationsInput = {
    set?: $Enums.EffectTrigger | null
  }

  export type EnumStackingRuleFieldUpdateOperationsInput = {
    set?: $Enums.StackingRule
  }

  export type SpellUpdateOneRequiredWithoutEffectsNestedInput = {
    create?: XOR<SpellCreateWithoutEffectsInput, SpellUncheckedCreateWithoutEffectsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutEffectsInput
    upsert?: SpellUpsertWithoutEffectsInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutEffectsInput, SpellUpdateWithoutEffectsInput>, SpellUncheckedUpdateWithoutEffectsInput>
  }

  export type CharacterSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<CharacterSkillCreateWithoutSkillInput, CharacterSkillUncheckedCreateWithoutSkillInput> | CharacterSkillCreateWithoutSkillInput[] | CharacterSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutSkillInput | CharacterSkillCreateOrConnectWithoutSkillInput[]
    createMany?: CharacterSkillCreateManySkillInputEnvelope
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
  }

  export type ClassSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<ClassSkillCreateWithoutSkillInput, ClassSkillUncheckedCreateWithoutSkillInput> | ClassSkillCreateWithoutSkillInput[] | ClassSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ClassSkillCreateOrConnectWithoutSkillInput | ClassSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ClassSkillCreateManySkillInputEnvelope
    connect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
  }

  export type MobSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<MobSkillCreateWithoutSkillInput, MobSkillUncheckedCreateWithoutSkillInput> | MobSkillCreateWithoutSkillInput[] | MobSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: MobSkillCreateOrConnectWithoutSkillInput | MobSkillCreateOrConnectWithoutSkillInput[]
    createMany?: MobSkillCreateManySkillInputEnvelope
    connect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
  }

  export type RaceSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<RaceSkillCreateWithoutSkillInput, RaceSkillUncheckedCreateWithoutSkillInput> | RaceSkillCreateWithoutSkillInput[] | RaceSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: RaceSkillCreateOrConnectWithoutSkillInput | RaceSkillCreateOrConnectWithoutSkillInput[]
    createMany?: RaceSkillCreateManySkillInputEnvelope
    connect?: RaceSkillWhereUniqueInput | RaceSkillWhereUniqueInput[]
  }

  export type CharacterSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<CharacterSkillCreateWithoutSkillInput, CharacterSkillUncheckedCreateWithoutSkillInput> | CharacterSkillCreateWithoutSkillInput[] | CharacterSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutSkillInput | CharacterSkillCreateOrConnectWithoutSkillInput[]
    createMany?: CharacterSkillCreateManySkillInputEnvelope
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
  }

  export type ClassSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<ClassSkillCreateWithoutSkillInput, ClassSkillUncheckedCreateWithoutSkillInput> | ClassSkillCreateWithoutSkillInput[] | ClassSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ClassSkillCreateOrConnectWithoutSkillInput | ClassSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ClassSkillCreateManySkillInputEnvelope
    connect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
  }

  export type MobSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<MobSkillCreateWithoutSkillInput, MobSkillUncheckedCreateWithoutSkillInput> | MobSkillCreateWithoutSkillInput[] | MobSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: MobSkillCreateOrConnectWithoutSkillInput | MobSkillCreateOrConnectWithoutSkillInput[]
    createMany?: MobSkillCreateManySkillInputEnvelope
    connect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
  }

  export type RaceSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<RaceSkillCreateWithoutSkillInput, RaceSkillUncheckedCreateWithoutSkillInput> | RaceSkillCreateWithoutSkillInput[] | RaceSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: RaceSkillCreateOrConnectWithoutSkillInput | RaceSkillCreateOrConnectWithoutSkillInput[]
    createMany?: RaceSkillCreateManySkillInputEnvelope
    connect?: RaceSkillWhereUniqueInput | RaceSkillWhereUniqueInput[]
  }

  export type EnumSkillTypeFieldUpdateOperationsInput = {
    set?: $Enums.SkillType
  }

  export type EnumSkillCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SkillCategory
  }

  export type CharacterSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutSkillInput, CharacterSkillUncheckedCreateWithoutSkillInput> | CharacterSkillCreateWithoutSkillInput[] | CharacterSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutSkillInput | CharacterSkillCreateOrConnectWithoutSkillInput[]
    upsert?: CharacterSkillUpsertWithWhereUniqueWithoutSkillInput | CharacterSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: CharacterSkillCreateManySkillInputEnvelope
    set?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    disconnect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    delete?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    update?: CharacterSkillUpdateWithWhereUniqueWithoutSkillInput | CharacterSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: CharacterSkillUpdateManyWithWhereWithoutSkillInput | CharacterSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
  }

  export type ClassSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ClassSkillCreateWithoutSkillInput, ClassSkillUncheckedCreateWithoutSkillInput> | ClassSkillCreateWithoutSkillInput[] | ClassSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ClassSkillCreateOrConnectWithoutSkillInput | ClassSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ClassSkillUpsertWithWhereUniqueWithoutSkillInput | ClassSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ClassSkillCreateManySkillInputEnvelope
    set?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    disconnect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    delete?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    connect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    update?: ClassSkillUpdateWithWhereUniqueWithoutSkillInput | ClassSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ClassSkillUpdateManyWithWhereWithoutSkillInput | ClassSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ClassSkillScalarWhereInput | ClassSkillScalarWhereInput[]
  }

  export type MobSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<MobSkillCreateWithoutSkillInput, MobSkillUncheckedCreateWithoutSkillInput> | MobSkillCreateWithoutSkillInput[] | MobSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: MobSkillCreateOrConnectWithoutSkillInput | MobSkillCreateOrConnectWithoutSkillInput[]
    upsert?: MobSkillUpsertWithWhereUniqueWithoutSkillInput | MobSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: MobSkillCreateManySkillInputEnvelope
    set?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    disconnect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    delete?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    connect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    update?: MobSkillUpdateWithWhereUniqueWithoutSkillInput | MobSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: MobSkillUpdateManyWithWhereWithoutSkillInput | MobSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: MobSkillScalarWhereInput | MobSkillScalarWhereInput[]
  }

  export type RaceSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<RaceSkillCreateWithoutSkillInput, RaceSkillUncheckedCreateWithoutSkillInput> | RaceSkillCreateWithoutSkillInput[] | RaceSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: RaceSkillCreateOrConnectWithoutSkillInput | RaceSkillCreateOrConnectWithoutSkillInput[]
    upsert?: RaceSkillUpsertWithWhereUniqueWithoutSkillInput | RaceSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: RaceSkillCreateManySkillInputEnvelope
    set?: RaceSkillWhereUniqueInput | RaceSkillWhereUniqueInput[]
    disconnect?: RaceSkillWhereUniqueInput | RaceSkillWhereUniqueInput[]
    delete?: RaceSkillWhereUniqueInput | RaceSkillWhereUniqueInput[]
    connect?: RaceSkillWhereUniqueInput | RaceSkillWhereUniqueInput[]
    update?: RaceSkillUpdateWithWhereUniqueWithoutSkillInput | RaceSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: RaceSkillUpdateManyWithWhereWithoutSkillInput | RaceSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: RaceSkillScalarWhereInput | RaceSkillScalarWhereInput[]
  }

  export type CharacterSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutSkillInput, CharacterSkillUncheckedCreateWithoutSkillInput> | CharacterSkillCreateWithoutSkillInput[] | CharacterSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutSkillInput | CharacterSkillCreateOrConnectWithoutSkillInput[]
    upsert?: CharacterSkillUpsertWithWhereUniqueWithoutSkillInput | CharacterSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: CharacterSkillCreateManySkillInputEnvelope
    set?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    disconnect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    delete?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    update?: CharacterSkillUpdateWithWhereUniqueWithoutSkillInput | CharacterSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: CharacterSkillUpdateManyWithWhereWithoutSkillInput | CharacterSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
  }

  export type ClassSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ClassSkillCreateWithoutSkillInput, ClassSkillUncheckedCreateWithoutSkillInput> | ClassSkillCreateWithoutSkillInput[] | ClassSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ClassSkillCreateOrConnectWithoutSkillInput | ClassSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ClassSkillUpsertWithWhereUniqueWithoutSkillInput | ClassSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ClassSkillCreateManySkillInputEnvelope
    set?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    disconnect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    delete?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    connect?: ClassSkillWhereUniqueInput | ClassSkillWhereUniqueInput[]
    update?: ClassSkillUpdateWithWhereUniqueWithoutSkillInput | ClassSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ClassSkillUpdateManyWithWhereWithoutSkillInput | ClassSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ClassSkillScalarWhereInput | ClassSkillScalarWhereInput[]
  }

  export type MobSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<MobSkillCreateWithoutSkillInput, MobSkillUncheckedCreateWithoutSkillInput> | MobSkillCreateWithoutSkillInput[] | MobSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: MobSkillCreateOrConnectWithoutSkillInput | MobSkillCreateOrConnectWithoutSkillInput[]
    upsert?: MobSkillUpsertWithWhereUniqueWithoutSkillInput | MobSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: MobSkillCreateManySkillInputEnvelope
    set?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    disconnect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    delete?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    connect?: MobSkillWhereUniqueInput | MobSkillWhereUniqueInput[]
    update?: MobSkillUpdateWithWhereUniqueWithoutSkillInput | MobSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: MobSkillUpdateManyWithWhereWithoutSkillInput | MobSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: MobSkillScalarWhereInput | MobSkillScalarWhereInput[]
  }

  export type RaceSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<RaceSkillCreateWithoutSkillInput, RaceSkillUncheckedCreateWithoutSkillInput> | RaceSkillCreateWithoutSkillInput[] | RaceSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: RaceSkillCreateOrConnectWithoutSkillInput | RaceSkillCreateOrConnectWithoutSkillInput[]
    upsert?: RaceSkillUpsertWithWhereUniqueWithoutSkillInput | RaceSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: RaceSkillCreateManySkillInputEnvelope
    set?: RaceSkillWhereUniqueInput | RaceSkillWhereUniqueInput[]
    disconnect?: RaceSkillWhereUniqueInput | RaceSkillWhereUniqueInput[]
    delete?: RaceSkillWhereUniqueInput | RaceSkillWhereUniqueInput[]
    connect?: RaceSkillWhereUniqueInput | RaceSkillWhereUniqueInput[]
    update?: RaceSkillUpdateWithWhereUniqueWithoutSkillInput | RaceSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: RaceSkillUpdateManyWithWhereWithoutSkillInput | RaceSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: RaceSkillScalarWhereInput | RaceSkillScalarWhereInput[]
  }

  export type GameClassCreateNestedOneWithoutSkillAccessInput = {
    create?: XOR<GameClassCreateWithoutSkillAccessInput, GameClassUncheckedCreateWithoutSkillAccessInput>
    connectOrCreate?: GameClassCreateOrConnectWithoutSkillAccessInput
    connect?: GameClassWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutClassSkillsInput = {
    create?: XOR<SkillCreateWithoutClassSkillsInput, SkillUncheckedCreateWithoutClassSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutClassSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type GameClassUpdateOneRequiredWithoutSkillAccessNestedInput = {
    create?: XOR<GameClassCreateWithoutSkillAccessInput, GameClassUncheckedCreateWithoutSkillAccessInput>
    connectOrCreate?: GameClassCreateOrConnectWithoutSkillAccessInput
    upsert?: GameClassUpsertWithoutSkillAccessInput
    connect?: GameClassWhereUniqueInput
    update?: XOR<XOR<GameClassUpdateToOneWithWhereWithoutSkillAccessInput, GameClassUpdateWithoutSkillAccessInput>, GameClassUncheckedUpdateWithoutSkillAccessInput>
  }

  export type SkillUpdateOneRequiredWithoutClassSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutClassSkillsInput, SkillUncheckedCreateWithoutClassSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutClassSkillsInput
    upsert?: SkillUpsertWithoutClassSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutClassSkillsInput, SkillUpdateWithoutClassSkillsInput>, SkillUncheckedUpdateWithoutClassSkillsInput>
  }

  export type SkillCreateNestedOneWithoutRaceSkillsInput = {
    create?: XOR<SkillCreateWithoutRaceSkillsInput, SkillUncheckedCreateWithoutRaceSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutRaceSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type SkillUpdateOneRequiredWithoutRaceSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutRaceSkillsInput, SkillUncheckedCreateWithoutRaceSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutRaceSkillsInput
    upsert?: SkillUpsertWithoutRaceSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutRaceSkillsInput, SkillUpdateWithoutRaceSkillsInput>, SkillUncheckedUpdateWithoutRaceSkillsInput>
  }

  export type CharacterCreateNestedOneWithoutSkillsInput = {
    create?: XOR<CharacterCreateWithoutSkillsInput, CharacterUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutSkillsInput
    connect?: CharacterWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutCharacterSkillsInput = {
    create?: XOR<SkillCreateWithoutCharacterSkillsInput, SkillUncheckedCreateWithoutCharacterSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCharacterSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type CharacterUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<CharacterCreateWithoutSkillsInput, CharacterUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutSkillsInput
    upsert?: CharacterUpsertWithoutSkillsInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutSkillsInput, CharacterUpdateWithoutSkillsInput>, CharacterUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutCharacterSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutCharacterSkillsInput, SkillUncheckedCreateWithoutCharacterSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCharacterSkillsInput
    upsert?: SkillUpsertWithoutCharacterSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutCharacterSkillsInput, SkillUpdateWithoutCharacterSkillsInput>, SkillUncheckedUpdateWithoutCharacterSkillsInput>
  }

  export type CharacterCreateNestedOneWithoutSpellsInput = {
    create?: XOR<CharacterCreateWithoutSpellsInput, CharacterUncheckedCreateWithoutSpellsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutSpellsInput
    connect?: CharacterWhereUniqueInput
  }

  export type SpellCreateNestedOneWithoutCharacterSpellsInput = {
    create?: XOR<SpellCreateWithoutCharacterSpellsInput, SpellUncheckedCreateWithoutCharacterSpellsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutCharacterSpellsInput
    connect?: SpellWhereUniqueInput
  }

  export type CharacterUpdateOneRequiredWithoutSpellsNestedInput = {
    create?: XOR<CharacterCreateWithoutSpellsInput, CharacterUncheckedCreateWithoutSpellsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutSpellsInput
    upsert?: CharacterUpsertWithoutSpellsInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutSpellsInput, CharacterUpdateWithoutSpellsInput>, CharacterUncheckedUpdateWithoutSpellsInput>
  }

  export type SpellUpdateOneRequiredWithoutCharacterSpellsNestedInput = {
    create?: XOR<SpellCreateWithoutCharacterSpellsInput, SpellUncheckedCreateWithoutCharacterSpellsInput>
    connectOrCreate?: SpellCreateOrConnectWithoutCharacterSpellsInput
    upsert?: SpellUpsertWithoutCharacterSpellsInput
    connect?: SpellWhereUniqueInput
    update?: XOR<XOR<SpellUpdateToOneWithWhereWithoutCharacterSpellsInput, SpellUpdateWithoutCharacterSpellsInput>, SpellUncheckedUpdateWithoutCharacterSpellsInput>
  }

  export type UserCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<UserCreateWithoutChangeLogsInput, UserUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangeLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChangeLogsNestedInput = {
    create?: XOR<UserCreateWithoutChangeLogsInput, UserUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangeLogsInput
    upsert?: UserUpsertWithoutChangeLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChangeLogsInput, UserUpdateWithoutChangeLogsInput>, UserUncheckedUpdateWithoutChangeLogsInput>
  }

  export type UserCreateNestedOneWithoutIssuedBansInput = {
    create?: XOR<UserCreateWithoutIssuedBansInput, UserUncheckedCreateWithoutIssuedBansInput>
    connectOrCreate?: UserCreateOrConnectWithoutIssuedBansInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBanRecordsInput = {
    create?: XOR<UserCreateWithoutBanRecordsInput, UserUncheckedCreateWithoutBanRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBanRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIssuedBansNestedInput = {
    create?: XOR<UserCreateWithoutIssuedBansInput, UserUncheckedCreateWithoutIssuedBansInput>
    connectOrCreate?: UserCreateOrConnectWithoutIssuedBansInput
    upsert?: UserUpsertWithoutIssuedBansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIssuedBansInput, UserUpdateWithoutIssuedBansInput>, UserUncheckedUpdateWithoutIssuedBansInput>
  }

  export type UserUpdateOneRequiredWithoutBanRecordsNestedInput = {
    create?: XOR<UserCreateWithoutBanRecordsInput, UserUncheckedCreateWithoutBanRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBanRecordsInput
    upsert?: UserUpsertWithoutBanRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBanRecordsInput, UserUpdateWithoutBanRecordsInput>, UserUncheckedUpdateWithoutBanRecordsInput>
  }

  export type CharacterItemCreateinstanceFlagsInput = {
    set: string[]
  }

  export type CharacterCreateNestedOneWithoutItemsInput = {
    create?: XOR<CharacterCreateWithoutItemsInput, CharacterUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutItemsInput
    connect?: CharacterWhereUniqueInput
  }

  export type CharacterItemCreateNestedOneWithoutContainedItemsInput = {
    create?: XOR<CharacterItemCreateWithoutContainedItemsInput, CharacterItemUncheckedCreateWithoutContainedItemsInput>
    connectOrCreate?: CharacterItemCreateOrConnectWithoutContainedItemsInput
    connect?: CharacterItemWhereUniqueInput
  }

  export type CharacterItemCreateNestedManyWithoutContainerInput = {
    create?: XOR<CharacterItemCreateWithoutContainerInput, CharacterItemUncheckedCreateWithoutContainerInput> | CharacterItemCreateWithoutContainerInput[] | CharacterItemUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutContainerInput | CharacterItemCreateOrConnectWithoutContainerInput[]
    createMany?: CharacterItemCreateManyContainerInputEnvelope
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
  }

  export type ObjectCreateNestedOneWithoutCharacterItemsInput = {
    create?: XOR<ObjectCreateWithoutCharacterItemsInput, ObjectUncheckedCreateWithoutCharacterItemsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutCharacterItemsInput
    connect?: ObjectWhereUniqueInput
  }

  export type CharacterItemUncheckedCreateNestedManyWithoutContainerInput = {
    create?: XOR<CharacterItemCreateWithoutContainerInput, CharacterItemUncheckedCreateWithoutContainerInput> | CharacterItemCreateWithoutContainerInput[] | CharacterItemUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutContainerInput | CharacterItemCreateOrConnectWithoutContainerInput[]
    createMany?: CharacterItemCreateManyContainerInputEnvelope
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
  }

  export type CharacterItemUpdateinstanceFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CharacterUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CharacterCreateWithoutItemsInput, CharacterUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutItemsInput
    upsert?: CharacterUpsertWithoutItemsInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutItemsInput, CharacterUpdateWithoutItemsInput>, CharacterUncheckedUpdateWithoutItemsInput>
  }

  export type CharacterItemUpdateOneWithoutContainedItemsNestedInput = {
    create?: XOR<CharacterItemCreateWithoutContainedItemsInput, CharacterItemUncheckedCreateWithoutContainedItemsInput>
    connectOrCreate?: CharacterItemCreateOrConnectWithoutContainedItemsInput
    upsert?: CharacterItemUpsertWithoutContainedItemsInput
    disconnect?: CharacterItemWhereInput | boolean
    delete?: CharacterItemWhereInput | boolean
    connect?: CharacterItemWhereUniqueInput
    update?: XOR<XOR<CharacterItemUpdateToOneWithWhereWithoutContainedItemsInput, CharacterItemUpdateWithoutContainedItemsInput>, CharacterItemUncheckedUpdateWithoutContainedItemsInput>
  }

  export type CharacterItemUpdateManyWithoutContainerNestedInput = {
    create?: XOR<CharacterItemCreateWithoutContainerInput, CharacterItemUncheckedCreateWithoutContainerInput> | CharacterItemCreateWithoutContainerInput[] | CharacterItemUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutContainerInput | CharacterItemCreateOrConnectWithoutContainerInput[]
    upsert?: CharacterItemUpsertWithWhereUniqueWithoutContainerInput | CharacterItemUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: CharacterItemCreateManyContainerInputEnvelope
    set?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    disconnect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    delete?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    update?: CharacterItemUpdateWithWhereUniqueWithoutContainerInput | CharacterItemUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: CharacterItemUpdateManyWithWhereWithoutContainerInput | CharacterItemUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: CharacterItemScalarWhereInput | CharacterItemScalarWhereInput[]
  }

  export type ObjectUpdateOneRequiredWithoutCharacterItemsNestedInput = {
    create?: XOR<ObjectCreateWithoutCharacterItemsInput, ObjectUncheckedCreateWithoutCharacterItemsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutCharacterItemsInput
    upsert?: ObjectUpsertWithoutCharacterItemsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutCharacterItemsInput, ObjectUpdateWithoutCharacterItemsInput>, ObjectUncheckedUpdateWithoutCharacterItemsInput>
  }

  export type CharacterItemUncheckedUpdateManyWithoutContainerNestedInput = {
    create?: XOR<CharacterItemCreateWithoutContainerInput, CharacterItemUncheckedCreateWithoutContainerInput> | CharacterItemCreateWithoutContainerInput[] | CharacterItemUncheckedCreateWithoutContainerInput[]
    connectOrCreate?: CharacterItemCreateOrConnectWithoutContainerInput | CharacterItemCreateOrConnectWithoutContainerInput[]
    upsert?: CharacterItemUpsertWithWhereUniqueWithoutContainerInput | CharacterItemUpsertWithWhereUniqueWithoutContainerInput[]
    createMany?: CharacterItemCreateManyContainerInputEnvelope
    set?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    disconnect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    delete?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    connect?: CharacterItemWhereUniqueInput | CharacterItemWhereUniqueInput[]
    update?: CharacterItemUpdateWithWhereUniqueWithoutContainerInput | CharacterItemUpdateWithWhereUniqueWithoutContainerInput[]
    updateMany?: CharacterItemUpdateManyWithWhereWithoutContainerInput | CharacterItemUpdateManyWithWhereWithoutContainerInput[]
    deleteMany?: CharacterItemScalarWhereInput | CharacterItemScalarWhereInput[]
  }

  export type CharacterCreateNestedOneWithoutEffectsInput = {
    create?: XOR<CharacterCreateWithoutEffectsInput, CharacterUncheckedCreateWithoutEffectsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutEffectsInput
    connect?: CharacterWhereUniqueInput
  }

  export type CharacterUpdateOneRequiredWithoutEffectsNestedInput = {
    create?: XOR<CharacterCreateWithoutEffectsInput, CharacterUncheckedCreateWithoutEffectsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutEffectsInput
    upsert?: CharacterUpsertWithoutEffectsInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutEffectsInput, CharacterUpdateWithoutEffectsInput>, CharacterUncheckedUpdateWithoutEffectsInput>
  }

  export type EquipmentSetCreateNestedOneWithoutItemsInput = {
    create?: XOR<EquipmentSetCreateWithoutItemsInput, EquipmentSetUncheckedCreateWithoutItemsInput>
    connectOrCreate?: EquipmentSetCreateOrConnectWithoutItemsInput
    connect?: EquipmentSetWhereUniqueInput
  }

  export type ObjectCreateNestedOneWithoutEquipmentSetItemsInput = {
    create?: XOR<ObjectCreateWithoutEquipmentSetItemsInput, ObjectUncheckedCreateWithoutEquipmentSetItemsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutEquipmentSetItemsInput
    connect?: ObjectWhereUniqueInput
  }

  export type EquipmentSetUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<EquipmentSetCreateWithoutItemsInput, EquipmentSetUncheckedCreateWithoutItemsInput>
    connectOrCreate?: EquipmentSetCreateOrConnectWithoutItemsInput
    upsert?: EquipmentSetUpsertWithoutItemsInput
    connect?: EquipmentSetWhereUniqueInput
    update?: XOR<XOR<EquipmentSetUpdateToOneWithWhereWithoutItemsInput, EquipmentSetUpdateWithoutItemsInput>, EquipmentSetUncheckedUpdateWithoutItemsInput>
  }

  export type ObjectUpdateOneRequiredWithoutEquipmentSetItemsNestedInput = {
    create?: XOR<ObjectCreateWithoutEquipmentSetItemsInput, ObjectUncheckedCreateWithoutEquipmentSetItemsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutEquipmentSetItemsInput
    upsert?: ObjectUpsertWithoutEquipmentSetItemsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutEquipmentSetItemsInput, ObjectUpdateWithoutEquipmentSetItemsInput>, ObjectUncheckedUpdateWithoutEquipmentSetItemsInput>
  }

  export type EquipmentSetItemCreateNestedManyWithoutEquipmentSetInput = {
    create?: XOR<EquipmentSetItemCreateWithoutEquipmentSetInput, EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput> | EquipmentSetItemCreateWithoutEquipmentSetInput[] | EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput[]
    connectOrCreate?: EquipmentSetItemCreateOrConnectWithoutEquipmentSetInput | EquipmentSetItemCreateOrConnectWithoutEquipmentSetInput[]
    createMany?: EquipmentSetItemCreateManyEquipmentSetInputEnvelope
    connect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
  }

  export type MobEquipmentSetCreateNestedManyWithoutEquipmentSetInput = {
    create?: XOR<MobEquipmentSetCreateWithoutEquipmentSetInput, MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput> | MobEquipmentSetCreateWithoutEquipmentSetInput[] | MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput[]
    connectOrCreate?: MobEquipmentSetCreateOrConnectWithoutEquipmentSetInput | MobEquipmentSetCreateOrConnectWithoutEquipmentSetInput[]
    createMany?: MobEquipmentSetCreateManyEquipmentSetInputEnvelope
    connect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
  }

  export type EquipmentSetItemUncheckedCreateNestedManyWithoutEquipmentSetInput = {
    create?: XOR<EquipmentSetItemCreateWithoutEquipmentSetInput, EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput> | EquipmentSetItemCreateWithoutEquipmentSetInput[] | EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput[]
    connectOrCreate?: EquipmentSetItemCreateOrConnectWithoutEquipmentSetInput | EquipmentSetItemCreateOrConnectWithoutEquipmentSetInput[]
    createMany?: EquipmentSetItemCreateManyEquipmentSetInputEnvelope
    connect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
  }

  export type MobEquipmentSetUncheckedCreateNestedManyWithoutEquipmentSetInput = {
    create?: XOR<MobEquipmentSetCreateWithoutEquipmentSetInput, MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput> | MobEquipmentSetCreateWithoutEquipmentSetInput[] | MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput[]
    connectOrCreate?: MobEquipmentSetCreateOrConnectWithoutEquipmentSetInput | MobEquipmentSetCreateOrConnectWithoutEquipmentSetInput[]
    createMany?: MobEquipmentSetCreateManyEquipmentSetInputEnvelope
    connect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
  }

  export type EquipmentSetItemUpdateManyWithoutEquipmentSetNestedInput = {
    create?: XOR<EquipmentSetItemCreateWithoutEquipmentSetInput, EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput> | EquipmentSetItemCreateWithoutEquipmentSetInput[] | EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput[]
    connectOrCreate?: EquipmentSetItemCreateOrConnectWithoutEquipmentSetInput | EquipmentSetItemCreateOrConnectWithoutEquipmentSetInput[]
    upsert?: EquipmentSetItemUpsertWithWhereUniqueWithoutEquipmentSetInput | EquipmentSetItemUpsertWithWhereUniqueWithoutEquipmentSetInput[]
    createMany?: EquipmentSetItemCreateManyEquipmentSetInputEnvelope
    set?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    disconnect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    delete?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    connect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    update?: EquipmentSetItemUpdateWithWhereUniqueWithoutEquipmentSetInput | EquipmentSetItemUpdateWithWhereUniqueWithoutEquipmentSetInput[]
    updateMany?: EquipmentSetItemUpdateManyWithWhereWithoutEquipmentSetInput | EquipmentSetItemUpdateManyWithWhereWithoutEquipmentSetInput[]
    deleteMany?: EquipmentSetItemScalarWhereInput | EquipmentSetItemScalarWhereInput[]
  }

  export type MobEquipmentSetUpdateManyWithoutEquipmentSetNestedInput = {
    create?: XOR<MobEquipmentSetCreateWithoutEquipmentSetInput, MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput> | MobEquipmentSetCreateWithoutEquipmentSetInput[] | MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput[]
    connectOrCreate?: MobEquipmentSetCreateOrConnectWithoutEquipmentSetInput | MobEquipmentSetCreateOrConnectWithoutEquipmentSetInput[]
    upsert?: MobEquipmentSetUpsertWithWhereUniqueWithoutEquipmentSetInput | MobEquipmentSetUpsertWithWhereUniqueWithoutEquipmentSetInput[]
    createMany?: MobEquipmentSetCreateManyEquipmentSetInputEnvelope
    set?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    disconnect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    delete?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    connect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    update?: MobEquipmentSetUpdateWithWhereUniqueWithoutEquipmentSetInput | MobEquipmentSetUpdateWithWhereUniqueWithoutEquipmentSetInput[]
    updateMany?: MobEquipmentSetUpdateManyWithWhereWithoutEquipmentSetInput | MobEquipmentSetUpdateManyWithWhereWithoutEquipmentSetInput[]
    deleteMany?: MobEquipmentSetScalarWhereInput | MobEquipmentSetScalarWhereInput[]
  }

  export type EquipmentSetItemUncheckedUpdateManyWithoutEquipmentSetNestedInput = {
    create?: XOR<EquipmentSetItemCreateWithoutEquipmentSetInput, EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput> | EquipmentSetItemCreateWithoutEquipmentSetInput[] | EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput[]
    connectOrCreate?: EquipmentSetItemCreateOrConnectWithoutEquipmentSetInput | EquipmentSetItemCreateOrConnectWithoutEquipmentSetInput[]
    upsert?: EquipmentSetItemUpsertWithWhereUniqueWithoutEquipmentSetInput | EquipmentSetItemUpsertWithWhereUniqueWithoutEquipmentSetInput[]
    createMany?: EquipmentSetItemCreateManyEquipmentSetInputEnvelope
    set?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    disconnect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    delete?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    connect?: EquipmentSetItemWhereUniqueInput | EquipmentSetItemWhereUniqueInput[]
    update?: EquipmentSetItemUpdateWithWhereUniqueWithoutEquipmentSetInput | EquipmentSetItemUpdateWithWhereUniqueWithoutEquipmentSetInput[]
    updateMany?: EquipmentSetItemUpdateManyWithWhereWithoutEquipmentSetInput | EquipmentSetItemUpdateManyWithWhereWithoutEquipmentSetInput[]
    deleteMany?: EquipmentSetItemScalarWhereInput | EquipmentSetItemScalarWhereInput[]
  }

  export type MobEquipmentSetUncheckedUpdateManyWithoutEquipmentSetNestedInput = {
    create?: XOR<MobEquipmentSetCreateWithoutEquipmentSetInput, MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput> | MobEquipmentSetCreateWithoutEquipmentSetInput[] | MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput[]
    connectOrCreate?: MobEquipmentSetCreateOrConnectWithoutEquipmentSetInput | MobEquipmentSetCreateOrConnectWithoutEquipmentSetInput[]
    upsert?: MobEquipmentSetUpsertWithWhereUniqueWithoutEquipmentSetInput | MobEquipmentSetUpsertWithWhereUniqueWithoutEquipmentSetInput[]
    createMany?: MobEquipmentSetCreateManyEquipmentSetInputEnvelope
    set?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    disconnect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    delete?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    connect?: MobEquipmentSetWhereUniqueInput | MobEquipmentSetWhereUniqueInput[]
    update?: MobEquipmentSetUpdateWithWhereUniqueWithoutEquipmentSetInput | MobEquipmentSetUpdateWithWhereUniqueWithoutEquipmentSetInput[]
    updateMany?: MobEquipmentSetUpdateManyWithWhereWithoutEquipmentSetInput | MobEquipmentSetUpdateManyWithWhereWithoutEquipmentSetInput[]
    deleteMany?: MobEquipmentSetScalarWhereInput | MobEquipmentSetScalarWhereInput[]
  }

  export type EquipmentSetCreateNestedOneWithoutMobEquipmentSetsInput = {
    create?: XOR<EquipmentSetCreateWithoutMobEquipmentSetsInput, EquipmentSetUncheckedCreateWithoutMobEquipmentSetsInput>
    connectOrCreate?: EquipmentSetCreateOrConnectWithoutMobEquipmentSetsInput
    connect?: EquipmentSetWhereUniqueInput
  }

  export type MobResetCreateNestedOneWithoutEquipmentSetsInput = {
    create?: XOR<MobResetCreateWithoutEquipmentSetsInput, MobResetUncheckedCreateWithoutEquipmentSetsInput>
    connectOrCreate?: MobResetCreateOrConnectWithoutEquipmentSetsInput
    connect?: MobResetWhereUniqueInput
  }

  export type EquipmentSetUpdateOneRequiredWithoutMobEquipmentSetsNestedInput = {
    create?: XOR<EquipmentSetCreateWithoutMobEquipmentSetsInput, EquipmentSetUncheckedCreateWithoutMobEquipmentSetsInput>
    connectOrCreate?: EquipmentSetCreateOrConnectWithoutMobEquipmentSetsInput
    upsert?: EquipmentSetUpsertWithoutMobEquipmentSetsInput
    connect?: EquipmentSetWhereUniqueInput
    update?: XOR<XOR<EquipmentSetUpdateToOneWithWhereWithoutMobEquipmentSetsInput, EquipmentSetUpdateWithoutMobEquipmentSetsInput>, EquipmentSetUncheckedUpdateWithoutMobEquipmentSetsInput>
  }

  export type MobResetUpdateOneRequiredWithoutEquipmentSetsNestedInput = {
    create?: XOR<MobResetCreateWithoutEquipmentSetsInput, MobResetUncheckedCreateWithoutEquipmentSetsInput>
    connectOrCreate?: MobResetCreateOrConnectWithoutEquipmentSetsInput
    upsert?: MobResetUpsertWithoutEquipmentSetsInput
    connect?: MobResetWhereUniqueInput
    update?: XOR<XOR<MobResetUpdateToOneWithWhereWithoutEquipmentSetsInput, MobResetUpdateWithoutEquipmentSetsInput>, MobResetUncheckedUpdateWithoutEquipmentSetsInput>
  }

  export type ObjectCreateNestedOneWithoutResetsInput = {
    create?: XOR<ObjectCreateWithoutResetsInput, ObjectUncheckedCreateWithoutResetsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutResetsInput
    connect?: ObjectWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutObjectResetsInput = {
    create?: XOR<RoomCreateWithoutObjectResetsInput, RoomUncheckedCreateWithoutObjectResetsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutObjectResetsInput
    connect?: RoomWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutObjectResetsInput = {
    create?: XOR<ZoneCreateWithoutObjectResetsInput, ZoneUncheckedCreateWithoutObjectResetsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutObjectResetsInput
    connect?: ZoneWhereUniqueInput
  }

  export type SpawnConditionCreateNestedManyWithoutObjectResetInput = {
    create?: XOR<SpawnConditionCreateWithoutObjectResetInput, SpawnConditionUncheckedCreateWithoutObjectResetInput> | SpawnConditionCreateWithoutObjectResetInput[] | SpawnConditionUncheckedCreateWithoutObjectResetInput[]
    connectOrCreate?: SpawnConditionCreateOrConnectWithoutObjectResetInput | SpawnConditionCreateOrConnectWithoutObjectResetInput[]
    createMany?: SpawnConditionCreateManyObjectResetInputEnvelope
    connect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
  }

  export type SpawnConditionUncheckedCreateNestedManyWithoutObjectResetInput = {
    create?: XOR<SpawnConditionCreateWithoutObjectResetInput, SpawnConditionUncheckedCreateWithoutObjectResetInput> | SpawnConditionCreateWithoutObjectResetInput[] | SpawnConditionUncheckedCreateWithoutObjectResetInput[]
    connectOrCreate?: SpawnConditionCreateOrConnectWithoutObjectResetInput | SpawnConditionCreateOrConnectWithoutObjectResetInput[]
    createMany?: SpawnConditionCreateManyObjectResetInputEnvelope
    connect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
  }

  export type ObjectUpdateOneRequiredWithoutResetsNestedInput = {
    create?: XOR<ObjectCreateWithoutResetsInput, ObjectUncheckedCreateWithoutResetsInput>
    connectOrCreate?: ObjectCreateOrConnectWithoutResetsInput
    upsert?: ObjectUpsertWithoutResetsInput
    connect?: ObjectWhereUniqueInput
    update?: XOR<XOR<ObjectUpdateToOneWithWhereWithoutResetsInput, ObjectUpdateWithoutResetsInput>, ObjectUncheckedUpdateWithoutResetsInput>
  }

  export type RoomUpdateOneRequiredWithoutObjectResetsNestedInput = {
    create?: XOR<RoomCreateWithoutObjectResetsInput, RoomUncheckedCreateWithoutObjectResetsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutObjectResetsInput
    upsert?: RoomUpsertWithoutObjectResetsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutObjectResetsInput, RoomUpdateWithoutObjectResetsInput>, RoomUncheckedUpdateWithoutObjectResetsInput>
  }

  export type ZoneUpdateOneRequiredWithoutObjectResetsNestedInput = {
    create?: XOR<ZoneCreateWithoutObjectResetsInput, ZoneUncheckedCreateWithoutObjectResetsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutObjectResetsInput
    upsert?: ZoneUpsertWithoutObjectResetsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutObjectResetsInput, ZoneUpdateWithoutObjectResetsInput>, ZoneUncheckedUpdateWithoutObjectResetsInput>
  }

  export type SpawnConditionUpdateManyWithoutObjectResetNestedInput = {
    create?: XOR<SpawnConditionCreateWithoutObjectResetInput, SpawnConditionUncheckedCreateWithoutObjectResetInput> | SpawnConditionCreateWithoutObjectResetInput[] | SpawnConditionUncheckedCreateWithoutObjectResetInput[]
    connectOrCreate?: SpawnConditionCreateOrConnectWithoutObjectResetInput | SpawnConditionCreateOrConnectWithoutObjectResetInput[]
    upsert?: SpawnConditionUpsertWithWhereUniqueWithoutObjectResetInput | SpawnConditionUpsertWithWhereUniqueWithoutObjectResetInput[]
    createMany?: SpawnConditionCreateManyObjectResetInputEnvelope
    set?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    disconnect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    delete?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    connect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    update?: SpawnConditionUpdateWithWhereUniqueWithoutObjectResetInput | SpawnConditionUpdateWithWhereUniqueWithoutObjectResetInput[]
    updateMany?: SpawnConditionUpdateManyWithWhereWithoutObjectResetInput | SpawnConditionUpdateManyWithWhereWithoutObjectResetInput[]
    deleteMany?: SpawnConditionScalarWhereInput | SpawnConditionScalarWhereInput[]
  }

  export type SpawnConditionUncheckedUpdateManyWithoutObjectResetNestedInput = {
    create?: XOR<SpawnConditionCreateWithoutObjectResetInput, SpawnConditionUncheckedCreateWithoutObjectResetInput> | SpawnConditionCreateWithoutObjectResetInput[] | SpawnConditionUncheckedCreateWithoutObjectResetInput[]
    connectOrCreate?: SpawnConditionCreateOrConnectWithoutObjectResetInput | SpawnConditionCreateOrConnectWithoutObjectResetInput[]
    upsert?: SpawnConditionUpsertWithWhereUniqueWithoutObjectResetInput | SpawnConditionUpsertWithWhereUniqueWithoutObjectResetInput[]
    createMany?: SpawnConditionCreateManyObjectResetInputEnvelope
    set?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    disconnect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    delete?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    connect?: SpawnConditionWhereUniqueInput | SpawnConditionWhereUniqueInput[]
    update?: SpawnConditionUpdateWithWhereUniqueWithoutObjectResetInput | SpawnConditionUpdateWithWhereUniqueWithoutObjectResetInput[]
    updateMany?: SpawnConditionUpdateManyWithWhereWithoutObjectResetInput | SpawnConditionUpdateManyWithWhereWithoutObjectResetInput[]
    deleteMany?: SpawnConditionScalarWhereInput | SpawnConditionScalarWhereInput[]
  }

  export type MobResetCreateNestedOneWithoutSpawnConditionsInput = {
    create?: XOR<MobResetCreateWithoutSpawnConditionsInput, MobResetUncheckedCreateWithoutSpawnConditionsInput>
    connectOrCreate?: MobResetCreateOrConnectWithoutSpawnConditionsInput
    connect?: MobResetWhereUniqueInput
  }

  export type ObjectResetCreateNestedOneWithoutSpawnConditionsInput = {
    create?: XOR<ObjectResetCreateWithoutSpawnConditionsInput, ObjectResetUncheckedCreateWithoutSpawnConditionsInput>
    connectOrCreate?: ObjectResetCreateOrConnectWithoutSpawnConditionsInput
    connect?: ObjectResetWhereUniqueInput
  }

  export type MobResetUpdateOneWithoutSpawnConditionsNestedInput = {
    create?: XOR<MobResetCreateWithoutSpawnConditionsInput, MobResetUncheckedCreateWithoutSpawnConditionsInput>
    connectOrCreate?: MobResetCreateOrConnectWithoutSpawnConditionsInput
    upsert?: MobResetUpsertWithoutSpawnConditionsInput
    disconnect?: MobResetWhereInput | boolean
    delete?: MobResetWhereInput | boolean
    connect?: MobResetWhereUniqueInput
    update?: XOR<XOR<MobResetUpdateToOneWithWhereWithoutSpawnConditionsInput, MobResetUpdateWithoutSpawnConditionsInput>, MobResetUncheckedUpdateWithoutSpawnConditionsInput>
  }

  export type ObjectResetUpdateOneWithoutSpawnConditionsNestedInput = {
    create?: XOR<ObjectResetCreateWithoutSpawnConditionsInput, ObjectResetUncheckedCreateWithoutSpawnConditionsInput>
    connectOrCreate?: ObjectResetCreateOrConnectWithoutSpawnConditionsInput
    upsert?: ObjectResetUpsertWithoutSpawnConditionsInput
    disconnect?: ObjectResetWhereInput | boolean
    delete?: ObjectResetWhereInput | boolean
    connect?: ObjectResetWhereUniqueInput
    update?: XOR<XOR<ObjectResetUpdateToOneWithWhereWithoutSpawnConditionsInput, ObjectResetUpdateWithoutSpawnConditionsInput>, ObjectResetUncheckedUpdateWithoutSpawnConditionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumRaceFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    not?: NestedEnumRaceFilter<$PrismaModel> | $Enums.Race
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRaceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Race[] | ListEnumRaceFieldRefInput<$PrismaModel>
    not?: NestedEnumRaceWithAggregatesFilter<$PrismaModel> | $Enums.Race
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRaceFilter<$PrismaModel>
    _max?: NestedEnumRaceFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumResetModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResetMode | EnumResetModeFieldRefInput<$PrismaModel>
    in?: $Enums.ResetMode[] | ListEnumResetModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResetMode[] | ListEnumResetModeFieldRefInput<$PrismaModel>
    not?: NestedEnumResetModeFilter<$PrismaModel> | $Enums.ResetMode
  }

  export type NestedEnumHemisphereFilter<$PrismaModel = never> = {
    equals?: $Enums.Hemisphere | EnumHemisphereFieldRefInput<$PrismaModel>
    in?: $Enums.Hemisphere[] | ListEnumHemisphereFieldRefInput<$PrismaModel>
    notIn?: $Enums.Hemisphere[] | ListEnumHemisphereFieldRefInput<$PrismaModel>
    not?: NestedEnumHemisphereFilter<$PrismaModel> | $Enums.Hemisphere
  }

  export type NestedEnumClimateFilter<$PrismaModel = never> = {
    equals?: $Enums.Climate | EnumClimateFieldRefInput<$PrismaModel>
    in?: $Enums.Climate[] | ListEnumClimateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Climate[] | ListEnumClimateFieldRefInput<$PrismaModel>
    not?: NestedEnumClimateFilter<$PrismaModel> | $Enums.Climate
  }

  export type NestedEnumResetModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResetMode | EnumResetModeFieldRefInput<$PrismaModel>
    in?: $Enums.ResetMode[] | ListEnumResetModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResetMode[] | ListEnumResetModeFieldRefInput<$PrismaModel>
    not?: NestedEnumResetModeWithAggregatesFilter<$PrismaModel> | $Enums.ResetMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResetModeFilter<$PrismaModel>
    _max?: NestedEnumResetModeFilter<$PrismaModel>
  }

  export type NestedEnumHemisphereWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Hemisphere | EnumHemisphereFieldRefInput<$PrismaModel>
    in?: $Enums.Hemisphere[] | ListEnumHemisphereFieldRefInput<$PrismaModel>
    notIn?: $Enums.Hemisphere[] | ListEnumHemisphereFieldRefInput<$PrismaModel>
    not?: NestedEnumHemisphereWithAggregatesFilter<$PrismaModel> | $Enums.Hemisphere
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHemisphereFilter<$PrismaModel>
    _max?: NestedEnumHemisphereFilter<$PrismaModel>
  }

  export type NestedEnumClimateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Climate | EnumClimateFieldRefInput<$PrismaModel>
    in?: $Enums.Climate[] | ListEnumClimateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Climate[] | ListEnumClimateFieldRefInput<$PrismaModel>
    not?: NestedEnumClimateWithAggregatesFilter<$PrismaModel> | $Enums.Climate
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClimateFilter<$PrismaModel>
    _max?: NestedEnumClimateFilter<$PrismaModel>
  }

  export type NestedEnumSectorFilter<$PrismaModel = never> = {
    equals?: $Enums.Sector | EnumSectorFieldRefInput<$PrismaModel>
    in?: $Enums.Sector[] | ListEnumSectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sector[] | ListEnumSectorFieldRefInput<$PrismaModel>
    not?: NestedEnumSectorFilter<$PrismaModel> | $Enums.Sector
  }

  export type NestedEnumSectorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sector | EnumSectorFieldRefInput<$PrismaModel>
    in?: $Enums.Sector[] | ListEnumSectorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sector[] | ListEnumSectorFieldRefInput<$PrismaModel>
    not?: NestedEnumSectorWithAggregatesFilter<$PrismaModel> | $Enums.Sector
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSectorFilter<$PrismaModel>
    _max?: NestedEnumSectorFilter<$PrismaModel>
  }

  export type NestedEnumDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionFilter<$PrismaModel> | $Enums.Direction
  }

  export type NestedEnumDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionWithAggregatesFilter<$PrismaModel> | $Enums.Direction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectionFilter<$PrismaModel>
    _max?: NestedEnumDirectionFilter<$PrismaModel>
  }

  export type NestedEnumPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionFilter<$PrismaModel> | $Enums.Position
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumSizeFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel>
    in?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumSizeFilter<$PrismaModel> | $Enums.Size
  }

  export type NestedEnumLifeForceFilter<$PrismaModel = never> = {
    equals?: $Enums.LifeForce | EnumLifeForceFieldRefInput<$PrismaModel>
    in?: $Enums.LifeForce[] | ListEnumLifeForceFieldRefInput<$PrismaModel>
    notIn?: $Enums.LifeForce[] | ListEnumLifeForceFieldRefInput<$PrismaModel>
    not?: NestedEnumLifeForceFilter<$PrismaModel> | $Enums.LifeForce
  }

  export type NestedEnumCompositionFilter<$PrismaModel = never> = {
    equals?: $Enums.Composition | EnumCompositionFieldRefInput<$PrismaModel>
    in?: $Enums.Composition[] | ListEnumCompositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Composition[] | ListEnumCompositionFieldRefInput<$PrismaModel>
    not?: NestedEnumCompositionFilter<$PrismaModel> | $Enums.Composition
  }

  export type NestedEnumStanceFilter<$PrismaModel = never> = {
    equals?: $Enums.Stance | EnumStanceFieldRefInput<$PrismaModel>
    in?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStanceFilter<$PrismaModel> | $Enums.Stance
  }

  export type NestedEnumDamageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDamageTypeFilter<$PrismaModel> | $Enums.DamageType
  }

  export type NestedEnumPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionWithAggregatesFilter<$PrismaModel> | $Enums.Position
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPositionFilter<$PrismaModel>
    _max?: NestedEnumPositionFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumSizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel>
    in?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumSizeWithAggregatesFilter<$PrismaModel> | $Enums.Size
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSizeFilter<$PrismaModel>
    _max?: NestedEnumSizeFilter<$PrismaModel>
  }

  export type NestedEnumLifeForceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LifeForce | EnumLifeForceFieldRefInput<$PrismaModel>
    in?: $Enums.LifeForce[] | ListEnumLifeForceFieldRefInput<$PrismaModel>
    notIn?: $Enums.LifeForce[] | ListEnumLifeForceFieldRefInput<$PrismaModel>
    not?: NestedEnumLifeForceWithAggregatesFilter<$PrismaModel> | $Enums.LifeForce
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLifeForceFilter<$PrismaModel>
    _max?: NestedEnumLifeForceFilter<$PrismaModel>
  }

  export type NestedEnumCompositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Composition | EnumCompositionFieldRefInput<$PrismaModel>
    in?: $Enums.Composition[] | ListEnumCompositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Composition[] | ListEnumCompositionFieldRefInput<$PrismaModel>
    not?: NestedEnumCompositionWithAggregatesFilter<$PrismaModel> | $Enums.Composition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompositionFilter<$PrismaModel>
    _max?: NestedEnumCompositionFilter<$PrismaModel>
  }

  export type NestedEnumStanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Stance | EnumStanceFieldRefInput<$PrismaModel>
    in?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Stance[] | ListEnumStanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStanceWithAggregatesFilter<$PrismaModel> | $Enums.Stance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStanceFilter<$PrismaModel>
    _max?: NestedEnumStanceFilter<$PrismaModel>
  }

  export type NestedEnumDamageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DamageType | EnumDamageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DamageType[] | ListEnumDamageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDamageTypeWithAggregatesFilter<$PrismaModel> | $Enums.DamageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDamageTypeFilter<$PrismaModel>
    _max?: NestedEnumDamageTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumObjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectType | EnumObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectType[] | ListEnumObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectType[] | ListEnumObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectTypeFilter<$PrismaModel> | $Enums.ObjectType
  }

  export type NestedEnumObjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectType | EnumObjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectType[] | ListEnumObjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectType[] | ListEnumObjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.ObjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObjectTypeFilter<$PrismaModel>
    _max?: NestedEnumObjectTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumScriptTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScriptType | EnumScriptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScriptType[] | ListEnumScriptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScriptType[] | ListEnumScriptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScriptTypeFilter<$PrismaModel> | $Enums.ScriptType
  }

  export type NestedEnumScriptTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScriptType | EnumScriptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScriptType[] | ListEnumScriptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScriptType[] | ListEnumScriptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScriptTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScriptType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScriptTypeFilter<$PrismaModel>
    _max?: NestedEnumScriptTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTargetScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetScope | EnumTargetScopeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetScope[] | ListEnumTargetScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetScope[] | ListEnumTargetScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetScopeFilter<$PrismaModel> | $Enums.TargetScope
  }

  export type NestedEnumSpellRangeFilter<$PrismaModel = never> = {
    equals?: $Enums.SpellRange | EnumSpellRangeFieldRefInput<$PrismaModel>
    in?: $Enums.SpellRange[] | ListEnumSpellRangeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpellRange[] | ListEnumSpellRangeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpellRangeFilter<$PrismaModel> | $Enums.SpellRange
  }

  export type NestedEnumTargetScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetScope | EnumTargetScopeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetScope[] | ListEnumTargetScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetScope[] | ListEnumTargetScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetScopeWithAggregatesFilter<$PrismaModel> | $Enums.TargetScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTargetScopeFilter<$PrismaModel>
    _max?: NestedEnumTargetScopeFilter<$PrismaModel>
  }

  export type NestedEnumSpellRangeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpellRange | EnumSpellRangeFieldRefInput<$PrismaModel>
    in?: $Enums.SpellRange[] | ListEnumSpellRangeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpellRange[] | ListEnumSpellRangeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpellRangeWithAggregatesFilter<$PrismaModel> | $Enums.SpellRange
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpellRangeFilter<$PrismaModel>
    _max?: NestedEnumSpellRangeFilter<$PrismaModel>
  }

  export type NestedEnumSaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SaveType | EnumSaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SaveType[] | ListEnumSaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaveType[] | ListEnumSaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSaveTypeFilter<$PrismaModel> | $Enums.SaveType
  }

  export type NestedEnumSaveResultFilter<$PrismaModel = never> = {
    equals?: $Enums.SaveResult | EnumSaveResultFieldRefInput<$PrismaModel>
    in?: $Enums.SaveResult[] | ListEnumSaveResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaveResult[] | ListEnumSaveResultFieldRefInput<$PrismaModel>
    not?: NestedEnumSaveResultFilter<$PrismaModel> | $Enums.SaveResult
  }

  export type NestedEnumSaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaveType | EnumSaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SaveType[] | ListEnumSaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaveType[] | ListEnumSaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.SaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaveTypeFilter<$PrismaModel>
    _max?: NestedEnumSaveTypeFilter<$PrismaModel>
  }

  export type NestedEnumSaveResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaveResult | EnumSaveResultFieldRefInput<$PrismaModel>
    in?: $Enums.SaveResult[] | ListEnumSaveResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaveResult[] | ListEnumSaveResultFieldRefInput<$PrismaModel>
    not?: NestedEnumSaveResultWithAggregatesFilter<$PrismaModel> | $Enums.SaveResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaveResultFilter<$PrismaModel>
    _max?: NestedEnumSaveResultFilter<$PrismaModel>
  }

  export type NestedEnumEffectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EffectType | EnumEffectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EffectType[] | ListEnumEffectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EffectType[] | ListEnumEffectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEffectTypeFilter<$PrismaModel> | $Enums.EffectType
  }

  export type NestedEnumEffectTriggerNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EffectTrigger | EnumEffectTriggerFieldRefInput<$PrismaModel> | null
    in?: $Enums.EffectTrigger[] | ListEnumEffectTriggerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EffectTrigger[] | ListEnumEffectTriggerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEffectTriggerNullableFilter<$PrismaModel> | $Enums.EffectTrigger | null
  }

  export type NestedEnumStackingRuleFilter<$PrismaModel = never> = {
    equals?: $Enums.StackingRule | EnumStackingRuleFieldRefInput<$PrismaModel>
    in?: $Enums.StackingRule[] | ListEnumStackingRuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StackingRule[] | ListEnumStackingRuleFieldRefInput<$PrismaModel>
    not?: NestedEnumStackingRuleFilter<$PrismaModel> | $Enums.StackingRule
  }

  export type NestedEnumEffectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EffectType | EnumEffectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EffectType[] | ListEnumEffectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EffectType[] | ListEnumEffectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEffectTypeWithAggregatesFilter<$PrismaModel> | $Enums.EffectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEffectTypeFilter<$PrismaModel>
    _max?: NestedEnumEffectTypeFilter<$PrismaModel>
  }

  export type NestedEnumEffectTriggerNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EffectTrigger | EnumEffectTriggerFieldRefInput<$PrismaModel> | null
    in?: $Enums.EffectTrigger[] | ListEnumEffectTriggerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EffectTrigger[] | ListEnumEffectTriggerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEffectTriggerNullableWithAggregatesFilter<$PrismaModel> | $Enums.EffectTrigger | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEffectTriggerNullableFilter<$PrismaModel>
    _max?: NestedEnumEffectTriggerNullableFilter<$PrismaModel>
  }

  export type NestedEnumStackingRuleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StackingRule | EnumStackingRuleFieldRefInput<$PrismaModel>
    in?: $Enums.StackingRule[] | ListEnumStackingRuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StackingRule[] | ListEnumStackingRuleFieldRefInput<$PrismaModel>
    not?: NestedEnumStackingRuleWithAggregatesFilter<$PrismaModel> | $Enums.StackingRule
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStackingRuleFilter<$PrismaModel>
    _max?: NestedEnumStackingRuleFilter<$PrismaModel>
  }

  export type NestedEnumSkillTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillType | EnumSkillTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillTypeFilter<$PrismaModel> | $Enums.SkillType
  }

  export type NestedEnumSkillCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryFilter<$PrismaModel> | $Enums.SkillCategory
  }

  export type NestedEnumSkillTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillType | EnumSkillTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillType[] | ListEnumSkillTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillTypeWithAggregatesFilter<$PrismaModel> | $Enums.SkillType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillTypeFilter<$PrismaModel>
    _max?: NestedEnumSkillTypeFilter<$PrismaModel>
  }

  export type NestedEnumSkillCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SkillCategory | EnumSkillCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SkillCategory[] | ListEnumSkillCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SkillCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillCategoryFilter<$PrismaModel>
    _max?: NestedEnumSkillCategoryFilter<$PrismaModel>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BanRecordCreateWithoutAdminInput = {
    id?: string
    reason: string
    bannedAt?: Date | string
    expiresAt?: Date | string | null
    unbannedAt?: Date | string | null
    unbannedBy?: string | null
    active?: boolean
    user: UserCreateNestedOneWithoutBanRecordsInput
  }

  export type BanRecordUncheckedCreateWithoutAdminInput = {
    id?: string
    userId: string
    reason: string
    bannedAt?: Date | string
    expiresAt?: Date | string | null
    unbannedAt?: Date | string | null
    unbannedBy?: string | null
    active?: boolean
  }

  export type BanRecordCreateOrConnectWithoutAdminInput = {
    where: BanRecordWhereUniqueInput
    create: XOR<BanRecordCreateWithoutAdminInput, BanRecordUncheckedCreateWithoutAdminInput>
  }

  export type BanRecordCreateManyAdminInputEnvelope = {
    data: BanRecordCreateManyAdminInput | BanRecordCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type BanRecordCreateWithoutUserInput = {
    id?: string
    reason: string
    bannedAt?: Date | string
    expiresAt?: Date | string | null
    unbannedAt?: Date | string | null
    unbannedBy?: string | null
    active?: boolean
    admin: UserCreateNestedOneWithoutIssuedBansInput
  }

  export type BanRecordUncheckedCreateWithoutUserInput = {
    id?: string
    bannedBy: string
    reason: string
    bannedAt?: Date | string
    expiresAt?: Date | string | null
    unbannedAt?: Date | string | null
    unbannedBy?: string | null
    active?: boolean
  }

  export type BanRecordCreateOrConnectWithoutUserInput = {
    where: BanRecordWhereUniqueInput
    create: XOR<BanRecordCreateWithoutUserInput, BanRecordUncheckedCreateWithoutUserInput>
  }

  export type BanRecordCreateManyUserInputEnvelope = {
    data: BanRecordCreateManyUserInput | BanRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChangeLogCreateWithoutUserInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    description?: string | null
  }

  export type ChangeLogUncheckedCreateWithoutUserInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    description?: string | null
  }

  export type ChangeLogCreateOrConnectWithoutUserInput = {
    where: ChangeLogWhereUniqueInput
    create: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput>
  }

  export type ChangeLogCreateManyUserInputEnvelope = {
    data: ChangeLogCreateManyUserInput | ChangeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CharacterCreateWithoutUserInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectCreateNestedManyWithoutCharacterInput
    items?: CharacterItemCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellCreateNestedManyWithoutCharacterInput
    gameClass?: GameClassCreateNestedOneWithoutCharactersInput
  }

  export type CharacterUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: number | null
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectUncheckedCreateNestedManyWithoutCharacterInput
    items?: CharacterItemUncheckedCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutUserInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput>
  }

  export type CharacterCreateManyUserInputEnvelope = {
    data: CharacterCreateManyUserInput | CharacterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    userId?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type BanRecordUpsertWithWhereUniqueWithoutAdminInput = {
    where: BanRecordWhereUniqueInput
    update: XOR<BanRecordUpdateWithoutAdminInput, BanRecordUncheckedUpdateWithoutAdminInput>
    create: XOR<BanRecordCreateWithoutAdminInput, BanRecordUncheckedCreateWithoutAdminInput>
  }

  export type BanRecordUpdateWithWhereUniqueWithoutAdminInput = {
    where: BanRecordWhereUniqueInput
    data: XOR<BanRecordUpdateWithoutAdminInput, BanRecordUncheckedUpdateWithoutAdminInput>
  }

  export type BanRecordUpdateManyWithWhereWithoutAdminInput = {
    where: BanRecordScalarWhereInput
    data: XOR<BanRecordUpdateManyMutationInput, BanRecordUncheckedUpdateManyWithoutAdminInput>
  }

  export type BanRecordScalarWhereInput = {
    AND?: BanRecordScalarWhereInput | BanRecordScalarWhereInput[]
    OR?: BanRecordScalarWhereInput[]
    NOT?: BanRecordScalarWhereInput | BanRecordScalarWhereInput[]
    id?: StringFilter<"BanRecord"> | string
    userId?: StringFilter<"BanRecord"> | string
    bannedBy?: StringFilter<"BanRecord"> | string
    reason?: StringFilter<"BanRecord"> | string
    bannedAt?: DateTimeFilter<"BanRecord"> | Date | string
    expiresAt?: DateTimeNullableFilter<"BanRecord"> | Date | string | null
    unbannedAt?: DateTimeNullableFilter<"BanRecord"> | Date | string | null
    unbannedBy?: StringNullableFilter<"BanRecord"> | string | null
    active?: BoolFilter<"BanRecord"> | boolean
  }

  export type BanRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: BanRecordWhereUniqueInput
    update: XOR<BanRecordUpdateWithoutUserInput, BanRecordUncheckedUpdateWithoutUserInput>
    create: XOR<BanRecordCreateWithoutUserInput, BanRecordUncheckedCreateWithoutUserInput>
  }

  export type BanRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: BanRecordWhereUniqueInput
    data: XOR<BanRecordUpdateWithoutUserInput, BanRecordUncheckedUpdateWithoutUserInput>
  }

  export type BanRecordUpdateManyWithWhereWithoutUserInput = {
    where: BanRecordScalarWhereInput
    data: XOR<BanRecordUpdateManyMutationInput, BanRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type ChangeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ChangeLogWhereUniqueInput
    update: XOR<ChangeLogUpdateWithoutUserInput, ChangeLogUncheckedUpdateWithoutUserInput>
    create: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput>
  }

  export type ChangeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ChangeLogWhereUniqueInput
    data: XOR<ChangeLogUpdateWithoutUserInput, ChangeLogUncheckedUpdateWithoutUserInput>
  }

  export type ChangeLogUpdateManyWithWhereWithoutUserInput = {
    where: ChangeLogScalarWhereInput
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ChangeLogScalarWhereInput = {
    AND?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
    OR?: ChangeLogScalarWhereInput[]
    NOT?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
    id?: StringFilter<"ChangeLog"> | string
    entityType?: StringFilter<"ChangeLog"> | string
    entityId?: StringFilter<"ChangeLog"> | string
    action?: StringFilter<"ChangeLog"> | string
    changes?: JsonFilter<"ChangeLog">
    userId?: StringFilter<"ChangeLog"> | string
    timestamp?: DateTimeFilter<"ChangeLog"> | Date | string
    description?: StringNullableFilter<"ChangeLog"> | string | null
  }

  export type CharacterUpsertWithWhereUniqueWithoutUserInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutUserInput, CharacterUncheckedUpdateWithoutUserInput>
    create: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutUserInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutUserInput, CharacterUncheckedUpdateWithoutUserInput>
  }

  export type CharacterUpdateManyWithWhereWithoutUserInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutUserInput>
  }

  export type CharacterScalarWhereInput = {
    AND?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    OR?: CharacterScalarWhereInput[]
    NOT?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    id?: StringFilter<"Character"> | string
    name?: StringFilter<"Character"> | string
    level?: IntFilter<"Character"> | number
    alignment?: IntFilter<"Character"> | number
    strength?: IntFilter<"Character"> | number
    intelligence?: IntFilter<"Character"> | number
    wisdom?: IntFilter<"Character"> | number
    dexterity?: IntFilter<"Character"> | number
    constitution?: IntFilter<"Character"> | number
    charisma?: IntFilter<"Character"> | number
    luck?: IntFilter<"Character"> | number
    hitPoints?: IntFilter<"Character"> | number
    movement?: IntFilter<"Character"> | number
    hitPointsMax?: IntFilter<"Character"> | number
    movementMax?: IntFilter<"Character"> | number
    copper?: IntFilter<"Character"> | number
    silver?: IntFilter<"Character"> | number
    gold?: IntFilter<"Character"> | number
    platinum?: IntFilter<"Character"> | number
    bankCopper?: IntFilter<"Character"> | number
    bankSilver?: IntFilter<"Character"> | number
    bankGold?: IntFilter<"Character"> | number
    bankPlatinum?: IntFilter<"Character"> | number
    total_wealth?: IntFilter<"Character"> | number
    average_stats?: IntFilter<"Character"> | number
    passwordHash?: StringNullableFilter<"Character"> | string | null
    raceType?: StringFilter<"Character"> | string
    race?: EnumRaceFilter<"Character"> | $Enums.Race
    gender?: StringFilter<"Character"> | string
    playerClass?: StringNullableFilter<"Character"> | string | null
    height?: IntNullableFilter<"Character"> | number | null
    weight?: IntNullableFilter<"Character"> | number | null
    baseSize?: IntFilter<"Character"> | number
    currentSize?: IntFilter<"Character"> | number
    hitRoll?: IntFilter<"Character"> | number
    damageRoll?: IntFilter<"Character"> | number
    armorClass?: IntFilter<"Character"> | number
    currentRoom?: IntNullableFilter<"Character"> | number | null
    saveRoom?: IntNullableFilter<"Character"> | number | null
    homeRoom?: IntNullableFilter<"Character"> | number | null
    lastLogin?: DateTimeNullableFilter<"Character"> | Date | string | null
    timePlayed?: IntFilter<"Character"> | number
    isOnline?: BoolFilter<"Character"> | boolean
    hunger?: IntFilter<"Character"> | number
    thirst?: IntFilter<"Character"> | number
    description?: StringNullableFilter<"Character"> | string | null
    title?: StringNullableFilter<"Character"> | string | null
    prompt?: StringFilter<"Character"> | string
    pageLength?: IntFilter<"Character"> | number
    playerFlags?: StringNullableListFilter<"Character">
    effectFlags?: StringNullableListFilter<"Character">
    privilegeFlags?: StringNullableListFilter<"Character">
    olcZones?: IntNullableListFilter<"Character">
    invisLevel?: IntFilter<"Character"> | number
    birthTime?: DateTimeFilter<"Character"> | Date | string
    userId?: StringFilter<"Character"> | string
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    classId?: IntNullableFilter<"Character"> | number | null
    experience?: IntFilter<"Character"> | number
    skillPoints?: IntFilter<"Character"> | number
  }

  export type CharacterEffectCreateWithoutCharacterInput = {
    id?: string
    effectName: string
    effectType?: string | null
    duration?: number | null
    strength?: number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: string | null
    sourceId?: number | null
    appliedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CharacterEffectUncheckedCreateWithoutCharacterInput = {
    id?: string
    effectName: string
    effectType?: string | null
    duration?: number | null
    strength?: number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: string | null
    sourceId?: number | null
    appliedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CharacterEffectCreateOrConnectWithoutCharacterInput = {
    where: CharacterEffectWhereUniqueInput
    create: XOR<CharacterEffectCreateWithoutCharacterInput, CharacterEffectUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterEffectCreateManyCharacterInputEnvelope = {
    data: CharacterEffectCreateManyCharacterInput | CharacterEffectCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type CharacterItemCreateWithoutCharacterInput = {
    id?: string
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    container?: CharacterItemCreateNestedOneWithoutContainedItemsInput
    containedItems?: CharacterItemCreateNestedManyWithoutContainerInput
    object: ObjectCreateNestedOneWithoutCharacterItemsInput
  }

  export type CharacterItemUncheckedCreateWithoutCharacterInput = {
    id?: string
    object_zone_id: number
    object_id: number
    containerId?: string | null
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    containedItems?: CharacterItemUncheckedCreateNestedManyWithoutContainerInput
  }

  export type CharacterItemCreateOrConnectWithoutCharacterInput = {
    where: CharacterItemWhereUniqueInput
    create: XOR<CharacterItemCreateWithoutCharacterInput, CharacterItemUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterItemCreateManyCharacterInputEnvelope = {
    data: CharacterItemCreateManyCharacterInput | CharacterItemCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type CharacterSkillCreateWithoutCharacterInput = {
    id?: string
    level?: number
    experience?: number
    lastUsed?: Date | string | null
    skill: SkillCreateNestedOneWithoutCharacterSkillsInput
  }

  export type CharacterSkillUncheckedCreateWithoutCharacterInput = {
    id?: string
    skillId: number
    level?: number
    experience?: number
    lastUsed?: Date | string | null
  }

  export type CharacterSkillCreateOrConnectWithoutCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    create: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSkillCreateManyCharacterInputEnvelope = {
    data: CharacterSkillCreateManyCharacterInput | CharacterSkillCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type CharacterSpellCreateWithoutCharacterInput = {
    id?: string
    known?: boolean
    proficiency?: number
    lastCast?: Date | string | null
    spell: SpellCreateNestedOneWithoutCharacterSpellsInput
  }

  export type CharacterSpellUncheckedCreateWithoutCharacterInput = {
    id?: string
    spellId: number
    known?: boolean
    proficiency?: number
    lastCast?: Date | string | null
  }

  export type CharacterSpellCreateOrConnectWithoutCharacterInput = {
    where: CharacterSpellWhereUniqueInput
    create: XOR<CharacterSpellCreateWithoutCharacterInput, CharacterSpellUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSpellCreateManyCharacterInputEnvelope = {
    data: CharacterSpellCreateManyCharacterInput | CharacterSpellCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type GameClassCreateWithoutCharactersInput = {
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skillAccess?: ClassSkillCreateNestedManyWithoutGameClassInput
    mobs?: MobCreateNestedManyWithoutGameClassInput
    spellCircles?: SpellClassCircleCreateNestedManyWithoutGameClassInput
  }

  export type GameClassUncheckedCreateWithoutCharactersInput = {
    id?: number
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skillAccess?: ClassSkillUncheckedCreateNestedManyWithoutGameClassInput
    mobs?: MobUncheckedCreateNestedManyWithoutGameClassInput
    spellCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutGameClassInput
  }

  export type GameClassCreateOrConnectWithoutCharactersInput = {
    where: GameClassWhereUniqueInput
    create: XOR<GameClassCreateWithoutCharactersInput, GameClassUncheckedCreateWithoutCharactersInput>
  }

  export type UserCreateWithoutCharactersInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    issuedBans?: BanRecordCreateNestedManyWithoutAdminInput
    banRecords?: BanRecordCreateNestedManyWithoutUserInput
    changeLogs?: ChangeLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCharactersInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    issuedBans?: BanRecordUncheckedCreateNestedManyWithoutAdminInput
    banRecords?: BanRecordUncheckedCreateNestedManyWithoutUserInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCharactersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
  }

  export type CharacterEffectUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterEffectWhereUniqueInput
    update: XOR<CharacterEffectUpdateWithoutCharacterInput, CharacterEffectUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterEffectCreateWithoutCharacterInput, CharacterEffectUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterEffectUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterEffectWhereUniqueInput
    data: XOR<CharacterEffectUpdateWithoutCharacterInput, CharacterEffectUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterEffectUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterEffectScalarWhereInput
    data: XOR<CharacterEffectUpdateManyMutationInput, CharacterEffectUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterEffectScalarWhereInput = {
    AND?: CharacterEffectScalarWhereInput | CharacterEffectScalarWhereInput[]
    OR?: CharacterEffectScalarWhereInput[]
    NOT?: CharacterEffectScalarWhereInput | CharacterEffectScalarWhereInput[]
    id?: StringFilter<"CharacterEffect"> | string
    characterId?: StringFilter<"CharacterEffect"> | string
    effectName?: StringFilter<"CharacterEffect"> | string
    effectType?: StringNullableFilter<"CharacterEffect"> | string | null
    duration?: IntNullableFilter<"CharacterEffect"> | number | null
    strength?: IntFilter<"CharacterEffect"> | number
    modifierData?: JsonFilter<"CharacterEffect">
    sourceType?: StringNullableFilter<"CharacterEffect"> | string | null
    sourceId?: IntNullableFilter<"CharacterEffect"> | number | null
    appliedAt?: DateTimeFilter<"CharacterEffect"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CharacterEffect"> | Date | string | null
  }

  export type CharacterItemUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterItemWhereUniqueInput
    update: XOR<CharacterItemUpdateWithoutCharacterInput, CharacterItemUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterItemCreateWithoutCharacterInput, CharacterItemUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterItemUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterItemWhereUniqueInput
    data: XOR<CharacterItemUpdateWithoutCharacterInput, CharacterItemUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterItemUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterItemScalarWhereInput
    data: XOR<CharacterItemUpdateManyMutationInput, CharacterItemUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterItemScalarWhereInput = {
    AND?: CharacterItemScalarWhereInput | CharacterItemScalarWhereInput[]
    OR?: CharacterItemScalarWhereInput[]
    NOT?: CharacterItemScalarWhereInput | CharacterItemScalarWhereInput[]
    id?: StringFilter<"CharacterItem"> | string
    characterId?: StringFilter<"CharacterItem"> | string
    object_zone_id?: IntFilter<"CharacterItem"> | number
    object_id?: IntFilter<"CharacterItem"> | number
    containerId?: StringNullableFilter<"CharacterItem"> | string | null
    equippedLocation?: StringNullableFilter<"CharacterItem"> | string | null
    condition?: IntFilter<"CharacterItem"> | number
    charges?: IntFilter<"CharacterItem"> | number
    instanceFlags?: StringNullableListFilter<"CharacterItem">
    customShortDesc?: StringNullableFilter<"CharacterItem"> | string | null
    customLongDesc?: StringNullableFilter<"CharacterItem"> | string | null
    customValues?: JsonFilter<"CharacterItem">
    createdAt?: DateTimeFilter<"CharacterItem"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterItem"> | Date | string
  }

  export type CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    update: XOR<CharacterSkillUpdateWithoutCharacterInput, CharacterSkillUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    data: XOR<CharacterSkillUpdateWithoutCharacterInput, CharacterSkillUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterSkillUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterSkillScalarWhereInput
    data: XOR<CharacterSkillUpdateManyMutationInput, CharacterSkillUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterSkillScalarWhereInput = {
    AND?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
    OR?: CharacterSkillScalarWhereInput[]
    NOT?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
    id?: StringFilter<"CharacterSkill"> | string
    characterId?: StringFilter<"CharacterSkill"> | string
    skillId?: IntFilter<"CharacterSkill"> | number
    level?: IntFilter<"CharacterSkill"> | number
    experience?: IntFilter<"CharacterSkill"> | number
    lastUsed?: DateTimeNullableFilter<"CharacterSkill"> | Date | string | null
  }

  export type CharacterSpellUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterSpellWhereUniqueInput
    update: XOR<CharacterSpellUpdateWithoutCharacterInput, CharacterSpellUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterSpellCreateWithoutCharacterInput, CharacterSpellUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSpellUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterSpellWhereUniqueInput
    data: XOR<CharacterSpellUpdateWithoutCharacterInput, CharacterSpellUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterSpellUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterSpellScalarWhereInput
    data: XOR<CharacterSpellUpdateManyMutationInput, CharacterSpellUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterSpellScalarWhereInput = {
    AND?: CharacterSpellScalarWhereInput | CharacterSpellScalarWhereInput[]
    OR?: CharacterSpellScalarWhereInput[]
    NOT?: CharacterSpellScalarWhereInput | CharacterSpellScalarWhereInput[]
    id?: StringFilter<"CharacterSpell"> | string
    characterId?: StringFilter<"CharacterSpell"> | string
    spellId?: IntFilter<"CharacterSpell"> | number
    known?: BoolFilter<"CharacterSpell"> | boolean
    proficiency?: IntFilter<"CharacterSpell"> | number
    lastCast?: DateTimeNullableFilter<"CharacterSpell"> | Date | string | null
  }

  export type GameClassUpsertWithoutCharactersInput = {
    update: XOR<GameClassUpdateWithoutCharactersInput, GameClassUncheckedUpdateWithoutCharactersInput>
    create: XOR<GameClassCreateWithoutCharactersInput, GameClassUncheckedCreateWithoutCharactersInput>
    where?: GameClassWhereInput
  }

  export type GameClassUpdateToOneWithWhereWithoutCharactersInput = {
    where?: GameClassWhereInput
    data: XOR<GameClassUpdateWithoutCharactersInput, GameClassUncheckedUpdateWithoutCharactersInput>
  }

  export type GameClassUpdateWithoutCharactersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillAccess?: ClassSkillUpdateManyWithoutGameClassNestedInput
    mobs?: MobUpdateManyWithoutGameClassNestedInput
    spellCircles?: SpellClassCircleUpdateManyWithoutGameClassNestedInput
  }

  export type GameClassUncheckedUpdateWithoutCharactersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillAccess?: ClassSkillUncheckedUpdateManyWithoutGameClassNestedInput
    mobs?: MobUncheckedUpdateManyWithoutGameClassNestedInput
    spellCircles?: SpellClassCircleUncheckedUpdateManyWithoutGameClassNestedInput
  }

  export type UserUpsertWithoutCharactersInput = {
    update: XOR<UserUpdateWithoutCharactersInput, UserUncheckedUpdateWithoutCharactersInput>
    create: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCharactersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCharactersInput, UserUncheckedUpdateWithoutCharactersInput>
  }

  export type UserUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    issuedBans?: BanRecordUpdateManyWithoutAdminNestedInput
    banRecords?: BanRecordUpdateManyWithoutUserNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    issuedBans?: BanRecordUncheckedUpdateManyWithoutAdminNestedInput
    banRecords?: BanRecordUncheckedUpdateManyWithoutUserNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MobResetCreateWithoutZoneInput = {
    id?: string
    max?: number
    name?: string | null
    probability?: number
    carrying?: MobCarryingCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedCreateNestedManyWithoutResetInput
    mob: MobCreateNestedOneWithoutResetsInput
    room: RoomCreateNestedOneWithoutMobResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutMobResetInput
  }

  export type MobResetUncheckedCreateWithoutZoneInput = {
    id?: string
    max?: number
    name?: string | null
    mobZoneId: number
    mobId: number
    roomZoneId: number
    roomId: number
    probability?: number
    carrying?: MobCarryingUncheckedCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetUncheckedCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedUncheckedCreateNestedManyWithoutResetInput
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutMobResetInput
  }

  export type MobResetCreateOrConnectWithoutZoneInput = {
    where: MobResetWhereUniqueInput
    create: XOR<MobResetCreateWithoutZoneInput, MobResetUncheckedCreateWithoutZoneInput>
  }

  export type MobResetCreateManyZoneInputEnvelope = {
    data: MobResetCreateManyZoneInput | MobResetCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type MobCreateWithoutZoneInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetCreateNestedManyWithoutMobInput
    skills?: MobSkillCreateNestedManyWithoutMobInput
    spells?: MobSpellCreateNestedManyWithoutMobInput
    gameClass?: GameClassCreateNestedOneWithoutMobsInput
    shops?: ShopCreateNestedManyWithoutKeeperInput
    triggers?: TriggerCreateNestedManyWithoutMobInput
  }

  export type MobUncheckedCreateWithoutZoneInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    classId?: number | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetUncheckedCreateNestedManyWithoutMobInput
    skills?: MobSkillUncheckedCreateNestedManyWithoutMobInput
    spells?: MobSpellUncheckedCreateNestedManyWithoutMobInput
    shops?: ShopUncheckedCreateNestedManyWithoutKeeperInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutMobInput
  }

  export type MobCreateOrConnectWithoutZoneInput = {
    where: MobWhereUniqueInput
    create: XOR<MobCreateWithoutZoneInput, MobUncheckedCreateWithoutZoneInput>
  }

  export type MobCreateManyZoneInputEnvelope = {
    data: MobCreateManyZoneInput | MobCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type ObjectResetCreateWithoutZoneInput = {
    id: string
    max?: number
    name?: string | null
    probability?: number
    object: ObjectCreateNestedOneWithoutResetsInput
    room: RoomCreateNestedOneWithoutObjectResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutObjectResetInput
  }

  export type ObjectResetUncheckedCreateWithoutZoneInput = {
    id: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
    roomZoneId: number
    roomId: number
    probability?: number
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutObjectResetInput
  }

  export type ObjectResetCreateOrConnectWithoutZoneInput = {
    where: ObjectResetWhereUniqueInput
    create: XOR<ObjectResetCreateWithoutZoneInput, ObjectResetUncheckedCreateWithoutZoneInput>
  }

  export type ObjectResetCreateManyZoneInputEnvelope = {
    data: ObjectResetCreateManyZoneInput | ObjectResetCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type ObjectCreateWithoutZoneInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutZoneInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutZoneInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutZoneInput, ObjectUncheckedCreateWithoutZoneInput>
  }

  export type ObjectCreateManyZoneInputEnvelope = {
    data: ObjectCreateManyZoneInput | ObjectCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutZoneInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    mobResets?: MobResetCreateNestedManyWithoutRoomInput
    objectResets?: ObjectResetCreateNestedManyWithoutRoomInput
    exits?: RoomExitCreateNestedManyWithoutRoomInput
    extraDescs?: RoomExtraDescriptionCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutZoneInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutRoomInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutRoomInput
    exits?: RoomExitUncheckedCreateNestedManyWithoutRoomInput
    extraDescs?: RoomExtraDescriptionUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutZoneInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutZoneInput, RoomUncheckedCreateWithoutZoneInput>
  }

  export type RoomCreateManyZoneInputEnvelope = {
    data: RoomCreateManyZoneInput | RoomCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutZoneInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptCreateNestedManyWithoutShopInput
    hours?: ShopHourCreateNestedManyWithoutShopInput
    items?: ShopItemCreateNestedManyWithoutShopInput
    rooms?: ShopRoomCreateNestedManyWithoutShopInput
    keeper?: MobCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateWithoutZoneInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    keeperZoneId?: number | null
    keeperId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedCreateNestedManyWithoutShopInput
    hours?: ShopHourUncheckedCreateNestedManyWithoutShopInput
    items?: ShopItemUncheckedCreateNestedManyWithoutShopInput
    rooms?: ShopRoomUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutZoneInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutZoneInput, ShopUncheckedCreateWithoutZoneInput>
  }

  export type ShopCreateManyZoneInputEnvelope = {
    data: ShopCreateManyZoneInput | ShopCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type TriggerCreateWithoutZoneInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
    mob?: MobCreateNestedOneWithoutTriggersInput
    object?: ObjectCreateNestedOneWithoutTriggersInput
  }

  export type TriggerUncheckedCreateWithoutZoneInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    mobZoneId?: number | null
    mobId?: number | null
    objectZoneId?: number | null
    objectId?: number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
  }

  export type TriggerCreateOrConnectWithoutZoneInput = {
    where: TriggerWhereUniqueInput
    create: XOR<TriggerCreateWithoutZoneInput, TriggerUncheckedCreateWithoutZoneInput>
  }

  export type TriggerCreateManyZoneInputEnvelope = {
    data: TriggerCreateManyZoneInput | TriggerCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type MobResetUpsertWithWhereUniqueWithoutZoneInput = {
    where: MobResetWhereUniqueInput
    update: XOR<MobResetUpdateWithoutZoneInput, MobResetUncheckedUpdateWithoutZoneInput>
    create: XOR<MobResetCreateWithoutZoneInput, MobResetUncheckedCreateWithoutZoneInput>
  }

  export type MobResetUpdateWithWhereUniqueWithoutZoneInput = {
    where: MobResetWhereUniqueInput
    data: XOR<MobResetUpdateWithoutZoneInput, MobResetUncheckedUpdateWithoutZoneInput>
  }

  export type MobResetUpdateManyWithWhereWithoutZoneInput = {
    where: MobResetScalarWhereInput
    data: XOR<MobResetUpdateManyMutationInput, MobResetUncheckedUpdateManyWithoutZoneInput>
  }

  export type MobResetScalarWhereInput = {
    AND?: MobResetScalarWhereInput | MobResetScalarWhereInput[]
    OR?: MobResetScalarWhereInput[]
    NOT?: MobResetScalarWhereInput | MobResetScalarWhereInput[]
    id?: StringFilter<"MobReset"> | string
    max?: IntFilter<"MobReset"> | number
    name?: StringNullableFilter<"MobReset"> | string | null
    mobZoneId?: IntFilter<"MobReset"> | number
    mobId?: IntFilter<"MobReset"> | number
    roomZoneId?: IntFilter<"MobReset"> | number
    roomId?: IntFilter<"MobReset"> | number
    zoneId?: IntFilter<"MobReset"> | number
    probability?: FloatFilter<"MobReset"> | number
  }

  export type MobUpsertWithWhereUniqueWithoutZoneInput = {
    where: MobWhereUniqueInput
    update: XOR<MobUpdateWithoutZoneInput, MobUncheckedUpdateWithoutZoneInput>
    create: XOR<MobCreateWithoutZoneInput, MobUncheckedCreateWithoutZoneInput>
  }

  export type MobUpdateWithWhereUniqueWithoutZoneInput = {
    where: MobWhereUniqueInput
    data: XOR<MobUpdateWithoutZoneInput, MobUncheckedUpdateWithoutZoneInput>
  }

  export type MobUpdateManyWithWhereWithoutZoneInput = {
    where: MobScalarWhereInput
    data: XOR<MobUpdateManyMutationInput, MobUncheckedUpdateManyWithoutZoneInput>
  }

  export type MobScalarWhereInput = {
    AND?: MobScalarWhereInput | MobScalarWhereInput[]
    OR?: MobScalarWhereInput[]
    NOT?: MobScalarWhereInput | MobScalarWhereInput[]
    id?: IntFilter<"Mob"> | number
    keywords?: StringNullableListFilter<"Mob">
    mobClass?: StringFilter<"Mob"> | string
    shortDesc?: StringFilter<"Mob"> | string
    longDesc?: StringFilter<"Mob"> | string
    desc?: StringFilter<"Mob"> | string
    alignment?: IntFilter<"Mob"> | number
    level?: IntFilter<"Mob"> | number
    armorClass?: IntFilter<"Mob"> | number
    hitRoll?: IntFilter<"Mob"> | number
    move?: IntFilter<"Mob"> | number
    hpDiceNum?: IntFilter<"Mob"> | number
    hpDiceSize?: IntFilter<"Mob"> | number
    hpDiceBonus?: IntFilter<"Mob"> | number
    damageDiceNum?: IntFilter<"Mob"> | number
    damageDiceSize?: IntFilter<"Mob"> | number
    damageDiceBonus?: IntFilter<"Mob"> | number
    copper?: IntFilter<"Mob"> | number
    silver?: IntFilter<"Mob"> | number
    gold?: IntFilter<"Mob"> | number
    platinum?: IntFilter<"Mob"> | number
    raceAlign?: IntFilter<"Mob"> | number
    total_wealth?: IntFilter<"Mob"> | number
    average_stats?: IntFilter<"Mob"> | number
    estimated_hp?: IntFilter<"Mob"> | number
    strength?: IntFilter<"Mob"> | number
    intelligence?: IntFilter<"Mob"> | number
    wisdom?: IntFilter<"Mob"> | number
    dexterity?: IntFilter<"Mob"> | number
    constitution?: IntFilter<"Mob"> | number
    charisma?: IntFilter<"Mob"> | number
    perception?: IntFilter<"Mob"> | number
    concealment?: IntFilter<"Mob"> | number
    zoneId?: IntFilter<"Mob"> | number
    createdAt?: DateTimeFilter<"Mob"> | Date | string
    updatedAt?: DateTimeFilter<"Mob"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Mob"> | Date | string | null
    createdBy?: StringNullableFilter<"Mob"> | string | null
    updatedBy?: StringNullableFilter<"Mob"> | string | null
    classId?: IntNullableFilter<"Mob"> | number | null
    race?: EnumRaceFilter<"Mob"> | $Enums.Race
    mobFlags?: EnumMobFlagNullableListFilter<"Mob">
    effectFlags?: EnumEffectFlagNullableListFilter<"Mob">
    position?: EnumPositionFilter<"Mob"> | $Enums.Position
    defaultPosition?: EnumPositionFilter<"Mob"> | $Enums.Position
    gender?: EnumGenderFilter<"Mob"> | $Enums.Gender
    size?: EnumSizeFilter<"Mob"> | $Enums.Size
    lifeForce?: EnumLifeForceFilter<"Mob"> | $Enums.LifeForce
    composition?: EnumCompositionFilter<"Mob"> | $Enums.Composition
    stance?: EnumStanceFilter<"Mob"> | $Enums.Stance
    damageType?: EnumDamageTypeFilter<"Mob"> | $Enums.DamageType
  }

  export type ObjectResetUpsertWithWhereUniqueWithoutZoneInput = {
    where: ObjectResetWhereUniqueInput
    update: XOR<ObjectResetUpdateWithoutZoneInput, ObjectResetUncheckedUpdateWithoutZoneInput>
    create: XOR<ObjectResetCreateWithoutZoneInput, ObjectResetUncheckedCreateWithoutZoneInput>
  }

  export type ObjectResetUpdateWithWhereUniqueWithoutZoneInput = {
    where: ObjectResetWhereUniqueInput
    data: XOR<ObjectResetUpdateWithoutZoneInput, ObjectResetUncheckedUpdateWithoutZoneInput>
  }

  export type ObjectResetUpdateManyWithWhereWithoutZoneInput = {
    where: ObjectResetScalarWhereInput
    data: XOR<ObjectResetUpdateManyMutationInput, ObjectResetUncheckedUpdateManyWithoutZoneInput>
  }

  export type ObjectResetScalarWhereInput = {
    AND?: ObjectResetScalarWhereInput | ObjectResetScalarWhereInput[]
    OR?: ObjectResetScalarWhereInput[]
    NOT?: ObjectResetScalarWhereInput | ObjectResetScalarWhereInput[]
    id?: StringFilter<"ObjectReset"> | string
    max?: IntFilter<"ObjectReset"> | number
    name?: StringNullableFilter<"ObjectReset"> | string | null
    objectZoneId?: IntFilter<"ObjectReset"> | number
    objectId?: IntFilter<"ObjectReset"> | number
    roomZoneId?: IntFilter<"ObjectReset"> | number
    roomId?: IntFilter<"ObjectReset"> | number
    zoneId?: IntFilter<"ObjectReset"> | number
    probability?: FloatFilter<"ObjectReset"> | number
  }

  export type ObjectUpsertWithWhereUniqueWithoutZoneInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutZoneInput, ObjectUncheckedUpdateWithoutZoneInput>
    create: XOR<ObjectCreateWithoutZoneInput, ObjectUncheckedCreateWithoutZoneInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutZoneInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutZoneInput, ObjectUncheckedUpdateWithoutZoneInput>
  }

  export type ObjectUpdateManyWithWhereWithoutZoneInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutZoneInput>
  }

  export type ObjectScalarWhereInput = {
    AND?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
    OR?: ObjectScalarWhereInput[]
    NOT?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
    id?: IntFilter<"Object"> | number
    type?: EnumObjectTypeFilter<"Object"> | $Enums.ObjectType
    keywords?: StringNullableListFilter<"Object">
    shortDesc?: StringFilter<"Object"> | string
    description?: StringFilter<"Object"> | string
    actionDesc?: StringNullableFilter<"Object"> | string | null
    weight?: FloatFilter<"Object"> | number
    cost?: IntFilter<"Object"> | number
    timer?: IntFilter<"Object"> | number
    decomposeTimer?: IntFilter<"Object"> | number
    level?: IntFilter<"Object"> | number
    concealment?: IntFilter<"Object"> | number
    values?: JsonFilter<"Object">
    zoneId?: IntFilter<"Object"> | number
    createdAt?: DateTimeFilter<"Object"> | Date | string
    updatedAt?: DateTimeFilter<"Object"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Object"> | Date | string | null
    createdBy?: StringNullableFilter<"Object"> | string | null
    updatedBy?: StringNullableFilter<"Object"> | string | null
    flags?: EnumObjectFlagNullableListFilter<"Object">
    effectFlags?: EnumEffectFlagNullableListFilter<"Object">
    wearFlags?: EnumWearFlagNullableListFilter<"Object">
  }

  export type RoomUpsertWithWhereUniqueWithoutZoneInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutZoneInput, RoomUncheckedUpdateWithoutZoneInput>
    create: XOR<RoomCreateWithoutZoneInput, RoomUncheckedCreateWithoutZoneInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutZoneInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutZoneInput, RoomUncheckedUpdateWithoutZoneInput>
  }

  export type RoomUpdateManyWithWhereWithoutZoneInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutZoneInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: IntFilter<"Room"> | number
    name?: StringFilter<"Room"> | string
    description?: StringFilter<"Room"> | string
    sector?: EnumSectorFilter<"Room"> | $Enums.Sector
    zoneId?: IntFilter<"Room"> | number
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Room"> | Date | string | null
    createdBy?: StringNullableFilter<"Room"> | string | null
    updatedBy?: StringNullableFilter<"Room"> | string | null
    flags?: EnumRoomFlagNullableListFilter<"Room">
    layoutX?: IntNullableFilter<"Room"> | number | null
    layoutY?: IntNullableFilter<"Room"> | number | null
    layoutZ?: IntNullableFilter<"Room"> | number | null
  }

  export type ShopUpsertWithWhereUniqueWithoutZoneInput = {
    where: ShopWhereUniqueInput
    update: XOR<ShopUpdateWithoutZoneInput, ShopUncheckedUpdateWithoutZoneInput>
    create: XOR<ShopCreateWithoutZoneInput, ShopUncheckedCreateWithoutZoneInput>
  }

  export type ShopUpdateWithWhereUniqueWithoutZoneInput = {
    where: ShopWhereUniqueInput
    data: XOR<ShopUpdateWithoutZoneInput, ShopUncheckedUpdateWithoutZoneInput>
  }

  export type ShopUpdateManyWithWhereWithoutZoneInput = {
    where: ShopScalarWhereInput
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyWithoutZoneInput>
  }

  export type ShopScalarWhereInput = {
    AND?: ShopScalarWhereInput | ShopScalarWhereInput[]
    OR?: ShopScalarWhereInput[]
    NOT?: ShopScalarWhereInput | ShopScalarWhereInput[]
    id?: IntFilter<"Shop"> | number
    buyProfit?: FloatFilter<"Shop"> | number
    sellProfit?: FloatFilter<"Shop"> | number
    temper1?: IntFilter<"Shop"> | number
    noSuchItem1?: StringNullableFilter<"Shop"> | string | null
    noSuchItem2?: StringNullableFilter<"Shop"> | string | null
    doNotBuy?: StringNullableFilter<"Shop"> | string | null
    missingCash1?: StringNullableFilter<"Shop"> | string | null
    missingCash2?: StringNullableFilter<"Shop"> | string | null
    messageBuy?: StringNullableFilter<"Shop"> | string | null
    messageSell?: StringNullableFilter<"Shop"> | string | null
    keeperZoneId?: IntNullableFilter<"Shop"> | number | null
    keeperId?: IntNullableFilter<"Shop"> | number | null
    zoneId?: IntFilter<"Shop"> | number
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    createdBy?: StringNullableFilter<"Shop"> | string | null
    updatedBy?: StringNullableFilter<"Shop"> | string | null
    flags?: EnumShopFlagNullableListFilter<"Shop">
    tradesWithFlags?: EnumShopTradesWithNullableListFilter<"Shop">
  }

  export type TriggerUpsertWithWhereUniqueWithoutZoneInput = {
    where: TriggerWhereUniqueInput
    update: XOR<TriggerUpdateWithoutZoneInput, TriggerUncheckedUpdateWithoutZoneInput>
    create: XOR<TriggerCreateWithoutZoneInput, TriggerUncheckedCreateWithoutZoneInput>
  }

  export type TriggerUpdateWithWhereUniqueWithoutZoneInput = {
    where: TriggerWhereUniqueInput
    data: XOR<TriggerUpdateWithoutZoneInput, TriggerUncheckedUpdateWithoutZoneInput>
  }

  export type TriggerUpdateManyWithWhereWithoutZoneInput = {
    where: TriggerScalarWhereInput
    data: XOR<TriggerUpdateManyMutationInput, TriggerUncheckedUpdateManyWithoutZoneInput>
  }

  export type TriggerScalarWhereInput = {
    AND?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
    OR?: TriggerScalarWhereInput[]
    NOT?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
    id?: StringFilter<"Trigger"> | string
    name?: StringFilter<"Trigger"> | string
    attachType?: EnumScriptTypeFilter<"Trigger"> | $Enums.ScriptType
    numArgs?: IntFilter<"Trigger"> | number
    argList?: StringNullableFilter<"Trigger"> | string | null
    commands?: StringFilter<"Trigger"> | string
    zoneId?: IntNullableFilter<"Trigger"> | number | null
    mobZoneId?: IntNullableFilter<"Trigger"> | number | null
    mobId?: IntNullableFilter<"Trigger"> | number | null
    objectZoneId?: IntNullableFilter<"Trigger"> | number | null
    objectId?: IntNullableFilter<"Trigger"> | number | null
    variables?: JsonFilter<"Trigger">
    createdAt?: DateTimeFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeFilter<"Trigger"> | Date | string
    createdBy?: StringNullableFilter<"Trigger"> | string | null
    updatedBy?: StringNullableFilter<"Trigger"> | string | null
    flags?: EnumTriggerFlagNullableListFilter<"Trigger">
  }

  export type MobResetCreateWithoutRoomInput = {
    id?: string
    max?: number
    name?: string | null
    probability?: number
    carrying?: MobCarryingCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedCreateNestedManyWithoutResetInput
    mob: MobCreateNestedOneWithoutResetsInput
    zone: ZoneCreateNestedOneWithoutMobResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutMobResetInput
  }

  export type MobResetUncheckedCreateWithoutRoomInput = {
    id?: string
    max?: number
    name?: string | null
    mobZoneId: number
    mobId: number
    zoneId: number
    probability?: number
    carrying?: MobCarryingUncheckedCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetUncheckedCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedUncheckedCreateNestedManyWithoutResetInput
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutMobResetInput
  }

  export type MobResetCreateOrConnectWithoutRoomInput = {
    where: MobResetWhereUniqueInput
    create: XOR<MobResetCreateWithoutRoomInput, MobResetUncheckedCreateWithoutRoomInput>
  }

  export type MobResetCreateManyRoomInputEnvelope = {
    data: MobResetCreateManyRoomInput | MobResetCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type ObjectResetCreateWithoutRoomInput = {
    id: string
    max?: number
    name?: string | null
    probability?: number
    object: ObjectCreateNestedOneWithoutResetsInput
    zone: ZoneCreateNestedOneWithoutObjectResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutObjectResetInput
  }

  export type ObjectResetUncheckedCreateWithoutRoomInput = {
    id: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
    zoneId: number
    probability?: number
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutObjectResetInput
  }

  export type ObjectResetCreateOrConnectWithoutRoomInput = {
    where: ObjectResetWhereUniqueInput
    create: XOR<ObjectResetCreateWithoutRoomInput, ObjectResetUncheckedCreateWithoutRoomInput>
  }

  export type ObjectResetCreateManyRoomInputEnvelope = {
    data: ObjectResetCreateManyRoomInput | ObjectResetCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type RoomExitCreateWithoutRoomInput = {
    id?: string
    direction: $Enums.Direction
    description?: string | null
    keyword?: string | null
    key?: string | null
    destination?: number | null
    flags?: RoomExitCreateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExitUncheckedCreateWithoutRoomInput = {
    id?: string
    direction: $Enums.Direction
    description?: string | null
    keyword?: string | null
    key?: string | null
    destination?: number | null
    flags?: RoomExitCreateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExitCreateOrConnectWithoutRoomInput = {
    where: RoomExitWhereUniqueInput
    create: XOR<RoomExitCreateWithoutRoomInput, RoomExitUncheckedCreateWithoutRoomInput>
  }

  export type RoomExitCreateManyRoomInputEnvelope = {
    data: RoomExitCreateManyRoomInput | RoomExitCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type RoomExtraDescriptionCreateWithoutRoomInput = {
    id?: string
    keyword: string
    description: string
  }

  export type RoomExtraDescriptionUncheckedCreateWithoutRoomInput = {
    id?: string
    keyword: string
    description: string
  }

  export type RoomExtraDescriptionCreateOrConnectWithoutRoomInput = {
    where: RoomExtraDescriptionWhereUniqueInput
    create: XOR<RoomExtraDescriptionCreateWithoutRoomInput, RoomExtraDescriptionUncheckedCreateWithoutRoomInput>
  }

  export type RoomExtraDescriptionCreateManyRoomInputEnvelope = {
    data: RoomExtraDescriptionCreateManyRoomInput | RoomExtraDescriptionCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type ZoneCreateWithoutRoomsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetCreateNestedManyWithoutZoneInput
    mobs?: MobCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetCreateNestedManyWithoutZoneInput
    objects?: ObjectCreateNestedManyWithoutZoneInput
    shops?: ShopCreateNestedManyWithoutZoneInput
    triggers?: TriggerCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutRoomsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutZoneInput
    mobs?: MobUncheckedCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutZoneInput
    objects?: ObjectUncheckedCreateNestedManyWithoutZoneInput
    shops?: ShopUncheckedCreateNestedManyWithoutZoneInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutRoomsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutRoomsInput, ZoneUncheckedCreateWithoutRoomsInput>
  }

  export type MobResetUpsertWithWhereUniqueWithoutRoomInput = {
    where: MobResetWhereUniqueInput
    update: XOR<MobResetUpdateWithoutRoomInput, MobResetUncheckedUpdateWithoutRoomInput>
    create: XOR<MobResetCreateWithoutRoomInput, MobResetUncheckedCreateWithoutRoomInput>
  }

  export type MobResetUpdateWithWhereUniqueWithoutRoomInput = {
    where: MobResetWhereUniqueInput
    data: XOR<MobResetUpdateWithoutRoomInput, MobResetUncheckedUpdateWithoutRoomInput>
  }

  export type MobResetUpdateManyWithWhereWithoutRoomInput = {
    where: MobResetScalarWhereInput
    data: XOR<MobResetUpdateManyMutationInput, MobResetUncheckedUpdateManyWithoutRoomInput>
  }

  export type ObjectResetUpsertWithWhereUniqueWithoutRoomInput = {
    where: ObjectResetWhereUniqueInput
    update: XOR<ObjectResetUpdateWithoutRoomInput, ObjectResetUncheckedUpdateWithoutRoomInput>
    create: XOR<ObjectResetCreateWithoutRoomInput, ObjectResetUncheckedCreateWithoutRoomInput>
  }

  export type ObjectResetUpdateWithWhereUniqueWithoutRoomInput = {
    where: ObjectResetWhereUniqueInput
    data: XOR<ObjectResetUpdateWithoutRoomInput, ObjectResetUncheckedUpdateWithoutRoomInput>
  }

  export type ObjectResetUpdateManyWithWhereWithoutRoomInput = {
    where: ObjectResetScalarWhereInput
    data: XOR<ObjectResetUpdateManyMutationInput, ObjectResetUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomExitUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomExitWhereUniqueInput
    update: XOR<RoomExitUpdateWithoutRoomInput, RoomExitUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomExitCreateWithoutRoomInput, RoomExitUncheckedCreateWithoutRoomInput>
  }

  export type RoomExitUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomExitWhereUniqueInput
    data: XOR<RoomExitUpdateWithoutRoomInput, RoomExitUncheckedUpdateWithoutRoomInput>
  }

  export type RoomExitUpdateManyWithWhereWithoutRoomInput = {
    where: RoomExitScalarWhereInput
    data: XOR<RoomExitUpdateManyMutationInput, RoomExitUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomExitScalarWhereInput = {
    AND?: RoomExitScalarWhereInput | RoomExitScalarWhereInput[]
    OR?: RoomExitScalarWhereInput[]
    NOT?: RoomExitScalarWhereInput | RoomExitScalarWhereInput[]
    id?: StringFilter<"RoomExit"> | string
    direction?: EnumDirectionFilter<"RoomExit"> | $Enums.Direction
    description?: StringNullableFilter<"RoomExit"> | string | null
    keyword?: StringNullableFilter<"RoomExit"> | string | null
    key?: StringNullableFilter<"RoomExit"> | string | null
    destination?: IntNullableFilter<"RoomExit"> | number | null
    roomZoneId?: IntFilter<"RoomExit"> | number
    roomId?: IntFilter<"RoomExit"> | number
    flags?: EnumExitFlagNullableListFilter<"RoomExit">
  }

  export type RoomExtraDescriptionUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomExtraDescriptionWhereUniqueInput
    update: XOR<RoomExtraDescriptionUpdateWithoutRoomInput, RoomExtraDescriptionUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomExtraDescriptionCreateWithoutRoomInput, RoomExtraDescriptionUncheckedCreateWithoutRoomInput>
  }

  export type RoomExtraDescriptionUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomExtraDescriptionWhereUniqueInput
    data: XOR<RoomExtraDescriptionUpdateWithoutRoomInput, RoomExtraDescriptionUncheckedUpdateWithoutRoomInput>
  }

  export type RoomExtraDescriptionUpdateManyWithWhereWithoutRoomInput = {
    where: RoomExtraDescriptionScalarWhereInput
    data: XOR<RoomExtraDescriptionUpdateManyMutationInput, RoomExtraDescriptionUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomExtraDescriptionScalarWhereInput = {
    AND?: RoomExtraDescriptionScalarWhereInput | RoomExtraDescriptionScalarWhereInput[]
    OR?: RoomExtraDescriptionScalarWhereInput[]
    NOT?: RoomExtraDescriptionScalarWhereInput | RoomExtraDescriptionScalarWhereInput[]
    id?: StringFilter<"RoomExtraDescription"> | string
    keyword?: StringFilter<"RoomExtraDescription"> | string
    description?: StringFilter<"RoomExtraDescription"> | string
    roomZoneId?: IntFilter<"RoomExtraDescription"> | number
    roomId?: IntFilter<"RoomExtraDescription"> | number
  }

  export type ZoneUpsertWithoutRoomsInput = {
    update: XOR<ZoneUpdateWithoutRoomsInput, ZoneUncheckedUpdateWithoutRoomsInput>
    create: XOR<ZoneCreateWithoutRoomsInput, ZoneUncheckedCreateWithoutRoomsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutRoomsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutRoomsInput, ZoneUncheckedUpdateWithoutRoomsInput>
  }

  export type ZoneUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUpdateManyWithoutZoneNestedInput
    mobs?: MobUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUpdateManyWithoutZoneNestedInput
    objects?: ObjectUpdateManyWithoutZoneNestedInput
    shops?: ShopUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUncheckedUpdateManyWithoutZoneNestedInput
    mobs?: MobUncheckedUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutZoneNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutZoneNestedInput
    shops?: ShopUncheckedUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type RoomCreateWithoutExitsInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    mobResets?: MobResetCreateNestedManyWithoutRoomInput
    objectResets?: ObjectResetCreateNestedManyWithoutRoomInput
    extraDescs?: RoomExtraDescriptionCreateNestedManyWithoutRoomInput
    zone: ZoneCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutExitsInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutRoomInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutRoomInput
    extraDescs?: RoomExtraDescriptionUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutExitsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutExitsInput, RoomUncheckedCreateWithoutExitsInput>
  }

  export type RoomUpsertWithoutExitsInput = {
    update: XOR<RoomUpdateWithoutExitsInput, RoomUncheckedUpdateWithoutExitsInput>
    create: XOR<RoomCreateWithoutExitsInput, RoomUncheckedCreateWithoutExitsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutExitsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutExitsInput, RoomUncheckedUpdateWithoutExitsInput>
  }

  export type RoomUpdateWithoutExitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    mobResets?: MobResetUpdateManyWithoutRoomNestedInput
    objectResets?: ObjectResetUpdateManyWithoutRoomNestedInput
    extraDescs?: RoomExtraDescriptionUpdateManyWithoutRoomNestedInput
    zone?: ZoneUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutExitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    mobResets?: MobResetUncheckedUpdateManyWithoutRoomNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutRoomNestedInput
    extraDescs?: RoomExtraDescriptionUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateWithoutExtraDescsInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    mobResets?: MobResetCreateNestedManyWithoutRoomInput
    objectResets?: ObjectResetCreateNestedManyWithoutRoomInput
    exits?: RoomExitCreateNestedManyWithoutRoomInput
    zone: ZoneCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutExtraDescsInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutRoomInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutRoomInput
    exits?: RoomExitUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutExtraDescsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutExtraDescsInput, RoomUncheckedCreateWithoutExtraDescsInput>
  }

  export type RoomUpsertWithoutExtraDescsInput = {
    update: XOR<RoomUpdateWithoutExtraDescsInput, RoomUncheckedUpdateWithoutExtraDescsInput>
    create: XOR<RoomCreateWithoutExtraDescsInput, RoomUncheckedCreateWithoutExtraDescsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutExtraDescsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutExtraDescsInput, RoomUncheckedUpdateWithoutExtraDescsInput>
  }

  export type RoomUpdateWithoutExtraDescsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    mobResets?: MobResetUpdateManyWithoutRoomNestedInput
    objectResets?: ObjectResetUpdateManyWithoutRoomNestedInput
    exits?: RoomExitUpdateManyWithoutRoomNestedInput
    zone?: ZoneUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutExtraDescsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    mobResets?: MobResetUncheckedUpdateManyWithoutRoomNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutRoomNestedInput
    exits?: RoomExitUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type MobResetCreateWithoutMobInput = {
    id?: string
    max?: number
    name?: string | null
    probability?: number
    carrying?: MobCarryingCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedCreateNestedManyWithoutResetInput
    room: RoomCreateNestedOneWithoutMobResetsInput
    zone: ZoneCreateNestedOneWithoutMobResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutMobResetInput
  }

  export type MobResetUncheckedCreateWithoutMobInput = {
    id?: string
    max?: number
    name?: string | null
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
    carrying?: MobCarryingUncheckedCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetUncheckedCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedUncheckedCreateNestedManyWithoutResetInput
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutMobResetInput
  }

  export type MobResetCreateOrConnectWithoutMobInput = {
    where: MobResetWhereUniqueInput
    create: XOR<MobResetCreateWithoutMobInput, MobResetUncheckedCreateWithoutMobInput>
  }

  export type MobResetCreateManyMobInputEnvelope = {
    data: MobResetCreateManyMobInput | MobResetCreateManyMobInput[]
    skipDuplicates?: boolean
  }

  export type MobSkillCreateWithoutMobInput = {
    level?: number
    skill: SkillCreateNestedOneWithoutMobSkillsInput
  }

  export type MobSkillUncheckedCreateWithoutMobInput = {
    id?: number
    skillId: number
    level?: number
  }

  export type MobSkillCreateOrConnectWithoutMobInput = {
    where: MobSkillWhereUniqueInput
    create: XOR<MobSkillCreateWithoutMobInput, MobSkillUncheckedCreateWithoutMobInput>
  }

  export type MobSkillCreateManyMobInputEnvelope = {
    data: MobSkillCreateManyMobInput | MobSkillCreateManyMobInput[]
    skipDuplicates?: boolean
  }

  export type MobSpellCreateWithoutMobInput = {
    circle?: number
    known?: boolean
    spell: SpellCreateNestedOneWithoutMobSpellsInput
  }

  export type MobSpellUncheckedCreateWithoutMobInput = {
    id?: number
    spellId: number
    circle?: number
    known?: boolean
  }

  export type MobSpellCreateOrConnectWithoutMobInput = {
    where: MobSpellWhereUniqueInput
    create: XOR<MobSpellCreateWithoutMobInput, MobSpellUncheckedCreateWithoutMobInput>
  }

  export type MobSpellCreateManyMobInputEnvelope = {
    data: MobSpellCreateManyMobInput | MobSpellCreateManyMobInput[]
    skipDuplicates?: boolean
  }

  export type GameClassCreateWithoutMobsInput = {
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutGameClassInput
    skillAccess?: ClassSkillCreateNestedManyWithoutGameClassInput
    spellCircles?: SpellClassCircleCreateNestedManyWithoutGameClassInput
  }

  export type GameClassUncheckedCreateWithoutMobsInput = {
    id?: number
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutGameClassInput
    skillAccess?: ClassSkillUncheckedCreateNestedManyWithoutGameClassInput
    spellCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutGameClassInput
  }

  export type GameClassCreateOrConnectWithoutMobsInput = {
    where: GameClassWhereUniqueInput
    create: XOR<GameClassCreateWithoutMobsInput, GameClassUncheckedCreateWithoutMobsInput>
  }

  export type ZoneCreateWithoutMobsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetCreateNestedManyWithoutZoneInput
    objects?: ObjectCreateNestedManyWithoutZoneInput
    rooms?: RoomCreateNestedManyWithoutZoneInput
    shops?: ShopCreateNestedManyWithoutZoneInput
    triggers?: TriggerCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutMobsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutZoneInput
    objects?: ObjectUncheckedCreateNestedManyWithoutZoneInput
    rooms?: RoomUncheckedCreateNestedManyWithoutZoneInput
    shops?: ShopUncheckedCreateNestedManyWithoutZoneInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutMobsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutMobsInput, ZoneUncheckedCreateWithoutMobsInput>
  }

  export type ShopCreateWithoutKeeperInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptCreateNestedManyWithoutShopInput
    hours?: ShopHourCreateNestedManyWithoutShopInput
    items?: ShopItemCreateNestedManyWithoutShopInput
    rooms?: ShopRoomCreateNestedManyWithoutShopInput
    zone: ZoneCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateWithoutKeeperInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedCreateNestedManyWithoutShopInput
    hours?: ShopHourUncheckedCreateNestedManyWithoutShopInput
    items?: ShopItemUncheckedCreateNestedManyWithoutShopInput
    rooms?: ShopRoomUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutKeeperInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutKeeperInput, ShopUncheckedCreateWithoutKeeperInput>
  }

  export type ShopCreateManyKeeperInputEnvelope = {
    data: ShopCreateManyKeeperInput | ShopCreateManyKeeperInput[]
    skipDuplicates?: boolean
  }

  export type TriggerCreateWithoutMobInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
    object?: ObjectCreateNestedOneWithoutTriggersInput
    zone?: ZoneCreateNestedOneWithoutTriggersInput
  }

  export type TriggerUncheckedCreateWithoutMobInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    zoneId?: number | null
    objectZoneId?: number | null
    objectId?: number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
  }

  export type TriggerCreateOrConnectWithoutMobInput = {
    where: TriggerWhereUniqueInput
    create: XOR<TriggerCreateWithoutMobInput, TriggerUncheckedCreateWithoutMobInput>
  }

  export type TriggerCreateManyMobInputEnvelope = {
    data: TriggerCreateManyMobInput | TriggerCreateManyMobInput[]
    skipDuplicates?: boolean
  }

  export type MobResetUpsertWithWhereUniqueWithoutMobInput = {
    where: MobResetWhereUniqueInput
    update: XOR<MobResetUpdateWithoutMobInput, MobResetUncheckedUpdateWithoutMobInput>
    create: XOR<MobResetCreateWithoutMobInput, MobResetUncheckedCreateWithoutMobInput>
  }

  export type MobResetUpdateWithWhereUniqueWithoutMobInput = {
    where: MobResetWhereUniqueInput
    data: XOR<MobResetUpdateWithoutMobInput, MobResetUncheckedUpdateWithoutMobInput>
  }

  export type MobResetUpdateManyWithWhereWithoutMobInput = {
    where: MobResetScalarWhereInput
    data: XOR<MobResetUpdateManyMutationInput, MobResetUncheckedUpdateManyWithoutMobInput>
  }

  export type MobSkillUpsertWithWhereUniqueWithoutMobInput = {
    where: MobSkillWhereUniqueInput
    update: XOR<MobSkillUpdateWithoutMobInput, MobSkillUncheckedUpdateWithoutMobInput>
    create: XOR<MobSkillCreateWithoutMobInput, MobSkillUncheckedCreateWithoutMobInput>
  }

  export type MobSkillUpdateWithWhereUniqueWithoutMobInput = {
    where: MobSkillWhereUniqueInput
    data: XOR<MobSkillUpdateWithoutMobInput, MobSkillUncheckedUpdateWithoutMobInput>
  }

  export type MobSkillUpdateManyWithWhereWithoutMobInput = {
    where: MobSkillScalarWhereInput
    data: XOR<MobSkillUpdateManyMutationInput, MobSkillUncheckedUpdateManyWithoutMobInput>
  }

  export type MobSkillScalarWhereInput = {
    AND?: MobSkillScalarWhereInput | MobSkillScalarWhereInput[]
    OR?: MobSkillScalarWhereInput[]
    NOT?: MobSkillScalarWhereInput | MobSkillScalarWhereInput[]
    id?: IntFilter<"MobSkill"> | number
    mobZoneId?: IntFilter<"MobSkill"> | number
    mobId?: IntFilter<"MobSkill"> | number
    skillId?: IntFilter<"MobSkill"> | number
    level?: IntFilter<"MobSkill"> | number
  }

  export type MobSpellUpsertWithWhereUniqueWithoutMobInput = {
    where: MobSpellWhereUniqueInput
    update: XOR<MobSpellUpdateWithoutMobInput, MobSpellUncheckedUpdateWithoutMobInput>
    create: XOR<MobSpellCreateWithoutMobInput, MobSpellUncheckedCreateWithoutMobInput>
  }

  export type MobSpellUpdateWithWhereUniqueWithoutMobInput = {
    where: MobSpellWhereUniqueInput
    data: XOR<MobSpellUpdateWithoutMobInput, MobSpellUncheckedUpdateWithoutMobInput>
  }

  export type MobSpellUpdateManyWithWhereWithoutMobInput = {
    where: MobSpellScalarWhereInput
    data: XOR<MobSpellUpdateManyMutationInput, MobSpellUncheckedUpdateManyWithoutMobInput>
  }

  export type MobSpellScalarWhereInput = {
    AND?: MobSpellScalarWhereInput | MobSpellScalarWhereInput[]
    OR?: MobSpellScalarWhereInput[]
    NOT?: MobSpellScalarWhereInput | MobSpellScalarWhereInput[]
    id?: IntFilter<"MobSpell"> | number
    mobZoneId?: IntFilter<"MobSpell"> | number
    mobId?: IntFilter<"MobSpell"> | number
    spellId?: IntFilter<"MobSpell"> | number
    circle?: IntFilter<"MobSpell"> | number
    known?: BoolFilter<"MobSpell"> | boolean
  }

  export type GameClassUpsertWithoutMobsInput = {
    update: XOR<GameClassUpdateWithoutMobsInput, GameClassUncheckedUpdateWithoutMobsInput>
    create: XOR<GameClassCreateWithoutMobsInput, GameClassUncheckedCreateWithoutMobsInput>
    where?: GameClassWhereInput
  }

  export type GameClassUpdateToOneWithWhereWithoutMobsInput = {
    where?: GameClassWhereInput
    data: XOR<GameClassUpdateWithoutMobsInput, GameClassUncheckedUpdateWithoutMobsInput>
  }

  export type GameClassUpdateWithoutMobsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutGameClassNestedInput
    skillAccess?: ClassSkillUpdateManyWithoutGameClassNestedInput
    spellCircles?: SpellClassCircleUpdateManyWithoutGameClassNestedInput
  }

  export type GameClassUncheckedUpdateWithoutMobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutGameClassNestedInput
    skillAccess?: ClassSkillUncheckedUpdateManyWithoutGameClassNestedInput
    spellCircles?: SpellClassCircleUncheckedUpdateManyWithoutGameClassNestedInput
  }

  export type ZoneUpsertWithoutMobsInput = {
    update: XOR<ZoneUpdateWithoutMobsInput, ZoneUncheckedUpdateWithoutMobsInput>
    create: XOR<ZoneCreateWithoutMobsInput, ZoneUncheckedCreateWithoutMobsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutMobsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutMobsInput, ZoneUncheckedUpdateWithoutMobsInput>
  }

  export type ZoneUpdateWithoutMobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUpdateManyWithoutZoneNestedInput
    objects?: ObjectUpdateManyWithoutZoneNestedInput
    rooms?: RoomUpdateManyWithoutZoneNestedInput
    shops?: ShopUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutMobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUncheckedUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutZoneNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutZoneNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutZoneNestedInput
    shops?: ShopUncheckedUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ShopUpsertWithWhereUniqueWithoutKeeperInput = {
    where: ShopWhereUniqueInput
    update: XOR<ShopUpdateWithoutKeeperInput, ShopUncheckedUpdateWithoutKeeperInput>
    create: XOR<ShopCreateWithoutKeeperInput, ShopUncheckedCreateWithoutKeeperInput>
  }

  export type ShopUpdateWithWhereUniqueWithoutKeeperInput = {
    where: ShopWhereUniqueInput
    data: XOR<ShopUpdateWithoutKeeperInput, ShopUncheckedUpdateWithoutKeeperInput>
  }

  export type ShopUpdateManyWithWhereWithoutKeeperInput = {
    where: ShopScalarWhereInput
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyWithoutKeeperInput>
  }

  export type TriggerUpsertWithWhereUniqueWithoutMobInput = {
    where: TriggerWhereUniqueInput
    update: XOR<TriggerUpdateWithoutMobInput, TriggerUncheckedUpdateWithoutMobInput>
    create: XOR<TriggerCreateWithoutMobInput, TriggerUncheckedCreateWithoutMobInput>
  }

  export type TriggerUpdateWithWhereUniqueWithoutMobInput = {
    where: TriggerWhereUniqueInput
    data: XOR<TriggerUpdateWithoutMobInput, TriggerUncheckedUpdateWithoutMobInput>
  }

  export type TriggerUpdateManyWithWhereWithoutMobInput = {
    where: TriggerScalarWhereInput
    data: XOR<TriggerUpdateManyMutationInput, TriggerUncheckedUpdateManyWithoutMobInput>
  }

  export type MobCreateWithoutSkillsInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetCreateNestedManyWithoutMobInput
    spells?: MobSpellCreateNestedManyWithoutMobInput
    gameClass?: GameClassCreateNestedOneWithoutMobsInput
    zone: ZoneCreateNestedOneWithoutMobsInput
    shops?: ShopCreateNestedManyWithoutKeeperInput
    triggers?: TriggerCreateNestedManyWithoutMobInput
  }

  export type MobUncheckedCreateWithoutSkillsInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    classId?: number | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetUncheckedCreateNestedManyWithoutMobInput
    spells?: MobSpellUncheckedCreateNestedManyWithoutMobInput
    shops?: ShopUncheckedCreateNestedManyWithoutKeeperInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutMobInput
  }

  export type MobCreateOrConnectWithoutSkillsInput = {
    where: MobWhereUniqueInput
    create: XOR<MobCreateWithoutSkillsInput, MobUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutMobSkillsInput = {
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSkills?: CharacterSkillCreateNestedManyWithoutSkillInput
    classSkills?: ClassSkillCreateNestedManyWithoutSkillInput
    raceSkills?: RaceSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutMobSkillsInput = {
    id?: number
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutSkillInput
    classSkills?: ClassSkillUncheckedCreateNestedManyWithoutSkillInput
    raceSkills?: RaceSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutMobSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutMobSkillsInput, SkillUncheckedCreateWithoutMobSkillsInput>
  }

  export type MobUpsertWithoutSkillsInput = {
    update: XOR<MobUpdateWithoutSkillsInput, MobUncheckedUpdateWithoutSkillsInput>
    create: XOR<MobCreateWithoutSkillsInput, MobUncheckedCreateWithoutSkillsInput>
    where?: MobWhereInput
  }

  export type MobUpdateToOneWithWhereWithoutSkillsInput = {
    where?: MobWhereInput
    data: XOR<MobUpdateWithoutSkillsInput, MobUncheckedUpdateWithoutSkillsInput>
  }

  export type MobUpdateWithoutSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUpdateManyWithoutMobNestedInput
    spells?: MobSpellUpdateManyWithoutMobNestedInput
    gameClass?: GameClassUpdateOneWithoutMobsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobsNestedInput
    shops?: ShopUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUpdateManyWithoutMobNestedInput
  }

  export type MobUncheckedUpdateWithoutSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUncheckedUpdateManyWithoutMobNestedInput
    spells?: MobSpellUncheckedUpdateManyWithoutMobNestedInput
    shops?: ShopUncheckedUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutMobNestedInput
  }

  export type SkillUpsertWithoutMobSkillsInput = {
    update: XOR<SkillUpdateWithoutMobSkillsInput, SkillUncheckedUpdateWithoutMobSkillsInput>
    create: XOR<SkillCreateWithoutMobSkillsInput, SkillUncheckedCreateWithoutMobSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutMobSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutMobSkillsInput, SkillUncheckedUpdateWithoutMobSkillsInput>
  }

  export type SkillUpdateWithoutMobSkillsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSkills?: CharacterSkillUpdateManyWithoutSkillNestedInput
    classSkills?: ClassSkillUpdateManyWithoutSkillNestedInput
    raceSkills?: RaceSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutMobSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutSkillNestedInput
    classSkills?: ClassSkillUncheckedUpdateManyWithoutSkillNestedInput
    raceSkills?: RaceSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type MobCreateWithoutSpellsInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetCreateNestedManyWithoutMobInput
    skills?: MobSkillCreateNestedManyWithoutMobInput
    gameClass?: GameClassCreateNestedOneWithoutMobsInput
    zone: ZoneCreateNestedOneWithoutMobsInput
    shops?: ShopCreateNestedManyWithoutKeeperInput
    triggers?: TriggerCreateNestedManyWithoutMobInput
  }

  export type MobUncheckedCreateWithoutSpellsInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    classId?: number | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetUncheckedCreateNestedManyWithoutMobInput
    skills?: MobSkillUncheckedCreateNestedManyWithoutMobInput
    shops?: ShopUncheckedCreateNestedManyWithoutKeeperInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutMobInput
  }

  export type MobCreateOrConnectWithoutSpellsInput = {
    where: MobWhereUniqueInput
    create: XOR<MobCreateWithoutSpellsInput, MobUncheckedCreateWithoutSpellsInput>
  }

  export type SpellCreateWithoutMobSpellsInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleCreateNestedManyWithoutSpellInput
    components?: SpellComponentCreateNestedManyWithoutSpellInput
    effects?: SpellEffectCreateNestedManyWithoutSpellInput
    messages?: SpellMessageCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingCreateNestedOneWithoutSpellInput
    school?: SpellSchoolCreateNestedOneWithoutSpellsInput
  }

  export type SpellUncheckedCreateWithoutMobSpellsInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellUncheckedCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput
    components?: SpellComponentUncheckedCreateNestedManyWithoutSpellInput
    effects?: SpellEffectUncheckedCreateNestedManyWithoutSpellInput
    messages?: SpellMessageUncheckedCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingUncheckedCreateNestedOneWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutMobSpellsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutMobSpellsInput, SpellUncheckedCreateWithoutMobSpellsInput>
  }

  export type MobUpsertWithoutSpellsInput = {
    update: XOR<MobUpdateWithoutSpellsInput, MobUncheckedUpdateWithoutSpellsInput>
    create: XOR<MobCreateWithoutSpellsInput, MobUncheckedCreateWithoutSpellsInput>
    where?: MobWhereInput
  }

  export type MobUpdateToOneWithWhereWithoutSpellsInput = {
    where?: MobWhereInput
    data: XOR<MobUpdateWithoutSpellsInput, MobUncheckedUpdateWithoutSpellsInput>
  }

  export type MobUpdateWithoutSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUpdateManyWithoutMobNestedInput
    skills?: MobSkillUpdateManyWithoutMobNestedInput
    gameClass?: GameClassUpdateOneWithoutMobsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobsNestedInput
    shops?: ShopUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUpdateManyWithoutMobNestedInput
  }

  export type MobUncheckedUpdateWithoutSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUncheckedUpdateManyWithoutMobNestedInput
    skills?: MobSkillUncheckedUpdateManyWithoutMobNestedInput
    shops?: ShopUncheckedUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutMobNestedInput
  }

  export type SpellUpsertWithoutMobSpellsInput = {
    update: XOR<SpellUpdateWithoutMobSpellsInput, SpellUncheckedUpdateWithoutMobSpellsInput>
    create: XOR<SpellCreateWithoutMobSpellsInput, SpellUncheckedCreateWithoutMobSpellsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutMobSpellsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutMobSpellsInput, SpellUncheckedUpdateWithoutMobSpellsInput>
  }

  export type SpellUpdateWithoutMobSpellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUpdateOneWithoutSpellNestedInput
    school?: SpellSchoolUpdateOneWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutMobSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUncheckedUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUncheckedUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUncheckedUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput
  }

  export type MobCarryingCreateWithoutResetInput = {
    id?: string
    max?: number
    name?: string | null
    object: ObjectCreateNestedOneWithoutMobCarryingInput
  }

  export type MobCarryingUncheckedCreateWithoutResetInput = {
    id?: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
  }

  export type MobCarryingCreateOrConnectWithoutResetInput = {
    where: MobCarryingWhereUniqueInput
    create: XOR<MobCarryingCreateWithoutResetInput, MobCarryingUncheckedCreateWithoutResetInput>
  }

  export type MobCarryingCreateManyResetInputEnvelope = {
    data: MobCarryingCreateManyResetInput | MobCarryingCreateManyResetInput[]
    skipDuplicates?: boolean
  }

  export type MobEquipmentSetCreateWithoutMobResetInput = {
    id: string
    probability?: number
    equipmentSet: EquipmentSetCreateNestedOneWithoutMobEquipmentSetsInput
  }

  export type MobEquipmentSetUncheckedCreateWithoutMobResetInput = {
    id: string
    equipmentSetId: string
    probability?: number
  }

  export type MobEquipmentSetCreateOrConnectWithoutMobResetInput = {
    where: MobEquipmentSetWhereUniqueInput
    create: XOR<MobEquipmentSetCreateWithoutMobResetInput, MobEquipmentSetUncheckedCreateWithoutMobResetInput>
  }

  export type MobEquipmentSetCreateManyMobResetInputEnvelope = {
    data: MobEquipmentSetCreateManyMobResetInput | MobEquipmentSetCreateManyMobResetInput[]
    skipDuplicates?: boolean
  }

  export type MobEquippedCreateWithoutResetInput = {
    id?: string
    max?: number
    location: string
    name?: string | null
    object: ObjectCreateNestedOneWithoutMobEquippedInput
  }

  export type MobEquippedUncheckedCreateWithoutResetInput = {
    id?: string
    max?: number
    location: string
    name?: string | null
    objectZoneId: number
    objectId: number
  }

  export type MobEquippedCreateOrConnectWithoutResetInput = {
    where: MobEquippedWhereUniqueInput
    create: XOR<MobEquippedCreateWithoutResetInput, MobEquippedUncheckedCreateWithoutResetInput>
  }

  export type MobEquippedCreateManyResetInputEnvelope = {
    data: MobEquippedCreateManyResetInput | MobEquippedCreateManyResetInput[]
    skipDuplicates?: boolean
  }

  export type MobCreateWithoutResetsInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    skills?: MobSkillCreateNestedManyWithoutMobInput
    spells?: MobSpellCreateNestedManyWithoutMobInput
    gameClass?: GameClassCreateNestedOneWithoutMobsInput
    zone: ZoneCreateNestedOneWithoutMobsInput
    shops?: ShopCreateNestedManyWithoutKeeperInput
    triggers?: TriggerCreateNestedManyWithoutMobInput
  }

  export type MobUncheckedCreateWithoutResetsInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    classId?: number | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    skills?: MobSkillUncheckedCreateNestedManyWithoutMobInput
    spells?: MobSpellUncheckedCreateNestedManyWithoutMobInput
    shops?: ShopUncheckedCreateNestedManyWithoutKeeperInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutMobInput
  }

  export type MobCreateOrConnectWithoutResetsInput = {
    where: MobWhereUniqueInput
    create: XOR<MobCreateWithoutResetsInput, MobUncheckedCreateWithoutResetsInput>
  }

  export type RoomCreateWithoutMobResetsInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    objectResets?: ObjectResetCreateNestedManyWithoutRoomInput
    exits?: RoomExitCreateNestedManyWithoutRoomInput
    extraDescs?: RoomExtraDescriptionCreateNestedManyWithoutRoomInput
    zone: ZoneCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutMobResetsInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutRoomInput
    exits?: RoomExitUncheckedCreateNestedManyWithoutRoomInput
    extraDescs?: RoomExtraDescriptionUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutMobResetsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutMobResetsInput, RoomUncheckedCreateWithoutMobResetsInput>
  }

  export type ZoneCreateWithoutMobResetsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobs?: MobCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetCreateNestedManyWithoutZoneInput
    objects?: ObjectCreateNestedManyWithoutZoneInput
    rooms?: RoomCreateNestedManyWithoutZoneInput
    shops?: ShopCreateNestedManyWithoutZoneInput
    triggers?: TriggerCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutMobResetsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobs?: MobUncheckedCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutZoneInput
    objects?: ObjectUncheckedCreateNestedManyWithoutZoneInput
    rooms?: RoomUncheckedCreateNestedManyWithoutZoneInput
    shops?: ShopUncheckedCreateNestedManyWithoutZoneInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutMobResetsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutMobResetsInput, ZoneUncheckedCreateWithoutMobResetsInput>
  }

  export type SpawnConditionCreateWithoutMobResetInput = {
    id: string
    type: string
    parameters?: JsonNullValueInput | InputJsonValue
    objectReset?: ObjectResetCreateNestedOneWithoutSpawnConditionsInput
  }

  export type SpawnConditionUncheckedCreateWithoutMobResetInput = {
    id: string
    type: string
    parameters?: JsonNullValueInput | InputJsonValue
    objectResetId?: string | null
  }

  export type SpawnConditionCreateOrConnectWithoutMobResetInput = {
    where: SpawnConditionWhereUniqueInput
    create: XOR<SpawnConditionCreateWithoutMobResetInput, SpawnConditionUncheckedCreateWithoutMobResetInput>
  }

  export type SpawnConditionCreateManyMobResetInputEnvelope = {
    data: SpawnConditionCreateManyMobResetInput | SpawnConditionCreateManyMobResetInput[]
    skipDuplicates?: boolean
  }

  export type MobCarryingUpsertWithWhereUniqueWithoutResetInput = {
    where: MobCarryingWhereUniqueInput
    update: XOR<MobCarryingUpdateWithoutResetInput, MobCarryingUncheckedUpdateWithoutResetInput>
    create: XOR<MobCarryingCreateWithoutResetInput, MobCarryingUncheckedCreateWithoutResetInput>
  }

  export type MobCarryingUpdateWithWhereUniqueWithoutResetInput = {
    where: MobCarryingWhereUniqueInput
    data: XOR<MobCarryingUpdateWithoutResetInput, MobCarryingUncheckedUpdateWithoutResetInput>
  }

  export type MobCarryingUpdateManyWithWhereWithoutResetInput = {
    where: MobCarryingScalarWhereInput
    data: XOR<MobCarryingUpdateManyMutationInput, MobCarryingUncheckedUpdateManyWithoutResetInput>
  }

  export type MobCarryingScalarWhereInput = {
    AND?: MobCarryingScalarWhereInput | MobCarryingScalarWhereInput[]
    OR?: MobCarryingScalarWhereInput[]
    NOT?: MobCarryingScalarWhereInput | MobCarryingScalarWhereInput[]
    id?: StringFilter<"MobCarrying"> | string
    max?: IntFilter<"MobCarrying"> | number
    name?: StringNullableFilter<"MobCarrying"> | string | null
    objectZoneId?: IntFilter<"MobCarrying"> | number
    objectId?: IntFilter<"MobCarrying"> | number
    resetId?: StringFilter<"MobCarrying"> | string
  }

  export type MobEquipmentSetUpsertWithWhereUniqueWithoutMobResetInput = {
    where: MobEquipmentSetWhereUniqueInput
    update: XOR<MobEquipmentSetUpdateWithoutMobResetInput, MobEquipmentSetUncheckedUpdateWithoutMobResetInput>
    create: XOR<MobEquipmentSetCreateWithoutMobResetInput, MobEquipmentSetUncheckedCreateWithoutMobResetInput>
  }

  export type MobEquipmentSetUpdateWithWhereUniqueWithoutMobResetInput = {
    where: MobEquipmentSetWhereUniqueInput
    data: XOR<MobEquipmentSetUpdateWithoutMobResetInput, MobEquipmentSetUncheckedUpdateWithoutMobResetInput>
  }

  export type MobEquipmentSetUpdateManyWithWhereWithoutMobResetInput = {
    where: MobEquipmentSetScalarWhereInput
    data: XOR<MobEquipmentSetUpdateManyMutationInput, MobEquipmentSetUncheckedUpdateManyWithoutMobResetInput>
  }

  export type MobEquipmentSetScalarWhereInput = {
    AND?: MobEquipmentSetScalarWhereInput | MobEquipmentSetScalarWhereInput[]
    OR?: MobEquipmentSetScalarWhereInput[]
    NOT?: MobEquipmentSetScalarWhereInput | MobEquipmentSetScalarWhereInput[]
    id?: StringFilter<"MobEquipmentSet"> | string
    mobResetId?: StringFilter<"MobEquipmentSet"> | string
    equipmentSetId?: StringFilter<"MobEquipmentSet"> | string
    probability?: FloatFilter<"MobEquipmentSet"> | number
  }

  export type MobEquippedUpsertWithWhereUniqueWithoutResetInput = {
    where: MobEquippedWhereUniqueInput
    update: XOR<MobEquippedUpdateWithoutResetInput, MobEquippedUncheckedUpdateWithoutResetInput>
    create: XOR<MobEquippedCreateWithoutResetInput, MobEquippedUncheckedCreateWithoutResetInput>
  }

  export type MobEquippedUpdateWithWhereUniqueWithoutResetInput = {
    where: MobEquippedWhereUniqueInput
    data: XOR<MobEquippedUpdateWithoutResetInput, MobEquippedUncheckedUpdateWithoutResetInput>
  }

  export type MobEquippedUpdateManyWithWhereWithoutResetInput = {
    where: MobEquippedScalarWhereInput
    data: XOR<MobEquippedUpdateManyMutationInput, MobEquippedUncheckedUpdateManyWithoutResetInput>
  }

  export type MobEquippedScalarWhereInput = {
    AND?: MobEquippedScalarWhereInput | MobEquippedScalarWhereInput[]
    OR?: MobEquippedScalarWhereInput[]
    NOT?: MobEquippedScalarWhereInput | MobEquippedScalarWhereInput[]
    id?: StringFilter<"MobEquipped"> | string
    max?: IntFilter<"MobEquipped"> | number
    location?: StringFilter<"MobEquipped"> | string
    name?: StringNullableFilter<"MobEquipped"> | string | null
    objectZoneId?: IntFilter<"MobEquipped"> | number
    objectId?: IntFilter<"MobEquipped"> | number
    resetId?: StringFilter<"MobEquipped"> | string
  }

  export type MobUpsertWithoutResetsInput = {
    update: XOR<MobUpdateWithoutResetsInput, MobUncheckedUpdateWithoutResetsInput>
    create: XOR<MobCreateWithoutResetsInput, MobUncheckedCreateWithoutResetsInput>
    where?: MobWhereInput
  }

  export type MobUpdateToOneWithWhereWithoutResetsInput = {
    where?: MobWhereInput
    data: XOR<MobUpdateWithoutResetsInput, MobUncheckedUpdateWithoutResetsInput>
  }

  export type MobUpdateWithoutResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    skills?: MobSkillUpdateManyWithoutMobNestedInput
    spells?: MobSpellUpdateManyWithoutMobNestedInput
    gameClass?: GameClassUpdateOneWithoutMobsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobsNestedInput
    shops?: ShopUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUpdateManyWithoutMobNestedInput
  }

  export type MobUncheckedUpdateWithoutResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    skills?: MobSkillUncheckedUpdateManyWithoutMobNestedInput
    spells?: MobSpellUncheckedUpdateManyWithoutMobNestedInput
    shops?: ShopUncheckedUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutMobNestedInput
  }

  export type RoomUpsertWithoutMobResetsInput = {
    update: XOR<RoomUpdateWithoutMobResetsInput, RoomUncheckedUpdateWithoutMobResetsInput>
    create: XOR<RoomCreateWithoutMobResetsInput, RoomUncheckedCreateWithoutMobResetsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutMobResetsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutMobResetsInput, RoomUncheckedUpdateWithoutMobResetsInput>
  }

  export type RoomUpdateWithoutMobResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    objectResets?: ObjectResetUpdateManyWithoutRoomNestedInput
    exits?: RoomExitUpdateManyWithoutRoomNestedInput
    extraDescs?: RoomExtraDescriptionUpdateManyWithoutRoomNestedInput
    zone?: ZoneUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutMobResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    objectResets?: ObjectResetUncheckedUpdateManyWithoutRoomNestedInput
    exits?: RoomExitUncheckedUpdateManyWithoutRoomNestedInput
    extraDescs?: RoomExtraDescriptionUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ZoneUpsertWithoutMobResetsInput = {
    update: XOR<ZoneUpdateWithoutMobResetsInput, ZoneUncheckedUpdateWithoutMobResetsInput>
    create: XOR<ZoneCreateWithoutMobResetsInput, ZoneUncheckedCreateWithoutMobResetsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutMobResetsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutMobResetsInput, ZoneUncheckedUpdateWithoutMobResetsInput>
  }

  export type ZoneUpdateWithoutMobResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobs?: MobUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUpdateManyWithoutZoneNestedInput
    objects?: ObjectUpdateManyWithoutZoneNestedInput
    rooms?: RoomUpdateManyWithoutZoneNestedInput
    shops?: ShopUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutMobResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobs?: MobUncheckedUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutZoneNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutZoneNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutZoneNestedInput
    shops?: ShopUncheckedUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type SpawnConditionUpsertWithWhereUniqueWithoutMobResetInput = {
    where: SpawnConditionWhereUniqueInput
    update: XOR<SpawnConditionUpdateWithoutMobResetInput, SpawnConditionUncheckedUpdateWithoutMobResetInput>
    create: XOR<SpawnConditionCreateWithoutMobResetInput, SpawnConditionUncheckedCreateWithoutMobResetInput>
  }

  export type SpawnConditionUpdateWithWhereUniqueWithoutMobResetInput = {
    where: SpawnConditionWhereUniqueInput
    data: XOR<SpawnConditionUpdateWithoutMobResetInput, SpawnConditionUncheckedUpdateWithoutMobResetInput>
  }

  export type SpawnConditionUpdateManyWithWhereWithoutMobResetInput = {
    where: SpawnConditionScalarWhereInput
    data: XOR<SpawnConditionUpdateManyMutationInput, SpawnConditionUncheckedUpdateManyWithoutMobResetInput>
  }

  export type SpawnConditionScalarWhereInput = {
    AND?: SpawnConditionScalarWhereInput | SpawnConditionScalarWhereInput[]
    OR?: SpawnConditionScalarWhereInput[]
    NOT?: SpawnConditionScalarWhereInput | SpawnConditionScalarWhereInput[]
    id?: StringFilter<"SpawnCondition"> | string
    type?: StringFilter<"SpawnCondition"> | string
    parameters?: JsonFilter<"SpawnCondition">
    mobResetId?: StringNullableFilter<"SpawnCondition"> | string | null
    objectResetId?: StringNullableFilter<"SpawnCondition"> | string | null
  }

  export type ObjectCreateWithoutMobCarryingInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutMobCarryingInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutMobCarryingInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutMobCarryingInput, ObjectUncheckedCreateWithoutMobCarryingInput>
  }

  export type MobResetCreateWithoutCarryingInput = {
    id?: string
    max?: number
    name?: string | null
    probability?: number
    equipmentSets?: MobEquipmentSetCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedCreateNestedManyWithoutResetInput
    mob: MobCreateNestedOneWithoutResetsInput
    room: RoomCreateNestedOneWithoutMobResetsInput
    zone: ZoneCreateNestedOneWithoutMobResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutMobResetInput
  }

  export type MobResetUncheckedCreateWithoutCarryingInput = {
    id?: string
    max?: number
    name?: string | null
    mobZoneId: number
    mobId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
    equipmentSets?: MobEquipmentSetUncheckedCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedUncheckedCreateNestedManyWithoutResetInput
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutMobResetInput
  }

  export type MobResetCreateOrConnectWithoutCarryingInput = {
    where: MobResetWhereUniqueInput
    create: XOR<MobResetCreateWithoutCarryingInput, MobResetUncheckedCreateWithoutCarryingInput>
  }

  export type ObjectUpsertWithoutMobCarryingInput = {
    update: XOR<ObjectUpdateWithoutMobCarryingInput, ObjectUncheckedUpdateWithoutMobCarryingInput>
    create: XOR<ObjectCreateWithoutMobCarryingInput, ObjectUncheckedCreateWithoutMobCarryingInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutMobCarryingInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutMobCarryingInput, ObjectUncheckedUpdateWithoutMobCarryingInput>
  }

  export type ObjectUpdateWithoutMobCarryingInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutMobCarryingInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type MobResetUpsertWithoutCarryingInput = {
    update: XOR<MobResetUpdateWithoutCarryingInput, MobResetUncheckedUpdateWithoutCarryingInput>
    create: XOR<MobResetCreateWithoutCarryingInput, MobResetUncheckedCreateWithoutCarryingInput>
    where?: MobResetWhereInput
  }

  export type MobResetUpdateToOneWithWhereWithoutCarryingInput = {
    where?: MobResetWhereInput
    data: XOR<MobResetUpdateWithoutCarryingInput, MobResetUncheckedUpdateWithoutCarryingInput>
  }

  export type MobResetUpdateWithoutCarryingInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    equipmentSets?: MobEquipmentSetUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUpdateManyWithoutResetNestedInput
    mob?: MobUpdateOneRequiredWithoutResetsNestedInput
    room?: RoomUpdateOneRequiredWithoutMobResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetUncheckedUpdateWithoutCarryingInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    equipmentSets?: MobEquipmentSetUncheckedUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUncheckedUpdateManyWithoutResetNestedInput
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutMobResetNestedInput
  }

  export type ObjectCreateWithoutMobEquippedInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutMobEquippedInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutMobEquippedInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutMobEquippedInput, ObjectUncheckedCreateWithoutMobEquippedInput>
  }

  export type MobResetCreateWithoutEquippedInput = {
    id?: string
    max?: number
    name?: string | null
    probability?: number
    carrying?: MobCarryingCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetCreateNestedManyWithoutMobResetInput
    mob: MobCreateNestedOneWithoutResetsInput
    room: RoomCreateNestedOneWithoutMobResetsInput
    zone: ZoneCreateNestedOneWithoutMobResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutMobResetInput
  }

  export type MobResetUncheckedCreateWithoutEquippedInput = {
    id?: string
    max?: number
    name?: string | null
    mobZoneId: number
    mobId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
    carrying?: MobCarryingUncheckedCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetUncheckedCreateNestedManyWithoutMobResetInput
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutMobResetInput
  }

  export type MobResetCreateOrConnectWithoutEquippedInput = {
    where: MobResetWhereUniqueInput
    create: XOR<MobResetCreateWithoutEquippedInput, MobResetUncheckedCreateWithoutEquippedInput>
  }

  export type ObjectUpsertWithoutMobEquippedInput = {
    update: XOR<ObjectUpdateWithoutMobEquippedInput, ObjectUncheckedUpdateWithoutMobEquippedInput>
    create: XOR<ObjectCreateWithoutMobEquippedInput, ObjectUncheckedCreateWithoutMobEquippedInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutMobEquippedInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutMobEquippedInput, ObjectUncheckedUpdateWithoutMobEquippedInput>
  }

  export type ObjectUpdateWithoutMobEquippedInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutMobEquippedInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type MobResetUpsertWithoutEquippedInput = {
    update: XOR<MobResetUpdateWithoutEquippedInput, MobResetUncheckedUpdateWithoutEquippedInput>
    create: XOR<MobResetCreateWithoutEquippedInput, MobResetUncheckedCreateWithoutEquippedInput>
    where?: MobResetWhereInput
  }

  export type MobResetUpdateToOneWithWhereWithoutEquippedInput = {
    where?: MobResetWhereInput
    data: XOR<MobResetUpdateWithoutEquippedInput, MobResetUncheckedUpdateWithoutEquippedInput>
  }

  export type MobResetUpdateWithoutEquippedInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUpdateManyWithoutMobResetNestedInput
    mob?: MobUpdateOneRequiredWithoutResetsNestedInput
    room?: RoomUpdateOneRequiredWithoutMobResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetUncheckedUpdateWithoutEquippedInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUncheckedUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUncheckedUpdateManyWithoutMobResetNestedInput
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutMobResetNestedInput
  }

  export type CharacterItemCreateWithoutObjectInput = {
    id?: string
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    character: CharacterCreateNestedOneWithoutItemsInput
    container?: CharacterItemCreateNestedOneWithoutContainedItemsInput
    containedItems?: CharacterItemCreateNestedManyWithoutContainerInput
  }

  export type CharacterItemUncheckedCreateWithoutObjectInput = {
    id?: string
    characterId: string
    containerId?: string | null
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    containedItems?: CharacterItemUncheckedCreateNestedManyWithoutContainerInput
  }

  export type CharacterItemCreateOrConnectWithoutObjectInput = {
    where: CharacterItemWhereUniqueInput
    create: XOR<CharacterItemCreateWithoutObjectInput, CharacterItemUncheckedCreateWithoutObjectInput>
  }

  export type CharacterItemCreateManyObjectInputEnvelope = {
    data: CharacterItemCreateManyObjectInput | CharacterItemCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentSetItemCreateWithoutObjectInput = {
    id: string
    slot?: string | null
    quantity?: number
    probability?: number
    equipmentSet: EquipmentSetCreateNestedOneWithoutItemsInput
  }

  export type EquipmentSetItemUncheckedCreateWithoutObjectInput = {
    id: string
    equipmentSetId: string
    slot?: string | null
    quantity?: number
    probability?: number
  }

  export type EquipmentSetItemCreateOrConnectWithoutObjectInput = {
    where: EquipmentSetItemWhereUniqueInput
    create: XOR<EquipmentSetItemCreateWithoutObjectInput, EquipmentSetItemUncheckedCreateWithoutObjectInput>
  }

  export type EquipmentSetItemCreateManyObjectInputEnvelope = {
    data: EquipmentSetItemCreateManyObjectInput | EquipmentSetItemCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type MobCarryingCreateWithoutObjectInput = {
    id?: string
    max?: number
    name?: string | null
    reset: MobResetCreateNestedOneWithoutCarryingInput
  }

  export type MobCarryingUncheckedCreateWithoutObjectInput = {
    id?: string
    max?: number
    name?: string | null
    resetId: string
  }

  export type MobCarryingCreateOrConnectWithoutObjectInput = {
    where: MobCarryingWhereUniqueInput
    create: XOR<MobCarryingCreateWithoutObjectInput, MobCarryingUncheckedCreateWithoutObjectInput>
  }

  export type MobCarryingCreateManyObjectInputEnvelope = {
    data: MobCarryingCreateManyObjectInput | MobCarryingCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type MobEquippedCreateWithoutObjectInput = {
    id?: string
    max?: number
    location: string
    name?: string | null
    reset: MobResetCreateNestedOneWithoutEquippedInput
  }

  export type MobEquippedUncheckedCreateWithoutObjectInput = {
    id?: string
    max?: number
    location: string
    name?: string | null
    resetId: string
  }

  export type MobEquippedCreateOrConnectWithoutObjectInput = {
    where: MobEquippedWhereUniqueInput
    create: XOR<MobEquippedCreateWithoutObjectInput, MobEquippedUncheckedCreateWithoutObjectInput>
  }

  export type MobEquippedCreateManyObjectInputEnvelope = {
    data: MobEquippedCreateManyObjectInput | MobEquippedCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type ObjectAffectCreateWithoutObjectInput = {
    id?: string
    location: string
    modifier: number
  }

  export type ObjectAffectUncheckedCreateWithoutObjectInput = {
    id?: string
    location: string
    modifier: number
  }

  export type ObjectAffectCreateOrConnectWithoutObjectInput = {
    where: ObjectAffectWhereUniqueInput
    create: XOR<ObjectAffectCreateWithoutObjectInput, ObjectAffectUncheckedCreateWithoutObjectInput>
  }

  export type ObjectAffectCreateManyObjectInputEnvelope = {
    data: ObjectAffectCreateManyObjectInput | ObjectAffectCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type ObjectExtraDescriptionCreateWithoutObjectInput = {
    id?: string
    keyword: string
    description: string
  }

  export type ObjectExtraDescriptionUncheckedCreateWithoutObjectInput = {
    id?: string
    keyword: string
    description: string
  }

  export type ObjectExtraDescriptionCreateOrConnectWithoutObjectInput = {
    where: ObjectExtraDescriptionWhereUniqueInput
    create: XOR<ObjectExtraDescriptionCreateWithoutObjectInput, ObjectExtraDescriptionUncheckedCreateWithoutObjectInput>
  }

  export type ObjectExtraDescriptionCreateManyObjectInputEnvelope = {
    data: ObjectExtraDescriptionCreateManyObjectInput | ObjectExtraDescriptionCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type ObjectResetCreateWithoutObjectInput = {
    id: string
    max?: number
    name?: string | null
    probability?: number
    room: RoomCreateNestedOneWithoutObjectResetsInput
    zone: ZoneCreateNestedOneWithoutObjectResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutObjectResetInput
  }

  export type ObjectResetUncheckedCreateWithoutObjectInput = {
    id: string
    max?: number
    name?: string | null
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutObjectResetInput
  }

  export type ObjectResetCreateOrConnectWithoutObjectInput = {
    where: ObjectResetWhereUniqueInput
    create: XOR<ObjectResetCreateWithoutObjectInput, ObjectResetUncheckedCreateWithoutObjectInput>
  }

  export type ObjectResetCreateManyObjectInputEnvelope = {
    data: ObjectResetCreateManyObjectInput | ObjectResetCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type ObjectSpellCreateWithoutObjectInput = {
    id?: string
    spell: string
    level?: number
  }

  export type ObjectSpellUncheckedCreateWithoutObjectInput = {
    id?: string
    spell: string
    level?: number
  }

  export type ObjectSpellCreateOrConnectWithoutObjectInput = {
    where: ObjectSpellWhereUniqueInput
    create: XOR<ObjectSpellCreateWithoutObjectInput, ObjectSpellUncheckedCreateWithoutObjectInput>
  }

  export type ObjectSpellCreateManyObjectInputEnvelope = {
    data: ObjectSpellCreateManyObjectInput | ObjectSpellCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type ZoneCreateWithoutObjectsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetCreateNestedManyWithoutZoneInput
    mobs?: MobCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetCreateNestedManyWithoutZoneInput
    rooms?: RoomCreateNestedManyWithoutZoneInput
    shops?: ShopCreateNestedManyWithoutZoneInput
    triggers?: TriggerCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutObjectsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutZoneInput
    mobs?: MobUncheckedCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutZoneInput
    rooms?: RoomUncheckedCreateNestedManyWithoutZoneInput
    shops?: ShopUncheckedCreateNestedManyWithoutZoneInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutObjectsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutObjectsInput, ZoneUncheckedCreateWithoutObjectsInput>
  }

  export type ShopItemCreateWithoutObjectInput = {
    id?: string
    amount?: number
    shop: ShopCreateNestedOneWithoutItemsInput
  }

  export type ShopItemUncheckedCreateWithoutObjectInput = {
    id?: string
    amount?: number
    shopZoneId: number
    shopId: number
  }

  export type ShopItemCreateOrConnectWithoutObjectInput = {
    where: ShopItemWhereUniqueInput
    create: XOR<ShopItemCreateWithoutObjectInput, ShopItemUncheckedCreateWithoutObjectInput>
  }

  export type ShopItemCreateManyObjectInputEnvelope = {
    data: ShopItemCreateManyObjectInput | ShopItemCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type TriggerCreateWithoutObjectInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
    mob?: MobCreateNestedOneWithoutTriggersInput
    zone?: ZoneCreateNestedOneWithoutTriggersInput
  }

  export type TriggerUncheckedCreateWithoutObjectInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    zoneId?: number | null
    mobZoneId?: number | null
    mobId?: number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
  }

  export type TriggerCreateOrConnectWithoutObjectInput = {
    where: TriggerWhereUniqueInput
    create: XOR<TriggerCreateWithoutObjectInput, TriggerUncheckedCreateWithoutObjectInput>
  }

  export type TriggerCreateManyObjectInputEnvelope = {
    data: TriggerCreateManyObjectInput | TriggerCreateManyObjectInput[]
    skipDuplicates?: boolean
  }

  export type CharacterItemUpsertWithWhereUniqueWithoutObjectInput = {
    where: CharacterItemWhereUniqueInput
    update: XOR<CharacterItemUpdateWithoutObjectInput, CharacterItemUncheckedUpdateWithoutObjectInput>
    create: XOR<CharacterItemCreateWithoutObjectInput, CharacterItemUncheckedCreateWithoutObjectInput>
  }

  export type CharacterItemUpdateWithWhereUniqueWithoutObjectInput = {
    where: CharacterItemWhereUniqueInput
    data: XOR<CharacterItemUpdateWithoutObjectInput, CharacterItemUncheckedUpdateWithoutObjectInput>
  }

  export type CharacterItemUpdateManyWithWhereWithoutObjectInput = {
    where: CharacterItemScalarWhereInput
    data: XOR<CharacterItemUpdateManyMutationInput, CharacterItemUncheckedUpdateManyWithoutObjectInput>
  }

  export type EquipmentSetItemUpsertWithWhereUniqueWithoutObjectInput = {
    where: EquipmentSetItemWhereUniqueInput
    update: XOR<EquipmentSetItemUpdateWithoutObjectInput, EquipmentSetItemUncheckedUpdateWithoutObjectInput>
    create: XOR<EquipmentSetItemCreateWithoutObjectInput, EquipmentSetItemUncheckedCreateWithoutObjectInput>
  }

  export type EquipmentSetItemUpdateWithWhereUniqueWithoutObjectInput = {
    where: EquipmentSetItemWhereUniqueInput
    data: XOR<EquipmentSetItemUpdateWithoutObjectInput, EquipmentSetItemUncheckedUpdateWithoutObjectInput>
  }

  export type EquipmentSetItemUpdateManyWithWhereWithoutObjectInput = {
    where: EquipmentSetItemScalarWhereInput
    data: XOR<EquipmentSetItemUpdateManyMutationInput, EquipmentSetItemUncheckedUpdateManyWithoutObjectInput>
  }

  export type EquipmentSetItemScalarWhereInput = {
    AND?: EquipmentSetItemScalarWhereInput | EquipmentSetItemScalarWhereInput[]
    OR?: EquipmentSetItemScalarWhereInput[]
    NOT?: EquipmentSetItemScalarWhereInput | EquipmentSetItemScalarWhereInput[]
    id?: StringFilter<"EquipmentSetItem"> | string
    equipmentSetId?: StringFilter<"EquipmentSetItem"> | string
    objectZoneId?: IntFilter<"EquipmentSetItem"> | number
    objectId?: IntFilter<"EquipmentSetItem"> | number
    slot?: StringNullableFilter<"EquipmentSetItem"> | string | null
    quantity?: IntFilter<"EquipmentSetItem"> | number
    probability?: FloatFilter<"EquipmentSetItem"> | number
  }

  export type MobCarryingUpsertWithWhereUniqueWithoutObjectInput = {
    where: MobCarryingWhereUniqueInput
    update: XOR<MobCarryingUpdateWithoutObjectInput, MobCarryingUncheckedUpdateWithoutObjectInput>
    create: XOR<MobCarryingCreateWithoutObjectInput, MobCarryingUncheckedCreateWithoutObjectInput>
  }

  export type MobCarryingUpdateWithWhereUniqueWithoutObjectInput = {
    where: MobCarryingWhereUniqueInput
    data: XOR<MobCarryingUpdateWithoutObjectInput, MobCarryingUncheckedUpdateWithoutObjectInput>
  }

  export type MobCarryingUpdateManyWithWhereWithoutObjectInput = {
    where: MobCarryingScalarWhereInput
    data: XOR<MobCarryingUpdateManyMutationInput, MobCarryingUncheckedUpdateManyWithoutObjectInput>
  }

  export type MobEquippedUpsertWithWhereUniqueWithoutObjectInput = {
    where: MobEquippedWhereUniqueInput
    update: XOR<MobEquippedUpdateWithoutObjectInput, MobEquippedUncheckedUpdateWithoutObjectInput>
    create: XOR<MobEquippedCreateWithoutObjectInput, MobEquippedUncheckedCreateWithoutObjectInput>
  }

  export type MobEquippedUpdateWithWhereUniqueWithoutObjectInput = {
    where: MobEquippedWhereUniqueInput
    data: XOR<MobEquippedUpdateWithoutObjectInput, MobEquippedUncheckedUpdateWithoutObjectInput>
  }

  export type MobEquippedUpdateManyWithWhereWithoutObjectInput = {
    where: MobEquippedScalarWhereInput
    data: XOR<MobEquippedUpdateManyMutationInput, MobEquippedUncheckedUpdateManyWithoutObjectInput>
  }

  export type ObjectAffectUpsertWithWhereUniqueWithoutObjectInput = {
    where: ObjectAffectWhereUniqueInput
    update: XOR<ObjectAffectUpdateWithoutObjectInput, ObjectAffectUncheckedUpdateWithoutObjectInput>
    create: XOR<ObjectAffectCreateWithoutObjectInput, ObjectAffectUncheckedCreateWithoutObjectInput>
  }

  export type ObjectAffectUpdateWithWhereUniqueWithoutObjectInput = {
    where: ObjectAffectWhereUniqueInput
    data: XOR<ObjectAffectUpdateWithoutObjectInput, ObjectAffectUncheckedUpdateWithoutObjectInput>
  }

  export type ObjectAffectUpdateManyWithWhereWithoutObjectInput = {
    where: ObjectAffectScalarWhereInput
    data: XOR<ObjectAffectUpdateManyMutationInput, ObjectAffectUncheckedUpdateManyWithoutObjectInput>
  }

  export type ObjectAffectScalarWhereInput = {
    AND?: ObjectAffectScalarWhereInput | ObjectAffectScalarWhereInput[]
    OR?: ObjectAffectScalarWhereInput[]
    NOT?: ObjectAffectScalarWhereInput | ObjectAffectScalarWhereInput[]
    id?: StringFilter<"ObjectAffect"> | string
    location?: StringFilter<"ObjectAffect"> | string
    modifier?: IntFilter<"ObjectAffect"> | number
    objectZoneId?: IntFilter<"ObjectAffect"> | number
    objectId?: IntFilter<"ObjectAffect"> | number
  }

  export type ObjectExtraDescriptionUpsertWithWhereUniqueWithoutObjectInput = {
    where: ObjectExtraDescriptionWhereUniqueInput
    update: XOR<ObjectExtraDescriptionUpdateWithoutObjectInput, ObjectExtraDescriptionUncheckedUpdateWithoutObjectInput>
    create: XOR<ObjectExtraDescriptionCreateWithoutObjectInput, ObjectExtraDescriptionUncheckedCreateWithoutObjectInput>
  }

  export type ObjectExtraDescriptionUpdateWithWhereUniqueWithoutObjectInput = {
    where: ObjectExtraDescriptionWhereUniqueInput
    data: XOR<ObjectExtraDescriptionUpdateWithoutObjectInput, ObjectExtraDescriptionUncheckedUpdateWithoutObjectInput>
  }

  export type ObjectExtraDescriptionUpdateManyWithWhereWithoutObjectInput = {
    where: ObjectExtraDescriptionScalarWhereInput
    data: XOR<ObjectExtraDescriptionUpdateManyMutationInput, ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectInput>
  }

  export type ObjectExtraDescriptionScalarWhereInput = {
    AND?: ObjectExtraDescriptionScalarWhereInput | ObjectExtraDescriptionScalarWhereInput[]
    OR?: ObjectExtraDescriptionScalarWhereInput[]
    NOT?: ObjectExtraDescriptionScalarWhereInput | ObjectExtraDescriptionScalarWhereInput[]
    id?: StringFilter<"ObjectExtraDescription"> | string
    keyword?: StringFilter<"ObjectExtraDescription"> | string
    description?: StringFilter<"ObjectExtraDescription"> | string
    objectZoneId?: IntFilter<"ObjectExtraDescription"> | number
    objectId?: IntFilter<"ObjectExtraDescription"> | number
  }

  export type ObjectResetUpsertWithWhereUniqueWithoutObjectInput = {
    where: ObjectResetWhereUniqueInput
    update: XOR<ObjectResetUpdateWithoutObjectInput, ObjectResetUncheckedUpdateWithoutObjectInput>
    create: XOR<ObjectResetCreateWithoutObjectInput, ObjectResetUncheckedCreateWithoutObjectInput>
  }

  export type ObjectResetUpdateWithWhereUniqueWithoutObjectInput = {
    where: ObjectResetWhereUniqueInput
    data: XOR<ObjectResetUpdateWithoutObjectInput, ObjectResetUncheckedUpdateWithoutObjectInput>
  }

  export type ObjectResetUpdateManyWithWhereWithoutObjectInput = {
    where: ObjectResetScalarWhereInput
    data: XOR<ObjectResetUpdateManyMutationInput, ObjectResetUncheckedUpdateManyWithoutObjectInput>
  }

  export type ObjectSpellUpsertWithWhereUniqueWithoutObjectInput = {
    where: ObjectSpellWhereUniqueInput
    update: XOR<ObjectSpellUpdateWithoutObjectInput, ObjectSpellUncheckedUpdateWithoutObjectInput>
    create: XOR<ObjectSpellCreateWithoutObjectInput, ObjectSpellUncheckedCreateWithoutObjectInput>
  }

  export type ObjectSpellUpdateWithWhereUniqueWithoutObjectInput = {
    where: ObjectSpellWhereUniqueInput
    data: XOR<ObjectSpellUpdateWithoutObjectInput, ObjectSpellUncheckedUpdateWithoutObjectInput>
  }

  export type ObjectSpellUpdateManyWithWhereWithoutObjectInput = {
    where: ObjectSpellScalarWhereInput
    data: XOR<ObjectSpellUpdateManyMutationInput, ObjectSpellUncheckedUpdateManyWithoutObjectInput>
  }

  export type ObjectSpellScalarWhereInput = {
    AND?: ObjectSpellScalarWhereInput | ObjectSpellScalarWhereInput[]
    OR?: ObjectSpellScalarWhereInput[]
    NOT?: ObjectSpellScalarWhereInput | ObjectSpellScalarWhereInput[]
    id?: StringFilter<"ObjectSpell"> | string
    spell?: StringFilter<"ObjectSpell"> | string
    level?: IntFilter<"ObjectSpell"> | number
    objectZoneId?: IntFilter<"ObjectSpell"> | number
    objectId?: IntFilter<"ObjectSpell"> | number
  }

  export type ZoneUpsertWithoutObjectsInput = {
    update: XOR<ZoneUpdateWithoutObjectsInput, ZoneUncheckedUpdateWithoutObjectsInput>
    create: XOR<ZoneCreateWithoutObjectsInput, ZoneUncheckedCreateWithoutObjectsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutObjectsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutObjectsInput, ZoneUncheckedUpdateWithoutObjectsInput>
  }

  export type ZoneUpdateWithoutObjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUpdateManyWithoutZoneNestedInput
    mobs?: MobUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUpdateManyWithoutZoneNestedInput
    rooms?: RoomUpdateManyWithoutZoneNestedInput
    shops?: ShopUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutObjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUncheckedUpdateManyWithoutZoneNestedInput
    mobs?: MobUncheckedUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutZoneNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutZoneNestedInput
    shops?: ShopUncheckedUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ShopItemUpsertWithWhereUniqueWithoutObjectInput = {
    where: ShopItemWhereUniqueInput
    update: XOR<ShopItemUpdateWithoutObjectInput, ShopItemUncheckedUpdateWithoutObjectInput>
    create: XOR<ShopItemCreateWithoutObjectInput, ShopItemUncheckedCreateWithoutObjectInput>
  }

  export type ShopItemUpdateWithWhereUniqueWithoutObjectInput = {
    where: ShopItemWhereUniqueInput
    data: XOR<ShopItemUpdateWithoutObjectInput, ShopItemUncheckedUpdateWithoutObjectInput>
  }

  export type ShopItemUpdateManyWithWhereWithoutObjectInput = {
    where: ShopItemScalarWhereInput
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyWithoutObjectInput>
  }

  export type ShopItemScalarWhereInput = {
    AND?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
    OR?: ShopItemScalarWhereInput[]
    NOT?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
    id?: StringFilter<"ShopItem"> | string
    amount?: IntFilter<"ShopItem"> | number
    shopZoneId?: IntFilter<"ShopItem"> | number
    shopId?: IntFilter<"ShopItem"> | number
    objectZoneId?: IntFilter<"ShopItem"> | number
    objectId?: IntFilter<"ShopItem"> | number
  }

  export type TriggerUpsertWithWhereUniqueWithoutObjectInput = {
    where: TriggerWhereUniqueInput
    update: XOR<TriggerUpdateWithoutObjectInput, TriggerUncheckedUpdateWithoutObjectInput>
    create: XOR<TriggerCreateWithoutObjectInput, TriggerUncheckedCreateWithoutObjectInput>
  }

  export type TriggerUpdateWithWhereUniqueWithoutObjectInput = {
    where: TriggerWhereUniqueInput
    data: XOR<TriggerUpdateWithoutObjectInput, TriggerUncheckedUpdateWithoutObjectInput>
  }

  export type TriggerUpdateManyWithWhereWithoutObjectInput = {
    where: TriggerScalarWhereInput
    data: XOR<TriggerUpdateManyMutationInput, TriggerUncheckedUpdateManyWithoutObjectInput>
  }

  export type ObjectCreateWithoutExtraDescsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutExtraDescsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutExtraDescsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutExtraDescsInput, ObjectUncheckedCreateWithoutExtraDescsInput>
  }

  export type ObjectUpsertWithoutExtraDescsInput = {
    update: XOR<ObjectUpdateWithoutExtraDescsInput, ObjectUncheckedUpdateWithoutExtraDescsInput>
    create: XOR<ObjectCreateWithoutExtraDescsInput, ObjectUncheckedCreateWithoutExtraDescsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutExtraDescsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutExtraDescsInput, ObjectUncheckedUpdateWithoutExtraDescsInput>
  }

  export type ObjectUpdateWithoutExtraDescsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutExtraDescsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ObjectCreateWithoutAffectsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutAffectsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutAffectsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutAffectsInput, ObjectUncheckedCreateWithoutAffectsInput>
  }

  export type ObjectUpsertWithoutAffectsInput = {
    update: XOR<ObjectUpdateWithoutAffectsInput, ObjectUncheckedUpdateWithoutAffectsInput>
    create: XOR<ObjectCreateWithoutAffectsInput, ObjectUncheckedCreateWithoutAffectsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutAffectsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutAffectsInput, ObjectUncheckedUpdateWithoutAffectsInput>
  }

  export type ObjectUpdateWithoutAffectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutAffectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ObjectCreateWithoutSpellsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutSpellsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutSpellsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutSpellsInput, ObjectUncheckedCreateWithoutSpellsInput>
  }

  export type ObjectUpsertWithoutSpellsInput = {
    update: XOR<ObjectUpdateWithoutSpellsInput, ObjectUncheckedUpdateWithoutSpellsInput>
    create: XOR<ObjectCreateWithoutSpellsInput, ObjectUncheckedCreateWithoutSpellsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutSpellsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutSpellsInput, ObjectUncheckedUpdateWithoutSpellsInput>
  }

  export type ObjectUpdateWithoutSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ShopAcceptCreateWithoutShopInput = {
    id?: string
    type: string
    keywords?: ShopAcceptCreatekeywordsInput | string[]
  }

  export type ShopAcceptUncheckedCreateWithoutShopInput = {
    id?: string
    type: string
    keywords?: ShopAcceptCreatekeywordsInput | string[]
  }

  export type ShopAcceptCreateOrConnectWithoutShopInput = {
    where: ShopAcceptWhereUniqueInput
    create: XOR<ShopAcceptCreateWithoutShopInput, ShopAcceptUncheckedCreateWithoutShopInput>
  }

  export type ShopAcceptCreateManyShopInputEnvelope = {
    data: ShopAcceptCreateManyShopInput | ShopAcceptCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type ShopHourCreateWithoutShopInput = {
    id?: string
    open: number
    close: number
  }

  export type ShopHourUncheckedCreateWithoutShopInput = {
    id?: string
    open: number
    close: number
  }

  export type ShopHourCreateOrConnectWithoutShopInput = {
    where: ShopHourWhereUniqueInput
    create: XOR<ShopHourCreateWithoutShopInput, ShopHourUncheckedCreateWithoutShopInput>
  }

  export type ShopHourCreateManyShopInputEnvelope = {
    data: ShopHourCreateManyShopInput | ShopHourCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type ShopItemCreateWithoutShopInput = {
    id?: string
    amount?: number
    object: ObjectCreateNestedOneWithoutShopItemsInput
  }

  export type ShopItemUncheckedCreateWithoutShopInput = {
    id?: string
    amount?: number
    objectZoneId: number
    objectId: number
  }

  export type ShopItemCreateOrConnectWithoutShopInput = {
    where: ShopItemWhereUniqueInput
    create: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput>
  }

  export type ShopItemCreateManyShopInputEnvelope = {
    data: ShopItemCreateManyShopInput | ShopItemCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type ShopRoomCreateWithoutShopInput = {
    id?: string
    roomId: number
  }

  export type ShopRoomUncheckedCreateWithoutShopInput = {
    id?: string
    roomId: number
  }

  export type ShopRoomCreateOrConnectWithoutShopInput = {
    where: ShopRoomWhereUniqueInput
    create: XOR<ShopRoomCreateWithoutShopInput, ShopRoomUncheckedCreateWithoutShopInput>
  }

  export type ShopRoomCreateManyShopInputEnvelope = {
    data: ShopRoomCreateManyShopInput | ShopRoomCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type MobCreateWithoutShopsInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetCreateNestedManyWithoutMobInput
    skills?: MobSkillCreateNestedManyWithoutMobInput
    spells?: MobSpellCreateNestedManyWithoutMobInput
    gameClass?: GameClassCreateNestedOneWithoutMobsInput
    zone: ZoneCreateNestedOneWithoutMobsInput
    triggers?: TriggerCreateNestedManyWithoutMobInput
  }

  export type MobUncheckedCreateWithoutShopsInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    classId?: number | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetUncheckedCreateNestedManyWithoutMobInput
    skills?: MobSkillUncheckedCreateNestedManyWithoutMobInput
    spells?: MobSpellUncheckedCreateNestedManyWithoutMobInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutMobInput
  }

  export type MobCreateOrConnectWithoutShopsInput = {
    where: MobWhereUniqueInput
    create: XOR<MobCreateWithoutShopsInput, MobUncheckedCreateWithoutShopsInput>
  }

  export type ZoneCreateWithoutShopsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetCreateNestedManyWithoutZoneInput
    mobs?: MobCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetCreateNestedManyWithoutZoneInput
    objects?: ObjectCreateNestedManyWithoutZoneInput
    rooms?: RoomCreateNestedManyWithoutZoneInput
    triggers?: TriggerCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutShopsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutZoneInput
    mobs?: MobUncheckedCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutZoneInput
    objects?: ObjectUncheckedCreateNestedManyWithoutZoneInput
    rooms?: RoomUncheckedCreateNestedManyWithoutZoneInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutShopsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutShopsInput, ZoneUncheckedCreateWithoutShopsInput>
  }

  export type ShopAcceptUpsertWithWhereUniqueWithoutShopInput = {
    where: ShopAcceptWhereUniqueInput
    update: XOR<ShopAcceptUpdateWithoutShopInput, ShopAcceptUncheckedUpdateWithoutShopInput>
    create: XOR<ShopAcceptCreateWithoutShopInput, ShopAcceptUncheckedCreateWithoutShopInput>
  }

  export type ShopAcceptUpdateWithWhereUniqueWithoutShopInput = {
    where: ShopAcceptWhereUniqueInput
    data: XOR<ShopAcceptUpdateWithoutShopInput, ShopAcceptUncheckedUpdateWithoutShopInput>
  }

  export type ShopAcceptUpdateManyWithWhereWithoutShopInput = {
    where: ShopAcceptScalarWhereInput
    data: XOR<ShopAcceptUpdateManyMutationInput, ShopAcceptUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopAcceptScalarWhereInput = {
    AND?: ShopAcceptScalarWhereInput | ShopAcceptScalarWhereInput[]
    OR?: ShopAcceptScalarWhereInput[]
    NOT?: ShopAcceptScalarWhereInput | ShopAcceptScalarWhereInput[]
    id?: StringFilter<"ShopAccept"> | string
    type?: StringFilter<"ShopAccept"> | string
    keywords?: StringNullableListFilter<"ShopAccept">
    shopZoneId?: IntFilter<"ShopAccept"> | number
    shopId?: IntFilter<"ShopAccept"> | number
  }

  export type ShopHourUpsertWithWhereUniqueWithoutShopInput = {
    where: ShopHourWhereUniqueInput
    update: XOR<ShopHourUpdateWithoutShopInput, ShopHourUncheckedUpdateWithoutShopInput>
    create: XOR<ShopHourCreateWithoutShopInput, ShopHourUncheckedCreateWithoutShopInput>
  }

  export type ShopHourUpdateWithWhereUniqueWithoutShopInput = {
    where: ShopHourWhereUniqueInput
    data: XOR<ShopHourUpdateWithoutShopInput, ShopHourUncheckedUpdateWithoutShopInput>
  }

  export type ShopHourUpdateManyWithWhereWithoutShopInput = {
    where: ShopHourScalarWhereInput
    data: XOR<ShopHourUpdateManyMutationInput, ShopHourUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopHourScalarWhereInput = {
    AND?: ShopHourScalarWhereInput | ShopHourScalarWhereInput[]
    OR?: ShopHourScalarWhereInput[]
    NOT?: ShopHourScalarWhereInput | ShopHourScalarWhereInput[]
    id?: StringFilter<"ShopHour"> | string
    open?: IntFilter<"ShopHour"> | number
    close?: IntFilter<"ShopHour"> | number
    shopZoneId?: IntFilter<"ShopHour"> | number
    shopId?: IntFilter<"ShopHour"> | number
  }

  export type ShopItemUpsertWithWhereUniqueWithoutShopInput = {
    where: ShopItemWhereUniqueInput
    update: XOR<ShopItemUpdateWithoutShopInput, ShopItemUncheckedUpdateWithoutShopInput>
    create: XOR<ShopItemCreateWithoutShopInput, ShopItemUncheckedCreateWithoutShopInput>
  }

  export type ShopItemUpdateWithWhereUniqueWithoutShopInput = {
    where: ShopItemWhereUniqueInput
    data: XOR<ShopItemUpdateWithoutShopInput, ShopItemUncheckedUpdateWithoutShopInput>
  }

  export type ShopItemUpdateManyWithWhereWithoutShopInput = {
    where: ShopItemScalarWhereInput
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopRoomUpsertWithWhereUniqueWithoutShopInput = {
    where: ShopRoomWhereUniqueInput
    update: XOR<ShopRoomUpdateWithoutShopInput, ShopRoomUncheckedUpdateWithoutShopInput>
    create: XOR<ShopRoomCreateWithoutShopInput, ShopRoomUncheckedCreateWithoutShopInput>
  }

  export type ShopRoomUpdateWithWhereUniqueWithoutShopInput = {
    where: ShopRoomWhereUniqueInput
    data: XOR<ShopRoomUpdateWithoutShopInput, ShopRoomUncheckedUpdateWithoutShopInput>
  }

  export type ShopRoomUpdateManyWithWhereWithoutShopInput = {
    where: ShopRoomScalarWhereInput
    data: XOR<ShopRoomUpdateManyMutationInput, ShopRoomUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopRoomScalarWhereInput = {
    AND?: ShopRoomScalarWhereInput | ShopRoomScalarWhereInput[]
    OR?: ShopRoomScalarWhereInput[]
    NOT?: ShopRoomScalarWhereInput | ShopRoomScalarWhereInput[]
    id?: StringFilter<"ShopRoom"> | string
    roomId?: IntFilter<"ShopRoom"> | number
    shopZoneId?: IntFilter<"ShopRoom"> | number
    shopId?: IntFilter<"ShopRoom"> | number
  }

  export type MobUpsertWithoutShopsInput = {
    update: XOR<MobUpdateWithoutShopsInput, MobUncheckedUpdateWithoutShopsInput>
    create: XOR<MobCreateWithoutShopsInput, MobUncheckedCreateWithoutShopsInput>
    where?: MobWhereInput
  }

  export type MobUpdateToOneWithWhereWithoutShopsInput = {
    where?: MobWhereInput
    data: XOR<MobUpdateWithoutShopsInput, MobUncheckedUpdateWithoutShopsInput>
  }

  export type MobUpdateWithoutShopsInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUpdateManyWithoutMobNestedInput
    skills?: MobSkillUpdateManyWithoutMobNestedInput
    spells?: MobSpellUpdateManyWithoutMobNestedInput
    gameClass?: GameClassUpdateOneWithoutMobsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobsNestedInput
    triggers?: TriggerUpdateManyWithoutMobNestedInput
  }

  export type MobUncheckedUpdateWithoutShopsInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUncheckedUpdateManyWithoutMobNestedInput
    skills?: MobSkillUncheckedUpdateManyWithoutMobNestedInput
    spells?: MobSpellUncheckedUpdateManyWithoutMobNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutMobNestedInput
  }

  export type ZoneUpsertWithoutShopsInput = {
    update: XOR<ZoneUpdateWithoutShopsInput, ZoneUncheckedUpdateWithoutShopsInput>
    create: XOR<ZoneCreateWithoutShopsInput, ZoneUncheckedCreateWithoutShopsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutShopsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutShopsInput, ZoneUncheckedUpdateWithoutShopsInput>
  }

  export type ZoneUpdateWithoutShopsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUpdateManyWithoutZoneNestedInput
    mobs?: MobUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUpdateManyWithoutZoneNestedInput
    objects?: ObjectUpdateManyWithoutZoneNestedInput
    rooms?: RoomUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutShopsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUncheckedUpdateManyWithoutZoneNestedInput
    mobs?: MobUncheckedUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutZoneNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutZoneNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ObjectCreateWithoutShopItemsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutShopItemsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutShopItemsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutShopItemsInput, ObjectUncheckedCreateWithoutShopItemsInput>
  }

  export type ShopCreateWithoutItemsInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptCreateNestedManyWithoutShopInput
    hours?: ShopHourCreateNestedManyWithoutShopInput
    rooms?: ShopRoomCreateNestedManyWithoutShopInput
    keeper?: MobCreateNestedOneWithoutShopsInput
    zone: ZoneCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateWithoutItemsInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    keeperZoneId?: number | null
    keeperId?: number | null
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedCreateNestedManyWithoutShopInput
    hours?: ShopHourUncheckedCreateNestedManyWithoutShopInput
    rooms?: ShopRoomUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutItemsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutItemsInput, ShopUncheckedCreateWithoutItemsInput>
  }

  export type ObjectUpsertWithoutShopItemsInput = {
    update: XOR<ObjectUpdateWithoutShopItemsInput, ObjectUncheckedUpdateWithoutShopItemsInput>
    create: XOR<ObjectCreateWithoutShopItemsInput, ObjectUncheckedCreateWithoutShopItemsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutShopItemsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutShopItemsInput, ObjectUncheckedUpdateWithoutShopItemsInput>
  }

  export type ObjectUpdateWithoutShopItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutShopItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ShopUpsertWithoutItemsInput = {
    update: XOR<ShopUpdateWithoutItemsInput, ShopUncheckedUpdateWithoutItemsInput>
    create: XOR<ShopCreateWithoutItemsInput, ShopUncheckedCreateWithoutItemsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutItemsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutItemsInput, ShopUncheckedUpdateWithoutItemsInput>
  }

  export type ShopUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUpdateManyWithoutShopNestedInput
    hours?: ShopHourUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUpdateManyWithoutShopNestedInput
    keeper?: MobUpdateOneWithoutShopsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    keeperZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    keeperId?: NullableIntFieldUpdateOperationsInput | number | null
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedUpdateManyWithoutShopNestedInput
    hours?: ShopHourUncheckedUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateWithoutAcceptsInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    hours?: ShopHourCreateNestedManyWithoutShopInput
    items?: ShopItemCreateNestedManyWithoutShopInput
    rooms?: ShopRoomCreateNestedManyWithoutShopInput
    keeper?: MobCreateNestedOneWithoutShopsInput
    zone: ZoneCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateWithoutAcceptsInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    keeperZoneId?: number | null
    keeperId?: number | null
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    hours?: ShopHourUncheckedCreateNestedManyWithoutShopInput
    items?: ShopItemUncheckedCreateNestedManyWithoutShopInput
    rooms?: ShopRoomUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutAcceptsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutAcceptsInput, ShopUncheckedCreateWithoutAcceptsInput>
  }

  export type ShopUpsertWithoutAcceptsInput = {
    update: XOR<ShopUpdateWithoutAcceptsInput, ShopUncheckedUpdateWithoutAcceptsInput>
    create: XOR<ShopCreateWithoutAcceptsInput, ShopUncheckedCreateWithoutAcceptsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutAcceptsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutAcceptsInput, ShopUncheckedUpdateWithoutAcceptsInput>
  }

  export type ShopUpdateWithoutAcceptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    hours?: ShopHourUpdateManyWithoutShopNestedInput
    items?: ShopItemUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUpdateManyWithoutShopNestedInput
    keeper?: MobUpdateOneWithoutShopsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateWithoutAcceptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    keeperZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    keeperId?: NullableIntFieldUpdateOperationsInput | number | null
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    hours?: ShopHourUncheckedUpdateManyWithoutShopNestedInput
    items?: ShopItemUncheckedUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateWithoutRoomsInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptCreateNestedManyWithoutShopInput
    hours?: ShopHourCreateNestedManyWithoutShopInput
    items?: ShopItemCreateNestedManyWithoutShopInput
    keeper?: MobCreateNestedOneWithoutShopsInput
    zone: ZoneCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateWithoutRoomsInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    keeperZoneId?: number | null
    keeperId?: number | null
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedCreateNestedManyWithoutShopInput
    hours?: ShopHourUncheckedCreateNestedManyWithoutShopInput
    items?: ShopItemUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutRoomsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutRoomsInput, ShopUncheckedCreateWithoutRoomsInput>
  }

  export type ShopUpsertWithoutRoomsInput = {
    update: XOR<ShopUpdateWithoutRoomsInput, ShopUncheckedUpdateWithoutRoomsInput>
    create: XOR<ShopCreateWithoutRoomsInput, ShopUncheckedCreateWithoutRoomsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutRoomsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutRoomsInput, ShopUncheckedUpdateWithoutRoomsInput>
  }

  export type ShopUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUpdateManyWithoutShopNestedInput
    hours?: ShopHourUpdateManyWithoutShopNestedInput
    items?: ShopItemUpdateManyWithoutShopNestedInput
    keeper?: MobUpdateOneWithoutShopsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    keeperZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    keeperId?: NullableIntFieldUpdateOperationsInput | number | null
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedUpdateManyWithoutShopNestedInput
    hours?: ShopHourUncheckedUpdateManyWithoutShopNestedInput
    items?: ShopItemUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateWithoutHoursInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptCreateNestedManyWithoutShopInput
    items?: ShopItemCreateNestedManyWithoutShopInput
    rooms?: ShopRoomCreateNestedManyWithoutShopInput
    keeper?: MobCreateNestedOneWithoutShopsInput
    zone: ZoneCreateNestedOneWithoutShopsInput
  }

  export type ShopUncheckedCreateWithoutHoursInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    keeperZoneId?: number | null
    keeperId?: number | null
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedCreateNestedManyWithoutShopInput
    items?: ShopItemUncheckedCreateNestedManyWithoutShopInput
    rooms?: ShopRoomUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutHoursInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutHoursInput, ShopUncheckedCreateWithoutHoursInput>
  }

  export type ShopUpsertWithoutHoursInput = {
    update: XOR<ShopUpdateWithoutHoursInput, ShopUncheckedUpdateWithoutHoursInput>
    create: XOR<ShopCreateWithoutHoursInput, ShopUncheckedCreateWithoutHoursInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutHoursInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutHoursInput, ShopUncheckedUpdateWithoutHoursInput>
  }

  export type ShopUpdateWithoutHoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUpdateManyWithoutShopNestedInput
    items?: ShopItemUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUpdateManyWithoutShopNestedInput
    keeper?: MobUpdateOneWithoutShopsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateWithoutHoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    keeperZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    keeperId?: NullableIntFieldUpdateOperationsInput | number | null
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedUpdateManyWithoutShopNestedInput
    items?: ShopItemUncheckedUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUncheckedUpdateManyWithoutShopNestedInput
  }

  export type MobCreateWithoutTriggersInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetCreateNestedManyWithoutMobInput
    skills?: MobSkillCreateNestedManyWithoutMobInput
    spells?: MobSpellCreateNestedManyWithoutMobInput
    gameClass?: GameClassCreateNestedOneWithoutMobsInput
    zone: ZoneCreateNestedOneWithoutMobsInput
    shops?: ShopCreateNestedManyWithoutKeeperInput
  }

  export type MobUncheckedCreateWithoutTriggersInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    classId?: number | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetUncheckedCreateNestedManyWithoutMobInput
    skills?: MobSkillUncheckedCreateNestedManyWithoutMobInput
    spells?: MobSpellUncheckedCreateNestedManyWithoutMobInput
    shops?: ShopUncheckedCreateNestedManyWithoutKeeperInput
  }

  export type MobCreateOrConnectWithoutTriggersInput = {
    where: MobWhereUniqueInput
    create: XOR<MobCreateWithoutTriggersInput, MobUncheckedCreateWithoutTriggersInput>
  }

  export type ObjectCreateWithoutTriggersInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutTriggersInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutTriggersInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutTriggersInput, ObjectUncheckedCreateWithoutTriggersInput>
  }

  export type ZoneCreateWithoutTriggersInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetCreateNestedManyWithoutZoneInput
    mobs?: MobCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetCreateNestedManyWithoutZoneInput
    objects?: ObjectCreateNestedManyWithoutZoneInput
    rooms?: RoomCreateNestedManyWithoutZoneInput
    shops?: ShopCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutTriggersInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutZoneInput
    mobs?: MobUncheckedCreateNestedManyWithoutZoneInput
    objectResets?: ObjectResetUncheckedCreateNestedManyWithoutZoneInput
    objects?: ObjectUncheckedCreateNestedManyWithoutZoneInput
    rooms?: RoomUncheckedCreateNestedManyWithoutZoneInput
    shops?: ShopUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutTriggersInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutTriggersInput, ZoneUncheckedCreateWithoutTriggersInput>
  }

  export type MobUpsertWithoutTriggersInput = {
    update: XOR<MobUpdateWithoutTriggersInput, MobUncheckedUpdateWithoutTriggersInput>
    create: XOR<MobCreateWithoutTriggersInput, MobUncheckedCreateWithoutTriggersInput>
    where?: MobWhereInput
  }

  export type MobUpdateToOneWithWhereWithoutTriggersInput = {
    where?: MobWhereInput
    data: XOR<MobUpdateWithoutTriggersInput, MobUncheckedUpdateWithoutTriggersInput>
  }

  export type MobUpdateWithoutTriggersInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUpdateManyWithoutMobNestedInput
    skills?: MobSkillUpdateManyWithoutMobNestedInput
    spells?: MobSpellUpdateManyWithoutMobNestedInput
    gameClass?: GameClassUpdateOneWithoutMobsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobsNestedInput
    shops?: ShopUpdateManyWithoutKeeperNestedInput
  }

  export type MobUncheckedUpdateWithoutTriggersInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUncheckedUpdateManyWithoutMobNestedInput
    skills?: MobSkillUncheckedUpdateManyWithoutMobNestedInput
    spells?: MobSpellUncheckedUpdateManyWithoutMobNestedInput
    shops?: ShopUncheckedUpdateManyWithoutKeeperNestedInput
  }

  export type ObjectUpsertWithoutTriggersInput = {
    update: XOR<ObjectUpdateWithoutTriggersInput, ObjectUncheckedUpdateWithoutTriggersInput>
    create: XOR<ObjectCreateWithoutTriggersInput, ObjectUncheckedCreateWithoutTriggersInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutTriggersInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutTriggersInput, ObjectUncheckedUpdateWithoutTriggersInput>
  }

  export type ObjectUpdateWithoutTriggersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutTriggersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ZoneUpsertWithoutTriggersInput = {
    update: XOR<ZoneUpdateWithoutTriggersInput, ZoneUncheckedUpdateWithoutTriggersInput>
    create: XOR<ZoneCreateWithoutTriggersInput, ZoneUncheckedCreateWithoutTriggersInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutTriggersInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutTriggersInput, ZoneUncheckedUpdateWithoutTriggersInput>
  }

  export type ZoneUpdateWithoutTriggersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUpdateManyWithoutZoneNestedInput
    mobs?: MobUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUpdateManyWithoutZoneNestedInput
    objects?: ObjectUpdateManyWithoutZoneNestedInput
    rooms?: RoomUpdateManyWithoutZoneNestedInput
    shops?: ShopUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutTriggersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUncheckedUpdateManyWithoutZoneNestedInput
    mobs?: MobUncheckedUpdateManyWithoutZoneNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutZoneNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutZoneNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutZoneNestedInput
    shops?: ShopUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    issuedBans?: BanRecordCreateNestedManyWithoutAdminInput
    banRecords?: BanRecordCreateNestedManyWithoutUserInput
    changeLogs?: ChangeLogCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    issuedBans?: BanRecordUncheckedCreateNestedManyWithoutAdminInput
    banRecords?: BanRecordUncheckedCreateNestedManyWithoutUserInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedBans?: BanRecordUpdateManyWithoutAdminNestedInput
    banRecords?: BanRecordUpdateManyWithoutUserNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedBans?: BanRecordUncheckedUpdateManyWithoutAdminNestedInput
    banRecords?: BanRecordUncheckedUpdateManyWithoutUserNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CharacterCreateWithoutGameClassInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectCreateNestedManyWithoutCharacterInput
    items?: CharacterItemCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellCreateNestedManyWithoutCharacterInput
    user: UserCreateNestedOneWithoutCharactersInput
  }

  export type CharacterUncheckedCreateWithoutGameClassInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectUncheckedCreateNestedManyWithoutCharacterInput
    items?: CharacterItemUncheckedCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutGameClassInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutGameClassInput, CharacterUncheckedCreateWithoutGameClassInput>
  }

  export type CharacterCreateManyGameClassInputEnvelope = {
    data: CharacterCreateManyGameClassInput | CharacterCreateManyGameClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassSkillCreateWithoutGameClassInput = {
    category?: $Enums.SkillCategory
    minLevel?: number
    maxLevel?: number
    skill: SkillCreateNestedOneWithoutClassSkillsInput
  }

  export type ClassSkillUncheckedCreateWithoutGameClassInput = {
    id?: number
    skillId: number
    category?: $Enums.SkillCategory
    minLevel?: number
    maxLevel?: number
  }

  export type ClassSkillCreateOrConnectWithoutGameClassInput = {
    where: ClassSkillWhereUniqueInput
    create: XOR<ClassSkillCreateWithoutGameClassInput, ClassSkillUncheckedCreateWithoutGameClassInput>
  }

  export type ClassSkillCreateManyGameClassInputEnvelope = {
    data: ClassSkillCreateManyGameClassInput | ClassSkillCreateManyGameClassInput[]
    skipDuplicates?: boolean
  }

  export type MobCreateWithoutGameClassInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetCreateNestedManyWithoutMobInput
    skills?: MobSkillCreateNestedManyWithoutMobInput
    spells?: MobSpellCreateNestedManyWithoutMobInput
    zone: ZoneCreateNestedOneWithoutMobsInput
    shops?: ShopCreateNestedManyWithoutKeeperInput
    triggers?: TriggerCreateNestedManyWithoutMobInput
  }

  export type MobUncheckedCreateWithoutGameClassInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
    resets?: MobResetUncheckedCreateNestedManyWithoutMobInput
    skills?: MobSkillUncheckedCreateNestedManyWithoutMobInput
    spells?: MobSpellUncheckedCreateNestedManyWithoutMobInput
    shops?: ShopUncheckedCreateNestedManyWithoutKeeperInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutMobInput
  }

  export type MobCreateOrConnectWithoutGameClassInput = {
    where: MobWhereUniqueInput
    create: XOR<MobCreateWithoutGameClassInput, MobUncheckedCreateWithoutGameClassInput>
  }

  export type MobCreateManyGameClassInputEnvelope = {
    data: MobCreateManyGameClassInput | MobCreateManyGameClassInput[]
    skipDuplicates?: boolean
  }

  export type SpellClassCircleCreateWithoutGameClassInput = {
    circle: number
    minLevel?: number | null
    proficiencyGain?: number | null
    spell: SpellCreateNestedOneWithoutClassCirclesInput
  }

  export type SpellClassCircleUncheckedCreateWithoutGameClassInput = {
    id?: number
    spellId: number
    circle: number
    minLevel?: number | null
    proficiencyGain?: number | null
  }

  export type SpellClassCircleCreateOrConnectWithoutGameClassInput = {
    where: SpellClassCircleWhereUniqueInput
    create: XOR<SpellClassCircleCreateWithoutGameClassInput, SpellClassCircleUncheckedCreateWithoutGameClassInput>
  }

  export type SpellClassCircleCreateManyGameClassInputEnvelope = {
    data: SpellClassCircleCreateManyGameClassInput | SpellClassCircleCreateManyGameClassInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutGameClassInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutGameClassInput, CharacterUncheckedUpdateWithoutGameClassInput>
    create: XOR<CharacterCreateWithoutGameClassInput, CharacterUncheckedCreateWithoutGameClassInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutGameClassInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutGameClassInput, CharacterUncheckedUpdateWithoutGameClassInput>
  }

  export type CharacterUpdateManyWithWhereWithoutGameClassInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutGameClassInput>
  }

  export type ClassSkillUpsertWithWhereUniqueWithoutGameClassInput = {
    where: ClassSkillWhereUniqueInput
    update: XOR<ClassSkillUpdateWithoutGameClassInput, ClassSkillUncheckedUpdateWithoutGameClassInput>
    create: XOR<ClassSkillCreateWithoutGameClassInput, ClassSkillUncheckedCreateWithoutGameClassInput>
  }

  export type ClassSkillUpdateWithWhereUniqueWithoutGameClassInput = {
    where: ClassSkillWhereUniqueInput
    data: XOR<ClassSkillUpdateWithoutGameClassInput, ClassSkillUncheckedUpdateWithoutGameClassInput>
  }

  export type ClassSkillUpdateManyWithWhereWithoutGameClassInput = {
    where: ClassSkillScalarWhereInput
    data: XOR<ClassSkillUpdateManyMutationInput, ClassSkillUncheckedUpdateManyWithoutGameClassInput>
  }

  export type ClassSkillScalarWhereInput = {
    AND?: ClassSkillScalarWhereInput | ClassSkillScalarWhereInput[]
    OR?: ClassSkillScalarWhereInput[]
    NOT?: ClassSkillScalarWhereInput | ClassSkillScalarWhereInput[]
    id?: IntFilter<"ClassSkill"> | number
    classId?: IntFilter<"ClassSkill"> | number
    skillId?: IntFilter<"ClassSkill"> | number
    category?: EnumSkillCategoryFilter<"ClassSkill"> | $Enums.SkillCategory
    minLevel?: IntFilter<"ClassSkill"> | number
    maxLevel?: IntFilter<"ClassSkill"> | number
  }

  export type MobUpsertWithWhereUniqueWithoutGameClassInput = {
    where: MobWhereUniqueInput
    update: XOR<MobUpdateWithoutGameClassInput, MobUncheckedUpdateWithoutGameClassInput>
    create: XOR<MobCreateWithoutGameClassInput, MobUncheckedCreateWithoutGameClassInput>
  }

  export type MobUpdateWithWhereUniqueWithoutGameClassInput = {
    where: MobWhereUniqueInput
    data: XOR<MobUpdateWithoutGameClassInput, MobUncheckedUpdateWithoutGameClassInput>
  }

  export type MobUpdateManyWithWhereWithoutGameClassInput = {
    where: MobScalarWhereInput
    data: XOR<MobUpdateManyMutationInput, MobUncheckedUpdateManyWithoutGameClassInput>
  }

  export type SpellClassCircleUpsertWithWhereUniqueWithoutGameClassInput = {
    where: SpellClassCircleWhereUniqueInput
    update: XOR<SpellClassCircleUpdateWithoutGameClassInput, SpellClassCircleUncheckedUpdateWithoutGameClassInput>
    create: XOR<SpellClassCircleCreateWithoutGameClassInput, SpellClassCircleUncheckedCreateWithoutGameClassInput>
  }

  export type SpellClassCircleUpdateWithWhereUniqueWithoutGameClassInput = {
    where: SpellClassCircleWhereUniqueInput
    data: XOR<SpellClassCircleUpdateWithoutGameClassInput, SpellClassCircleUncheckedUpdateWithoutGameClassInput>
  }

  export type SpellClassCircleUpdateManyWithWhereWithoutGameClassInput = {
    where: SpellClassCircleScalarWhereInput
    data: XOR<SpellClassCircleUpdateManyMutationInput, SpellClassCircleUncheckedUpdateManyWithoutGameClassInput>
  }

  export type SpellClassCircleScalarWhereInput = {
    AND?: SpellClassCircleScalarWhereInput | SpellClassCircleScalarWhereInput[]
    OR?: SpellClassCircleScalarWhereInput[]
    NOT?: SpellClassCircleScalarWhereInput | SpellClassCircleScalarWhereInput[]
    id?: IntFilter<"SpellClassCircle"> | number
    spellId?: IntFilter<"SpellClassCircle"> | number
    classId?: IntFilter<"SpellClassCircle"> | number
    circle?: IntFilter<"SpellClassCircle"> | number
    minLevel?: IntNullableFilter<"SpellClassCircle"> | number | null
    proficiencyGain?: IntNullableFilter<"SpellClassCircle"> | number | null
  }

  export type CharacterSpellCreateWithoutSpellInput = {
    id?: string
    known?: boolean
    proficiency?: number
    lastCast?: Date | string | null
    character: CharacterCreateNestedOneWithoutSpellsInput
  }

  export type CharacterSpellUncheckedCreateWithoutSpellInput = {
    id?: string
    characterId: string
    known?: boolean
    proficiency?: number
    lastCast?: Date | string | null
  }

  export type CharacterSpellCreateOrConnectWithoutSpellInput = {
    where: CharacterSpellWhereUniqueInput
    create: XOR<CharacterSpellCreateWithoutSpellInput, CharacterSpellUncheckedCreateWithoutSpellInput>
  }

  export type CharacterSpellCreateManySpellInputEnvelope = {
    data: CharacterSpellCreateManySpellInput | CharacterSpellCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type MobSpellCreateWithoutSpellInput = {
    circle?: number
    known?: boolean
    mob: MobCreateNestedOneWithoutSpellsInput
  }

  export type MobSpellUncheckedCreateWithoutSpellInput = {
    id?: number
    mobZoneId: number
    mobId: number
    circle?: number
    known?: boolean
  }

  export type MobSpellCreateOrConnectWithoutSpellInput = {
    where: MobSpellWhereUniqueInput
    create: XOR<MobSpellCreateWithoutSpellInput, MobSpellUncheckedCreateWithoutSpellInput>
  }

  export type MobSpellCreateManySpellInputEnvelope = {
    data: MobSpellCreateManySpellInput | MobSpellCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellClassCircleCreateWithoutSpellInput = {
    circle: number
    minLevel?: number | null
    proficiencyGain?: number | null
    gameClass: GameClassCreateNestedOneWithoutSpellCirclesInput
  }

  export type SpellClassCircleUncheckedCreateWithoutSpellInput = {
    id?: number
    classId: number
    circle: number
    minLevel?: number | null
    proficiencyGain?: number | null
  }

  export type SpellClassCircleCreateOrConnectWithoutSpellInput = {
    where: SpellClassCircleWhereUniqueInput
    create: XOR<SpellClassCircleCreateWithoutSpellInput, SpellClassCircleUncheckedCreateWithoutSpellInput>
  }

  export type SpellClassCircleCreateManySpellInputEnvelope = {
    data: SpellClassCircleCreateManySpellInput | SpellClassCircleCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellComponentCreateWithoutSpellInput = {
    objectId: number
    consumed?: boolean
    required?: boolean
  }

  export type SpellComponentUncheckedCreateWithoutSpellInput = {
    id?: number
    objectId: number
    consumed?: boolean
    required?: boolean
  }

  export type SpellComponentCreateOrConnectWithoutSpellInput = {
    where: SpellComponentWhereUniqueInput
    create: XOR<SpellComponentCreateWithoutSpellInput, SpellComponentUncheckedCreateWithoutSpellInput>
  }

  export type SpellComponentCreateManySpellInputEnvelope = {
    data: SpellComponentCreateManySpellInput | SpellComponentCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellEffectCreateWithoutSpellInput = {
    effectType: $Enums.EffectType
    order?: number
    chancePct?: number
    trigger?: $Enums.EffectTrigger | null
    durationFormula?: string | null
    stackingRule?: $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params: JsonNullValueInput | InputJsonValue
  }

  export type SpellEffectUncheckedCreateWithoutSpellInput = {
    id?: number
    effectType: $Enums.EffectType
    order?: number
    chancePct?: number
    trigger?: $Enums.EffectTrigger | null
    durationFormula?: string | null
    stackingRule?: $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params: JsonNullValueInput | InputJsonValue
  }

  export type SpellEffectCreateOrConnectWithoutSpellInput = {
    where: SpellEffectWhereUniqueInput
    create: XOR<SpellEffectCreateWithoutSpellInput, SpellEffectUncheckedCreateWithoutSpellInput>
  }

  export type SpellEffectCreateManySpellInputEnvelope = {
    data: SpellEffectCreateManySpellInput | SpellEffectCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellMessageCreateWithoutSpellInput = {
    startToCaster?: string | null
    startToVictim?: string | null
    startToRoom?: string | null
    successToCaster?: string | null
    successToVictim?: string | null
    successToRoom?: string | null
    failToCaster?: string | null
    failToVictim?: string | null
    failToRoom?: string | null
    wearoffToTarget?: string | null
    wearoffToRoom?: string | null
  }

  export type SpellMessageUncheckedCreateWithoutSpellInput = {
    id?: number
    startToCaster?: string | null
    startToVictim?: string | null
    startToRoom?: string | null
    successToCaster?: string | null
    successToVictim?: string | null
    successToRoom?: string | null
    failToCaster?: string | null
    failToVictim?: string | null
    failToRoom?: string | null
    wearoffToTarget?: string | null
    wearoffToRoom?: string | null
  }

  export type SpellMessageCreateOrConnectWithoutSpellInput = {
    where: SpellMessageWhereUniqueInput
    create: XOR<SpellMessageCreateWithoutSpellInput, SpellMessageUncheckedCreateWithoutSpellInput>
  }

  export type SpellRestrictionCreateWithoutSpellInput = {
    indoorsOnly?: boolean
    outdoorsOnly?: boolean
    noSafeRooms?: boolean
    noTeleportFlagsMask?: number | null
    terrainMask?: number | null
    disallowStatesMask?: number | null
  }

  export type SpellRestrictionUncheckedCreateWithoutSpellInput = {
    id?: number
    indoorsOnly?: boolean
    outdoorsOnly?: boolean
    noSafeRooms?: boolean
    noTeleportFlagsMask?: number | null
    terrainMask?: number | null
    disallowStatesMask?: number | null
  }

  export type SpellRestrictionCreateOrConnectWithoutSpellInput = {
    where: SpellRestrictionWhereUniqueInput
    create: XOR<SpellRestrictionCreateWithoutSpellInput, SpellRestrictionUncheckedCreateWithoutSpellInput>
  }

  export type SpellSavingThrowCreateWithoutSpellInput = {
    saveType?: $Enums.SaveType
    onSave?: $Enums.SaveResult
    dcFormula: string
    saveModifierMask?: number | null
  }

  export type SpellSavingThrowUncheckedCreateWithoutSpellInput = {
    id?: number
    saveType?: $Enums.SaveType
    onSave?: $Enums.SaveResult
    dcFormula: string
    saveModifierMask?: number | null
  }

  export type SpellSavingThrowCreateOrConnectWithoutSpellInput = {
    where: SpellSavingThrowWhereUniqueInput
    create: XOR<SpellSavingThrowCreateWithoutSpellInput, SpellSavingThrowUncheckedCreateWithoutSpellInput>
  }

  export type SpellSavingThrowCreateManySpellInputEnvelope = {
    data: SpellSavingThrowCreateManySpellInput | SpellSavingThrowCreateManySpellInput[]
    skipDuplicates?: boolean
  }

  export type SpellTargetingCreateWithoutSpellInput = {
    allowedTargetsMask: number
    targetScope?: $Enums.TargetScope
    maxTargets?: number
    range?: $Enums.SpellRange
    requireLos?: boolean
    filtersMask?: number | null
  }

  export type SpellTargetingUncheckedCreateWithoutSpellInput = {
    id?: number
    allowedTargetsMask: number
    targetScope?: $Enums.TargetScope
    maxTargets?: number
    range?: $Enums.SpellRange
    requireLos?: boolean
    filtersMask?: number | null
  }

  export type SpellTargetingCreateOrConnectWithoutSpellInput = {
    where: SpellTargetingWhereUniqueInput
    create: XOR<SpellTargetingCreateWithoutSpellInput, SpellTargetingUncheckedCreateWithoutSpellInput>
  }

  export type SpellSchoolCreateWithoutSpellsInput = {
    name: string
    description?: string | null
  }

  export type SpellSchoolUncheckedCreateWithoutSpellsInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type SpellSchoolCreateOrConnectWithoutSpellsInput = {
    where: SpellSchoolWhereUniqueInput
    create: XOR<SpellSchoolCreateWithoutSpellsInput, SpellSchoolUncheckedCreateWithoutSpellsInput>
  }

  export type CharacterSpellUpsertWithWhereUniqueWithoutSpellInput = {
    where: CharacterSpellWhereUniqueInput
    update: XOR<CharacterSpellUpdateWithoutSpellInput, CharacterSpellUncheckedUpdateWithoutSpellInput>
    create: XOR<CharacterSpellCreateWithoutSpellInput, CharacterSpellUncheckedCreateWithoutSpellInput>
  }

  export type CharacterSpellUpdateWithWhereUniqueWithoutSpellInput = {
    where: CharacterSpellWhereUniqueInput
    data: XOR<CharacterSpellUpdateWithoutSpellInput, CharacterSpellUncheckedUpdateWithoutSpellInput>
  }

  export type CharacterSpellUpdateManyWithWhereWithoutSpellInput = {
    where: CharacterSpellScalarWhereInput
    data: XOR<CharacterSpellUpdateManyMutationInput, CharacterSpellUncheckedUpdateManyWithoutSpellInput>
  }

  export type MobSpellUpsertWithWhereUniqueWithoutSpellInput = {
    where: MobSpellWhereUniqueInput
    update: XOR<MobSpellUpdateWithoutSpellInput, MobSpellUncheckedUpdateWithoutSpellInput>
    create: XOR<MobSpellCreateWithoutSpellInput, MobSpellUncheckedCreateWithoutSpellInput>
  }

  export type MobSpellUpdateWithWhereUniqueWithoutSpellInput = {
    where: MobSpellWhereUniqueInput
    data: XOR<MobSpellUpdateWithoutSpellInput, MobSpellUncheckedUpdateWithoutSpellInput>
  }

  export type MobSpellUpdateManyWithWhereWithoutSpellInput = {
    where: MobSpellScalarWhereInput
    data: XOR<MobSpellUpdateManyMutationInput, MobSpellUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellClassCircleUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellClassCircleWhereUniqueInput
    update: XOR<SpellClassCircleUpdateWithoutSpellInput, SpellClassCircleUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellClassCircleCreateWithoutSpellInput, SpellClassCircleUncheckedCreateWithoutSpellInput>
  }

  export type SpellClassCircleUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellClassCircleWhereUniqueInput
    data: XOR<SpellClassCircleUpdateWithoutSpellInput, SpellClassCircleUncheckedUpdateWithoutSpellInput>
  }

  export type SpellClassCircleUpdateManyWithWhereWithoutSpellInput = {
    where: SpellClassCircleScalarWhereInput
    data: XOR<SpellClassCircleUpdateManyMutationInput, SpellClassCircleUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellComponentUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellComponentWhereUniqueInput
    update: XOR<SpellComponentUpdateWithoutSpellInput, SpellComponentUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellComponentCreateWithoutSpellInput, SpellComponentUncheckedCreateWithoutSpellInput>
  }

  export type SpellComponentUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellComponentWhereUniqueInput
    data: XOR<SpellComponentUpdateWithoutSpellInput, SpellComponentUncheckedUpdateWithoutSpellInput>
  }

  export type SpellComponentUpdateManyWithWhereWithoutSpellInput = {
    where: SpellComponentScalarWhereInput
    data: XOR<SpellComponentUpdateManyMutationInput, SpellComponentUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellComponentScalarWhereInput = {
    AND?: SpellComponentScalarWhereInput | SpellComponentScalarWhereInput[]
    OR?: SpellComponentScalarWhereInput[]
    NOT?: SpellComponentScalarWhereInput | SpellComponentScalarWhereInput[]
    id?: IntFilter<"SpellComponent"> | number
    spellId?: IntFilter<"SpellComponent"> | number
    objectId?: IntFilter<"SpellComponent"> | number
    consumed?: BoolFilter<"SpellComponent"> | boolean
    required?: BoolFilter<"SpellComponent"> | boolean
  }

  export type SpellEffectUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellEffectWhereUniqueInput
    update: XOR<SpellEffectUpdateWithoutSpellInput, SpellEffectUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellEffectCreateWithoutSpellInput, SpellEffectUncheckedCreateWithoutSpellInput>
  }

  export type SpellEffectUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellEffectWhereUniqueInput
    data: XOR<SpellEffectUpdateWithoutSpellInput, SpellEffectUncheckedUpdateWithoutSpellInput>
  }

  export type SpellEffectUpdateManyWithWhereWithoutSpellInput = {
    where: SpellEffectScalarWhereInput
    data: XOR<SpellEffectUpdateManyMutationInput, SpellEffectUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellEffectScalarWhereInput = {
    AND?: SpellEffectScalarWhereInput | SpellEffectScalarWhereInput[]
    OR?: SpellEffectScalarWhereInput[]
    NOT?: SpellEffectScalarWhereInput | SpellEffectScalarWhereInput[]
    id?: IntFilter<"SpellEffect"> | number
    spellId?: IntFilter<"SpellEffect"> | number
    effectType?: EnumEffectTypeFilter<"SpellEffect"> | $Enums.EffectType
    order?: IntFilter<"SpellEffect"> | number
    chancePct?: IntFilter<"SpellEffect"> | number
    trigger?: EnumEffectTriggerNullableFilter<"SpellEffect"> | $Enums.EffectTrigger | null
    durationFormula?: StringNullableFilter<"SpellEffect"> | string | null
    stackingRule?: EnumStackingRuleFilter<"SpellEffect"> | $Enums.StackingRule
    conditionFilter?: JsonNullableFilter<"SpellEffect">
    params?: JsonFilter<"SpellEffect">
  }

  export type SpellMessageUpsertWithoutSpellInput = {
    update: XOR<SpellMessageUpdateWithoutSpellInput, SpellMessageUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellMessageCreateWithoutSpellInput, SpellMessageUncheckedCreateWithoutSpellInput>
    where?: SpellMessageWhereInput
  }

  export type SpellMessageUpdateToOneWithWhereWithoutSpellInput = {
    where?: SpellMessageWhereInput
    data: XOR<SpellMessageUpdateWithoutSpellInput, SpellMessageUncheckedUpdateWithoutSpellInput>
  }

  export type SpellMessageUpdateWithoutSpellInput = {
    startToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    startToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    startToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    successToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    successToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    successToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    failToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    failToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    failToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToTarget?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToRoom?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellMessageUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    startToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    startToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    startToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    successToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    successToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    successToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    failToCaster?: NullableStringFieldUpdateOperationsInput | string | null
    failToVictim?: NullableStringFieldUpdateOperationsInput | string | null
    failToRoom?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToTarget?: NullableStringFieldUpdateOperationsInput | string | null
    wearoffToRoom?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellRestrictionUpsertWithoutSpellInput = {
    update: XOR<SpellRestrictionUpdateWithoutSpellInput, SpellRestrictionUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellRestrictionCreateWithoutSpellInput, SpellRestrictionUncheckedCreateWithoutSpellInput>
    where?: SpellRestrictionWhereInput
  }

  export type SpellRestrictionUpdateToOneWithWhereWithoutSpellInput = {
    where?: SpellRestrictionWhereInput
    data: XOR<SpellRestrictionUpdateWithoutSpellInput, SpellRestrictionUncheckedUpdateWithoutSpellInput>
  }

  export type SpellRestrictionUpdateWithoutSpellInput = {
    indoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    outdoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    noSafeRooms?: BoolFieldUpdateOperationsInput | boolean
    noTeleportFlagsMask?: NullableIntFieldUpdateOperationsInput | number | null
    terrainMask?: NullableIntFieldUpdateOperationsInput | number | null
    disallowStatesMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellRestrictionUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    indoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    outdoorsOnly?: BoolFieldUpdateOperationsInput | boolean
    noSafeRooms?: BoolFieldUpdateOperationsInput | boolean
    noTeleportFlagsMask?: NullableIntFieldUpdateOperationsInput | number | null
    terrainMask?: NullableIntFieldUpdateOperationsInput | number | null
    disallowStatesMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSavingThrowUpsertWithWhereUniqueWithoutSpellInput = {
    where: SpellSavingThrowWhereUniqueInput
    update: XOR<SpellSavingThrowUpdateWithoutSpellInput, SpellSavingThrowUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellSavingThrowCreateWithoutSpellInput, SpellSavingThrowUncheckedCreateWithoutSpellInput>
  }

  export type SpellSavingThrowUpdateWithWhereUniqueWithoutSpellInput = {
    where: SpellSavingThrowWhereUniqueInput
    data: XOR<SpellSavingThrowUpdateWithoutSpellInput, SpellSavingThrowUncheckedUpdateWithoutSpellInput>
  }

  export type SpellSavingThrowUpdateManyWithWhereWithoutSpellInput = {
    where: SpellSavingThrowScalarWhereInput
    data: XOR<SpellSavingThrowUpdateManyMutationInput, SpellSavingThrowUncheckedUpdateManyWithoutSpellInput>
  }

  export type SpellSavingThrowScalarWhereInput = {
    AND?: SpellSavingThrowScalarWhereInput | SpellSavingThrowScalarWhereInput[]
    OR?: SpellSavingThrowScalarWhereInput[]
    NOT?: SpellSavingThrowScalarWhereInput | SpellSavingThrowScalarWhereInput[]
    id?: IntFilter<"SpellSavingThrow"> | number
    spellId?: IntFilter<"SpellSavingThrow"> | number
    saveType?: EnumSaveTypeFilter<"SpellSavingThrow"> | $Enums.SaveType
    onSave?: EnumSaveResultFilter<"SpellSavingThrow"> | $Enums.SaveResult
    dcFormula?: StringFilter<"SpellSavingThrow"> | string
    saveModifierMask?: IntNullableFilter<"SpellSavingThrow"> | number | null
  }

  export type SpellTargetingUpsertWithoutSpellInput = {
    update: XOR<SpellTargetingUpdateWithoutSpellInput, SpellTargetingUncheckedUpdateWithoutSpellInput>
    create: XOR<SpellTargetingCreateWithoutSpellInput, SpellTargetingUncheckedCreateWithoutSpellInput>
    where?: SpellTargetingWhereInput
  }

  export type SpellTargetingUpdateToOneWithWhereWithoutSpellInput = {
    where?: SpellTargetingWhereInput
    data: XOR<SpellTargetingUpdateWithoutSpellInput, SpellTargetingUncheckedUpdateWithoutSpellInput>
  }

  export type SpellTargetingUpdateWithoutSpellInput = {
    allowedTargetsMask?: IntFieldUpdateOperationsInput | number
    targetScope?: EnumTargetScopeFieldUpdateOperationsInput | $Enums.TargetScope
    maxTargets?: IntFieldUpdateOperationsInput | number
    range?: EnumSpellRangeFieldUpdateOperationsInput | $Enums.SpellRange
    requireLos?: BoolFieldUpdateOperationsInput | boolean
    filtersMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellTargetingUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    allowedTargetsMask?: IntFieldUpdateOperationsInput | number
    targetScope?: EnumTargetScopeFieldUpdateOperationsInput | $Enums.TargetScope
    maxTargets?: IntFieldUpdateOperationsInput | number
    range?: EnumSpellRangeFieldUpdateOperationsInput | $Enums.SpellRange
    requireLos?: BoolFieldUpdateOperationsInput | boolean
    filtersMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSchoolUpsertWithoutSpellsInput = {
    update: XOR<SpellSchoolUpdateWithoutSpellsInput, SpellSchoolUncheckedUpdateWithoutSpellsInput>
    create: XOR<SpellSchoolCreateWithoutSpellsInput, SpellSchoolUncheckedCreateWithoutSpellsInput>
    where?: SpellSchoolWhereInput
  }

  export type SpellSchoolUpdateToOneWithWhereWithoutSpellsInput = {
    where?: SpellSchoolWhereInput
    data: XOR<SpellSchoolUpdateWithoutSpellsInput, SpellSchoolUncheckedUpdateWithoutSpellsInput>
  }

  export type SpellSchoolUpdateWithoutSpellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellSchoolUncheckedUpdateWithoutSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpellCreateWithoutSchoolInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleCreateNestedManyWithoutSpellInput
    components?: SpellComponentCreateNestedManyWithoutSpellInput
    effects?: SpellEffectCreateNestedManyWithoutSpellInput
    messages?: SpellMessageCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingCreateNestedOneWithoutSpellInput
  }

  export type SpellUncheckedCreateWithoutSchoolInput = {
    id?: number
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellUncheckedCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellUncheckedCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput
    components?: SpellComponentUncheckedCreateNestedManyWithoutSpellInput
    effects?: SpellEffectUncheckedCreateNestedManyWithoutSpellInput
    messages?: SpellMessageUncheckedCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingUncheckedCreateNestedOneWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutSchoolInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutSchoolInput, SpellUncheckedCreateWithoutSchoolInput>
  }

  export type SpellCreateManySchoolInputEnvelope = {
    data: SpellCreateManySchoolInput | SpellCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SpellUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SpellWhereUniqueInput
    update: XOR<SpellUpdateWithoutSchoolInput, SpellUncheckedUpdateWithoutSchoolInput>
    create: XOR<SpellCreateWithoutSchoolInput, SpellUncheckedCreateWithoutSchoolInput>
  }

  export type SpellUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SpellWhereUniqueInput
    data: XOR<SpellUpdateWithoutSchoolInput, SpellUncheckedUpdateWithoutSchoolInput>
  }

  export type SpellUpdateManyWithWhereWithoutSchoolInput = {
    where: SpellScalarWhereInput
    data: XOR<SpellUpdateManyMutationInput, SpellUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SpellScalarWhereInput = {
    AND?: SpellScalarWhereInput | SpellScalarWhereInput[]
    OR?: SpellScalarWhereInput[]
    NOT?: SpellScalarWhereInput | SpellScalarWhereInput[]
    id?: IntFilter<"Spell"> | number
    name?: StringFilter<"Spell"> | string
    schoolId?: IntNullableFilter<"Spell"> | number | null
    minPosition?: EnumPositionFilter<"Spell"> | $Enums.Position
    violent?: BoolFilter<"Spell"> | boolean
    castTimeRounds?: IntFilter<"Spell"> | number
    cooldownMs?: IntFilter<"Spell"> | number
    inCombatOnly?: BoolFilter<"Spell"> | boolean
    isArea?: BoolFilter<"Spell"> | boolean
    notes?: StringNullableFilter<"Spell"> | string | null
    createdAt?: DateTimeFilter<"Spell"> | Date | string
    updatedAt?: DateTimeFilter<"Spell"> | Date | string
  }

  export type GameClassCreateWithoutSpellCirclesInput = {
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutGameClassInput
    skillAccess?: ClassSkillCreateNestedManyWithoutGameClassInput
    mobs?: MobCreateNestedManyWithoutGameClassInput
  }

  export type GameClassUncheckedCreateWithoutSpellCirclesInput = {
    id?: number
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutGameClassInput
    skillAccess?: ClassSkillUncheckedCreateNestedManyWithoutGameClassInput
    mobs?: MobUncheckedCreateNestedManyWithoutGameClassInput
  }

  export type GameClassCreateOrConnectWithoutSpellCirclesInput = {
    where: GameClassWhereUniqueInput
    create: XOR<GameClassCreateWithoutSpellCirclesInput, GameClassUncheckedCreateWithoutSpellCirclesInput>
  }

  export type SpellCreateWithoutClassCirclesInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellCreateNestedManyWithoutSpellInput
    components?: SpellComponentCreateNestedManyWithoutSpellInput
    effects?: SpellEffectCreateNestedManyWithoutSpellInput
    messages?: SpellMessageCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingCreateNestedOneWithoutSpellInput
    school?: SpellSchoolCreateNestedOneWithoutSpellsInput
  }

  export type SpellUncheckedCreateWithoutClassCirclesInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellUncheckedCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellUncheckedCreateNestedManyWithoutSpellInput
    components?: SpellComponentUncheckedCreateNestedManyWithoutSpellInput
    effects?: SpellEffectUncheckedCreateNestedManyWithoutSpellInput
    messages?: SpellMessageUncheckedCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingUncheckedCreateNestedOneWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutClassCirclesInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutClassCirclesInput, SpellUncheckedCreateWithoutClassCirclesInput>
  }

  export type GameClassUpsertWithoutSpellCirclesInput = {
    update: XOR<GameClassUpdateWithoutSpellCirclesInput, GameClassUncheckedUpdateWithoutSpellCirclesInput>
    create: XOR<GameClassCreateWithoutSpellCirclesInput, GameClassUncheckedCreateWithoutSpellCirclesInput>
    where?: GameClassWhereInput
  }

  export type GameClassUpdateToOneWithWhereWithoutSpellCirclesInput = {
    where?: GameClassWhereInput
    data: XOR<GameClassUpdateWithoutSpellCirclesInput, GameClassUncheckedUpdateWithoutSpellCirclesInput>
  }

  export type GameClassUpdateWithoutSpellCirclesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutGameClassNestedInput
    skillAccess?: ClassSkillUpdateManyWithoutGameClassNestedInput
    mobs?: MobUpdateManyWithoutGameClassNestedInput
  }

  export type GameClassUncheckedUpdateWithoutSpellCirclesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutGameClassNestedInput
    skillAccess?: ClassSkillUncheckedUpdateManyWithoutGameClassNestedInput
    mobs?: MobUncheckedUpdateManyWithoutGameClassNestedInput
  }

  export type SpellUpsertWithoutClassCirclesInput = {
    update: XOR<SpellUpdateWithoutClassCirclesInput, SpellUncheckedUpdateWithoutClassCirclesInput>
    create: XOR<SpellCreateWithoutClassCirclesInput, SpellUncheckedCreateWithoutClassCirclesInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutClassCirclesInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutClassCirclesInput, SpellUncheckedUpdateWithoutClassCirclesInput>
  }

  export type SpellUpdateWithoutClassCirclesInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUpdateOneWithoutSpellNestedInput
    school?: SpellSchoolUpdateOneWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutClassCirclesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUncheckedUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUncheckedUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUncheckedUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUncheckedUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput
  }

  export type SpellCreateWithoutTargetingInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleCreateNestedManyWithoutSpellInput
    components?: SpellComponentCreateNestedManyWithoutSpellInput
    effects?: SpellEffectCreateNestedManyWithoutSpellInput
    messages?: SpellMessageCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowCreateNestedManyWithoutSpellInput
    school?: SpellSchoolCreateNestedOneWithoutSpellsInput
  }

  export type SpellUncheckedCreateWithoutTargetingInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellUncheckedCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellUncheckedCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput
    components?: SpellComponentUncheckedCreateNestedManyWithoutSpellInput
    effects?: SpellEffectUncheckedCreateNestedManyWithoutSpellInput
    messages?: SpellMessageUncheckedCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutTargetingInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutTargetingInput, SpellUncheckedCreateWithoutTargetingInput>
  }

  export type SpellUpsertWithoutTargetingInput = {
    update: XOR<SpellUpdateWithoutTargetingInput, SpellUncheckedUpdateWithoutTargetingInput>
    create: XOR<SpellCreateWithoutTargetingInput, SpellUncheckedCreateWithoutTargetingInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutTargetingInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutTargetingInput, SpellUncheckedUpdateWithoutTargetingInput>
  }

  export type SpellUpdateWithoutTargetingInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUpdateManyWithoutSpellNestedInput
    school?: SpellSchoolUpdateOneWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutTargetingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUncheckedUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUncheckedUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUncheckedUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUncheckedUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput
  }

  export type SpellCreateWithoutSavingThrowsInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleCreateNestedManyWithoutSpellInput
    components?: SpellComponentCreateNestedManyWithoutSpellInput
    effects?: SpellEffectCreateNestedManyWithoutSpellInput
    messages?: SpellMessageCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionCreateNestedOneWithoutSpellInput
    targeting?: SpellTargetingCreateNestedOneWithoutSpellInput
    school?: SpellSchoolCreateNestedOneWithoutSpellsInput
  }

  export type SpellUncheckedCreateWithoutSavingThrowsInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellUncheckedCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellUncheckedCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput
    components?: SpellComponentUncheckedCreateNestedManyWithoutSpellInput
    effects?: SpellEffectUncheckedCreateNestedManyWithoutSpellInput
    messages?: SpellMessageUncheckedCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput
    targeting?: SpellTargetingUncheckedCreateNestedOneWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutSavingThrowsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutSavingThrowsInput, SpellUncheckedCreateWithoutSavingThrowsInput>
  }

  export type SpellUpsertWithoutSavingThrowsInput = {
    update: XOR<SpellUpdateWithoutSavingThrowsInput, SpellUncheckedUpdateWithoutSavingThrowsInput>
    create: XOR<SpellCreateWithoutSavingThrowsInput, SpellUncheckedCreateWithoutSavingThrowsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutSavingThrowsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutSavingThrowsInput, SpellUncheckedUpdateWithoutSavingThrowsInput>
  }

  export type SpellUpdateWithoutSavingThrowsInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUpdateOneWithoutSpellNestedInput
    targeting?: SpellTargetingUpdateOneWithoutSpellNestedInput
    school?: SpellSchoolUpdateOneWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutSavingThrowsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUncheckedUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUncheckedUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUncheckedUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUncheckedUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput
    targeting?: SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput
  }

  export type SpellCreateWithoutMessagesInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleCreateNestedManyWithoutSpellInput
    components?: SpellComponentCreateNestedManyWithoutSpellInput
    effects?: SpellEffectCreateNestedManyWithoutSpellInput
    restrictions?: SpellRestrictionCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingCreateNestedOneWithoutSpellInput
    school?: SpellSchoolCreateNestedOneWithoutSpellsInput
  }

  export type SpellUncheckedCreateWithoutMessagesInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellUncheckedCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellUncheckedCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput
    components?: SpellComponentUncheckedCreateNestedManyWithoutSpellInput
    effects?: SpellEffectUncheckedCreateNestedManyWithoutSpellInput
    restrictions?: SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingUncheckedCreateNestedOneWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutMessagesInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutMessagesInput, SpellUncheckedCreateWithoutMessagesInput>
  }

  export type SpellUpsertWithoutMessagesInput = {
    update: XOR<SpellUpdateWithoutMessagesInput, SpellUncheckedUpdateWithoutMessagesInput>
    create: XOR<SpellCreateWithoutMessagesInput, SpellUncheckedCreateWithoutMessagesInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutMessagesInput, SpellUncheckedUpdateWithoutMessagesInput>
  }

  export type SpellUpdateWithoutMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUpdateManyWithoutSpellNestedInput
    restrictions?: SpellRestrictionUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUpdateOneWithoutSpellNestedInput
    school?: SpellSchoolUpdateOneWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUncheckedUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUncheckedUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUncheckedUpdateManyWithoutSpellNestedInput
    restrictions?: SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput
  }

  export type SpellCreateWithoutComponentsInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleCreateNestedManyWithoutSpellInput
    effects?: SpellEffectCreateNestedManyWithoutSpellInput
    messages?: SpellMessageCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingCreateNestedOneWithoutSpellInput
    school?: SpellSchoolCreateNestedOneWithoutSpellsInput
  }

  export type SpellUncheckedCreateWithoutComponentsInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellUncheckedCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellUncheckedCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput
    effects?: SpellEffectUncheckedCreateNestedManyWithoutSpellInput
    messages?: SpellMessageUncheckedCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingUncheckedCreateNestedOneWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutComponentsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutComponentsInput, SpellUncheckedCreateWithoutComponentsInput>
  }

  export type SpellUpsertWithoutComponentsInput = {
    update: XOR<SpellUpdateWithoutComponentsInput, SpellUncheckedUpdateWithoutComponentsInput>
    create: XOR<SpellCreateWithoutComponentsInput, SpellUncheckedCreateWithoutComponentsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutComponentsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutComponentsInput, SpellUncheckedUpdateWithoutComponentsInput>
  }

  export type SpellUpdateWithoutComponentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUpdateOneWithoutSpellNestedInput
    school?: SpellSchoolUpdateOneWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutComponentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUncheckedUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUncheckedUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUncheckedUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput
  }

  export type SpellCreateWithoutRestrictionsInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleCreateNestedManyWithoutSpellInput
    components?: SpellComponentCreateNestedManyWithoutSpellInput
    effects?: SpellEffectCreateNestedManyWithoutSpellInput
    messages?: SpellMessageCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingCreateNestedOneWithoutSpellInput
    school?: SpellSchoolCreateNestedOneWithoutSpellsInput
  }

  export type SpellUncheckedCreateWithoutRestrictionsInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellUncheckedCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellUncheckedCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput
    components?: SpellComponentUncheckedCreateNestedManyWithoutSpellInput
    effects?: SpellEffectUncheckedCreateNestedManyWithoutSpellInput
    messages?: SpellMessageUncheckedCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingUncheckedCreateNestedOneWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutRestrictionsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutRestrictionsInput, SpellUncheckedCreateWithoutRestrictionsInput>
  }

  export type SpellUpsertWithoutRestrictionsInput = {
    update: XOR<SpellUpdateWithoutRestrictionsInput, SpellUncheckedUpdateWithoutRestrictionsInput>
    create: XOR<SpellCreateWithoutRestrictionsInput, SpellUncheckedCreateWithoutRestrictionsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutRestrictionsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutRestrictionsInput, SpellUncheckedUpdateWithoutRestrictionsInput>
  }

  export type SpellUpdateWithoutRestrictionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUpdateOneWithoutSpellNestedInput
    school?: SpellSchoolUpdateOneWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutRestrictionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUncheckedUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUncheckedUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUncheckedUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUncheckedUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput
  }

  export type SpellCreateWithoutEffectsInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleCreateNestedManyWithoutSpellInput
    components?: SpellComponentCreateNestedManyWithoutSpellInput
    messages?: SpellMessageCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingCreateNestedOneWithoutSpellInput
    school?: SpellSchoolCreateNestedOneWithoutSpellsInput
  }

  export type SpellUncheckedCreateWithoutEffectsInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSpells?: CharacterSpellUncheckedCreateNestedManyWithoutSpellInput
    mobSpells?: MobSpellUncheckedCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput
    components?: SpellComponentUncheckedCreateNestedManyWithoutSpellInput
    messages?: SpellMessageUncheckedCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingUncheckedCreateNestedOneWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutEffectsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutEffectsInput, SpellUncheckedCreateWithoutEffectsInput>
  }

  export type SpellUpsertWithoutEffectsInput = {
    update: XOR<SpellUpdateWithoutEffectsInput, SpellUncheckedUpdateWithoutEffectsInput>
    create: XOR<SpellCreateWithoutEffectsInput, SpellUncheckedCreateWithoutEffectsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutEffectsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutEffectsInput, SpellUncheckedUpdateWithoutEffectsInput>
  }

  export type SpellUpdateWithoutEffectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUpdateOneWithoutSpellNestedInput
    school?: SpellSchoolUpdateOneWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutEffectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUncheckedUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUncheckedUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUncheckedUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput
  }

  export type CharacterSkillCreateWithoutSkillInput = {
    id?: string
    level?: number
    experience?: number
    lastUsed?: Date | string | null
    character: CharacterCreateNestedOneWithoutSkillsInput
  }

  export type CharacterSkillUncheckedCreateWithoutSkillInput = {
    id?: string
    characterId: string
    level?: number
    experience?: number
    lastUsed?: Date | string | null
  }

  export type CharacterSkillCreateOrConnectWithoutSkillInput = {
    where: CharacterSkillWhereUniqueInput
    create: XOR<CharacterSkillCreateWithoutSkillInput, CharacterSkillUncheckedCreateWithoutSkillInput>
  }

  export type CharacterSkillCreateManySkillInputEnvelope = {
    data: CharacterSkillCreateManySkillInput | CharacterSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type ClassSkillCreateWithoutSkillInput = {
    category?: $Enums.SkillCategory
    minLevel?: number
    maxLevel?: number
    gameClass: GameClassCreateNestedOneWithoutSkillAccessInput
  }

  export type ClassSkillUncheckedCreateWithoutSkillInput = {
    id?: number
    classId: number
    category?: $Enums.SkillCategory
    minLevel?: number
    maxLevel?: number
  }

  export type ClassSkillCreateOrConnectWithoutSkillInput = {
    where: ClassSkillWhereUniqueInput
    create: XOR<ClassSkillCreateWithoutSkillInput, ClassSkillUncheckedCreateWithoutSkillInput>
  }

  export type ClassSkillCreateManySkillInputEnvelope = {
    data: ClassSkillCreateManySkillInput | ClassSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type MobSkillCreateWithoutSkillInput = {
    level?: number
    mob: MobCreateNestedOneWithoutSkillsInput
  }

  export type MobSkillUncheckedCreateWithoutSkillInput = {
    id?: number
    mobZoneId: number
    mobId: number
    level?: number
  }

  export type MobSkillCreateOrConnectWithoutSkillInput = {
    where: MobSkillWhereUniqueInput
    create: XOR<MobSkillCreateWithoutSkillInput, MobSkillUncheckedCreateWithoutSkillInput>
  }

  export type MobSkillCreateManySkillInputEnvelope = {
    data: MobSkillCreateManySkillInput | MobSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type RaceSkillCreateWithoutSkillInput = {
    race: $Enums.Race
    category?: $Enums.SkillCategory
    bonus?: number
  }

  export type RaceSkillUncheckedCreateWithoutSkillInput = {
    id?: number
    race: $Enums.Race
    category?: $Enums.SkillCategory
    bonus?: number
  }

  export type RaceSkillCreateOrConnectWithoutSkillInput = {
    where: RaceSkillWhereUniqueInput
    create: XOR<RaceSkillCreateWithoutSkillInput, RaceSkillUncheckedCreateWithoutSkillInput>
  }

  export type RaceSkillCreateManySkillInputEnvelope = {
    data: RaceSkillCreateManySkillInput | RaceSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type CharacterSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: CharacterSkillWhereUniqueInput
    update: XOR<CharacterSkillUpdateWithoutSkillInput, CharacterSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<CharacterSkillCreateWithoutSkillInput, CharacterSkillUncheckedCreateWithoutSkillInput>
  }

  export type CharacterSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: CharacterSkillWhereUniqueInput
    data: XOR<CharacterSkillUpdateWithoutSkillInput, CharacterSkillUncheckedUpdateWithoutSkillInput>
  }

  export type CharacterSkillUpdateManyWithWhereWithoutSkillInput = {
    where: CharacterSkillScalarWhereInput
    data: XOR<CharacterSkillUpdateManyMutationInput, CharacterSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type ClassSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: ClassSkillWhereUniqueInput
    update: XOR<ClassSkillUpdateWithoutSkillInput, ClassSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<ClassSkillCreateWithoutSkillInput, ClassSkillUncheckedCreateWithoutSkillInput>
  }

  export type ClassSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: ClassSkillWhereUniqueInput
    data: XOR<ClassSkillUpdateWithoutSkillInput, ClassSkillUncheckedUpdateWithoutSkillInput>
  }

  export type ClassSkillUpdateManyWithWhereWithoutSkillInput = {
    where: ClassSkillScalarWhereInput
    data: XOR<ClassSkillUpdateManyMutationInput, ClassSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type MobSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: MobSkillWhereUniqueInput
    update: XOR<MobSkillUpdateWithoutSkillInput, MobSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<MobSkillCreateWithoutSkillInput, MobSkillUncheckedCreateWithoutSkillInput>
  }

  export type MobSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: MobSkillWhereUniqueInput
    data: XOR<MobSkillUpdateWithoutSkillInput, MobSkillUncheckedUpdateWithoutSkillInput>
  }

  export type MobSkillUpdateManyWithWhereWithoutSkillInput = {
    where: MobSkillScalarWhereInput
    data: XOR<MobSkillUpdateManyMutationInput, MobSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type RaceSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: RaceSkillWhereUniqueInput
    update: XOR<RaceSkillUpdateWithoutSkillInput, RaceSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<RaceSkillCreateWithoutSkillInput, RaceSkillUncheckedCreateWithoutSkillInput>
  }

  export type RaceSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: RaceSkillWhereUniqueInput
    data: XOR<RaceSkillUpdateWithoutSkillInput, RaceSkillUncheckedUpdateWithoutSkillInput>
  }

  export type RaceSkillUpdateManyWithWhereWithoutSkillInput = {
    where: RaceSkillScalarWhereInput
    data: XOR<RaceSkillUpdateManyMutationInput, RaceSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type RaceSkillScalarWhereInput = {
    AND?: RaceSkillScalarWhereInput | RaceSkillScalarWhereInput[]
    OR?: RaceSkillScalarWhereInput[]
    NOT?: RaceSkillScalarWhereInput | RaceSkillScalarWhereInput[]
    id?: IntFilter<"RaceSkill"> | number
    race?: EnumRaceFilter<"RaceSkill"> | $Enums.Race
    skillId?: IntFilter<"RaceSkill"> | number
    category?: EnumSkillCategoryFilter<"RaceSkill"> | $Enums.SkillCategory
    bonus?: IntFilter<"RaceSkill"> | number
  }

  export type GameClassCreateWithoutSkillAccessInput = {
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutGameClassInput
    mobs?: MobCreateNestedManyWithoutGameClassInput
    spellCircles?: SpellClassCircleCreateNestedManyWithoutGameClassInput
  }

  export type GameClassUncheckedCreateWithoutSkillAccessInput = {
    id?: number
    name: string
    description?: string | null
    hitDice?: string
    primaryStat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutGameClassInput
    mobs?: MobUncheckedCreateNestedManyWithoutGameClassInput
    spellCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutGameClassInput
  }

  export type GameClassCreateOrConnectWithoutSkillAccessInput = {
    where: GameClassWhereUniqueInput
    create: XOR<GameClassCreateWithoutSkillAccessInput, GameClassUncheckedCreateWithoutSkillAccessInput>
  }

  export type SkillCreateWithoutClassSkillsInput = {
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSkills?: CharacterSkillCreateNestedManyWithoutSkillInput
    mobSkills?: MobSkillCreateNestedManyWithoutSkillInput
    raceSkills?: RaceSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutClassSkillsInput = {
    id?: number
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutSkillInput
    mobSkills?: MobSkillUncheckedCreateNestedManyWithoutSkillInput
    raceSkills?: RaceSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutClassSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutClassSkillsInput, SkillUncheckedCreateWithoutClassSkillsInput>
  }

  export type GameClassUpsertWithoutSkillAccessInput = {
    update: XOR<GameClassUpdateWithoutSkillAccessInput, GameClassUncheckedUpdateWithoutSkillAccessInput>
    create: XOR<GameClassCreateWithoutSkillAccessInput, GameClassUncheckedCreateWithoutSkillAccessInput>
    where?: GameClassWhereInput
  }

  export type GameClassUpdateToOneWithWhereWithoutSkillAccessInput = {
    where?: GameClassWhereInput
    data: XOR<GameClassUpdateWithoutSkillAccessInput, GameClassUncheckedUpdateWithoutSkillAccessInput>
  }

  export type GameClassUpdateWithoutSkillAccessInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutGameClassNestedInput
    mobs?: MobUpdateManyWithoutGameClassNestedInput
    spellCircles?: SpellClassCircleUpdateManyWithoutGameClassNestedInput
  }

  export type GameClassUncheckedUpdateWithoutSkillAccessInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hitDice?: StringFieldUpdateOperationsInput | string
    primaryStat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutGameClassNestedInput
    mobs?: MobUncheckedUpdateManyWithoutGameClassNestedInput
    spellCircles?: SpellClassCircleUncheckedUpdateManyWithoutGameClassNestedInput
  }

  export type SkillUpsertWithoutClassSkillsInput = {
    update: XOR<SkillUpdateWithoutClassSkillsInput, SkillUncheckedUpdateWithoutClassSkillsInput>
    create: XOR<SkillCreateWithoutClassSkillsInput, SkillUncheckedCreateWithoutClassSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutClassSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutClassSkillsInput, SkillUncheckedUpdateWithoutClassSkillsInput>
  }

  export type SkillUpdateWithoutClassSkillsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSkills?: CharacterSkillUpdateManyWithoutSkillNestedInput
    mobSkills?: MobSkillUpdateManyWithoutSkillNestedInput
    raceSkills?: RaceSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutClassSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutSkillNestedInput
    mobSkills?: MobSkillUncheckedUpdateManyWithoutSkillNestedInput
    raceSkills?: RaceSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateWithoutRaceSkillsInput = {
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSkills?: CharacterSkillCreateNestedManyWithoutSkillInput
    classSkills?: ClassSkillCreateNestedManyWithoutSkillInput
    mobSkills?: MobSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutRaceSkillsInput = {
    id?: number
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutSkillInput
    classSkills?: ClassSkillUncheckedCreateNestedManyWithoutSkillInput
    mobSkills?: MobSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutRaceSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutRaceSkillsInput, SkillUncheckedCreateWithoutRaceSkillsInput>
  }

  export type SkillUpsertWithoutRaceSkillsInput = {
    update: XOR<SkillUpdateWithoutRaceSkillsInput, SkillUncheckedUpdateWithoutRaceSkillsInput>
    create: XOR<SkillCreateWithoutRaceSkillsInput, SkillUncheckedCreateWithoutRaceSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutRaceSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutRaceSkillsInput, SkillUncheckedUpdateWithoutRaceSkillsInput>
  }

  export type SkillUpdateWithoutRaceSkillsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSkills?: CharacterSkillUpdateManyWithoutSkillNestedInput
    classSkills?: ClassSkillUpdateManyWithoutSkillNestedInput
    mobSkills?: MobSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutRaceSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutSkillNestedInput
    classSkills?: ClassSkillUncheckedUpdateManyWithoutSkillNestedInput
    mobSkills?: MobSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type CharacterCreateWithoutSkillsInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectCreateNestedManyWithoutCharacterInput
    items?: CharacterItemCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellCreateNestedManyWithoutCharacterInput
    gameClass?: GameClassCreateNestedOneWithoutCharactersInput
    user: UserCreateNestedOneWithoutCharactersInput
  }

  export type CharacterUncheckedCreateWithoutSkillsInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: number | null
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectUncheckedCreateNestedManyWithoutCharacterInput
    items?: CharacterItemUncheckedCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutSkillsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutSkillsInput, CharacterUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutCharacterSkillsInput = {
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classSkills?: ClassSkillCreateNestedManyWithoutSkillInput
    mobSkills?: MobSkillCreateNestedManyWithoutSkillInput
    raceSkills?: RaceSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutCharacterSkillsInput = {
    id?: number
    name: string
    description?: string | null
    type: $Enums.SkillType
    category?: $Enums.SkillCategory
    maxLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classSkills?: ClassSkillUncheckedCreateNestedManyWithoutSkillInput
    mobSkills?: MobSkillUncheckedCreateNestedManyWithoutSkillInput
    raceSkills?: RaceSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutCharacterSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutCharacterSkillsInput, SkillUncheckedCreateWithoutCharacterSkillsInput>
  }

  export type CharacterUpsertWithoutSkillsInput = {
    update: XOR<CharacterUpdateWithoutSkillsInput, CharacterUncheckedUpdateWithoutSkillsInput>
    create: XOR<CharacterCreateWithoutSkillsInput, CharacterUncheckedCreateWithoutSkillsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutSkillsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutSkillsInput, CharacterUncheckedUpdateWithoutSkillsInput>
  }

  export type CharacterUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUpdateManyWithoutCharacterNestedInput
    items?: CharacterItemUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUpdateManyWithoutCharacterNestedInput
    gameClass?: GameClassUpdateOneWithoutCharactersNestedInput
    user?: UserUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type CharacterUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUncheckedUpdateManyWithoutCharacterNestedInput
    items?: CharacterItemUncheckedUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type SkillUpsertWithoutCharacterSkillsInput = {
    update: XOR<SkillUpdateWithoutCharacterSkillsInput, SkillUncheckedUpdateWithoutCharacterSkillsInput>
    create: XOR<SkillCreateWithoutCharacterSkillsInput, SkillUncheckedCreateWithoutCharacterSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutCharacterSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutCharacterSkillsInput, SkillUncheckedUpdateWithoutCharacterSkillsInput>
  }

  export type SkillUpdateWithoutCharacterSkillsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classSkills?: ClassSkillUpdateManyWithoutSkillNestedInput
    mobSkills?: MobSkillUpdateManyWithoutSkillNestedInput
    raceSkills?: RaceSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutCharacterSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSkillTypeFieldUpdateOperationsInput | $Enums.SkillType
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    maxLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classSkills?: ClassSkillUncheckedUpdateManyWithoutSkillNestedInput
    mobSkills?: MobSkillUncheckedUpdateManyWithoutSkillNestedInput
    raceSkills?: RaceSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type CharacterCreateWithoutSpellsInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectCreateNestedManyWithoutCharacterInput
    items?: CharacterItemCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    gameClass?: GameClassCreateNestedOneWithoutCharactersInput
    user: UserCreateNestedOneWithoutCharactersInput
  }

  export type CharacterUncheckedCreateWithoutSpellsInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: number | null
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectUncheckedCreateNestedManyWithoutCharacterInput
    items?: CharacterItemUncheckedCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutSpellsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutSpellsInput, CharacterUncheckedCreateWithoutSpellsInput>
  }

  export type SpellCreateWithoutCharacterSpellsInput = {
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mobSpells?: MobSpellCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleCreateNestedManyWithoutSpellInput
    components?: SpellComponentCreateNestedManyWithoutSpellInput
    effects?: SpellEffectCreateNestedManyWithoutSpellInput
    messages?: SpellMessageCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingCreateNestedOneWithoutSpellInput
    school?: SpellSchoolCreateNestedOneWithoutSpellsInput
  }

  export type SpellUncheckedCreateWithoutCharacterSpellsInput = {
    id?: number
    name: string
    schoolId?: number | null
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mobSpells?: MobSpellUncheckedCreateNestedManyWithoutSpellInput
    classCircles?: SpellClassCircleUncheckedCreateNestedManyWithoutSpellInput
    components?: SpellComponentUncheckedCreateNestedManyWithoutSpellInput
    effects?: SpellEffectUncheckedCreateNestedManyWithoutSpellInput
    messages?: SpellMessageUncheckedCreateNestedOneWithoutSpellInput
    restrictions?: SpellRestrictionUncheckedCreateNestedOneWithoutSpellInput
    savingThrows?: SpellSavingThrowUncheckedCreateNestedManyWithoutSpellInput
    targeting?: SpellTargetingUncheckedCreateNestedOneWithoutSpellInput
  }

  export type SpellCreateOrConnectWithoutCharacterSpellsInput = {
    where: SpellWhereUniqueInput
    create: XOR<SpellCreateWithoutCharacterSpellsInput, SpellUncheckedCreateWithoutCharacterSpellsInput>
  }

  export type CharacterUpsertWithoutSpellsInput = {
    update: XOR<CharacterUpdateWithoutSpellsInput, CharacterUncheckedUpdateWithoutSpellsInput>
    create: XOR<CharacterCreateWithoutSpellsInput, CharacterUncheckedCreateWithoutSpellsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutSpellsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutSpellsInput, CharacterUncheckedUpdateWithoutSpellsInput>
  }

  export type CharacterUpdateWithoutSpellsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUpdateManyWithoutCharacterNestedInput
    items?: CharacterItemUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    gameClass?: GameClassUpdateOneWithoutCharactersNestedInput
    user?: UserUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type CharacterUncheckedUpdateWithoutSpellsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUncheckedUpdateManyWithoutCharacterNestedInput
    items?: CharacterItemUncheckedUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type SpellUpsertWithoutCharacterSpellsInput = {
    update: XOR<SpellUpdateWithoutCharacterSpellsInput, SpellUncheckedUpdateWithoutCharacterSpellsInput>
    create: XOR<SpellCreateWithoutCharacterSpellsInput, SpellUncheckedCreateWithoutCharacterSpellsInput>
    where?: SpellWhereInput
  }

  export type SpellUpdateToOneWithWhereWithoutCharacterSpellsInput = {
    where?: SpellWhereInput
    data: XOR<SpellUpdateWithoutCharacterSpellsInput, SpellUncheckedUpdateWithoutCharacterSpellsInput>
  }

  export type SpellUpdateWithoutCharacterSpellsInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mobSpells?: MobSpellUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUpdateOneWithoutSpellNestedInput
    school?: SpellSchoolUpdateOneWithoutSpellsNestedInput
  }

  export type SpellUncheckedUpdateWithoutCharacterSpellsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mobSpells?: MobSpellUncheckedUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUncheckedUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUncheckedUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUncheckedUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput
  }

  export type UserCreateWithoutChangeLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    issuedBans?: BanRecordCreateNestedManyWithoutAdminInput
    banRecords?: BanRecordCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChangeLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    issuedBans?: BanRecordUncheckedCreateNestedManyWithoutAdminInput
    banRecords?: BanRecordUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChangeLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChangeLogsInput, UserUncheckedCreateWithoutChangeLogsInput>
  }

  export type UserUpsertWithoutChangeLogsInput = {
    update: XOR<UserUpdateWithoutChangeLogsInput, UserUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<UserCreateWithoutChangeLogsInput, UserUncheckedCreateWithoutChangeLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChangeLogsInput, UserUncheckedUpdateWithoutChangeLogsInput>
  }

  export type UserUpdateWithoutChangeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    issuedBans?: BanRecordUpdateManyWithoutAdminNestedInput
    banRecords?: BanRecordUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChangeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    issuedBans?: BanRecordUncheckedUpdateManyWithoutAdminNestedInput
    banRecords?: BanRecordUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutIssuedBansInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    banRecords?: BanRecordCreateNestedManyWithoutUserInput
    changeLogs?: ChangeLogCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIssuedBansInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    banRecords?: BanRecordUncheckedCreateNestedManyWithoutUserInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIssuedBansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIssuedBansInput, UserUncheckedCreateWithoutIssuedBansInput>
  }

  export type UserCreateWithoutBanRecordsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    issuedBans?: BanRecordCreateNestedManyWithoutAdminInput
    changeLogs?: ChangeLogCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBanRecordsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    lastFailedLogin?: Date | string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    issuedBans?: BanRecordUncheckedCreateNestedManyWithoutAdminInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBanRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBanRecordsInput, UserUncheckedCreateWithoutBanRecordsInput>
  }

  export type UserUpsertWithoutIssuedBansInput = {
    update: XOR<UserUpdateWithoutIssuedBansInput, UserUncheckedUpdateWithoutIssuedBansInput>
    create: XOR<UserCreateWithoutIssuedBansInput, UserUncheckedCreateWithoutIssuedBansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIssuedBansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIssuedBansInput, UserUncheckedUpdateWithoutIssuedBansInput>
  }

  export type UserUpdateWithoutIssuedBansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    banRecords?: BanRecordUpdateManyWithoutUserNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIssuedBansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    banRecords?: BanRecordUncheckedUpdateManyWithoutUserNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutBanRecordsInput = {
    update: XOR<UserUpdateWithoutBanRecordsInput, UserUncheckedUpdateWithoutBanRecordsInput>
    create: XOR<UserCreateWithoutBanRecordsInput, UserUncheckedCreateWithoutBanRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBanRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBanRecordsInput, UserUncheckedUpdateWithoutBanRecordsInput>
  }

  export type UserUpdateWithoutBanRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    issuedBans?: BanRecordUpdateManyWithoutAdminNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBanRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailedLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    issuedBans?: BanRecordUncheckedUpdateManyWithoutAdminNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CharacterCreateWithoutItemsInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellCreateNestedManyWithoutCharacterInput
    gameClass?: GameClassCreateNestedOneWithoutCharactersInput
    user: UserCreateNestedOneWithoutCharactersInput
  }

  export type CharacterUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: number | null
    experience?: number
    skillPoints?: number
    effects?: CharacterEffectUncheckedCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutItemsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutItemsInput, CharacterUncheckedCreateWithoutItemsInput>
  }

  export type CharacterItemCreateWithoutContainedItemsInput = {
    id?: string
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    character: CharacterCreateNestedOneWithoutItemsInput
    container?: CharacterItemCreateNestedOneWithoutContainedItemsInput
    object: ObjectCreateNestedOneWithoutCharacterItemsInput
  }

  export type CharacterItemUncheckedCreateWithoutContainedItemsInput = {
    id?: string
    characterId: string
    object_zone_id: number
    object_id: number
    containerId?: string | null
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterItemCreateOrConnectWithoutContainedItemsInput = {
    where: CharacterItemWhereUniqueInput
    create: XOR<CharacterItemCreateWithoutContainedItemsInput, CharacterItemUncheckedCreateWithoutContainedItemsInput>
  }

  export type CharacterItemCreateWithoutContainerInput = {
    id?: string
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    character: CharacterCreateNestedOneWithoutItemsInput
    containedItems?: CharacterItemCreateNestedManyWithoutContainerInput
    object: ObjectCreateNestedOneWithoutCharacterItemsInput
  }

  export type CharacterItemUncheckedCreateWithoutContainerInput = {
    id?: string
    characterId: string
    object_zone_id: number
    object_id: number
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    containedItems?: CharacterItemUncheckedCreateNestedManyWithoutContainerInput
  }

  export type CharacterItemCreateOrConnectWithoutContainerInput = {
    where: CharacterItemWhereUniqueInput
    create: XOR<CharacterItemCreateWithoutContainerInput, CharacterItemUncheckedCreateWithoutContainerInput>
  }

  export type CharacterItemCreateManyContainerInputEnvelope = {
    data: CharacterItemCreateManyContainerInput | CharacterItemCreateManyContainerInput[]
    skipDuplicates?: boolean
  }

  export type ObjectCreateWithoutCharacterItemsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutCharacterItemsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutCharacterItemsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutCharacterItemsInput, ObjectUncheckedCreateWithoutCharacterItemsInput>
  }

  export type CharacterUpsertWithoutItemsInput = {
    update: XOR<CharacterUpdateWithoutItemsInput, CharacterUncheckedUpdateWithoutItemsInput>
    create: XOR<CharacterCreateWithoutItemsInput, CharacterUncheckedCreateWithoutItemsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutItemsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutItemsInput, CharacterUncheckedUpdateWithoutItemsInput>
  }

  export type CharacterUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUpdateManyWithoutCharacterNestedInput
    gameClass?: GameClassUpdateOneWithoutCharactersNestedInput
    user?: UserUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type CharacterUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUncheckedUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterItemUpsertWithoutContainedItemsInput = {
    update: XOR<CharacterItemUpdateWithoutContainedItemsInput, CharacterItemUncheckedUpdateWithoutContainedItemsInput>
    create: XOR<CharacterItemCreateWithoutContainedItemsInput, CharacterItemUncheckedCreateWithoutContainedItemsInput>
    where?: CharacterItemWhereInput
  }

  export type CharacterItemUpdateToOneWithWhereWithoutContainedItemsInput = {
    where?: CharacterItemWhereInput
    data: XOR<CharacterItemUpdateWithoutContainedItemsInput, CharacterItemUncheckedUpdateWithoutContainedItemsInput>
  }

  export type CharacterItemUpdateWithoutContainedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutItemsNestedInput
    container?: CharacterItemUpdateOneWithoutContainedItemsNestedInput
    object?: ObjectUpdateOneRequiredWithoutCharacterItemsNestedInput
  }

  export type CharacterItemUncheckedUpdateWithoutContainedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    object_zone_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterItemUpsertWithWhereUniqueWithoutContainerInput = {
    where: CharacterItemWhereUniqueInput
    update: XOR<CharacterItemUpdateWithoutContainerInput, CharacterItemUncheckedUpdateWithoutContainerInput>
    create: XOR<CharacterItemCreateWithoutContainerInput, CharacterItemUncheckedCreateWithoutContainerInput>
  }

  export type CharacterItemUpdateWithWhereUniqueWithoutContainerInput = {
    where: CharacterItemWhereUniqueInput
    data: XOR<CharacterItemUpdateWithoutContainerInput, CharacterItemUncheckedUpdateWithoutContainerInput>
  }

  export type CharacterItemUpdateManyWithWhereWithoutContainerInput = {
    where: CharacterItemScalarWhereInput
    data: XOR<CharacterItemUpdateManyMutationInput, CharacterItemUncheckedUpdateManyWithoutContainerInput>
  }

  export type ObjectUpsertWithoutCharacterItemsInput = {
    update: XOR<ObjectUpdateWithoutCharacterItemsInput, ObjectUncheckedUpdateWithoutCharacterItemsInput>
    create: XOR<ObjectCreateWithoutCharacterItemsInput, ObjectUncheckedCreateWithoutCharacterItemsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutCharacterItemsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutCharacterItemsInput, ObjectUncheckedUpdateWithoutCharacterItemsInput>
  }

  export type ObjectUpdateWithoutCharacterItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutCharacterItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type CharacterCreateWithoutEffectsInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    experience?: number
    skillPoints?: number
    items?: CharacterItemCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellCreateNestedManyWithoutCharacterInput
    gameClass?: GameClassCreateNestedOneWithoutCharactersInput
    user: UserCreateNestedOneWithoutCharactersInput
  }

  export type CharacterUncheckedCreateWithoutEffectsInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: number | null
    experience?: number
    skillPoints?: number
    items?: CharacterItemUncheckedCreateNestedManyWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    spells?: CharacterSpellUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutEffectsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutEffectsInput, CharacterUncheckedCreateWithoutEffectsInput>
  }

  export type CharacterUpsertWithoutEffectsInput = {
    update: XOR<CharacterUpdateWithoutEffectsInput, CharacterUncheckedUpdateWithoutEffectsInput>
    create: XOR<CharacterCreateWithoutEffectsInput, CharacterUncheckedCreateWithoutEffectsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutEffectsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutEffectsInput, CharacterUncheckedUpdateWithoutEffectsInput>
  }

  export type CharacterUpdateWithoutEffectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    items?: CharacterItemUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUpdateManyWithoutCharacterNestedInput
    gameClass?: GameClassUpdateOneWithoutCharactersNestedInput
    user?: UserUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type CharacterUncheckedUpdateWithoutEffectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    items?: CharacterItemUncheckedUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type EquipmentSetCreateWithoutItemsInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mobEquipmentSets?: MobEquipmentSetCreateNestedManyWithoutEquipmentSetInput
  }

  export type EquipmentSetUncheckedCreateWithoutItemsInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mobEquipmentSets?: MobEquipmentSetUncheckedCreateNestedManyWithoutEquipmentSetInput
  }

  export type EquipmentSetCreateOrConnectWithoutItemsInput = {
    where: EquipmentSetWhereUniqueInput
    create: XOR<EquipmentSetCreateWithoutItemsInput, EquipmentSetUncheckedCreateWithoutItemsInput>
  }

  export type ObjectCreateWithoutEquipmentSetItemsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    resets?: ObjectResetCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutEquipmentSetItemsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    resets?: ObjectResetUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutEquipmentSetItemsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutEquipmentSetItemsInput, ObjectUncheckedCreateWithoutEquipmentSetItemsInput>
  }

  export type EquipmentSetUpsertWithoutItemsInput = {
    update: XOR<EquipmentSetUpdateWithoutItemsInput, EquipmentSetUncheckedUpdateWithoutItemsInput>
    create: XOR<EquipmentSetCreateWithoutItemsInput, EquipmentSetUncheckedCreateWithoutItemsInput>
    where?: EquipmentSetWhereInput
  }

  export type EquipmentSetUpdateToOneWithWhereWithoutItemsInput = {
    where?: EquipmentSetWhereInput
    data: XOR<EquipmentSetUpdateWithoutItemsInput, EquipmentSetUncheckedUpdateWithoutItemsInput>
  }

  export type EquipmentSetUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mobEquipmentSets?: MobEquipmentSetUpdateManyWithoutEquipmentSetNestedInput
  }

  export type EquipmentSetUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mobEquipmentSets?: MobEquipmentSetUncheckedUpdateManyWithoutEquipmentSetNestedInput
  }

  export type ObjectUpsertWithoutEquipmentSetItemsInput = {
    update: XOR<ObjectUpdateWithoutEquipmentSetItemsInput, ObjectUncheckedUpdateWithoutEquipmentSetItemsInput>
    create: XOR<ObjectCreateWithoutEquipmentSetItemsInput, ObjectUncheckedCreateWithoutEquipmentSetItemsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutEquipmentSetItemsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutEquipmentSetItemsInput, ObjectUncheckedUpdateWithoutEquipmentSetItemsInput>
  }

  export type ObjectUpdateWithoutEquipmentSetItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutEquipmentSetItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type EquipmentSetItemCreateWithoutEquipmentSetInput = {
    id: string
    slot?: string | null
    quantity?: number
    probability?: number
    object: ObjectCreateNestedOneWithoutEquipmentSetItemsInput
  }

  export type EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput = {
    id: string
    objectZoneId: number
    objectId: number
    slot?: string | null
    quantity?: number
    probability?: number
  }

  export type EquipmentSetItemCreateOrConnectWithoutEquipmentSetInput = {
    where: EquipmentSetItemWhereUniqueInput
    create: XOR<EquipmentSetItemCreateWithoutEquipmentSetInput, EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput>
  }

  export type EquipmentSetItemCreateManyEquipmentSetInputEnvelope = {
    data: EquipmentSetItemCreateManyEquipmentSetInput | EquipmentSetItemCreateManyEquipmentSetInput[]
    skipDuplicates?: boolean
  }

  export type MobEquipmentSetCreateWithoutEquipmentSetInput = {
    id: string
    probability?: number
    mobReset: MobResetCreateNestedOneWithoutEquipmentSetsInput
  }

  export type MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput = {
    id: string
    mobResetId: string
    probability?: number
  }

  export type MobEquipmentSetCreateOrConnectWithoutEquipmentSetInput = {
    where: MobEquipmentSetWhereUniqueInput
    create: XOR<MobEquipmentSetCreateWithoutEquipmentSetInput, MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput>
  }

  export type MobEquipmentSetCreateManyEquipmentSetInputEnvelope = {
    data: MobEquipmentSetCreateManyEquipmentSetInput | MobEquipmentSetCreateManyEquipmentSetInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentSetItemUpsertWithWhereUniqueWithoutEquipmentSetInput = {
    where: EquipmentSetItemWhereUniqueInput
    update: XOR<EquipmentSetItemUpdateWithoutEquipmentSetInput, EquipmentSetItemUncheckedUpdateWithoutEquipmentSetInput>
    create: XOR<EquipmentSetItemCreateWithoutEquipmentSetInput, EquipmentSetItemUncheckedCreateWithoutEquipmentSetInput>
  }

  export type EquipmentSetItemUpdateWithWhereUniqueWithoutEquipmentSetInput = {
    where: EquipmentSetItemWhereUniqueInput
    data: XOR<EquipmentSetItemUpdateWithoutEquipmentSetInput, EquipmentSetItemUncheckedUpdateWithoutEquipmentSetInput>
  }

  export type EquipmentSetItemUpdateManyWithWhereWithoutEquipmentSetInput = {
    where: EquipmentSetItemScalarWhereInput
    data: XOR<EquipmentSetItemUpdateManyMutationInput, EquipmentSetItemUncheckedUpdateManyWithoutEquipmentSetInput>
  }

  export type MobEquipmentSetUpsertWithWhereUniqueWithoutEquipmentSetInput = {
    where: MobEquipmentSetWhereUniqueInput
    update: XOR<MobEquipmentSetUpdateWithoutEquipmentSetInput, MobEquipmentSetUncheckedUpdateWithoutEquipmentSetInput>
    create: XOR<MobEquipmentSetCreateWithoutEquipmentSetInput, MobEquipmentSetUncheckedCreateWithoutEquipmentSetInput>
  }

  export type MobEquipmentSetUpdateWithWhereUniqueWithoutEquipmentSetInput = {
    where: MobEquipmentSetWhereUniqueInput
    data: XOR<MobEquipmentSetUpdateWithoutEquipmentSetInput, MobEquipmentSetUncheckedUpdateWithoutEquipmentSetInput>
  }

  export type MobEquipmentSetUpdateManyWithWhereWithoutEquipmentSetInput = {
    where: MobEquipmentSetScalarWhereInput
    data: XOR<MobEquipmentSetUpdateManyMutationInput, MobEquipmentSetUncheckedUpdateManyWithoutEquipmentSetInput>
  }

  export type EquipmentSetCreateWithoutMobEquipmentSetsInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    items?: EquipmentSetItemCreateNestedManyWithoutEquipmentSetInput
  }

  export type EquipmentSetUncheckedCreateWithoutMobEquipmentSetsInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    items?: EquipmentSetItemUncheckedCreateNestedManyWithoutEquipmentSetInput
  }

  export type EquipmentSetCreateOrConnectWithoutMobEquipmentSetsInput = {
    where: EquipmentSetWhereUniqueInput
    create: XOR<EquipmentSetCreateWithoutMobEquipmentSetsInput, EquipmentSetUncheckedCreateWithoutMobEquipmentSetsInput>
  }

  export type MobResetCreateWithoutEquipmentSetsInput = {
    id?: string
    max?: number
    name?: string | null
    probability?: number
    carrying?: MobCarryingCreateNestedManyWithoutResetInput
    equipped?: MobEquippedCreateNestedManyWithoutResetInput
    mob: MobCreateNestedOneWithoutResetsInput
    room: RoomCreateNestedOneWithoutMobResetsInput
    zone: ZoneCreateNestedOneWithoutMobResetsInput
    spawnConditions?: SpawnConditionCreateNestedManyWithoutMobResetInput
  }

  export type MobResetUncheckedCreateWithoutEquipmentSetsInput = {
    id?: string
    max?: number
    name?: string | null
    mobZoneId: number
    mobId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
    carrying?: MobCarryingUncheckedCreateNestedManyWithoutResetInput
    equipped?: MobEquippedUncheckedCreateNestedManyWithoutResetInput
    spawnConditions?: SpawnConditionUncheckedCreateNestedManyWithoutMobResetInput
  }

  export type MobResetCreateOrConnectWithoutEquipmentSetsInput = {
    where: MobResetWhereUniqueInput
    create: XOR<MobResetCreateWithoutEquipmentSetsInput, MobResetUncheckedCreateWithoutEquipmentSetsInput>
  }

  export type EquipmentSetUpsertWithoutMobEquipmentSetsInput = {
    update: XOR<EquipmentSetUpdateWithoutMobEquipmentSetsInput, EquipmentSetUncheckedUpdateWithoutMobEquipmentSetsInput>
    create: XOR<EquipmentSetCreateWithoutMobEquipmentSetsInput, EquipmentSetUncheckedCreateWithoutMobEquipmentSetsInput>
    where?: EquipmentSetWhereInput
  }

  export type EquipmentSetUpdateToOneWithWhereWithoutMobEquipmentSetsInput = {
    where?: EquipmentSetWhereInput
    data: XOR<EquipmentSetUpdateWithoutMobEquipmentSetsInput, EquipmentSetUncheckedUpdateWithoutMobEquipmentSetsInput>
  }

  export type EquipmentSetUpdateWithoutMobEquipmentSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: EquipmentSetItemUpdateManyWithoutEquipmentSetNestedInput
  }

  export type EquipmentSetUncheckedUpdateWithoutMobEquipmentSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: EquipmentSetItemUncheckedUpdateManyWithoutEquipmentSetNestedInput
  }

  export type MobResetUpsertWithoutEquipmentSetsInput = {
    update: XOR<MobResetUpdateWithoutEquipmentSetsInput, MobResetUncheckedUpdateWithoutEquipmentSetsInput>
    create: XOR<MobResetCreateWithoutEquipmentSetsInput, MobResetUncheckedCreateWithoutEquipmentSetsInput>
    where?: MobResetWhereInput
  }

  export type MobResetUpdateToOneWithWhereWithoutEquipmentSetsInput = {
    where?: MobResetWhereInput
    data: XOR<MobResetUpdateWithoutEquipmentSetsInput, MobResetUncheckedUpdateWithoutEquipmentSetsInput>
  }

  export type MobResetUpdateWithoutEquipmentSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUpdateManyWithoutResetNestedInput
    equipped?: MobEquippedUpdateManyWithoutResetNestedInput
    mob?: MobUpdateOneRequiredWithoutResetsNestedInput
    room?: RoomUpdateOneRequiredWithoutMobResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetUncheckedUpdateWithoutEquipmentSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUncheckedUpdateManyWithoutResetNestedInput
    equipped?: MobEquippedUncheckedUpdateManyWithoutResetNestedInput
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutMobResetNestedInput
  }

  export type ObjectCreateWithoutResetsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellCreateNestedManyWithoutObjectInput
    zone: ZoneCreateNestedOneWithoutObjectsInput
    shopItems?: ShopItemCreateNestedManyWithoutObjectInput
    triggers?: TriggerCreateNestedManyWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutResetsInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedCreateNestedManyWithoutObjectInput
    equipmentSetItems?: EquipmentSetItemUncheckedCreateNestedManyWithoutObjectInput
    mobCarrying?: MobCarryingUncheckedCreateNestedManyWithoutObjectInput
    mobEquipped?: MobEquippedUncheckedCreateNestedManyWithoutObjectInput
    affects?: ObjectAffectUncheckedCreateNestedManyWithoutObjectInput
    extraDescs?: ObjectExtraDescriptionUncheckedCreateNestedManyWithoutObjectInput
    spells?: ObjectSpellUncheckedCreateNestedManyWithoutObjectInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutObjectInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutObjectInput
  }

  export type ObjectCreateOrConnectWithoutResetsInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutResetsInput, ObjectUncheckedCreateWithoutResetsInput>
  }

  export type RoomCreateWithoutObjectResetsInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    mobResets?: MobResetCreateNestedManyWithoutRoomInput
    exits?: RoomExitCreateNestedManyWithoutRoomInput
    extraDescs?: RoomExtraDescriptionCreateNestedManyWithoutRoomInput
    zone: ZoneCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutObjectResetsInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutRoomInput
    exits?: RoomExitUncheckedCreateNestedManyWithoutRoomInput
    extraDescs?: RoomExtraDescriptionUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutObjectResetsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutObjectResetsInput, RoomUncheckedCreateWithoutObjectResetsInput>
  }

  export type ZoneCreateWithoutObjectResetsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetCreateNestedManyWithoutZoneInput
    mobs?: MobCreateNestedManyWithoutZoneInput
    objects?: ObjectCreateNestedManyWithoutZoneInput
    rooms?: RoomCreateNestedManyWithoutZoneInput
    shops?: ShopCreateNestedManyWithoutZoneInput
    triggers?: TriggerCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutObjectResetsInput = {
    id: number
    name: string
    lifespan?: number
    resetMode?: $Enums.ResetMode
    hemisphere?: $Enums.Hemisphere
    climate?: $Enums.Climate
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    mobResets?: MobResetUncheckedCreateNestedManyWithoutZoneInput
    mobs?: MobUncheckedCreateNestedManyWithoutZoneInput
    objects?: ObjectUncheckedCreateNestedManyWithoutZoneInput
    rooms?: RoomUncheckedCreateNestedManyWithoutZoneInput
    shops?: ShopUncheckedCreateNestedManyWithoutZoneInput
    triggers?: TriggerUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutObjectResetsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutObjectResetsInput, ZoneUncheckedCreateWithoutObjectResetsInput>
  }

  export type SpawnConditionCreateWithoutObjectResetInput = {
    id: string
    type: string
    parameters?: JsonNullValueInput | InputJsonValue
    mobReset?: MobResetCreateNestedOneWithoutSpawnConditionsInput
  }

  export type SpawnConditionUncheckedCreateWithoutObjectResetInput = {
    id: string
    type: string
    parameters?: JsonNullValueInput | InputJsonValue
    mobResetId?: string | null
  }

  export type SpawnConditionCreateOrConnectWithoutObjectResetInput = {
    where: SpawnConditionWhereUniqueInput
    create: XOR<SpawnConditionCreateWithoutObjectResetInput, SpawnConditionUncheckedCreateWithoutObjectResetInput>
  }

  export type SpawnConditionCreateManyObjectResetInputEnvelope = {
    data: SpawnConditionCreateManyObjectResetInput | SpawnConditionCreateManyObjectResetInput[]
    skipDuplicates?: boolean
  }

  export type ObjectUpsertWithoutResetsInput = {
    update: XOR<ObjectUpdateWithoutResetsInput, ObjectUncheckedUpdateWithoutResetsInput>
    create: XOR<ObjectCreateWithoutResetsInput, ObjectUncheckedCreateWithoutResetsInput>
    where?: ObjectWhereInput
  }

  export type ObjectUpdateToOneWithWhereWithoutResetsInput = {
    where?: ObjectWhereInput
    data: XOR<ObjectUpdateWithoutResetsInput, ObjectUncheckedUpdateWithoutResetsInput>
  }

  export type ObjectUpdateWithoutResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectsNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type RoomUpsertWithoutObjectResetsInput = {
    update: XOR<RoomUpdateWithoutObjectResetsInput, RoomUncheckedUpdateWithoutObjectResetsInput>
    create: XOR<RoomCreateWithoutObjectResetsInput, RoomUncheckedCreateWithoutObjectResetsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutObjectResetsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutObjectResetsInput, RoomUncheckedUpdateWithoutObjectResetsInput>
  }

  export type RoomUpdateWithoutObjectResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    mobResets?: MobResetUpdateManyWithoutRoomNestedInput
    exits?: RoomExitUpdateManyWithoutRoomNestedInput
    extraDescs?: RoomExtraDescriptionUpdateManyWithoutRoomNestedInput
    zone?: ZoneUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutObjectResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    mobResets?: MobResetUncheckedUpdateManyWithoutRoomNestedInput
    exits?: RoomExitUncheckedUpdateManyWithoutRoomNestedInput
    extraDescs?: RoomExtraDescriptionUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ZoneUpsertWithoutObjectResetsInput = {
    update: XOR<ZoneUpdateWithoutObjectResetsInput, ZoneUncheckedUpdateWithoutObjectResetsInput>
    create: XOR<ZoneCreateWithoutObjectResetsInput, ZoneUncheckedCreateWithoutObjectResetsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutObjectResetsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutObjectResetsInput, ZoneUncheckedUpdateWithoutObjectResetsInput>
  }

  export type ZoneUpdateWithoutObjectResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUpdateManyWithoutZoneNestedInput
    mobs?: MobUpdateManyWithoutZoneNestedInput
    objects?: ObjectUpdateManyWithoutZoneNestedInput
    rooms?: RoomUpdateManyWithoutZoneNestedInput
    shops?: ShopUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutObjectResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lifespan?: IntFieldUpdateOperationsInput | number
    resetMode?: EnumResetModeFieldUpdateOperationsInput | $Enums.ResetMode
    hemisphere?: EnumHemisphereFieldUpdateOperationsInput | $Enums.Hemisphere
    climate?: EnumClimateFieldUpdateOperationsInput | $Enums.Climate
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    mobResets?: MobResetUncheckedUpdateManyWithoutZoneNestedInput
    mobs?: MobUncheckedUpdateManyWithoutZoneNestedInput
    objects?: ObjectUncheckedUpdateManyWithoutZoneNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutZoneNestedInput
    shops?: ShopUncheckedUpdateManyWithoutZoneNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type SpawnConditionUpsertWithWhereUniqueWithoutObjectResetInput = {
    where: SpawnConditionWhereUniqueInput
    update: XOR<SpawnConditionUpdateWithoutObjectResetInput, SpawnConditionUncheckedUpdateWithoutObjectResetInput>
    create: XOR<SpawnConditionCreateWithoutObjectResetInput, SpawnConditionUncheckedCreateWithoutObjectResetInput>
  }

  export type SpawnConditionUpdateWithWhereUniqueWithoutObjectResetInput = {
    where: SpawnConditionWhereUniqueInput
    data: XOR<SpawnConditionUpdateWithoutObjectResetInput, SpawnConditionUncheckedUpdateWithoutObjectResetInput>
  }

  export type SpawnConditionUpdateManyWithWhereWithoutObjectResetInput = {
    where: SpawnConditionScalarWhereInput
    data: XOR<SpawnConditionUpdateManyMutationInput, SpawnConditionUncheckedUpdateManyWithoutObjectResetInput>
  }

  export type MobResetCreateWithoutSpawnConditionsInput = {
    id?: string
    max?: number
    name?: string | null
    probability?: number
    carrying?: MobCarryingCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedCreateNestedManyWithoutResetInput
    mob: MobCreateNestedOneWithoutResetsInput
    room: RoomCreateNestedOneWithoutMobResetsInput
    zone: ZoneCreateNestedOneWithoutMobResetsInput
  }

  export type MobResetUncheckedCreateWithoutSpawnConditionsInput = {
    id?: string
    max?: number
    name?: string | null
    mobZoneId: number
    mobId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
    carrying?: MobCarryingUncheckedCreateNestedManyWithoutResetInput
    equipmentSets?: MobEquipmentSetUncheckedCreateNestedManyWithoutMobResetInput
    equipped?: MobEquippedUncheckedCreateNestedManyWithoutResetInput
  }

  export type MobResetCreateOrConnectWithoutSpawnConditionsInput = {
    where: MobResetWhereUniqueInput
    create: XOR<MobResetCreateWithoutSpawnConditionsInput, MobResetUncheckedCreateWithoutSpawnConditionsInput>
  }

  export type ObjectResetCreateWithoutSpawnConditionsInput = {
    id: string
    max?: number
    name?: string | null
    probability?: number
    object: ObjectCreateNestedOneWithoutResetsInput
    room: RoomCreateNestedOneWithoutObjectResetsInput
    zone: ZoneCreateNestedOneWithoutObjectResetsInput
  }

  export type ObjectResetUncheckedCreateWithoutSpawnConditionsInput = {
    id: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
  }

  export type ObjectResetCreateOrConnectWithoutSpawnConditionsInput = {
    where: ObjectResetWhereUniqueInput
    create: XOR<ObjectResetCreateWithoutSpawnConditionsInput, ObjectResetUncheckedCreateWithoutSpawnConditionsInput>
  }

  export type MobResetUpsertWithoutSpawnConditionsInput = {
    update: XOR<MobResetUpdateWithoutSpawnConditionsInput, MobResetUncheckedUpdateWithoutSpawnConditionsInput>
    create: XOR<MobResetCreateWithoutSpawnConditionsInput, MobResetUncheckedCreateWithoutSpawnConditionsInput>
    where?: MobResetWhereInput
  }

  export type MobResetUpdateToOneWithWhereWithoutSpawnConditionsInput = {
    where?: MobResetWhereInput
    data: XOR<MobResetUpdateWithoutSpawnConditionsInput, MobResetUncheckedUpdateWithoutSpawnConditionsInput>
  }

  export type MobResetUpdateWithoutSpawnConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUpdateManyWithoutResetNestedInput
    mob?: MobUpdateOneRequiredWithoutResetsNestedInput
    room?: RoomUpdateOneRequiredWithoutMobResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobResetsNestedInput
  }

  export type MobResetUncheckedUpdateWithoutSpawnConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUncheckedUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUncheckedUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUncheckedUpdateManyWithoutResetNestedInput
  }

  export type ObjectResetUpsertWithoutSpawnConditionsInput = {
    update: XOR<ObjectResetUpdateWithoutSpawnConditionsInput, ObjectResetUncheckedUpdateWithoutSpawnConditionsInput>
    create: XOR<ObjectResetCreateWithoutSpawnConditionsInput, ObjectResetUncheckedCreateWithoutSpawnConditionsInput>
    where?: ObjectResetWhereInput
  }

  export type ObjectResetUpdateToOneWithWhereWithoutSpawnConditionsInput = {
    where?: ObjectResetWhereInput
    data: XOR<ObjectResetUpdateWithoutSpawnConditionsInput, ObjectResetUncheckedUpdateWithoutSpawnConditionsInput>
  }

  export type ObjectResetUpdateWithoutSpawnConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    object?: ObjectUpdateOneRequiredWithoutResetsNestedInput
    room?: RoomUpdateOneRequiredWithoutObjectResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectResetsNestedInput
  }

  export type ObjectResetUncheckedUpdateWithoutSpawnConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BanRecordCreateManyAdminInput = {
    id?: string
    userId: string
    reason: string
    bannedAt?: Date | string
    expiresAt?: Date | string | null
    unbannedAt?: Date | string | null
    unbannedBy?: string | null
    active?: boolean
  }

  export type BanRecordCreateManyUserInput = {
    id?: string
    bannedBy: string
    reason: string
    bannedAt?: Date | string
    expiresAt?: Date | string | null
    unbannedAt?: Date | string | null
    unbannedBy?: string | null
    active?: boolean
  }

  export type ChangeLogCreateManyUserInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    description?: string | null
  }

  export type CharacterCreateManyUserInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    classId?: number | null
    experience?: number
    skillPoints?: number
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BanRecordUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    bannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutBanRecordsNestedInput
  }

  export type BanRecordUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    bannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BanRecordUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    bannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BanRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    bannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    admin?: UserUpdateOneRequiredWithoutIssuedBansNestedInput
  }

  export type BanRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannedBy?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    bannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BanRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannedBy?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    bannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unbannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChangeLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUpdateManyWithoutCharacterNestedInput
    items?: CharacterItemUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUpdateManyWithoutCharacterNestedInput
    gameClass?: GameClassUpdateOneWithoutCharactersNestedInput
  }

  export type CharacterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUncheckedUpdateManyWithoutCharacterNestedInput
    items?: CharacterItemUncheckedUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterEffectCreateManyCharacterInput = {
    id?: string
    effectName: string
    effectType?: string | null
    duration?: number | null
    strength?: number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: string | null
    sourceId?: number | null
    appliedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CharacterItemCreateManyCharacterInput = {
    id?: string
    object_zone_id: number
    object_id: number
    containerId?: string | null
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterSkillCreateManyCharacterInput = {
    id?: string
    skillId: number
    level?: number
    experience?: number
    lastUsed?: Date | string | null
  }

  export type CharacterSpellCreateManyCharacterInput = {
    id?: string
    spellId: number
    known?: boolean
    proficiency?: number
    lastCast?: Date | string | null
  }

  export type CharacterEffectUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    effectName?: StringFieldUpdateOperationsInput | string
    effectType?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: IntFieldUpdateOperationsInput | number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterEffectUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    effectName?: StringFieldUpdateOperationsInput | string
    effectType?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: IntFieldUpdateOperationsInput | number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterEffectUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    effectName?: StringFieldUpdateOperationsInput | string
    effectType?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    strength?: IntFieldUpdateOperationsInput | number
    modifierData?: JsonNullValueInput | InputJsonValue
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableIntFieldUpdateOperationsInput | number | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterItemUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    container?: CharacterItemUpdateOneWithoutContainedItemsNestedInput
    containedItems?: CharacterItemUpdateManyWithoutContainerNestedInput
    object?: ObjectUpdateOneRequiredWithoutCharacterItemsNestedInput
  }

  export type CharacterItemUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    object_zone_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containedItems?: CharacterItemUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type CharacterItemUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    object_zone_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterSkillUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skill?: SkillUpdateOneRequiredWithoutCharacterSkillsNestedInput
  }

  export type CharacterSkillUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterSkillUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterSpellUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    known?: BoolFieldUpdateOperationsInput | boolean
    proficiency?: IntFieldUpdateOperationsInput | number
    lastCast?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spell?: SpellUpdateOneRequiredWithoutCharacterSpellsNestedInput
  }

  export type CharacterSpellUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    spellId?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
    proficiency?: IntFieldUpdateOperationsInput | number
    lastCast?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterSpellUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    spellId?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
    proficiency?: IntFieldUpdateOperationsInput | number
    lastCast?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobResetCreateManyZoneInput = {
    id?: string
    max?: number
    name?: string | null
    mobZoneId: number
    mobId: number
    roomZoneId: number
    roomId: number
    probability?: number
  }

  export type MobCreateManyZoneInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    classId?: number | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
  }

  export type ObjectResetCreateManyZoneInput = {
    id: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
    roomZoneId: number
    roomId: number
    probability?: number
  }

  export type ObjectCreateManyZoneInput = {
    id: number
    type?: $Enums.ObjectType
    keywords?: ObjectCreatekeywordsInput | string[]
    shortDesc: string
    description: string
    actionDesc?: string | null
    weight?: number
    cost?: number
    timer?: number
    decomposeTimer?: number
    level?: number
    concealment?: number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ObjectCreateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectCreateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectCreatewearFlagsInput | $Enums.WearFlag[]
  }

  export type RoomCreateManyZoneInput = {
    id: number
    name: string
    description: string
    sector?: $Enums.Sector
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    flags?: RoomCreateflagsInput | $Enums.RoomFlag[]
    layoutX?: number | null
    layoutY?: number | null
    layoutZ?: number | null
  }

  export type ShopCreateManyZoneInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    keeperZoneId?: number | null
    keeperId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
  }

  export type TriggerCreateManyZoneInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    mobZoneId?: number | null
    mobId?: number | null
    objectZoneId?: number | null
    objectId?: number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
  }

  export type MobResetUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUpdateManyWithoutResetNestedInput
    mob?: MobUpdateOneRequiredWithoutResetsNestedInput
    room?: RoomUpdateOneRequiredWithoutMobResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUncheckedUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUncheckedUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUncheckedUpdateManyWithoutResetNestedInput
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUpdateManyWithoutMobNestedInput
    skills?: MobSkillUpdateManyWithoutMobNestedInput
    spells?: MobSpellUpdateManyWithoutMobNestedInput
    gameClass?: GameClassUpdateOneWithoutMobsNestedInput
    shops?: ShopUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUpdateManyWithoutMobNestedInput
  }

  export type MobUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUncheckedUpdateManyWithoutMobNestedInput
    skills?: MobSkillUncheckedUpdateManyWithoutMobNestedInput
    spells?: MobSpellUncheckedUpdateManyWithoutMobNestedInput
    shops?: ShopUncheckedUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutMobNestedInput
  }

  export type MobUncheckedUpdateManyWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableIntFieldUpdateOperationsInput | number | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
  }

  export type ObjectResetUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    object?: ObjectUpdateOneRequiredWithoutResetsNestedInput
    room?: RoomUpdateOneRequiredWithoutObjectResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutObjectResetNestedInput
  }

  export type ObjectResetUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutObjectResetNestedInput
  }

  export type ObjectResetUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
    characterItems?: CharacterItemUncheckedUpdateManyWithoutObjectNestedInput
    equipmentSetItems?: EquipmentSetItemUncheckedUpdateManyWithoutObjectNestedInput
    mobCarrying?: MobCarryingUncheckedUpdateManyWithoutObjectNestedInput
    mobEquipped?: MobEquippedUncheckedUpdateManyWithoutObjectNestedInput
    affects?: ObjectAffectUncheckedUpdateManyWithoutObjectNestedInput
    extraDescs?: ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectNestedInput
    resets?: ObjectResetUncheckedUpdateManyWithoutObjectNestedInput
    spells?: ObjectSpellUncheckedUpdateManyWithoutObjectNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutObjectNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateManyWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumObjectTypeFieldUpdateOperationsInput | $Enums.ObjectType
    keywords?: ObjectUpdatekeywordsInput | string[]
    shortDesc?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionDesc?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: FloatFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    timer?: IntFieldUpdateOperationsInput | number
    decomposeTimer?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    values?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ObjectUpdateflagsInput | $Enums.ObjectFlag[]
    effectFlags?: ObjectUpdateeffectFlagsInput | $Enums.EffectFlag[]
    wearFlags?: ObjectUpdatewearFlagsInput | $Enums.WearFlag[]
  }

  export type RoomUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    mobResets?: MobResetUpdateManyWithoutRoomNestedInput
    objectResets?: ObjectResetUpdateManyWithoutRoomNestedInput
    exits?: RoomExitUpdateManyWithoutRoomNestedInput
    extraDescs?: RoomExtraDescriptionUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
    mobResets?: MobResetUncheckedUpdateManyWithoutRoomNestedInput
    objectResets?: ObjectResetUncheckedUpdateManyWithoutRoomNestedInput
    exits?: RoomExitUncheckedUpdateManyWithoutRoomNestedInput
    extraDescs?: RoomExtraDescriptionUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    sector?: EnumSectorFieldUpdateOperationsInput | $Enums.Sector
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: RoomUpdateflagsInput | $Enums.RoomFlag[]
    layoutX?: NullableIntFieldUpdateOperationsInput | number | null
    layoutY?: NullableIntFieldUpdateOperationsInput | number | null
    layoutZ?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ShopUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUpdateManyWithoutShopNestedInput
    hours?: ShopHourUpdateManyWithoutShopNestedInput
    items?: ShopItemUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUpdateManyWithoutShopNestedInput
    keeper?: MobUpdateOneWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    keeperZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    keeperId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedUpdateManyWithoutShopNestedInput
    hours?: ShopHourUncheckedUpdateManyWithoutShopNestedInput
    items?: ShopItemUncheckedUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateManyWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    keeperZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    keeperId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
  }

  export type TriggerUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
    mob?: MobUpdateOneWithoutTriggersNestedInput
    object?: ObjectUpdateOneWithoutTriggersNestedInput
  }

  export type TriggerUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    mobZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    mobId?: NullableIntFieldUpdateOperationsInput | number | null
    objectZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
  }

  export type TriggerUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    mobZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    mobId?: NullableIntFieldUpdateOperationsInput | number | null
    objectZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
  }

  export type MobResetCreateManyRoomInput = {
    id?: string
    max?: number
    name?: string | null
    mobZoneId: number
    mobId: number
    zoneId: number
    probability?: number
  }

  export type ObjectResetCreateManyRoomInput = {
    id: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
    zoneId: number
    probability?: number
  }

  export type RoomExitCreateManyRoomInput = {
    id?: string
    direction: $Enums.Direction
    description?: string | null
    keyword?: string | null
    key?: string | null
    destination?: number | null
    flags?: RoomExitCreateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExtraDescriptionCreateManyRoomInput = {
    id?: string
    keyword: string
    description: string
  }

  export type MobResetUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUpdateManyWithoutResetNestedInput
    mob?: MobUpdateOneRequiredWithoutResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUncheckedUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUncheckedUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUncheckedUpdateManyWithoutResetNestedInput
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectResetUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    object?: ObjectUpdateOneRequiredWithoutResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutObjectResetNestedInput
  }

  export type ObjectResetUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutObjectResetNestedInput
  }

  export type ObjectResetUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type RoomExitUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: RoomExitUpdateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExitUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: RoomExitUpdateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExitUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: RoomExitUpdateflagsInput | $Enums.ExitFlag[]
  }

  export type RoomExtraDescriptionUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RoomExtraDescriptionUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RoomExtraDescriptionUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type MobResetCreateManyMobInput = {
    id?: string
    max?: number
    name?: string | null
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
  }

  export type MobSkillCreateManyMobInput = {
    id?: number
    skillId: number
    level?: number
  }

  export type MobSpellCreateManyMobInput = {
    id?: number
    spellId: number
    circle?: number
    known?: boolean
  }

  export type ShopCreateManyKeeperInput = {
    id: number
    buyProfit?: number
    sellProfit?: number
    temper1?: number
    noSuchItem1?: string | null
    noSuchItem2?: string | null
    doNotBuy?: string | null
    missingCash1?: string | null
    missingCash2?: string | null
    messageBuy?: string | null
    messageSell?: string | null
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: ShopCreateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopCreatetradesWithFlagsInput | $Enums.ShopTradesWith[]
  }

  export type TriggerCreateManyMobInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    zoneId?: number | null
    objectZoneId?: number | null
    objectId?: number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
  }

  export type MobResetUpdateWithoutMobInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUpdateManyWithoutResetNestedInput
    room?: RoomUpdateOneRequiredWithoutMobResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetUncheckedUpdateWithoutMobInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    carrying?: MobCarryingUncheckedUpdateManyWithoutResetNestedInput
    equipmentSets?: MobEquipmentSetUncheckedUpdateManyWithoutMobResetNestedInput
    equipped?: MobEquippedUncheckedUpdateManyWithoutResetNestedInput
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutMobResetNestedInput
  }

  export type MobResetUncheckedUpdateManyWithoutMobInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobSkillUpdateWithoutMobInput = {
    level?: IntFieldUpdateOperationsInput | number
    skill?: SkillUpdateOneRequiredWithoutMobSkillsNestedInput
  }

  export type MobSkillUncheckedUpdateWithoutMobInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type MobSkillUncheckedUpdateManyWithoutMobInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type MobSpellUpdateWithoutMobInput = {
    circle?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
    spell?: SpellUpdateOneRequiredWithoutMobSpellsNestedInput
  }

  export type MobSpellUncheckedUpdateWithoutMobInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MobSpellUncheckedUpdateManyWithoutMobInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShopUpdateWithoutKeeperInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUpdateManyWithoutShopNestedInput
    hours?: ShopHourUpdateManyWithoutShopNestedInput
    items?: ShopItemUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUpdateManyWithoutShopNestedInput
    zone?: ZoneUpdateOneRequiredWithoutShopsNestedInput
  }

  export type ShopUncheckedUpdateWithoutKeeperInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
    accepts?: ShopAcceptUncheckedUpdateManyWithoutShopNestedInput
    hours?: ShopHourUncheckedUpdateManyWithoutShopNestedInput
    items?: ShopItemUncheckedUpdateManyWithoutShopNestedInput
    rooms?: ShopRoomUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateManyWithoutKeeperInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyProfit?: FloatFieldUpdateOperationsInput | number
    sellProfit?: FloatFieldUpdateOperationsInput | number
    temper1?: IntFieldUpdateOperationsInput | number
    noSuchItem1?: NullableStringFieldUpdateOperationsInput | string | null
    noSuchItem2?: NullableStringFieldUpdateOperationsInput | string | null
    doNotBuy?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash1?: NullableStringFieldUpdateOperationsInput | string | null
    missingCash2?: NullableStringFieldUpdateOperationsInput | string | null
    messageBuy?: NullableStringFieldUpdateOperationsInput | string | null
    messageSell?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: ShopUpdateflagsInput | $Enums.ShopFlag[]
    tradesWithFlags?: ShopUpdatetradesWithFlagsInput | $Enums.ShopTradesWith[]
  }

  export type TriggerUpdateWithoutMobInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
    object?: ObjectUpdateOneWithoutTriggersNestedInput
    zone?: ZoneUpdateOneWithoutTriggersNestedInput
  }

  export type TriggerUncheckedUpdateWithoutMobInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableIntFieldUpdateOperationsInput | number | null
    objectZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
  }

  export type TriggerUncheckedUpdateManyWithoutMobInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableIntFieldUpdateOperationsInput | number | null
    objectZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
  }

  export type MobCarryingCreateManyResetInput = {
    id?: string
    max?: number
    name?: string | null
    objectZoneId: number
    objectId: number
  }

  export type MobEquipmentSetCreateManyMobResetInput = {
    id: string
    equipmentSetId: string
    probability?: number
  }

  export type MobEquippedCreateManyResetInput = {
    id?: string
    max?: number
    location: string
    name?: string | null
    objectZoneId: number
    objectId: number
  }

  export type SpawnConditionCreateManyMobResetInput = {
    id: string
    type: string
    parameters?: JsonNullValueInput | InputJsonValue
    objectResetId?: string | null
  }

  export type MobCarryingUpdateWithoutResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    object?: ObjectUpdateOneRequiredWithoutMobCarryingNestedInput
  }

  export type MobCarryingUncheckedUpdateWithoutResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type MobCarryingUncheckedUpdateManyWithoutResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type MobEquipmentSetUpdateWithoutMobResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
    equipmentSet?: EquipmentSetUpdateOneRequiredWithoutMobEquipmentSetsNestedInput
  }

  export type MobEquipmentSetUncheckedUpdateWithoutMobResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentSetId?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobEquipmentSetUncheckedUpdateManyWithoutMobResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentSetId?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobEquippedUpdateWithoutResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    object?: ObjectUpdateOneRequiredWithoutMobEquippedNestedInput
  }

  export type MobEquippedUncheckedUpdateWithoutResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type MobEquippedUncheckedUpdateManyWithoutResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type SpawnConditionUpdateWithoutMobResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    objectReset?: ObjectResetUpdateOneWithoutSpawnConditionsNestedInput
  }

  export type SpawnConditionUncheckedUpdateWithoutMobResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    objectResetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpawnConditionUncheckedUpdateManyWithoutMobResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    objectResetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterItemCreateManyObjectInput = {
    id?: string
    characterId: string
    containerId?: string | null
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentSetItemCreateManyObjectInput = {
    id: string
    equipmentSetId: string
    slot?: string | null
    quantity?: number
    probability?: number
  }

  export type MobCarryingCreateManyObjectInput = {
    id?: string
    max?: number
    name?: string | null
    resetId: string
  }

  export type MobEquippedCreateManyObjectInput = {
    id?: string
    max?: number
    location: string
    name?: string | null
    resetId: string
  }

  export type ObjectAffectCreateManyObjectInput = {
    id?: string
    location: string
    modifier: number
  }

  export type ObjectExtraDescriptionCreateManyObjectInput = {
    id?: string
    keyword: string
    description: string
  }

  export type ObjectResetCreateManyObjectInput = {
    id: string
    max?: number
    name?: string | null
    roomZoneId: number
    roomId: number
    zoneId: number
    probability?: number
  }

  export type ObjectSpellCreateManyObjectInput = {
    id?: string
    spell: string
    level?: number
  }

  export type ShopItemCreateManyObjectInput = {
    id?: string
    amount?: number
    shopZoneId: number
    shopId: number
  }

  export type TriggerCreateManyObjectInput = {
    id?: string
    name: string
    attachType: $Enums.ScriptType
    numArgs?: number
    argList?: string | null
    commands: string
    zoneId?: number | null
    mobZoneId?: number | null
    mobId?: number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    flags?: TriggerCreateflagsInput | $Enums.TriggerFlag[]
  }

  export type CharacterItemUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutItemsNestedInput
    container?: CharacterItemUpdateOneWithoutContainedItemsNestedInput
    containedItems?: CharacterItemUpdateManyWithoutContainerNestedInput
  }

  export type CharacterItemUncheckedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containedItems?: CharacterItemUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type CharacterItemUncheckedUpdateManyWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentSetItemUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    equipmentSet?: EquipmentSetUpdateOneRequiredWithoutItemsNestedInput
  }

  export type EquipmentSetItemUncheckedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentSetId?: StringFieldUpdateOperationsInput | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentSetItemUncheckedUpdateManyWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentSetId?: StringFieldUpdateOperationsInput | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobCarryingUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reset?: MobResetUpdateOneRequiredWithoutCarryingNestedInput
  }

  export type MobCarryingUncheckedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    resetId?: StringFieldUpdateOperationsInput | string
  }

  export type MobCarryingUncheckedUpdateManyWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    resetId?: StringFieldUpdateOperationsInput | string
  }

  export type MobEquippedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reset?: MobResetUpdateOneRequiredWithoutEquippedNestedInput
  }

  export type MobEquippedUncheckedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    resetId?: StringFieldUpdateOperationsInput | string
  }

  export type MobEquippedUncheckedUpdateManyWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    resetId?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectAffectUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectAffectUncheckedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectAffectUncheckedUpdateManyWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectExtraDescriptionUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectExtraDescriptionUncheckedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectExtraDescriptionUncheckedUpdateManyWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectResetUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    probability?: FloatFieldUpdateOperationsInput | number
    room?: RoomUpdateOneRequiredWithoutObjectResetsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutObjectResetsNestedInput
    spawnConditions?: SpawnConditionUpdateManyWithoutObjectResetNestedInput
  }

  export type ObjectResetUncheckedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    spawnConditions?: SpawnConditionUncheckedUpdateManyWithoutObjectResetNestedInput
  }

  export type ObjectResetUncheckedUpdateManyWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    roomZoneId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectSpellUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    spell?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectSpellUncheckedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    spell?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectSpellUncheckedUpdateManyWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    spell?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ShopItemUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    shop?: ShopUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ShopItemUncheckedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    shopZoneId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopItemUncheckedUpdateManyWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    shopZoneId?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
  }

  export type TriggerUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
    mob?: MobUpdateOneWithoutTriggersNestedInput
    zone?: ZoneUpdateOneWithoutTriggersNestedInput
  }

  export type TriggerUncheckedUpdateWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableIntFieldUpdateOperationsInput | number | null
    mobZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    mobId?: NullableIntFieldUpdateOperationsInput | number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
  }

  export type TriggerUncheckedUpdateManyWithoutObjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attachType?: EnumScriptTypeFieldUpdateOperationsInput | $Enums.ScriptType
    numArgs?: IntFieldUpdateOperationsInput | number
    argList?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableIntFieldUpdateOperationsInput | number | null
    mobZoneId?: NullableIntFieldUpdateOperationsInput | number | null
    mobId?: NullableIntFieldUpdateOperationsInput | number | null
    variables?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: TriggerUpdateflagsInput | $Enums.TriggerFlag[]
  }

  export type ShopAcceptCreateManyShopInput = {
    id?: string
    type: string
    keywords?: ShopAcceptCreatekeywordsInput | string[]
  }

  export type ShopHourCreateManyShopInput = {
    id?: string
    open: number
    close: number
  }

  export type ShopItemCreateManyShopInput = {
    id?: string
    amount?: number
    objectZoneId: number
    objectId: number
  }

  export type ShopRoomCreateManyShopInput = {
    id?: string
    roomId: number
  }

  export type ShopAcceptUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ShopAcceptUpdatekeywordsInput | string[]
  }

  export type ShopAcceptUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ShopAcceptUpdatekeywordsInput | string[]
  }

  export type ShopAcceptUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ShopAcceptUpdatekeywordsInput | string[]
  }

  export type ShopHourUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    open?: IntFieldUpdateOperationsInput | number
    close?: IntFieldUpdateOperationsInput | number
  }

  export type ShopHourUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    open?: IntFieldUpdateOperationsInput | number
    close?: IntFieldUpdateOperationsInput | number
  }

  export type ShopHourUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    open?: IntFieldUpdateOperationsInput | number
    close?: IntFieldUpdateOperationsInput | number
  }

  export type ShopItemUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    object?: ObjectUpdateOneRequiredWithoutShopItemsNestedInput
  }

  export type ShopItemUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopItemUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopRoomUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopRoomUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
  }

  export type ShopRoomUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterCreateManyGameClassInput = {
    id?: string
    name: string
    level?: number
    alignment?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    luck?: number
    hitPoints?: number
    movement?: number
    hitPointsMax?: number
    movementMax?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    bankCopper?: number
    bankSilver?: number
    bankGold?: number
    bankPlatinum?: number
    total_wealth?: number
    average_stats?: number
    passwordHash?: string | null
    raceType?: string
    race?: $Enums.Race
    gender?: string
    playerClass?: string | null
    height?: number | null
    weight?: number | null
    baseSize?: number
    currentSize?: number
    hitRoll?: number
    damageRoll?: number
    armorClass?: number
    currentRoom?: number | null
    saveRoom?: number | null
    homeRoom?: number | null
    lastLogin?: Date | string | null
    timePlayed?: number
    isOnline?: boolean
    hunger?: number
    thirst?: number
    description?: string | null
    title?: string | null
    prompt?: string
    pageLength?: number
    playerFlags?: CharacterCreateplayerFlagsInput | string[]
    effectFlags?: CharacterCreateeffectFlagsInput | string[]
    privilegeFlags?: CharacterCreateprivilegeFlagsInput | string[]
    olcZones?: CharacterCreateolcZonesInput | number[]
    invisLevel?: number
    birthTime?: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    experience?: number
    skillPoints?: number
  }

  export type ClassSkillCreateManyGameClassInput = {
    id?: number
    skillId: number
    category?: $Enums.SkillCategory
    minLevel?: number
    maxLevel?: number
  }

  export type MobCreateManyGameClassInput = {
    id: number
    keywords?: MobCreatekeywordsInput | string[]
    mobClass: string
    shortDesc: string
    longDesc: string
    desc: string
    alignment?: number
    level?: number
    armorClass?: number
    hitRoll?: number
    move?: number
    hpDiceNum?: number
    hpDiceSize?: number
    hpDiceBonus?: number
    damageDiceNum?: number
    damageDiceSize?: number
    damageDiceBonus?: number
    copper?: number
    silver?: number
    gold?: number
    platinum?: number
    raceAlign?: number
    total_wealth?: number
    average_stats?: number
    estimated_hp?: number
    strength?: number
    intelligence?: number
    wisdom?: number
    dexterity?: number
    constitution?: number
    charisma?: number
    perception?: number
    concealment?: number
    zoneId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted_at?: Date | string | null
    createdBy?: string | null
    updatedBy?: string | null
    race?: $Enums.Race
    mobFlags?: MobCreatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobCreateeffectFlagsInput | $Enums.EffectFlag[]
    position?: $Enums.Position
    defaultPosition?: $Enums.Position
    gender?: $Enums.Gender
    size?: $Enums.Size
    lifeForce?: $Enums.LifeForce
    composition?: $Enums.Composition
    stance?: $Enums.Stance
    damageType?: $Enums.DamageType
  }

  export type SpellClassCircleCreateManyGameClassInput = {
    id?: number
    spellId: number
    circle: number
    minLevel?: number | null
    proficiencyGain?: number | null
  }

  export type CharacterUpdateWithoutGameClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUpdateManyWithoutCharacterNestedInput
    items?: CharacterItemUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUpdateManyWithoutCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type CharacterUncheckedUpdateWithoutGameClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
    effects?: CharacterEffectUncheckedUpdateManyWithoutCharacterNestedInput
    items?: CharacterItemUncheckedUpdateManyWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    spells?: CharacterSpellUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutGameClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    alignment?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    hitPoints?: IntFieldUpdateOperationsInput | number
    movement?: IntFieldUpdateOperationsInput | number
    hitPointsMax?: IntFieldUpdateOperationsInput | number
    movementMax?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    bankCopper?: IntFieldUpdateOperationsInput | number
    bankSilver?: IntFieldUpdateOperationsInput | number
    bankGold?: IntFieldUpdateOperationsInput | number
    bankPlatinum?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    raceType?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    gender?: StringFieldUpdateOperationsInput | string
    playerClass?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    baseSize?: IntFieldUpdateOperationsInput | number
    currentSize?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    damageRoll?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    currentRoom?: NullableIntFieldUpdateOperationsInput | number | null
    saveRoom?: NullableIntFieldUpdateOperationsInput | number | null
    homeRoom?: NullableIntFieldUpdateOperationsInput | number | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timePlayed?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    hunger?: IntFieldUpdateOperationsInput | number
    thirst?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    pageLength?: IntFieldUpdateOperationsInput | number
    playerFlags?: CharacterUpdateplayerFlagsInput | string[]
    effectFlags?: CharacterUpdateeffectFlagsInput | string[]
    privilegeFlags?: CharacterUpdateprivilegeFlagsInput | string[]
    olcZones?: CharacterUpdateolcZonesInput | number[]
    invisLevel?: IntFieldUpdateOperationsInput | number
    birthTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experience?: IntFieldUpdateOperationsInput | number
    skillPoints?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillUpdateWithoutGameClassInput = {
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    skill?: SkillUpdateOneRequiredWithoutClassSkillsNestedInput
  }

  export type ClassSkillUncheckedUpdateWithoutGameClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillUncheckedUpdateManyWithoutGameClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
  }

  export type MobUpdateWithoutGameClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUpdateManyWithoutMobNestedInput
    skills?: MobSkillUpdateManyWithoutMobNestedInput
    spells?: MobSpellUpdateManyWithoutMobNestedInput
    zone?: ZoneUpdateOneRequiredWithoutMobsNestedInput
    shops?: ShopUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUpdateManyWithoutMobNestedInput
  }

  export type MobUncheckedUpdateWithoutGameClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
    resets?: MobResetUncheckedUpdateManyWithoutMobNestedInput
    skills?: MobSkillUncheckedUpdateManyWithoutMobNestedInput
    spells?: MobSpellUncheckedUpdateManyWithoutMobNestedInput
    shops?: ShopUncheckedUpdateManyWithoutKeeperNestedInput
    triggers?: TriggerUncheckedUpdateManyWithoutMobNestedInput
  }

  export type MobUncheckedUpdateManyWithoutGameClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    keywords?: MobUpdatekeywordsInput | string[]
    mobClass?: StringFieldUpdateOperationsInput | string
    shortDesc?: StringFieldUpdateOperationsInput | string
    longDesc?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    alignment?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    armorClass?: IntFieldUpdateOperationsInput | number
    hitRoll?: IntFieldUpdateOperationsInput | number
    move?: IntFieldUpdateOperationsInput | number
    hpDiceNum?: IntFieldUpdateOperationsInput | number
    hpDiceSize?: IntFieldUpdateOperationsInput | number
    hpDiceBonus?: IntFieldUpdateOperationsInput | number
    damageDiceNum?: IntFieldUpdateOperationsInput | number
    damageDiceSize?: IntFieldUpdateOperationsInput | number
    damageDiceBonus?: IntFieldUpdateOperationsInput | number
    copper?: IntFieldUpdateOperationsInput | number
    silver?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    platinum?: IntFieldUpdateOperationsInput | number
    raceAlign?: IntFieldUpdateOperationsInput | number
    total_wealth?: IntFieldUpdateOperationsInput | number
    average_stats?: IntFieldUpdateOperationsInput | number
    estimated_hp?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    charisma?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    concealment?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    mobFlags?: MobUpdatemobFlagsInput | $Enums.MobFlag[]
    effectFlags?: MobUpdateeffectFlagsInput | $Enums.EffectFlag[]
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    defaultPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    lifeForce?: EnumLifeForceFieldUpdateOperationsInput | $Enums.LifeForce
    composition?: EnumCompositionFieldUpdateOperationsInput | $Enums.Composition
    stance?: EnumStanceFieldUpdateOperationsInput | $Enums.Stance
    damageType?: EnumDamageTypeFieldUpdateOperationsInput | $Enums.DamageType
  }

  export type SpellClassCircleUpdateWithoutGameClassInput = {
    circle?: IntFieldUpdateOperationsInput | number
    minLevel?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyGain?: NullableIntFieldUpdateOperationsInput | number | null
    spell?: SpellUpdateOneRequiredWithoutClassCirclesNestedInput
  }

  export type SpellClassCircleUncheckedUpdateWithoutGameClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    minLevel?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyGain?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellClassCircleUncheckedUpdateManyWithoutGameClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    spellId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    minLevel?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyGain?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterSpellCreateManySpellInput = {
    id?: string
    characterId: string
    known?: boolean
    proficiency?: number
    lastCast?: Date | string | null
  }

  export type MobSpellCreateManySpellInput = {
    id?: number
    mobZoneId: number
    mobId: number
    circle?: number
    known?: boolean
  }

  export type SpellClassCircleCreateManySpellInput = {
    id?: number
    classId: number
    circle: number
    minLevel?: number | null
    proficiencyGain?: number | null
  }

  export type SpellComponentCreateManySpellInput = {
    id?: number
    objectId: number
    consumed?: boolean
    required?: boolean
  }

  export type SpellEffectCreateManySpellInput = {
    id?: number
    effectType: $Enums.EffectType
    order?: number
    chancePct?: number
    trigger?: $Enums.EffectTrigger | null
    durationFormula?: string | null
    stackingRule?: $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params: JsonNullValueInput | InputJsonValue
  }

  export type SpellSavingThrowCreateManySpellInput = {
    id?: number
    saveType?: $Enums.SaveType
    onSave?: $Enums.SaveResult
    dcFormula: string
    saveModifierMask?: number | null
  }

  export type CharacterSpellUpdateWithoutSpellInput = {
    id?: StringFieldUpdateOperationsInput | string
    known?: BoolFieldUpdateOperationsInput | boolean
    proficiency?: IntFieldUpdateOperationsInput | number
    lastCast?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    character?: CharacterUpdateOneRequiredWithoutSpellsNestedInput
  }

  export type CharacterSpellUncheckedUpdateWithoutSpellInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    known?: BoolFieldUpdateOperationsInput | boolean
    proficiency?: IntFieldUpdateOperationsInput | number
    lastCast?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterSpellUncheckedUpdateManyWithoutSpellInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    known?: BoolFieldUpdateOperationsInput | boolean
    proficiency?: IntFieldUpdateOperationsInput | number
    lastCast?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobSpellUpdateWithoutSpellInput = {
    circle?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
    mob?: MobUpdateOneRequiredWithoutSpellsNestedInput
  }

  export type MobSpellUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MobSpellUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    known?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellClassCircleUpdateWithoutSpellInput = {
    circle?: IntFieldUpdateOperationsInput | number
    minLevel?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyGain?: NullableIntFieldUpdateOperationsInput | number | null
    gameClass?: GameClassUpdateOneRequiredWithoutSpellCirclesNestedInput
  }

  export type SpellClassCircleUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    minLevel?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyGain?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellClassCircleUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    circle?: IntFieldUpdateOperationsInput | number
    minLevel?: NullableIntFieldUpdateOperationsInput | number | null
    proficiencyGain?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellComponentUpdateWithoutSpellInput = {
    objectId?: IntFieldUpdateOperationsInput | number
    consumed?: BoolFieldUpdateOperationsInput | boolean
    required?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellComponentUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    consumed?: BoolFieldUpdateOperationsInput | boolean
    required?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellComponentUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    consumed?: BoolFieldUpdateOperationsInput | boolean
    required?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpellEffectUpdateWithoutSpellInput = {
    effectType?: EnumEffectTypeFieldUpdateOperationsInput | $Enums.EffectType
    order?: IntFieldUpdateOperationsInput | number
    chancePct?: IntFieldUpdateOperationsInput | number
    trigger?: NullableEnumEffectTriggerFieldUpdateOperationsInput | $Enums.EffectTrigger | null
    durationFormula?: NullableStringFieldUpdateOperationsInput | string | null
    stackingRule?: EnumStackingRuleFieldUpdateOperationsInput | $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params?: JsonNullValueInput | InputJsonValue
  }

  export type SpellEffectUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    effectType?: EnumEffectTypeFieldUpdateOperationsInput | $Enums.EffectType
    order?: IntFieldUpdateOperationsInput | number
    chancePct?: IntFieldUpdateOperationsInput | number
    trigger?: NullableEnumEffectTriggerFieldUpdateOperationsInput | $Enums.EffectTrigger | null
    durationFormula?: NullableStringFieldUpdateOperationsInput | string | null
    stackingRule?: EnumStackingRuleFieldUpdateOperationsInput | $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params?: JsonNullValueInput | InputJsonValue
  }

  export type SpellEffectUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    effectType?: EnumEffectTypeFieldUpdateOperationsInput | $Enums.EffectType
    order?: IntFieldUpdateOperationsInput | number
    chancePct?: IntFieldUpdateOperationsInput | number
    trigger?: NullableEnumEffectTriggerFieldUpdateOperationsInput | $Enums.EffectTrigger | null
    durationFormula?: NullableStringFieldUpdateOperationsInput | string | null
    stackingRule?: EnumStackingRuleFieldUpdateOperationsInput | $Enums.StackingRule
    conditionFilter?: NullableJsonNullValueInput | InputJsonValue
    params?: JsonNullValueInput | InputJsonValue
  }

  export type SpellSavingThrowUpdateWithoutSpellInput = {
    saveType?: EnumSaveTypeFieldUpdateOperationsInput | $Enums.SaveType
    onSave?: EnumSaveResultFieldUpdateOperationsInput | $Enums.SaveResult
    dcFormula?: StringFieldUpdateOperationsInput | string
    saveModifierMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSavingThrowUncheckedUpdateWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    saveType?: EnumSaveTypeFieldUpdateOperationsInput | $Enums.SaveType
    onSave?: EnumSaveResultFieldUpdateOperationsInput | $Enums.SaveResult
    dcFormula?: StringFieldUpdateOperationsInput | string
    saveModifierMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellSavingThrowUncheckedUpdateManyWithoutSpellInput = {
    id?: IntFieldUpdateOperationsInput | number
    saveType?: EnumSaveTypeFieldUpdateOperationsInput | $Enums.SaveType
    onSave?: EnumSaveResultFieldUpdateOperationsInput | $Enums.SaveResult
    dcFormula?: StringFieldUpdateOperationsInput | string
    saveModifierMask?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpellCreateManySchoolInput = {
    id?: number
    name: string
    minPosition?: $Enums.Position
    violent?: boolean
    castTimeRounds?: number
    cooldownMs?: number
    inCombatOnly?: boolean
    isArea?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpellUpdateWithoutSchoolInput = {
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUpdateOneWithoutSpellNestedInput
  }

  export type SpellUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterSpells?: CharacterSpellUncheckedUpdateManyWithoutSpellNestedInput
    mobSpells?: MobSpellUncheckedUpdateManyWithoutSpellNestedInput
    classCircles?: SpellClassCircleUncheckedUpdateManyWithoutSpellNestedInput
    components?: SpellComponentUncheckedUpdateManyWithoutSpellNestedInput
    effects?: SpellEffectUncheckedUpdateManyWithoutSpellNestedInput
    messages?: SpellMessageUncheckedUpdateOneWithoutSpellNestedInput
    restrictions?: SpellRestrictionUncheckedUpdateOneWithoutSpellNestedInput
    savingThrows?: SpellSavingThrowUncheckedUpdateManyWithoutSpellNestedInput
    targeting?: SpellTargetingUncheckedUpdateOneWithoutSpellNestedInput
  }

  export type SpellUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    violent?: BoolFieldUpdateOperationsInput | boolean
    castTimeRounds?: IntFieldUpdateOperationsInput | number
    cooldownMs?: IntFieldUpdateOperationsInput | number
    inCombatOnly?: BoolFieldUpdateOperationsInput | boolean
    isArea?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterSkillCreateManySkillInput = {
    id?: string
    characterId: string
    level?: number
    experience?: number
    lastUsed?: Date | string | null
  }

  export type ClassSkillCreateManySkillInput = {
    id?: number
    classId: number
    category?: $Enums.SkillCategory
    minLevel?: number
    maxLevel?: number
  }

  export type MobSkillCreateManySkillInput = {
    id?: number
    mobZoneId: number
    mobId: number
    level?: number
  }

  export type RaceSkillCreateManySkillInput = {
    id?: number
    race: $Enums.Race
    category?: $Enums.SkillCategory
    bonus?: number
  }

  export type CharacterSkillUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    character?: CharacterUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type CharacterSkillUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassSkillUpdateWithoutSkillInput = {
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    gameClass?: GameClassUpdateOneRequiredWithoutSkillAccessNestedInput
  }

  export type ClassSkillUncheckedUpdateWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ClassSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    classId?: IntFieldUpdateOperationsInput | number
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    minLevel?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
  }

  export type MobSkillUpdateWithoutSkillInput = {
    level?: IntFieldUpdateOperationsInput | number
    mob?: MobUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type MobSkillUncheckedUpdateWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type MobSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobZoneId?: IntFieldUpdateOperationsInput | number
    mobId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type RaceSkillUpdateWithoutSkillInput = {
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    bonus?: IntFieldUpdateOperationsInput | number
  }

  export type RaceSkillUncheckedUpdateWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    bonus?: IntFieldUpdateOperationsInput | number
  }

  export type RaceSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    category?: EnumSkillCategoryFieldUpdateOperationsInput | $Enums.SkillCategory
    bonus?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterItemCreateManyContainerInput = {
    id?: string
    characterId: string
    object_zone_id: number
    object_id: number
    equippedLocation?: string | null
    condition?: number
    charges?: number
    instanceFlags?: CharacterItemCreateinstanceFlagsInput | string[]
    customShortDesc?: string | null
    customLongDesc?: string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterItemUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutItemsNestedInput
    containedItems?: CharacterItemUpdateManyWithoutContainerNestedInput
    object?: ObjectUpdateOneRequiredWithoutCharacterItemsNestedInput
  }

  export type CharacterItemUncheckedUpdateWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    object_zone_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    containedItems?: CharacterItemUncheckedUpdateManyWithoutContainerNestedInput
  }

  export type CharacterItemUncheckedUpdateManyWithoutContainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    object_zone_id?: IntFieldUpdateOperationsInput | number
    object_id?: IntFieldUpdateOperationsInput | number
    equippedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    instanceFlags?: CharacterItemUpdateinstanceFlagsInput | string[]
    customShortDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customLongDesc?: NullableStringFieldUpdateOperationsInput | string | null
    customValues?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentSetItemCreateManyEquipmentSetInput = {
    id: string
    objectZoneId: number
    objectId: number
    slot?: string | null
    quantity?: number
    probability?: number
  }

  export type MobEquipmentSetCreateManyEquipmentSetInput = {
    id: string
    mobResetId: string
    probability?: number
  }

  export type EquipmentSetItemUpdateWithoutEquipmentSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    object?: ObjectUpdateOneRequiredWithoutEquipmentSetItemsNestedInput
  }

  export type EquipmentSetItemUncheckedUpdateWithoutEquipmentSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type EquipmentSetItemUncheckedUpdateManyWithoutEquipmentSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectZoneId?: IntFieldUpdateOperationsInput | number
    objectId?: IntFieldUpdateOperationsInput | number
    slot?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobEquipmentSetUpdateWithoutEquipmentSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
    mobReset?: MobResetUpdateOneRequiredWithoutEquipmentSetsNestedInput
  }

  export type MobEquipmentSetUncheckedUpdateWithoutEquipmentSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobResetId?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type MobEquipmentSetUncheckedUpdateManyWithoutEquipmentSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobResetId?: StringFieldUpdateOperationsInput | string
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type SpawnConditionCreateManyObjectResetInput = {
    id: string
    type: string
    parameters?: JsonNullValueInput | InputJsonValue
    mobResetId?: string | null
  }

  export type SpawnConditionUpdateWithoutObjectResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    mobReset?: MobResetUpdateOneWithoutSpawnConditionsNestedInput
  }

  export type SpawnConditionUncheckedUpdateWithoutObjectResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    mobResetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpawnConditionUncheckedUpdateManyWithoutObjectResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: JsonNullValueInput | InputJsonValue
    mobResetId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterCountOutputTypeDefaultArgs instead
     */
    export type CharacterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneCountOutputTypeDefaultArgs instead
     */
    export type ZoneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomCountOutputTypeDefaultArgs instead
     */
    export type RoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobCountOutputTypeDefaultArgs instead
     */
    export type MobCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobResetCountOutputTypeDefaultArgs instead
     */
    export type MobResetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobResetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectCountOutputTypeDefaultArgs instead
     */
    export type ObjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopCountOutputTypeDefaultArgs instead
     */
    export type ShopCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameClassCountOutputTypeDefaultArgs instead
     */
    export type GameClassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameClassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellCountOutputTypeDefaultArgs instead
     */
    export type SpellCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellSchoolCountOutputTypeDefaultArgs instead
     */
    export type SpellSchoolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellSchoolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillCountOutputTypeDefaultArgs instead
     */
    export type SkillCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterItemCountOutputTypeDefaultArgs instead
     */
    export type CharacterItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentSetCountOutputTypeDefaultArgs instead
     */
    export type EquipmentSetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentSetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectResetCountOutputTypeDefaultArgs instead
     */
    export type ObjectResetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectResetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterDefaultArgs instead
     */
    export type CharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneDefaultArgs instead
     */
    export type ZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomExitDefaultArgs instead
     */
    export type RoomExitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomExitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomExtraDescriptionDefaultArgs instead
     */
    export type RoomExtraDescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomExtraDescriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobDefaultArgs instead
     */
    export type MobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobSkillDefaultArgs instead
     */
    export type MobSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobSpellDefaultArgs instead
     */
    export type MobSpellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobSpellDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobResetDefaultArgs instead
     */
    export type MobResetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobResetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobCarryingDefaultArgs instead
     */
    export type MobCarryingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobCarryingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobEquippedDefaultArgs instead
     */
    export type MobEquippedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobEquippedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectDefaultArgs instead
     */
    export type ObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectExtraDescriptionDefaultArgs instead
     */
    export type ObjectExtraDescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectExtraDescriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectAffectDefaultArgs instead
     */
    export type ObjectAffectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectAffectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectSpellDefaultArgs instead
     */
    export type ObjectSpellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectSpellDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopDefaultArgs instead
     */
    export type ShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopItemDefaultArgs instead
     */
    export type ShopItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopAcceptDefaultArgs instead
     */
    export type ShopAcceptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopAcceptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopRoomDefaultArgs instead
     */
    export type ShopRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopRoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopHourDefaultArgs instead
     */
    export type ShopHourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopHourDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TriggerDefaultArgs instead
     */
    export type TriggerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TriggerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameClassDefaultArgs instead
     */
    export type GameClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellDefaultArgs instead
     */
    export type SpellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellSchoolDefaultArgs instead
     */
    export type SpellSchoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellSchoolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellClassCircleDefaultArgs instead
     */
    export type SpellClassCircleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellClassCircleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellTargetingDefaultArgs instead
     */
    export type SpellTargetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellTargetingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellSavingThrowDefaultArgs instead
     */
    export type SpellSavingThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellSavingThrowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellMessageDefaultArgs instead
     */
    export type SpellMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellComponentDefaultArgs instead
     */
    export type SpellComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellComponentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellRestrictionDefaultArgs instead
     */
    export type SpellRestrictionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellRestrictionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpellEffectDefaultArgs instead
     */
    export type SpellEffectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpellEffectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillDefaultArgs instead
     */
    export type SkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassSkillDefaultArgs instead
     */
    export type ClassSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RaceSkillDefaultArgs instead
     */
    export type RaceSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RaceSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterSkillDefaultArgs instead
     */
    export type CharacterSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterSpellDefaultArgs instead
     */
    export type CharacterSpellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterSpellDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChangeLogDefaultArgs instead
     */
    export type ChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChangeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BanRecordDefaultArgs instead
     */
    export type BanRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BanRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterItemDefaultArgs instead
     */
    export type CharacterItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterEffectDefaultArgs instead
     */
    export type CharacterEffectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterEffectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentSetItemDefaultArgs instead
     */
    export type EquipmentSetItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentSetItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentSetDefaultArgs instead
     */
    export type EquipmentSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentSetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobEquipmentSetDefaultArgs instead
     */
    export type MobEquipmentSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobEquipmentSetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectResetDefaultArgs instead
     */
    export type ObjectResetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectResetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpawnConditionDefaultArgs instead
     */
    export type SpawnConditionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpawnConditionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}